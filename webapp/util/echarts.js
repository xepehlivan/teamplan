sap.ui.define(function() {
    var t, e;
    return t = this,
    e = function() {
        "use strict";
        var t, e = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
        function i(t, e) {
            return t(e = {
                exports: {}
            }, e.exports),
            e.exports
        }
        "undefined" != typeof window ? t = window.__DEV__ : void 0 !== e && (t = e.__DEV__),
        void 0 === t && (t = !0);
        var n = 2311;
        var a = function() {
            return n++
        };
        var et = "object" == typeof wx && "function" == typeof wx.getSystemInfoSync ? {
            browser: {},
            os: {},
            node: !1,
            wxa: !0,
            canvasSupported: !0,
            svgSupported: !1,
            touchEventsSupported: !0,
            domSupported: !1
        } : "undefined" == typeof document && "undefined" != typeof self ? {
            browser: {},
            os: {},
            node: !1,
            worker: !0,
            canvasSupported: !0,
            domSupported: !1
        } : "undefined" == typeof navigator ? {
            browser: {},
            os: {},
            node: !0,
            worker: !1,
            canvasSupported: !0,
            svgSupported: !0,
            domSupported: !1
        } : function(t) {
            var e = {}
              , i = t.match(/Firefox\/([\d.]+)/)
              , n = t.match(/MSIE\s([\d.]+)/) || t.match(/Trident\/.+?rv:(([\d.]+))/)
              , a = t.match(/Edge\/([\d.]+)/)
              , r = /micromessenger/i.test(t);
            i && (e.firefox = !0,
            e.version = i[1]);
            n && (e.ie = !0,
            e.version = n[1]);
            a && (e.edge = !0,
            e.version = a[1]);
            r && (e.weChat = !0);
            return {
                browser: e,
                os: {},
                node: !1,
                canvasSupported: !!document.createElement("canvas").getContext,
                svgSupported: "undefined" != typeof SVGRect,
                touchEventsSupported: "ontouchstart"in window && !e.ie && !e.edge,
                pointerEventsSupported: "onpointerdown"in window && (e.edge || e.ie && 11 <= e.version),
                domSupported: "undefined" != typeof document
            }
        }(navigator.userAgent)
          , s = {
            "[object Function]": 1,
            "[object RegExp]": 1,
            "[object Date]": 1,
            "[object Error]": 1,
            "[object CanvasGradient]": 1,
            "[object CanvasPattern]": 1,
            "[object Image]": 1,
            "[object Canvas]": 1
        }
          , l = {
            "[object Int8Array]": 1,
            "[object Uint8Array]": 1,
            "[object Uint8ClampedArray]": 1,
            "[object Int16Array]": 1,
            "[object Uint16Array]": 1,
            "[object Int32Array]": 1,
            "[object Uint32Array]": 1,
            "[object Float32Array]": 1,
            "[object Float64Array]": 1
        }
          , u = Object.prototype.toString
          , r = Array.prototype
          , o = r.forEach
          , h = r.filter
          , c = r.slice
          , d = r.map
          , p = r.reduce
          , f = {};
        function g(t) {
            if (null == t || "object" != typeof t)
                return t;
            var e = t
              , i = u.call(t);
            if ("[object Array]" === i) {
                if (!T(t)) {
                    e = [];
                    for (var n = 0, a = t.length; n < a; n++)
                        e[n] = g(t[n])
                }
            } else if (l[i]) {
                if (!T(t)) {
                    var r = t.constructor;
                    if (t.constructor.from)
                        e = r.from(t);
                    else {
                        e = new r(t.length);
                        for (n = 0,
                        a = t.length; n < a; n++)
                            e[n] = g(t[n])
                    }
                }
            } else if (!s[i] && !T(t) && !I(t))
                for (var o in e = {},
                t)
                    t.hasOwnProperty(o) && (e[o] = g(t[o]));
            return e
        }
        function m(t, e, i) {
            if (!S(e) || !S(t))
                return i ? g(e) : t;
            for (var n in e)
                if (e.hasOwnProperty(n)) {
                    var a = t[n]
                      , r = e[n];
                    !S(r) || !S(a) || w(r) || w(a) || I(r) || I(a) || M(r) || M(a) || T(r) || T(a) ? !i && n in t || (t[n] = g(e[n])) : m(a, r, i)
                }
            return t
        }
        function v(t, e, i) {
            for (var n in e)
                e.hasOwnProperty(n) && (i ? null != e[n] : null == t[n]) && (t[n] = e[n]);
            return t
        }
        function y() {
            return f.createCanvas()
        }
        var x;
        function _(t, e, i) {
            if (t && e)
                if (t.forEach && t.forEach === o)
                    t.forEach(e, i);
                else if (t.length === +t.length)
                    for (var n = 0, a = t.length; n < a; n++)
                        e.call(i, t[n], n, t);
                else
                    for (var r in t)
                        t.hasOwnProperty(r) && e.call(i, t[r], r, t)
        }
        function b(t, e) {
            var i = c.call(arguments, 2);
            return function() {
                return t.apply(e, i.concat(c.call(arguments)))
            }
        }
        function w(t) {
            return "[object Array]" === u.call(t)
        }
        function S(t) {
            var e = typeof t;
            return "function" == e || !!t && "object" == e
        }
        function M(t) {
            return !!s[u.call(t)]
        }
        function I(t) {
            return "object" == typeof t && "number" == typeof t.nodeType && "object" == typeof t.ownerDocument
        }
        f.createCanvas = function() {
            return document.createElement("canvas")
        }
        ;
        var A = "__ec_primitive__";
        function T(t) {
            return t[A]
        }
        function C(t) {
            var i = w(t);
            this.data = {};
            var n = this;
            function e(t, e) {
                i ? n.set(t, e) : n.set(e, t)
            }
            t instanceof C ? t.each(e) : t && _(t, e)
        }
        C.prototype = {
            constructor: C,
            get: function(t) {
                return this.data.hasOwnProperty(t) ? this.data[t] : null
            },
            set: function(t, e) {
                return this.data[t] = e
            },
            each: function(t, e) {
                for (var i in void 0 !== e && (t = b(t, e)),
                this.data)
                    this.data.hasOwnProperty(i) && t(this.data[i], i)
            },
            removeKey: function(t) {
                delete this.data[t]
            }
        };
        var it = {
            $override: function(t, e) {
                "createCanvas" === t && (x = null),
                f[t] = e
            },
            clone: g,
            merge: m,
            mergeAll: function(t, e) {
                for (var i = t[0], n = 1, a = t.length; n < a; n++)
                    i = m(i, t[n], e);
                return i
            },
            extend: function(t, e) {
                for (var i in e)
                    e.hasOwnProperty(i) && (t[i] = e[i]);
                return t
            },
            defaults: v,
            createCanvas: y,
            getContext: function() {
                return x = x || y().getContext("2d")
            },
            indexOf: function(t, e) {
                if (t) {
                    if (t.indexOf)
                        return t.indexOf(e);
                    for (var i = 0, n = t.length; i < n; i++)
                        if (t[i] === e)
                            return i
                }
                return -1
            },
            inherits: function(t, e) {
                var i = t.prototype;
                function n() {}
                for (var a in n.prototype = e.prototype,
                t.prototype = new n,
                i)
                    t.prototype[a] = i[a];
                (t.prototype.constructor = t).superClass = e
            },
            mixin: function(t, e, i) {
                v(t = "prototype"in t ? t.prototype : t, e = "prototype"in e ? e.prototype : e, i)
            },
            isArrayLike: function(t) {
                if (t)
                    return "string" != typeof t && "number" == typeof t.length
            },
            each: _,
            map: function(t, e, i) {
                if (t && e) {
                    if (t.map && t.map === d)
                        return t.map(e, i);
                    for (var n = [], a = 0, r = t.length; a < r; a++)
                        n.push(e.call(i, t[a], a, t));
                    return n
                }
            },
            reduce: function(t, e, i, n) {
                if (t && e) {
                    if (t.reduce && t.reduce === p)
                        return t.reduce(e, i, n);
                    for (var a = 0, r = t.length; a < r; a++)
                        i = e.call(n, i, t[a], a, t);
                    return i
                }
            },
            filter: function(t, e, i) {
                if (t && e) {
                    if (t.filter && t.filter === h)
                        return t.filter(e, i);
                    for (var n = [], a = 0, r = t.length; a < r; a++)
                        e.call(i, t[a], a, t) && n.push(t[a]);
                    return n
                }
            },
            find: function(t, e, i) {
                if (t && e)
                    for (var n = 0, a = t.length; n < a; n++)
                        if (e.call(i, t[n], n, t))
                            return t[n]
            },
            bind: b,
            curry: function(t) {
                var e = c.call(arguments, 1);
                return function() {
                    return t.apply(this, e.concat(c.call(arguments)))
                }
            },
            isArray: w,
            isFunction: function(t) {
                return "function" == typeof t
            },
            isString: function(t) {
                return "[object String]" === u.call(t)
            },
            isObject: S,
            isBuiltInObject: M,
            isTypedArray: function(t) {
                return !!l[u.call(t)]
            },
            isDom: I,
            eqNaN: function(t) {
                return t != t
            },
            retrieve: function(t) {
                for (var e = 0, i = arguments.length; e < i; e++)
                    if (null != arguments[e])
                        return arguments[e]
            },
            retrieve2: function(t, e) {
                return null != t ? t : e
            },
            retrieve3: function(t, e, i) {
                return null != t ? t : null != e ? e : i
            },
            slice: function() {
                return Function.call.apply(c, arguments)
            },
            normalizeCssArray: function(t) {
                if ("number" == typeof t)
                    return [t, t, t, t];
                var e = t.length;
                return 2 === e ? [t[0], t[1], t[0], t[1]] : 3 === e ? [t[0], t[1], t[2], t[1]] : t
            },
            assert: function(t, e) {
                if (!t)
                    throw new Error(e)
            },
            trim: function(t) {
                return null == t ? null : "function" == typeof t.trim ? t.trim() : t.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
            },
            setAsPrimitive: function(t) {
                t[A] = !0
            },
            isPrimitive: T,
            createHashMap: function(t) {
                return new C(t)
            },
            concatArray: function(t, e) {
                for (var i = new t.constructor(t.length + e.length), n = 0; n < t.length; n++)
                    i[n] = t[n];
                var a = t.length;
                for (n = 0; n < e.length; n++)
                    i[n + a] = e[n];
                return i
            },
            noop: function() {}
        }
          , D = "undefined" == typeof Float32Array ? Array : Float32Array;
        function L(t) {
            return Math.sqrt(P(t))
        }
        function P(t) {
            return t[0] * t[0] + t[1] * t[1]
        }
        function k(t, e) {
            return Math.sqrt((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1]))
        }
        function O(t, e) {
            return (t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])
        }
        var R = {
            create: function(t, e) {
                var i = new D(2);
                return null == t && (t = 0),
                null == e && (e = 0),
                i[0] = t,
                i[1] = e,
                i
            },
            copy: function(t, e) {
                return t[0] = e[0],
                t[1] = e[1],
                t
            },
            clone: function(t) {
                var e = new D(2);
                return e[0] = t[0],
                e[1] = t[1],
                e
            },
            set: function(t, e, i) {
                return t[0] = e,
                t[1] = i,
                t
            },
            add: function(t, e, i) {
                return t[0] = e[0] + i[0],
                t[1] = e[1] + i[1],
                t
            },
            scaleAndAdd: function(t, e, i, n) {
                return t[0] = e[0] + i[0] * n,
                t[1] = e[1] + i[1] * n,
                t
            },
            sub: function(t, e, i) {
                return t[0] = e[0] - i[0],
                t[1] = e[1] - i[1],
                t
            },
            len: L,
            length: L,
            lenSquare: P,
            lengthSquare: P,
            mul: function(t, e, i) {
                return t[0] = e[0] * i[0],
                t[1] = e[1] * i[1],
                t
            },
            div: function(t, e, i) {
                return t[0] = e[0] / i[0],
                t[1] = e[1] / i[1],
                t
            },
            dot: function(t, e) {
                return t[0] * e[0] + t[1] * e[1]
            },
            scale: function(t, e, i) {
                return t[0] = e[0] * i,
                t[1] = e[1] * i,
                t
            },
            normalize: function(t, e) {
                var i = L(e);
                return 0 === i ? (t[0] = 0,
                t[1] = 0) : (t[0] = e[0] / i,
                t[1] = e[1] / i),
                t
            },
            distance: k,
            dist: k,
            distanceSquare: O,
            distSquare: O,
            negate: function(t, e) {
                return t[0] = -e[0],
                t[1] = -e[1],
                t
            },
            lerp: function(t, e, i, n) {
                return t[0] = e[0] + n * (i[0] - e[0]),
                t[1] = e[1] + n * (i[1] - e[1]),
                t
            },
            applyTransform: function(t, e, i) {
                var n = e[0]
                  , a = e[1];
                return t[0] = i[0] * n + i[2] * a + i[4],
                t[1] = i[1] * n + i[3] * a + i[5],
                t
            },
            min: function(t, e, i) {
                return t[0] = Math.min(e[0], i[0]),
                t[1] = Math.min(e[1], i[1]),
                t
            },
            max: function(t, e, i) {
                return t[0] = Math.max(e[0], i[0]),
                t[1] = Math.max(e[1], i[1]),
                t
            }
        };
        function N() {
            this.on("mousedown", this._dragStart, this),
            this.on("mousemove", this._drag, this),
            this.on("mouseup", this._dragEnd, this),
            this.on("globalout", this._dragEnd, this)
        }
        function E(t, e) {
            return {
                target: t,
                topTarget: e && e.topTarget
            }
        }
        N.prototype = {
            constructor: N,
            _dragStart: function(t) {
                var e = t.target;
                e && e.draggable && ((this._draggingTarget = e).dragging = !0,
                this._x = t.offsetX,
                this._y = t.offsetY,
                this.dispatchToElement(E(e, t), "dragstart", t.event))
            },
            _drag: function(t) {
                var e = this._draggingTarget;
                if (e) {
                    var i = t.offsetX
                      , n = t.offsetY
                      , a = i - this._x
                      , r = n - this._y;
                    this._x = i,
                    this._y = n,
                    e.drift(a, r, t),
                    this.dispatchToElement(E(e, t), "drag", t.event);
                    var o = this.findHover(i, n, e).target
                      , s = this._dropTarget;
                    e !== (this._dropTarget = o) && (s && o !== s && this.dispatchToElement(E(s, t), "dragleave", t.event),
                    o && o !== s && this.dispatchToElement(E(o, t), "dragenter", t.event))
                }
            },
            _dragEnd: function(t) {
                var e = this._draggingTarget;
                e && (e.dragging = !1),
                this.dispatchToElement(E(e, t), "dragend", t.event),
                this._dropTarget && this.dispatchToElement(E(this._dropTarget, t), "drop", t.event),
                this._draggingTarget = null,
                this._dropTarget = null
            }
        };
        function z(t) {
            this._$handlers = {},
            this._$eventProcessor = t
        }
        var V = N
          , B = Array.prototype.slice;
        function G(t, e, i, n, a, r) {
            var o = t._$handlers;
            if ("function" == typeof i && (a = n,
            n = i,
            i = null),
            !n || !e)
                return t;
            i = function(t, e) {
                var i = t._$eventProcessor;
                return null != e && i && i.normalizeQuery && (e = i.normalizeQuery(e)),
                e
            }(t, i),
            o[e] || (o[e] = []);
            for (var s = 0; s < o[e].length; s++)
                if (o[e][s].h === n)
                    return t;
            var l = {
                h: n,
                one: r,
                query: i,
                ctx: a || t,
                callAtLast: n.zrEventfulCallAtLast
            }
              , u = o[e].length - 1
              , h = o[e][u];
            return h && h.callAtLast ? o[e].splice(u, 0, l) : o[e].push(l),
            t
        }
        z.prototype = {
            constructor: z,
            one: function(t, e, i, n) {
                return G(this, t, e, i, n, !0)
            },
            on: function(t, e, i, n) {
                return G(this, t, e, i, n, !1)
            },
            isSilent: function(t) {
                var e = this._$handlers;
                return !e[t] || !e[t].length
            },
            off: function(t, e) {
                var i = this._$handlers;
                if (!t)
                    return this._$handlers = {},
                    this;
                if (e) {
                    if (i[t]) {
                        for (var n = [], a = 0, r = i[t].length; a < r; a++)
                            i[t][a].h !== e && n.push(i[t][a]);
                        i[t] = n
                    }
                    i[t] && 0 === i[t].length && delete i[t]
                } else
                    delete i[t];
                return this
            },
            trigger: function(t) {
                var e = this._$handlers[t]
                  , i = this._$eventProcessor;
                if (e) {
                    var n = arguments
                      , a = n.length;
                    3 < a && (n = B.call(n, 1));
                    for (var r = e.length, o = 0; o < r; ) {
                        var s = e[o];
                        if (i && i.filter && null != s.query && !i.filter(t, s.query))
                            o++;
                        else {
                            switch (a) {
                            case 1:
                                s.h.call(s.ctx);
                                break;
                            case 2:
                                s.h.call(s.ctx, n[1]);
                                break;
                            case 3:
                                s.h.call(s.ctx, n[1], n[2]);
                                break;
                            default:
                                s.h.apply(s.ctx, n)
                            }
                            s.one ? (e.splice(o, 1),
                            r--) : o++
                        }
                    }
                }
                return i && i.afterTrigger && i.afterTrigger(t),
                this
            },
            triggerWithContext: function(t) {
                var e = this._$handlers[t]
                  , i = this._$eventProcessor;
                if (e) {
                    var n = arguments
                      , a = n.length;
                    4 < a && (n = B.call(n, 1, n.length - 1));
                    for (var r = n[n.length - 1], o = e.length, s = 0; s < o; ) {
                        var l = e[s];
                        if (i && i.filter && null != l.query && !i.filter(t, l.query))
                            s++;
                        else {
                            switch (a) {
                            case 1:
                                l.h.call(r);
                                break;
                            case 2:
                                l.h.call(r, n[1]);
                                break;
                            case 3:
                                l.h.call(r, n[1], n[2]);
                                break;
                            default:
                                l.h.apply(r, n)
                            }
                            l.one ? (e.splice(s, 1),
                            o--) : s++
                        }
                    }
                }
                return i && i.afterTrigger && i.afterTrigger(t),
                this
            }
        };
        var nt = z
          , F = nt
          , H = "undefined" != typeof window && !!window.addEventListener
          , W = /^(?:mouse|pointer|contextmenu|drag|drop)|click/;
        function Z(t, e, i, n) {
            return i = i || {},
            n || !et.canvasSupported ? U(t, e, i) : et.browser.firefox && null != e.layerX && e.layerX !== e.offsetX ? (i.zrX = e.layerX,
            i.zrY = e.layerY) : null != e.offsetX ? (i.zrX = e.offsetX,
            i.zrY = e.offsetY) : U(t, e, i),
            i
        }
        function U(t, e, i) {
            var n = function(t) {
                return t.getBoundingClientRect ? t.getBoundingClientRect() : {
                    left: 0,
                    top: 0
                }
            }(t);
            i.zrX = e.clientX - n.left,
            i.zrY = e.clientY - n.top
        }
        function Y() {
            this._track = []
        }
        var j = {
            Dispatcher: F,
            clientToLocal: Z,
            normalizeEvent: function(t, e, i) {
                if (null != (e = e || window.event).zrX)
                    return e;
                var n = e.type;
                if (n && 0 <= n.indexOf("touch")) {
                    var a = "touchend" !== n ? e.targetTouches[0] : e.changedTouches[0];
                    a && Z(t, a, e, i)
                } else
                    Z(t, e, e, i),
                    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
                var r = e.button;
                return null == e.which && void 0 !== r && W.test(e.type) && (e.which = 1 & r ? 1 : 2 & r ? 3 : 4 & r ? 2 : 0),
                e
            },
            addEventListener: function(t, e, i) {
                H ? t.addEventListener(e, i) : t.attachEvent("on" + e, i)
            },
            removeEventListener: function(t, e, i) {
                H ? t.removeEventListener(e, i) : t.detachEvent("on" + e, i)
            },
            stop: H ? function(t) {
                t.preventDefault(),
                t.stopPropagation(),
                t.cancelBubble = !0
            }
            : function(t) {
                t.returnValue = !1,
                t.cancelBubble = !0
            }
            ,
            isMiddleOrRightButtonOnMouseUpDown: function(t) {
                return 2 === t.which || 3 === t.which
            },
            notLeftMouse: function(t) {
                return 1 < t.which
            }
        };
        function X(t) {
            var e = t[1][0] - t[0][0]
              , i = t[1][1] - t[0][1];
            return Math.sqrt(e * e + i * i)
        }
        Y.prototype = {
            constructor: Y,
            recognize: function(t, e, i) {
                return this._doTrack(t, e, i),
                this._recognize(t)
            },
            clear: function() {
                return this._track.length = 0,
                this
            },
            _doTrack: function(t, e, i) {
                var n = t.touches;
                if (n) {
                    for (var a = {
                        points: [],
                        touches: [],
                        target: e,
                        event: t
                    }, r = 0, o = n.length; r < o; r++) {
                        var s = n[r]
                          , l = j.clientToLocal(i, s, {});
                        a.points.push([l.zrX, l.zrY]),
                        a.touches.push(s)
                    }
                    this._track.push(a)
                }
            },
            _recognize: function(t) {
                for (var e in q)
                    if (q.hasOwnProperty(e)) {
                        var i = q[e](this._track, t);
                        if (i)
                            return i
                    }
            }
        };
        var q = {
            pinch: function(t, e) {
                var i = t.length;
                if (i) {
                    var n = (t[i - 1] || {}).points
                      , a = (t[i - 2] || {}).points || n;
                    if (a && 1 < a.length && n && 1 < n.length) {
                        var r = X(n) / X(a);
                        isFinite(r) || (r = 1),
                        e.pinchScale = r;
                        var o = function(t) {
                            return [(t[0][0] + t[1][0]) / 2, (t[0][1] + t[1][1]) / 2]
                        }(n);
                        return e.pinchX = o[0],
                        e.pinchY = o[1],
                        {
                            type: "pinch",
                            target: t[0].target,
                            event: e
                        }
                    }
                }
            }
        }
          , K = Y
          , $ = "silent";
        function J(t) {
            j.stop(this.event)
        }
        function Q() {}
        Q.prototype.dispose = function() {}
        ;
        function tt(t, e, i, n) {
            nt.call(this),
            this.storage = t,
            this.painter = e,
            this.painterRoot = n,
            i = i || new Q,
            this.proxy = null,
            this._hovered = {},
            this._lastTouchMoment,
            this._lastX,
            this._lastY,
            this._gestureMgr,
            V.call(this),
            this.setHandlerProxy(i)
        }
        var at = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"];
        function rt(t, e, i) {
            if (t[t.rectHover ? "rectContain" : "contain"](e, i)) {
                for (var n, a = t; a; ) {
                    if (a.clipPath && !a.clipPath.contain(e, i))
                        return !1;
                    a.silent && (n = !0),
                    a = a.parent
                }
                return !n || $
            }
            return !1
        }
        tt.prototype = {
            constructor: tt,
            setHandlerProxy: function(e) {
                this.proxy && this.proxy.dispose(),
                e && (it.each(at, function(t) {
                    e.on && e.on(t, this[t], this)
                }, this),
                e.handler = this),
                this.proxy = e
            },
            mousemove: function(t) {
                var e = t.zrX
                  , i = t.zrY
                  , n = this._hovered
                  , a = n.target;
                a && !a.__zr && (a = (n = this.findHover(n.x, n.y)).target);
                var r = this._hovered = this.findHover(e, i)
                  , o = r.target
                  , s = this.proxy;
                s.setCursor && s.setCursor(o ? o.cursor : "default"),
                a && o !== a && this.dispatchToElement(n, "mouseout", t),
                this.dispatchToElement(r, "mousemove", t),
                o && o !== a && this.dispatchToElement(r, "mouseover", t)
            },
            mouseout: function(t) {
                this.dispatchToElement(this._hovered, "mouseout", t);
                for (var e, i = t.toElement || t.relatedTarget; (i = i && i.parentNode) && 9 !== i.nodeType && !(e = i === this.painterRoot); )
                    ;
                e || this.trigger("globalout", {
                    event: t
                })
            },
            resize: function(t) {
                this._hovered = {}
            },
            dispatch: function(t, e) {
                var i = this[t];
                i && i.call(this, e)
            },
            dispose: function() {
                this.proxy.dispose(),
                this.storage = this.proxy = this.painter = null
            },
            setCursorStyle: function(t) {
                var e = this.proxy;
                e.setCursor && e.setCursor(t)
            },
            dispatchToElement: function(t, e, i) {
                var n = (t = t || {}).target;
                if (!n || !n.silent) {
                    for (var a = "on" + e, r = function(t, e, i) {
                        return {
                            type: t,
                            event: i,
                            target: e.target,
                            topTarget: e.topTarget,
                            cancelBubble: !1,
                            offsetX: i.zrX,
                            offsetY: i.zrY,
                            gestureEvent: i.gestureEvent,
                            pinchX: i.pinchX,
                            pinchY: i.pinchY,
                            pinchScale: i.pinchScale,
                            wheelDelta: i.zrDelta,
                            zrByTouch: i.zrByTouch,
                            which: i.which,
                            stop: J
                        }
                    }(e, t, i); n && (n[a] && (r.cancelBubble = n[a].call(n, r)),
                    n.trigger(e, r),
                    n = n.parent,
                    !r.cancelBubble); )
                        ;
                    r.cancelBubble || (this.trigger(e, r),
                    this.painter && this.painter.eachOtherLayer(function(t) {
                        "function" == typeof t[a] && t[a].call(t, r),
                        t.trigger && t.trigger(e, r)
                    }))
                }
            },
            findHover: function(t, e, i) {
                for (var n = this.storage.getDisplayList(), a = {
                    x: t,
                    y: e
                }, r = n.length - 1; 0 <= r; r--) {
                    var o;
                    if (n[r] !== i && !n[r].ignore && (o = rt(n[r], t, e)) && (a.topTarget || (a.topTarget = n[r]),
                    o !== $)) {
                        a.target = n[r];
                        break
                    }
                }
                return a
            },
            processGesture: function(t, e) {
                this._gestureMgr || (this._gestureMgr = new K);
                var i = this._gestureMgr;
                "start" === e && i.clear();
                var n = i.recognize(t, this.findHover(t.zrX, t.zrY, null).target, this.proxy.dom);
                if ("end" === e && i.clear(),
                n) {
                    var a = n.type;
                    t.gestureEvent = a,
                    this.dispatchToElement({
                        target: n.target
                    }, a, n.event)
                }
            }
        },
        it.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(n) {
            tt.prototype[n] = function(t) {
                var e = this.findHover(t.zrX, t.zrY)
                  , i = e.target;
                if ("mousedown" === n)
                    this._downEl = i,
                    this._downPoint = [t.zrX, t.zrY],
                    this._upEl = i;
                else if ("mouseup" === n)
                    this._upEl = i;
                else if ("click" === n) {
                    if (this._downEl !== this._upEl || !this._downPoint || 4 < R.dist(this._downPoint, [t.zrX, t.zrY]))
                        return;
                    this._downPoint = null
                }
                this.dispatchToElement(e, n, t)
            }
        }),
        it.mixin(tt, nt),
        it.mixin(tt, V);
        var ot = tt
          , st = "undefined" == typeof Float32Array ? Array : Float32Array;
        function lt() {
            var t = new st(6);
            return ut(t),
            t
        }
        function ut(t) {
            return t[0] = 1,
            t[1] = 0,
            t[2] = 0,
            t[3] = 1,
            t[4] = 0,
            t[5] = 0,
            t
        }
        function ht(t, e) {
            return t[0] = e[0],
            t[1] = e[1],
            t[2] = e[2],
            t[3] = e[3],
            t[4] = e[4],
            t[5] = e[5],
            t
        }
        var ct = {
            create: lt,
            identity: ut,
            copy: ht,
            mul: function(t, e, i) {
                var n = e[0] * i[0] + e[2] * i[1]
                  , a = e[1] * i[0] + e[3] * i[1]
                  , r = e[0] * i[2] + e[2] * i[3]
                  , o = e[1] * i[2] + e[3] * i[3]
                  , s = e[0] * i[4] + e[2] * i[5] + e[4]
                  , l = e[1] * i[4] + e[3] * i[5] + e[5];
                return t[0] = n,
                t[1] = a,
                t[2] = r,
                t[3] = o,
                t[4] = s,
                t[5] = l,
                t
            },
            translate: function(t, e, i) {
                return t[0] = e[0],
                t[1] = e[1],
                t[2] = e[2],
                t[3] = e[3],
                t[4] = e[4] + i[0],
                t[5] = e[5] + i[1],
                t
            },
            rotate: function(t, e, i) {
                var n = e[0]
                  , a = e[2]
                  , r = e[4]
                  , o = e[1]
                  , s = e[3]
                  , l = e[5]
                  , u = Math.sin(i)
                  , h = Math.cos(i);
                return t[0] = n * h + o * u,
                t[1] = -n * u + o * h,
                t[2] = a * h + s * u,
                t[3] = -a * u + h * s,
                t[4] = h * r + u * l,
                t[5] = h * l - u * r,
                t
            },
            scale: function(t, e, i) {
                var n = i[0]
                  , a = i[1];
                return t[0] = e[0] * n,
                t[1] = e[1] * a,
                t[2] = e[2] * n,
                t[3] = e[3] * a,
                t[4] = e[4] * n,
                t[5] = e[5] * a,
                t
            },
            invert: function(t, e) {
                var i = e[0]
                  , n = e[2]
                  , a = e[4]
                  , r = e[1]
                  , o = e[3]
                  , s = e[5]
                  , l = i * o - r * n;
                return l ? (l = 1 / l,
                t[0] = o * l,
                t[1] = -r * l,
                t[2] = -n * l,
                t[3] = i * l,
                t[4] = (n * s - o * a) * l,
                t[5] = (r * a - i * s) * l,
                t) : null
            },
            clone: function(t) {
                var e = lt();
                return ht(e, t),
                e
            }
        }
          , dt = ct.identity;
        function pt(t) {
            return 5e-5 < t || t < -5e-5
        }
        function ft(t) {
            (t = t || {}).position || (this.position = [0, 0]),
            null == t.rotation && (this.rotation = 0),
            t.scale || (this.scale = [1, 1]),
            this.origin = this.origin || null
        }
        var gt = ft.prototype;
        gt.transform = null,
        gt.needLocalTransform = function() {
            return pt(this.rotation) || pt(this.position[0]) || pt(this.position[1]) || pt(this.scale[0] - 1) || pt(this.scale[1] - 1)
        }
        ;
        var mt = [];
        gt.updateTransform = function() {
            var t = this.parent
              , e = t && t.transform
              , i = this.needLocalTransform()
              , n = this.transform;
            if (i || e) {
                n = n || ct.create(),
                i ? this.getLocalTransform(n) : dt(n),
                e && (i ? ct.mul(n, t.transform, n) : ct.copy(n, t.transform)),
                this.transform = n;
                var a = this.globalScaleRatio;
                if (null != a && 1 !== a) {
                    this.getGlobalScale(mt);
                    var r = mt[0] < 0 ? -1 : 1
                      , o = mt[1] < 0 ? -1 : 1
                      , s = ((mt[0] - r) * a + r) / mt[0] || 0
                      , l = ((mt[1] - o) * a + o) / mt[1] || 0;
                    n[0] *= s,
                    n[1] *= s,
                    n[2] *= l,
                    n[3] *= l
                }
                this.invTransform = this.invTransform || ct.create(),
                ct.invert(this.invTransform, n)
            } else
                n && dt(n)
        }
        ,
        gt.getLocalTransform = function(t) {
            return ft.getLocalTransform(this, t)
        }
        ,
        gt.setTransform = function(t) {
            var e = this.transform
              , i = t.dpr || 1;
            e ? t.setTransform(i * e[0], i * e[1], i * e[2], i * e[3], i * e[4], i * e[5]) : t.setTransform(i, 0, 0, i, 0, 0)
        }
        ,
        gt.restoreTransform = function(t) {
            var e = t.dpr || 1;
            t.setTransform(e, 0, 0, e, 0, 0)
        }
        ;
        var vt = []
          , yt = ct.create();
        gt.setLocalTransform = function(t) {
            if (t) {
                var e = t[0] * t[0] + t[1] * t[1]
                  , i = t[2] * t[2] + t[3] * t[3]
                  , n = this.position
                  , a = this.scale;
                pt(e - 1) && (e = Math.sqrt(e)),
                pt(i - 1) && (i = Math.sqrt(i)),
                t[0] < 0 && (e = -e),
                t[3] < 0 && (i = -i),
                n[0] = t[4],
                n[1] = t[5],
                a[0] = e,
                a[1] = i,
                this.rotation = Math.atan2(-t[1] / i, t[0] / e)
            }
        }
        ,
        gt.decomposeTransform = function() {
            if (this.transform) {
                var t = this.parent
                  , e = this.transform;
                t && t.transform && (ct.mul(vt, t.invTransform, e),
                e = vt);
                var i = this.origin;
                i && (i[0] || i[1]) && (yt[4] = i[0],
                yt[5] = i[1],
                ct.mul(vt, e, yt),
                vt[4] -= i[0],
                vt[5] -= i[1],
                e = vt),
                this.setLocalTransform(e)
            }
        }
        ,
        gt.getGlobalScale = function(t) {
            var e = this.transform;
            return t = t || [],
            e ? (t[0] = Math.sqrt(e[0] * e[0] + e[1] * e[1]),
            t[1] = Math.sqrt(e[2] * e[2] + e[3] * e[3]),
            e[0] < 0 && (t[0] = -t[0]),
            e[3] < 0 && (t[1] = -t[1])) : (t[0] = 1,
            t[1] = 1),
            t
        }
        ,
        gt.transformCoordToLocal = function(t, e) {
            var i = [t, e]
              , n = this.invTransform;
            return n && R.applyTransform(i, i, n),
            i
        }
        ,
        gt.transformCoordToGlobal = function(t, e) {
            var i = [t, e]
              , n = this.transform;
            return n && R.applyTransform(i, i, n),
            i
        }
        ,
        ft.getLocalTransform = function(t, e) {
            dt(e = e || []);
            var i = t.origin
              , n = t.scale || [1, 1]
              , a = t.rotation || 0
              , r = t.position || [0, 0];
            return i && (e[4] -= i[0],
            e[5] -= i[1]),
            ct.scale(e, e, n),
            a && ct.rotate(e, e, a),
            i && (e[4] += i[0],
            e[5] += i[1]),
            e[4] += r[0],
            e[5] += r[1],
            e
        }
        ;
        var xt = ft
          , _t = {
            linear: function(t) {
                return t
            },
            quadraticIn: function(t) {
                return t * t
            },
            quadraticOut: function(t) {
                return t * (2 - t)
            },
            quadraticInOut: function(t) {
                return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
            },
            cubicIn: function(t) {
                return t * t * t
            },
            cubicOut: function(t) {
                return --t * t * t + 1
            },
            cubicInOut: function(t) {
                return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
            },
            quarticIn: function(t) {
                return t * t * t * t
            },
            quarticOut: function(t) {
                return 1 - --t * t * t * t
            },
            quarticInOut: function(t) {
                return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
            },
            quinticIn: function(t) {
                return t * t * t * t * t
            },
            quinticOut: function(t) {
                return --t * t * t * t * t + 1
            },
            quinticInOut: function(t) {
                return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
            },
            sinusoidalIn: function(t) {
                return 1 - Math.cos(t * Math.PI / 2)
            },
            sinusoidalOut: function(t) {
                return Math.sin(t * Math.PI / 2)
            },
            sinusoidalInOut: function(t) {
                return .5 * (1 - Math.cos(Math.PI * t))
            },
            exponentialIn: function(t) {
                return 0 === t ? 0 : Math.pow(1024, t - 1)
            },
            exponentialOut: function(t) {
                return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
            },
            exponentialInOut: function(t) {
                return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
            },
            circularIn: function(t) {
                return 1 - Math.sqrt(1 - t * t)
            },
            circularOut: function(t) {
                return Math.sqrt(1 - --t * t)
            },
            circularInOut: function(t) {
                return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
            },
            elasticIn: function(t) {
                var e, i = .1;
                return 0 === t ? 0 : 1 === t ? 1 : (e = !i || i < 1 ? (i = 1,
                .1) : .4 * Math.asin(1 / i) / (2 * Math.PI),
                -i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4))
            },
            elasticOut: function(t) {
                var e, i = .1;
                return 0 === t ? 0 : 1 === t ? 1 : (e = !i || i < 1 ? (i = 1,
                .1) : .4 * Math.asin(1 / i) / (2 * Math.PI),
                i * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / .4) + 1)
            },
            elasticInOut: function(t) {
                var e, i = .1;
                return 0 === t ? 0 : 1 === t ? 1 : (e = !i || i < 1 ? (i = 1,
                .1) : .4 * Math.asin(1 / i) / (2 * Math.PI),
                (t *= 2) < 1 ? i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * -.5 : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / .4) * .5 + 1)
            },
            backIn: function(t) {
                return t * t * (2.70158 * t - 1.70158)
            },
            backOut: function(t) {
                return --t * t * (2.70158 * t + 1.70158) + 1
            },
            backInOut: function(t) {
                var e = 2.5949095;
                return (t *= 2) < 1 ? t * t * ((1 + e) * t - e) * .5 : .5 * ((t -= 2) * t * ((1 + e) * t + e) + 2)
            },
            bounceIn: function(t) {
                return 1 - _t.bounceOut(1 - t)
            },
            bounceOut: function(t) {
                return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
            },
            bounceInOut: function(t) {
                return t < .5 ? .5 * _t.bounceIn(2 * t) : .5 * _t.bounceOut(2 * t - 1) + .5
            }
        }
          , bt = _t;
        function wt(t) {
            this._target = t.target,
            this._life = t.life || 1e3,
            this._delay = t.delay || 0,
            this._initialized = !1,
            this.loop = null != t.loop && t.loop,
            this.gap = t.gap || 0,
            this.easing = t.easing || "Linear",
            this.onframe = t.onframe,
            this.ondestroy = t.ondestroy,
            this.onrestart = t.onrestart,
            this._pausedTime = 0,
            this._paused = !1
        }
        wt.prototype = {
            constructor: wt,
            step: function(t, e) {
                if (this._initialized || (this._startTime = t + this._delay,
                this._initialized = !0),
                this._paused)
                    this._pausedTime += e;
                else {
                    var i = (t - this._startTime - this._pausedTime) / this._life;
                    if (!(i < 0)) {
                        i = Math.min(i, 1);
                        var n = this.easing
                          , a = "string" == typeof n ? bt[n] : n
                          , r = "function" == typeof a ? a(i) : i;
                        return this.fire("frame", r),
                        1 === i ? this.loop ? (this.restart(t),
                        "restart") : (this._needsRemove = !0,
                        "destroy") : null
                    }
                }
            },
            restart: function(t) {
                var e = (t - this._startTime - this._pausedTime) % this._life;
                this._startTime = t - e + this.gap,
                this._pausedTime = 0,
                this._needsRemove = !1
            },
            fire: function(t, e) {
                this[t = "on" + t] && this[t](this._target, e)
            },
            pause: function() {
                this._paused = !0
            },
            resume: function() {
                this._paused = !1
            }
        };
        function St() {
            this.head = null,
            this.tail = null,
            this._len = 0
        }
        var Mt = wt
          , It = St.prototype;
        It.insert = function(t) {
            var e = new Tt(t);
            return this.insertEntry(e),
            e
        }
        ,
        It.insertEntry = function(t) {
            this.head ? ((this.tail.next = t).prev = this.tail,
            t.next = null,
            this.tail = t) : this.head = this.tail = t,
            this._len++
        }
        ,
        It.remove = function(t) {
            var e = t.prev
              , i = t.next;
            e ? e.next = i : this.head = i,
            i ? i.prev = e : this.tail = e,
            t.next = t.prev = null,
            this._len--
        }
        ,
        It.len = function() {
            return this._len
        }
        ,
        It.clear = function() {
            this.head = this.tail = null,
            this._len = 0
        }
        ;
        function At(t) {
            this._list = new St,
            this._map = {},
            this._maxSize = t || 10,
            this._lastRemovedEntry = null
        }
        var Tt = function(t) {
            this.value = t,
            this.next,
            this.prev
        }
          , Ct = At.prototype;
        Ct.put = function(t, e) {
            var i = this._list
              , n = this._map
              , a = null;
            if (null == n[t]) {
                var r = i.len()
                  , o = this._lastRemovedEntry;
                if (r >= this._maxSize && 0 < r) {
                    var s = i.head;
                    i.remove(s),
                    delete n[s.key],
                    a = s.value,
                    this._lastRemovedEntry = s
                }
                o ? o.value = e : o = new Tt(e),
                o.key = t,
                i.insertEntry(o),
                n[t] = o
            }
            return a
        }
        ,
        Ct.get = function(t) {
            var e = this._map[t]
              , i = this._list;
            if (null != e)
                return e !== i.tail && (i.remove(e),
                i.insertEntry(e)),
                e.value
        }
        ,
        Ct.clear = function() {
            this._list.clear(),
            this._map = {}
        }
        ;
        var Dt = At
          , Lt = {
            transparent: [0, 0, 0, 0],
            aliceblue: [240, 248, 255, 1],
            antiquewhite: [250, 235, 215, 1],
            aqua: [0, 255, 255, 1],
            aquamarine: [127, 255, 212, 1],
            azure: [240, 255, 255, 1],
            beige: [245, 245, 220, 1],
            bisque: [255, 228, 196, 1],
            black: [0, 0, 0, 1],
            blanchedalmond: [255, 235, 205, 1],
            blue: [0, 0, 255, 1],
            blueviolet: [138, 43, 226, 1],
            brown: [165, 42, 42, 1],
            burlywood: [222, 184, 135, 1],
            cadetblue: [95, 158, 160, 1],
            chartreuse: [127, 255, 0, 1],
            chocolate: [210, 105, 30, 1],
            coral: [255, 127, 80, 1],
            cornflowerblue: [100, 149, 237, 1],
            cornsilk: [255, 248, 220, 1],
            crimson: [220, 20, 60, 1],
            cyan: [0, 255, 255, 1],
            darkblue: [0, 0, 139, 1],
            darkcyan: [0, 139, 139, 1],
            darkgoldenrod: [184, 134, 11, 1],
            darkgray: [169, 169, 169, 1],
            darkgreen: [0, 100, 0, 1],
            darkgrey: [169, 169, 169, 1],
            darkkhaki: [189, 183, 107, 1],
            darkmagenta: [139, 0, 139, 1],
            darkolivegreen: [85, 107, 47, 1],
            darkorange: [255, 140, 0, 1],
            darkorchid: [153, 50, 204, 1],
            darkred: [139, 0, 0, 1],
            darksalmon: [233, 150, 122, 1],
            darkseagreen: [143, 188, 143, 1],
            darkslateblue: [72, 61, 139, 1],
            darkslategray: [47, 79, 79, 1],
            darkslategrey: [47, 79, 79, 1],
            darkturquoise: [0, 206, 209, 1],
            darkviolet: [148, 0, 211, 1],
            deeppink: [255, 20, 147, 1],
            deepskyblue: [0, 191, 255, 1],
            dimgray: [105, 105, 105, 1],
            dimgrey: [105, 105, 105, 1],
            dodgerblue: [30, 144, 255, 1],
            firebrick: [178, 34, 34, 1],
            floralwhite: [255, 250, 240, 1],
            forestgreen: [34, 139, 34, 1],
            fuchsia: [255, 0, 255, 1],
            gainsboro: [220, 220, 220, 1],
            ghostwhite: [248, 248, 255, 1],
            gold: [255, 215, 0, 1],
            goldenrod: [218, 165, 32, 1],
            gray: [128, 128, 128, 1],
            green: [0, 128, 0, 1],
            greenyellow: [173, 255, 47, 1],
            grey: [128, 128, 128, 1],
            honeydew: [240, 255, 240, 1],
            hotpink: [255, 105, 180, 1],
            indianred: [205, 92, 92, 1],
            indigo: [75, 0, 130, 1],
            ivory: [255, 255, 240, 1],
            khaki: [240, 230, 140, 1],
            lavender: [230, 230, 250, 1],
            lavenderblush: [255, 240, 245, 1],
            lawngreen: [124, 252, 0, 1],
            lemonchiffon: [255, 250, 205, 1],
            lightblue: [173, 216, 230, 1],
            lightcoral: [240, 128, 128, 1],
            lightcyan: [224, 255, 255, 1],
            lightgoldenrodyellow: [250, 250, 210, 1],
            lightgray: [211, 211, 211, 1],
            lightgreen: [144, 238, 144, 1],
            lightgrey: [211, 211, 211, 1],
            lightpink: [255, 182, 193, 1],
            lightsalmon: [255, 160, 122, 1],
            lightseagreen: [32, 178, 170, 1],
            lightskyblue: [135, 206, 250, 1],
            lightslategray: [119, 136, 153, 1],
            lightslategrey: [119, 136, 153, 1],
            lightsteelblue: [176, 196, 222, 1],
            lightyellow: [255, 255, 224, 1],
            lime: [0, 255, 0, 1],
            limegreen: [50, 205, 50, 1],
            linen: [250, 240, 230, 1],
            magenta: [255, 0, 255, 1],
            maroon: [128, 0, 0, 1],
            mediumaquamarine: [102, 205, 170, 1],
            mediumblue: [0, 0, 205, 1],
            mediumorchid: [186, 85, 211, 1],
            mediumpurple: [147, 112, 219, 1],
            mediumseagreen: [60, 179, 113, 1],
            mediumslateblue: [123, 104, 238, 1],
            mediumspringgreen: [0, 250, 154, 1],
            mediumturquoise: [72, 209, 204, 1],
            mediumvioletred: [199, 21, 133, 1],
            midnightblue: [25, 25, 112, 1],
            mintcream: [245, 255, 250, 1],
            mistyrose: [255, 228, 225, 1],
            moccasin: [255, 228, 181, 1],
            navajowhite: [255, 222, 173, 1],
            navy: [0, 0, 128, 1],
            oldlace: [253, 245, 230, 1],
            olive: [128, 128, 0, 1],
            olivedrab: [107, 142, 35, 1],
            orange: [255, 165, 0, 1],
            orangered: [255, 69, 0, 1],
            orchid: [218, 112, 214, 1],
            palegoldenrod: [238, 232, 170, 1],
            palegreen: [152, 251, 152, 1],
            paleturquoise: [175, 238, 238, 1],
            palevioletred: [219, 112, 147, 1],
            papayawhip: [255, 239, 213, 1],
            peachpuff: [255, 218, 185, 1],
            peru: [205, 133, 63, 1],
            pink: [255, 192, 203, 1],
            plum: [221, 160, 221, 1],
            powderblue: [176, 224, 230, 1],
            purple: [128, 0, 128, 1],
            red: [255, 0, 0, 1],
            rosybrown: [188, 143, 143, 1],
            royalblue: [65, 105, 225, 1],
            saddlebrown: [139, 69, 19, 1],
            salmon: [250, 128, 114, 1],
            sandybrown: [244, 164, 96, 1],
            seagreen: [46, 139, 87, 1],
            seashell: [255, 245, 238, 1],
            sienna: [160, 82, 45, 1],
            silver: [192, 192, 192, 1],
            skyblue: [135, 206, 235, 1],
            slateblue: [106, 90, 205, 1],
            slategray: [112, 128, 144, 1],
            slategrey: [112, 128, 144, 1],
            snow: [255, 250, 250, 1],
            springgreen: [0, 255, 127, 1],
            steelblue: [70, 130, 180, 1],
            tan: [210, 180, 140, 1],
            teal: [0, 128, 128, 1],
            thistle: [216, 191, 216, 1],
            tomato: [255, 99, 71, 1],
            turquoise: [64, 224, 208, 1],
            violet: [238, 130, 238, 1],
            wheat: [245, 222, 179, 1],
            white: [255, 255, 255, 1],
            whitesmoke: [245, 245, 245, 1],
            yellow: [255, 255, 0, 1],
            yellowgreen: [154, 205, 50, 1]
        };
        function Pt(t) {
            return (t = Math.round(t)) < 0 ? 0 : 255 < t ? 255 : t
        }
        function kt(t) {
            return t < 0 ? 0 : 1 < t ? 1 : t
        }
        function Ot(t) {
            return t.length && "%" === t.charAt(t.length - 1) ? Pt(parseFloat(t) / 100 * 255) : Pt(parseInt(t, 10))
        }
        function Rt(t) {
            return t.length && "%" === t.charAt(t.length - 1) ? kt(parseFloat(t) / 100) : kt(parseFloat(t))
        }
        function Nt(t, e, i) {
            return i < 0 ? i += 1 : 1 < i && (i -= 1),
            6 * i < 1 ? t + (e - t) * i * 6 : 2 * i < 1 ? e : 3 * i < 2 ? t + (e - t) * (2 / 3 - i) * 6 : t
        }
        function Et(t, e, i) {
            return t + (e - t) * i
        }
        function zt(t, e, i, n, a) {
            return t[0] = e,
            t[1] = i,
            t[2] = n,
            t[3] = a,
            t
        }
        function Vt(t, e) {
            return t[0] = e[0],
            t[1] = e[1],
            t[2] = e[2],
            t[3] = e[3],
            t
        }
        var Bt = new Dt(20)
          , Gt = null;
        function Ft(t, e) {
            Gt && Vt(Gt, e),
            Gt = Bt.put(t, Gt || e.slice())
        }
        function Ht(t, e) {
            if (t) {
                e = e || [];
                var i = Bt.get(t);
                if (i)
                    return Vt(e, i);
                var n, a = (t += "").replace(/ /g, "").toLowerCase();
                if (a in Lt)
                    return Vt(e, Lt[a]),
                    Ft(t, e),
                    e;
                if ("#" === a.charAt(0))
                    return 4 === a.length ? 0 <= (n = parseInt(a.substr(1), 16)) && n <= 4095 ? (zt(e, (3840 & n) >> 4 | (3840 & n) >> 8, 240 & n | (240 & n) >> 4, 15 & n | (15 & n) << 4, 1),
                    Ft(t, e),
                    e) : void zt(e, 0, 0, 0, 1) : 7 === a.length ? 0 <= (n = parseInt(a.substr(1), 16)) && n <= 16777215 ? (zt(e, (16711680 & n) >> 16, (65280 & n) >> 8, 255 & n, 1),
                    Ft(t, e),
                    e) : void zt(e, 0, 0, 0, 1) : void 0;
                var r = a.indexOf("(")
                  , o = a.indexOf(")");
                if (-1 !== r && o + 1 === a.length) {
                    var s = a.substr(0, r)
                      , l = a.substr(r + 1, o - (r + 1)).split(",")
                      , u = 1;
                    switch (s) {
                    case "rgba":
                        if (4 !== l.length)
                            return void zt(e, 0, 0, 0, 1);
                        u = Rt(l.pop());
                    case "rgb":
                        return 3 !== l.length ? void zt(e, 0, 0, 0, 1) : (zt(e, Ot(l[0]), Ot(l[1]), Ot(l[2]), u),
                        Ft(t, e),
                        e);
                    case "hsla":
                        return 4 !== l.length ? void zt(e, 0, 0, 0, 1) : (l[3] = Rt(l[3]),
                        Wt(l, e),
                        Ft(t, e),
                        e);
                    case "hsl":
                        return 3 !== l.length ? void zt(e, 0, 0, 0, 1) : (Wt(l, e),
                        Ft(t, e),
                        e);
                    default:
                        return
                    }
                }
                zt(e, 0, 0, 0, 1)
            }
        }
        function Wt(t, e) {
            var i = (parseFloat(t[0]) % 360 + 360) % 360 / 360
              , n = Rt(t[1])
              , a = Rt(t[2])
              , r = a <= .5 ? a * (n + 1) : a + n - a * n
              , o = 2 * a - r;
            return zt(e = e || [], Pt(255 * Nt(o, r, i + 1 / 3)), Pt(255 * Nt(o, r, i)), Pt(255 * Nt(o, r, i - 1 / 3)), 1),
            4 === t.length && (e[3] = t[3]),
            e
        }
        function Zt(t, e, i) {
            if (e && e.length && 0 <= t && t <= 1) {
                i = i || [];
                var n = t * (e.length - 1)
                  , a = Math.floor(n)
                  , r = Math.ceil(n)
                  , o = e[a]
                  , s = e[r]
                  , l = n - a;
                return i[0] = Pt(Et(o[0], s[0], l)),
                i[1] = Pt(Et(o[1], s[1], l)),
                i[2] = Pt(Et(o[2], s[2], l)),
                i[3] = kt(Et(o[3], s[3], l)),
                i
            }
        }
        function Ut(t, e, i) {
            if (e && e.length && 0 <= t && t <= 1) {
                var n = t * (e.length - 1)
                  , a = Math.floor(n)
                  , r = Math.ceil(n)
                  , o = Ht(e[a])
                  , s = Ht(e[r])
                  , l = n - a
                  , u = Yt([Pt(Et(o[0], s[0], l)), Pt(Et(o[1], s[1], l)), Pt(Et(o[2], s[2], l)), kt(Et(o[3], s[3], l))], "rgba");
                return i ? {
                    color: u,
                    leftIndex: a,
                    rightIndex: r,
                    value: n
                } : u
            }
        }
        function Yt(t, e) {
            if (t && t.length) {
                var i = t[0] + "," + t[1] + "," + t[2];
                return "rgba" !== e && "hsva" !== e && "hsla" !== e || (i += "," + t[3]),
                e + "(" + i + ")"
            }
        }
        var jt = {
            parse: Ht,
            lift: function(t, e) {
                var i = Ht(t);
                if (i) {
                    for (var n = 0; n < 3; n++)
                        i[n] = e < 0 ? i[n] * (1 - e) | 0 : (255 - i[n]) * e + i[n] | 0,
                        255 < i[n] ? i[n] = 255 : t[n] < 0 && (i[n] = 0);
                    return Yt(i, 4 === i.length ? "rgba" : "rgb")
                }
            },
            toHex: function(t) {
                var e = Ht(t);
                if (e)
                    return ((1 << 24) + (e[0] << 16) + (e[1] << 8) + +e[2]).toString(16).slice(1)
            },
            fastLerp: Zt,
            fastMapToColor: Zt,
            lerp: Ut,
            mapToColor: Ut,
            modifyHSL: function(t, e, i, n) {
                if (t = Ht(t))
                    return t = function(t) {
                        if (t) {
                            var e, i, n = t[0] / 255, a = t[1] / 255, r = t[2] / 255, o = Math.min(n, a, r), s = Math.max(n, a, r), l = s - o, u = (s + o) / 2;
                            if (0 == l)
                                i = e = 0;
                            else {
                                i = u < .5 ? l / (s + o) : l / (2 - s - o);
                                var h = ((s - n) / 6 + l / 2) / l
                                  , c = ((s - a) / 6 + l / 2) / l
                                  , d = ((s - r) / 6 + l / 2) / l;
                                n === s ? e = d - c : a === s ? e = 1 / 3 + h - d : r === s && (e = 2 / 3 + c - h),
                                e < 0 && (e += 1),
                                1 < e && (e -= 1)
                            }
                            var p = [360 * e, i, u];
                            return null != t[3] && p.push(t[3]),
                            p
                        }
                    }(t),
                    null != e && (t[0] = function(t) {
                        return (t = Math.round(t)) < 0 ? 0 : 360 < t ? 360 : t
                    }(e)),
                    null != i && (t[1] = Rt(i)),
                    null != n && (t[2] = Rt(n)),
                    Yt(Wt(t), "rgba")
            },
            modifyAlpha: function(t, e) {
                if ((t = Ht(t)) && null != e)
                    return t[3] = kt(e),
                    Yt(t, "rgba")
            },
            stringify: Yt
        }
          , Xt = it.isArrayLike
          , qt = Array.prototype.slice;
        function Kt(t, e) {
            return t[e]
        }
        function $t(t, e, i) {
            t[e] = i
        }
        function Jt(t, e, i) {
            return (e - t) * i + t
        }
        function Qt(t, e, i) {
            return .5 < i ? e : t
        }
        function te(t, e, i, n, a) {
            var r = t.length;
            if (1 === a)
                for (var o = 0; o < r; o++)
                    n[o] = Jt(t[o], e[o], i);
            else {
                var s = r && t[0].length;
                for (o = 0; o < r; o++)
                    for (var l = 0; l < s; l++)
                        n[o][l] = Jt(t[o][l], e[o][l], i)
            }
        }
        function ee(t, e, i) {
            var n = t.length
              , a = e.length;
            if (n !== a)
                if (a < n)
                    t.length = a;
                else
                    for (var r = n; r < a; r++)
                        t.push(1 === i ? e[r] : qt.call(e[r]));
            var o = t[0] && t[0].length;
            for (r = 0; r < t.length; r++)
                if (1 === i)
                    isNaN(t[r]) && (t[r] = e[r]);
                else
                    for (var s = 0; s < o; s++)
                        isNaN(t[r][s]) && (t[r][s] = e[r][s])
        }
        function ie(t, e, i) {
            if (t === e)
                return !0;
            var n = t.length;
            if (n !== e.length)
                return !1;
            if (1 === i) {
                for (var a = 0; a < n; a++)
                    if (t[a] !== e[a])
                        return !1
            } else {
                var r = t[0].length;
                for (a = 0; a < n; a++)
                    for (var o = 0; o < r; o++)
                        if (t[a][o] !== e[a][o])
                            return !1
            }
            return !0
        }
        function ne(t, e, i, n, a, r, o, s, l) {
            var u = t.length;
            if (1 === l)
                for (var h = 0; h < u; h++)
                    s[h] = ae(t[h], e[h], i[h], n[h], a, r, o);
            else {
                var c = t[0].length;
                for (h = 0; h < u; h++)
                    for (var d = 0; d < c; d++)
                        s[h][d] = ae(t[h][d], e[h][d], i[h][d], n[h][d], a, r, o)
            }
        }
        function ae(t, e, i, n, a, r, o) {
            var s = .5 * (i - t)
              , l = .5 * (n - e);
            return (2 * (e - i) + s + l) * o + (-3 * (e - i) - 2 * s - l) * r + s * a + e
        }
        function re(t) {
            if (Xt(t)) {
                var e = t.length;
                if (Xt(t[0])) {
                    for (var i = [], n = 0; n < e; n++)
                        i.push(qt.call(t[n]));
                    return i
                }
                return qt.call(t)
            }
            return t
        }
        function oe(t) {
            return t[0] = Math.floor(t[0]),
            t[1] = Math.floor(t[1]),
            t[2] = Math.floor(t[2]),
            "rgba(" + t.join(",") + ")"
        }
        function se(t, e, i, n, r, a) {
            var o = t._getter
              , s = t._setter
              , l = "spline" === e
              , u = n.length;
            if (u) {
                var h, c = n[0].value, d = Xt(c), p = !1, f = !1, g = d ? function(t) {
                    var e = t[t.length - 1].value;
                    return Xt(e && e[0]) ? 2 : 1
                }(n) : 0;
                n.sort(function(t, e) {
                    return t.time - e.time
                }),
                h = n[u - 1].time;
                for (var m = [], v = [], y = n[0].value, x = !0, _ = 0; _ < u; _++) {
                    m.push(n[_].time / h);
                    var b = n[_].value;
                    if (d && ie(b, y, g) || !d && b === y || (x = !1),
                    "string" == typeof (y = b)) {
                        var w = jt.parse(b);
                        w ? (b = w,
                        p = !0) : f = !0
                    }
                    v.push(b)
                }
                if (a || !x) {
                    var S = v[u - 1];
                    for (_ = 0; _ < u - 1; _++)
                        d ? ee(v[_], S, g) : !isNaN(v[_]) || isNaN(S) || f || p || (v[_] = S);
                    d && ee(o(t._target, r), S, g);
                    var M, I, A, T, C, D = 0, L = 0;
                    if (p)
                        var P = [0, 0, 0, 0];
                    var k = new Mt({
                        target: t._target,
                        life: h,
                        loop: t._loop,
                        delay: t._delay,
                        onframe: function(t, e) {
                            var i;
                            if (e < 0)
                                i = 0;
                            else if (e < L) {
                                for (i = Math.min(D + 1, u - 1); 0 <= i && !(m[i] <= e); i--)
                                    ;
                                i = Math.min(i, u - 2)
                            } else {
                                for (i = D; i < u && !(m[i] > e); i++)
                                    ;
                                i = Math.min(i - 1, u - 2)
                            }
                            L = e;
                            var n = m[(D = i) + 1] - m[i];
                            if (0 != n)
                                if (M = (e - m[i]) / n,
                                l)
                                    if (A = v[i],
                                    I = v[0 === i ? i : i - 1],
                                    T = v[u - 2 < i ? u - 1 : i + 1],
                                    C = v[u - 3 < i ? u - 1 : i + 2],
                                    d)
                                        ne(I, A, T, C, M, M * M, M * M * M, o(t, r), g);
                                    else {
                                        if (p)
                                            a = ne(I, A, T, C, M, M * M, M * M * M, P, 1),
                                            a = oe(P);
                                        else {
                                            if (f)
                                                return Qt(A, T, M);
                                            a = ae(I, A, T, C, M, M * M, M * M * M)
                                        }
                                        s(t, r, a)
                                    }
                                else if (d)
                                    te(v[i], v[i + 1], M, o(t, r), g);
                                else {
                                    var a;
                                    if (p)
                                        te(v[i], v[i + 1], M, P, 1),
                                        a = oe(P);
                                    else {
                                        if (f)
                                            return Qt(v[i], v[i + 1], M);
                                        a = Jt(v[i], v[i + 1], M)
                                    }
                                    s(t, r, a)
                                }
                        },
                        ondestroy: i
                    });
                    return e && "spline" !== e && (k.easing = e),
                    k
                }
            }
        }
        function le(t, e, i, n) {
            this._tracks = {},
            this._target = t,
            this._loop = e || !1,
            this._getter = i || Kt,
            this._setter = n || $t,
            this._clipCount = 0,
            this._delay = 0,
            this._doneList = [],
            this._onframeList = [],
            this._clipList = []
        }
        le.prototype = {
            when: function(t, e) {
                var i = this._tracks;
                for (var n in e)
                    if (e.hasOwnProperty(n)) {
                        if (!i[n]) {
                            i[n] = [];
                            var a = this._getter(this._target, n);
                            if (null == a)
                                continue;
                            0 !== t && i[n].push({
                                time: 0,
                                value: re(a)
                            })
                        }
                        i[n].push({
                            time: t,
                            value: e[n]
                        })
                    }
                return this
            },
            during: function(t) {
                return this._onframeList.push(t),
                this
            },
            pause: function() {
                for (var t = 0; t < this._clipList.length; t++)
                    this._clipList[t].pause();
                this._paused = !0
            },
            resume: function() {
                for (var t = 0; t < this._clipList.length; t++)
                    this._clipList[t].resume();
                this._paused = !1
            },
            isPaused: function() {
                return !!this._paused
            },
            _doneCallback: function() {
                this._tracks = {},
                this._clipList.length = 0;
                for (var t = this._doneList, e = t.length, i = 0; i < e; i++)
                    t[i].call(this)
            },
            start: function(t, e) {
                function i() {
                    --r || a._doneCallback()
                }
                var n, a = this, r = 0;
                for (var o in this._tracks)
                    if (this._tracks.hasOwnProperty(o)) {
                        var s = se(this, t, i, this._tracks[o], o, e);
                        s && (this._clipList.push(s),
                        r++,
                        this.animation && this.animation.addClip(s),
                        n = s)
                    }
                if (n) {
                    var l = n.onframe;
                    n.onframe = function(t, e) {
                        l(t, e);
                        for (var i = 0; i < a._onframeList.length; i++)
                            a._onframeList[i](t, e)
                    }
                }
                return r || this._doneCallback(),
                this
            },
            stop: function(t) {
                for (var e = this._clipList, i = this.animation, n = 0; n < e.length; n++) {
                    var a = e[n];
                    t && a.onframe(this._target, 1),
                    i && i.removeClip(a)
                }
                e.length = 0
            },
            delay: function(t) {
                return this._delay = t,
                this
            },
            done: function(t) {
                return t && this._doneList.push(t),
                this
            },
            getClips: function() {
                return this._clipList
            }
        };
        var ue = le
          , he = 1;
        "undefined" != typeof window && (he = Math.max(window.devicePixelRatio || 1, 1));
        function ce() {
            this.animators = []
        }
        var de = {
            debugMode: 0,
            devicePixelRatio: he
        }
          , pe = function() {}
          , fe = it.isString
          , ge = it.isFunction
          , me = it.isObject
          , ve = it.isArrayLike
          , ye = it.indexOf;
        function xe(t, e, i, n, a, r, o, s) {
            fe(n) ? (r = a,
            a = n,
            n = 0) : ge(a) ? (r = a,
            a = "linear",
            n = 0) : ge(n) ? (r = n,
            n = 0) : i = ge(i) ? (r = i,
            500) : i || 500,
            t.stopAnimation(),
            function t(e, i, n, a, r, o, s) {
                var l = {};
                var u = 0;
                for (var h in a)
                    a.hasOwnProperty(h) && (null != n[h] ? me(a[h]) && !ve(a[h]) ? t(e, i ? i + "." + h : h, n[h], a[h], r, o, s) : (s ? (l[h] = n[h],
                    _e(e, i, h, a[h])) : l[h] = a[h],
                    u++) : null == a[h] || s || _e(e, i, h, a[h]));
                0 < u && e.animate(i, !1).when(null == r ? 500 : r, l).delay(o || 0)
            }(t, "", t, e, i, n, s);
            var l = t.animators.slice()
              , u = l.length;
            function h() {
                --u || r && r()
            }
            u || r && r();
            for (var c = 0; c < l.length; c++)
                l[c].done(h).start(a, o)
        }
        function _e(t, e, i, n) {
            if (e) {
                var a = {};
                a[e] = {},
                a[e][i] = n,
                t.attr(a)
            } else
                t.attr(i, n)
        }
        ce.prototype = {
            constructor: ce,
            animate: function(t, e) {
                var i, n = !1, a = this, r = this.__zr;
                if (t) {
                    var o = t.split(".")
                      , s = a;
                    n = "shape" === o[0];
                    for (var l = 0, u = o.length; l < u; l++)
                        s = s && s[o[l]];
                    s && (i = s)
                } else
                    i = a;
                if (i) {
                    var h = a.animators
                      , c = new ue(i,e);
                    return c.during(function(t) {
                        a.dirty(n)
                    }).done(function() {
                        h.splice(ye(h, c), 1)
                    }),
                    h.push(c),
                    r && r.animation.addAnimator(c),
                    c
                }
                pe('Property "' + t + '" is not existed in element ' + a.id)
            },
            stopAnimation: function(t) {
                for (var e = this.animators, i = e.length, n = 0; n < i; n++)
                    e[n].stop(t);
                return e.length = 0,
                this
            },
            animateTo: function(t, e, i, n, a, r) {
                xe(this, t, e, i, n, a, r)
            },
            animateFrom: function(t, e, i, n, a, r) {
                xe(this, t, e, i, n, a, r, !0)
            }
        };
        function be(t) {
            xt.call(this, t),
            nt.call(this, t),
            we.call(this, t),
            this.id = t.id || a()
        }
        var we = ce;
        be.prototype = {
            type: "element",
            name: "",
            __zr: null,
            ignore: !1,
            clipPath: null,
            isGroup: !1,
            drift: function(t, e) {
                switch (this.draggable) {
                case "horizontal":
                    e = 0;
                    break;
                case "vertical":
                    t = 0
                }
                var i = this.transform;
                (i = i || (this.transform = [1, 0, 0, 1, 0, 0]))[4] += t,
                i[5] += e,
                this.decomposeTransform(),
                this.dirty(!1)
            },
            beforeUpdate: function() {},
            afterUpdate: function() {},
            update: function() {
                this.updateTransform()
            },
            traverse: function(t, e) {},
            attrKV: function(t, e) {
                if ("position" === t || "scale" === t || "origin" === t) {
                    if (e) {
                        var i = this[t];
                        (i = i || (this[t] = []))[0] = e[0],
                        i[1] = e[1]
                    }
                } else
                    this[t] = e
            },
            hide: function() {
                this.ignore = !0,
                this.__zr && this.__zr.refresh()
            },
            show: function() {
                this.ignore = !1,
                this.__zr && this.__zr.refresh()
            },
            attr: function(t, e) {
                if ("string" == typeof t)
                    this.attrKV(t, e);
                else if (it.isObject(t))
                    for (var i in t)
                        t.hasOwnProperty(i) && this.attrKV(i, t[i]);
                return this.dirty(!1),
                this
            },
            setClipPath: function(t) {
                var e = this.__zr;
                e && t.addSelfToZr(e),
                this.clipPath && this.clipPath !== t && this.removeClipPath(),
                (this.clipPath = t).__zr = e,
                (t.__clipTarget = this).dirty(!1)
            },
            removeClipPath: function() {
                var t = this.clipPath;
                t && (t.__zr && t.removeSelfFromZr(t.__zr),
                t.__zr = null,
                t.__clipTarget = null,
                this.clipPath = null,
                this.dirty(!1))
            },
            addSelfToZr: function(t) {
                this.__zr = t;
                var e = this.animators;
                if (e)
                    for (var i = 0; i < e.length; i++)
                        t.animation.addAnimator(e[i]);
                this.clipPath && this.clipPath.addSelfToZr(t)
            },
            removeSelfFromZr: function(t) {
                this.__zr = null;
                var e = this.animators;
                if (e)
                    for (var i = 0; i < e.length; i++)
                        t.animation.removeAnimator(e[i]);
                this.clipPath && this.clipPath.removeSelfFromZr(t)
            }
        },
        it.mixin(be, we),
        it.mixin(be, xt),
        it.mixin(be, nt);
        var Se, Me, Ie, Ae, Te = be, Ce = R.applyTransform, De = Math.min, Le = Math.max;
        function Pe(t, e, i, n) {
            i < 0 && (t += i,
            i = -i),
            n < 0 && (e += n,
            n = -n),
            this.x = t,
            this.y = e,
            this.width = i,
            this.height = n
        }
        Pe.prototype = {
            constructor: Pe,
            union: function(t) {
                var e = De(t.x, this.x)
                  , i = De(t.y, this.y);
                this.width = Le(t.x + t.width, this.x + this.width) - e,
                this.height = Le(t.y + t.height, this.y + this.height) - i,
                this.x = e,
                this.y = i
            },
            applyTransform: (Se = [],
            Me = [],
            Ie = [],
            Ae = [],
            function(t) {
                if (t) {
                    Se[0] = Ie[0] = this.x,
                    Se[1] = Ae[1] = this.y,
                    Me[0] = Ae[0] = this.x + this.width,
                    Me[1] = Ie[1] = this.y + this.height,
                    Ce(Se, Se, t),
                    Ce(Me, Me, t),
                    Ce(Ie, Ie, t),
                    Ce(Ae, Ae, t),
                    this.x = De(Se[0], Me[0], Ie[0], Ae[0]),
                    this.y = De(Se[1], Me[1], Ie[1], Ae[1]);
                    var e = Le(Se[0], Me[0], Ie[0], Ae[0])
                      , i = Le(Se[1], Me[1], Ie[1], Ae[1]);
                    this.width = e - this.x,
                    this.height = i - this.y
                }
            }
            ),
            calculateTransform: function(t) {
                var e = t.width / this.width
                  , i = t.height / this.height
                  , n = ct.create();
                return ct.translate(n, n, [-this.x, -this.y]),
                ct.scale(n, n, [e, i]),
                ct.translate(n, n, [t.x, t.y]),
                n
            },
            intersect: function(t) {
                if (!t)
                    return !1;
                t instanceof Pe || (t = Pe.create(t));
                var e = this.x
                  , i = this.x + this.width
                  , n = this.y
                  , a = this.y + this.height
                  , r = t.x
                  , o = t.x + t.width
                  , s = t.y
                  , l = t.y + t.height;
                return !(i < r || o < e || a < s || l < n)
            },
            contain: function(t, e) {
                return t >= this.x && t <= this.x + this.width && e >= this.y && e <= this.y + this.height
            },
            clone: function() {
                return new Pe(this.x,this.y,this.width,this.height)
            },
            copy: function(t) {
                this.x = t.x,
                this.y = t.y,
                this.width = t.width,
                this.height = t.height
            },
            plain: function() {
                return {
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height
                }
            }
        },
        Pe.create = function(t) {
            return new Pe(t.x,t.y,t.width,t.height)
        }
        ;
        function ke(t) {
            for (var e in t = t || {},
            Te.call(this, t),
            t)
                t.hasOwnProperty(e) && (this[e] = t[e]);
            this._children = [],
            this.__storage = null,
            this.__dirty = !0
        }
        var Oe = Pe;
        ke.prototype = {
            constructor: ke,
            isGroup: !0,
            type: "group",
            silent: !1,
            children: function() {
                return this._children.slice()
            },
            childAt: function(t) {
                return this._children[t]
            },
            childOfName: function(t) {
                for (var e = this._children, i = 0; i < e.length; i++)
                    if (e[i].name === t)
                        return e[i]
            },
            childCount: function() {
                return this._children.length
            },
            add: function(t) {
                return t && t !== this && t.parent !== this && (this._children.push(t),
                this._doAdd(t)),
                this
            },
            addBefore: function(t, e) {
                if (t && t !== this && t.parent !== this && e && e.parent === this) {
                    var i = this._children
                      , n = i.indexOf(e);
                    0 <= n && (i.splice(n, 0, t),
                    this._doAdd(t))
                }
                return this
            },
            _doAdd: function(t) {
                t.parent && t.parent.remove(t);
                var e = (t.parent = this).__storage
                  , i = this.__zr;
                e && e !== t.__storage && (e.addToStorage(t),
                t instanceof ke && t.addChildrenToStorage(e)),
                i && i.refresh()
            },
            remove: function(t) {
                var e = this.__zr
                  , i = this.__storage
                  , n = this._children
                  , a = it.indexOf(n, t);
                return a < 0 || (n.splice(a, 1),
                t.parent = null,
                i && (i.delFromStorage(t),
                t instanceof ke && t.delChildrenFromStorage(i)),
                e && e.refresh()),
                this
            },
            removeAll: function() {
                var t, e, i = this._children, n = this.__storage;
                for (e = 0; e < i.length; e++)
                    t = i[e],
                    n && (n.delFromStorage(t),
                    t instanceof ke && t.delChildrenFromStorage(n)),
                    t.parent = null;
                return i.length = 0,
                this
            },
            eachChild: function(t, e) {
                for (var i = this._children, n = 0; n < i.length; n++) {
                    var a = i[n];
                    t.call(e, a, n)
                }
                return this
            },
            traverse: function(t, e) {
                for (var i = 0; i < this._children.length; i++) {
                    var n = this._children[i];
                    t.call(e, n),
                    "group" === n.type && n.traverse(t, e)
                }
                return this
            },
            addChildrenToStorage: function(t) {
                for (var e = 0; e < this._children.length; e++) {
                    var i = this._children[e];
                    t.addToStorage(i),
                    i instanceof ke && i.addChildrenToStorage(t)
                }
            },
            delChildrenFromStorage: function(t) {
                for (var e = 0; e < this._children.length; e++) {
                    var i = this._children[e];
                    t.delFromStorage(i),
                    i instanceof ke && i.delChildrenFromStorage(t)
                }
            },
            dirty: function() {
                return this.__dirty = !0,
                this.__zr && this.__zr.refresh(),
                this
            },
            getBoundingRect: function(t) {
                for (var e = null, i = new Oe(0,0,0,0), n = t || this._children, a = [], r = 0; r < n.length; r++) {
                    var o = n[r];
                    if (!o.ignore && !o.invisible) {
                        var s = o.getBoundingRect()
                          , l = o.getLocalTransform(a);
                        l ? (i.copy(s),
                        i.applyTransform(l),
                        (e = e || i.clone()).union(i)) : (e = e || s.clone()).union(s)
                    }
                }
                return e || i
            }
        },
        it.inherits(ke, Te);
        var Re = ke
          , Ne = 32
          , Ee = 7;
        function ze(t, e, i, n) {
            var a = e + 1;
            if (a === i)
                return 1;
            if (n(t[a++], t[e]) < 0) {
                for (; a < i && n(t[a], t[a - 1]) < 0; )
                    a++;
                !function(t, e, i) {
                    i--;
                    for (; e < i; ) {
                        var n = t[e];
                        t[e++] = t[i],
                        t[i--] = n
                    }
                }(t, e, a)
            } else
                for (; a < i && 0 <= n(t[a], t[a - 1]); )
                    a++;
            return a - e
        }
        function Ve(t, e, i, n, a) {
            for (n === e && n++; n < i; n++) {
                for (var r, o = t[n], s = e, l = n; s < l; )
                    a(o, t[r = s + l >>> 1]) < 0 ? l = r : s = 1 + r;
                var u = n - s;
                switch (u) {
                case 3:
                    t[s + 3] = t[s + 2];
                case 2:
                    t[s + 2] = t[s + 1];
                case 1:
                    t[s + 1] = t[s];
                    break;
                default:
                    for (; 0 < u; )
                        t[s + u] = t[s + u - 1],
                        u--
                }
                t[s] = o
            }
        }
        function Be(t, e, i, n, a, r) {
            var o = 0
              , s = 0
              , l = 1;
            if (0 < r(t, e[i + a])) {
                for (s = n - a; l < s && 0 < r(t, e[i + a + l]); )
                    (l = 1 + ((o = l) << 1)) <= 0 && (l = s);
                s < l && (l = s),
                o += a,
                l += a
            } else {
                for (s = a + 1; l < s && r(t, e[i + a - l]) <= 0; )
                    (l = 1 + ((o = l) << 1)) <= 0 && (l = s);
                s < l && (l = s);
                var u = o;
                o = a - l,
                l = a - u
            }
            for (o++; o < l; ) {
                var h = o + (l - o >>> 1);
                0 < r(t, e[i + h]) ? o = h + 1 : l = h
            }
            return l
        }
        function Ge(t, e, i, n, a, r) {
            var o = 0
              , s = 0
              , l = 1;
            if (r(t, e[i + a]) < 0) {
                for (s = a + 1; l < s && r(t, e[i + a - l]) < 0; )
                    (l = 1 + ((o = l) << 1)) <= 0 && (l = s);
                s < l && (l = s);
                var u = o;
                o = a - l,
                l = a - u
            } else {
                for (s = n - a; l < s && 0 <= r(t, e[i + a + l]); )
                    (l = 1 + ((o = l) << 1)) <= 0 && (l = s);
                s < l && (l = s),
                o += a,
                l += a
            }
            for (o++; o < l; ) {
                var h = o + (l - o >>> 1);
                r(t, e[i + h]) < 0 ? l = h : o = h + 1
            }
            return l
        }
        function Fe(f, g) {
            var o, s, m = Ee, l = 0;
            f.length;
            var v = [];
            function e(t) {
                var e = o[t]
                  , i = s[t]
                  , n = o[t + 1]
                  , a = s[t + 1];
                s[t] = i + a,
                t === l - 3 && (o[t + 1] = o[t + 2],
                s[t + 1] = s[t + 2]),
                l--;
                var r = Ge(f[n], f, e, i, 0, g);
                e += r,
                0 !== (i -= r) && 0 !== (a = Be(f[e + i - 1], f, n, a, a - 1, g)) && (i <= a ? function(t, e, i, n) {
                    var a = 0;
                    for (a = 0; a < e; a++)
                        v[a] = f[t + a];
                    var r = 0
                      , o = i
                      , s = t;
                    if (f[s++] = f[o++],
                    0 == --n) {
                        for (a = 0; a < e; a++)
                            f[s + a] = v[r + a];
                        return
                    }
                    if (1 === e) {
                        for (a = 0; a < n; a++)
                            f[s + a] = f[o + a];
                        return f[s + n] = v[r]
                    }
                    var l, u, h, c = m;
                    for (; ; ) {
                        u = l = 0,
                        h = !1;
                        do {
                            if (g(f[o], v[r]) < 0) {
                                if (f[s++] = f[o++],
                                u++,
                                (l = 0) == --n) {
                                    h = !0;
                                    break
                                }
                            } else if (f[s++] = v[r++],
                            l++,
                            u = 0,
                            1 == --e) {
                                h = !0;
                                break
                            }
                        } while ((l | u) < c);
                        if (h)
                            break;
                        do {
                            if (0 !== (l = Ge(f[o], v, r, e, 0, g))) {
                                for (a = 0; a < l; a++)
                                    f[s + a] = v[r + a];
                                if (s += l,
                                r += l,
                                (e -= l) <= 1) {
                                    h = !0;
                                    break
                                }
                            }
                            if (f[s++] = f[o++],
                            0 == --n) {
                                h = !0;
                                break
                            }
                            if (0 !== (u = Be(v[r], f, o, n, 0, g))) {
                                for (a = 0; a < u; a++)
                                    f[s + a] = f[o + a];
                                if (s += u,
                                o += u,
                                0 === (n -= u)) {
                                    h = !0;
                                    break
                                }
                            }
                            if (f[s++] = v[r++],
                            1 == --e) {
                                h = !0;
                                break
                            }
                            c--
                        } while (Ee <= l || Ee <= u);
                        if (h)
                            break;
                        c < 0 && (c = 0),
                        c += 2
                    }
                    if ((m = c) < 1 && (m = 1),
                    1 === e) {
                        for (a = 0; a < n; a++)
                            f[s + a] = f[o + a];
                        f[s + n] = v[r]
                    } else {
                        if (0 === e)
                            throw new Error;
                        for (a = 0; a < e; a++)
                            f[s + a] = v[r + a]
                    }
                }(e, i, n, a) : function(t, e, i, n) {
                    var a = 0;
                    for (a = 0; a < n; a++)
                        v[a] = f[i + a];
                    var r = t + e - 1
                      , o = n - 1
                      , s = i + n - 1
                      , l = 0
                      , u = 0;
                    if (f[s--] = f[r--],
                    0 == --e) {
                        for (l = s - (n - 1),
                        a = 0; a < n; a++)
                            f[l + a] = v[a];
                        return
                    }
                    if (1 === n) {
                        for (u = (s -= e) + 1,
                        l = (r -= e) + 1,
                        a = e - 1; 0 <= a; a--)
                            f[u + a] = f[l + a];
                        return f[s] = v[o]
                    }
                    var h = m;
                    for (; ; ) {
                        var c = 0
                          , d = 0
                          , p = !1;
                        do {
                            if (g(v[o], f[r]) < 0) {
                                if (f[s--] = f[r--],
                                c++,
                                (d = 0) == --e) {
                                    p = !0;
                                    break
                                }
                            } else if (f[s--] = v[o--],
                            d++,
                            c = 0,
                            1 == --n) {
                                p = !0;
                                break
                            }
                        } while ((c | d) < h);
                        if (p)
                            break;
                        do {
                            if (0 !== (c = e - Ge(v[o], f, t, e, e - 1, g))) {
                                for (e -= c,
                                u = (s -= c) + 1,
                                l = (r -= c) + 1,
                                a = c - 1; 0 <= a; a--)
                                    f[u + a] = f[l + a];
                                if (0 === e) {
                                    p = !0;
                                    break
                                }
                            }
                            if (f[s--] = v[o--],
                            1 == --n) {
                                p = !0;
                                break
                            }
                            if (0 !== (d = n - Be(f[r], v, 0, n, n - 1, g))) {
                                for (n -= d,
                                u = (s -= d) + 1,
                                l = (o -= d) + 1,
                                a = 0; a < d; a++)
                                    f[u + a] = v[l + a];
                                if (n <= 1) {
                                    p = !0;
                                    break
                                }
                            }
                            if (f[s--] = f[r--],
                            0 == --e) {
                                p = !0;
                                break
                            }
                            h--
                        } while (Ee <= c || Ee <= d);
                        if (p)
                            break;
                        h < 0 && (h = 0),
                        h += 2
                    }
                    (m = h) < 1 && (m = 1);
                    if (1 === n) {
                        for (u = (s -= e) + 1,
                        l = (r -= e) + 1,
                        a = e - 1; 0 <= a; a--)
                            f[u + a] = f[l + a];
                        f[s] = v[o]
                    } else {
                        if (0 === n)
                            throw new Error;
                        for (l = s - (n - 1),
                        a = 0; a < n; a++)
                            f[l + a] = v[a]
                    }
                }(e, i, n, a))
            }
            o = [],
            s = [],
            this.mergeRuns = function() {
                for (; 1 < l; ) {
                    var t = l - 2;
                    if (1 <= t && s[t - 1] <= s[t] + s[t + 1] || 2 <= t && s[t - 2] <= s[t] + s[t - 1])
                        s[t - 1] < s[t + 1] && t--;
                    else if (s[t] > s[t + 1])
                        break;
                    e(t)
                }
            }
            ,
            this.forceMergeRuns = function() {
                for (; 1 < l; ) {
                    var t = l - 2;
                    0 < t && s[t - 1] < s[t + 1] && t--,
                    e(t)
                }
            }
            ,
            this.pushRun = function(t, e) {
                o[l] = t,
                s[l] = e,
                l += 1
            }
        }
        var He = function(t, e, i, n) {
            i = i || 0;
            var a = (n = n || t.length) - i;
            if (!(a < 2)) {
                var r = 0;
                if (a < Ne)
                    Ve(t, i, n, i + (r = ze(t, i, n, e)), e);
                else {
                    var o = new Fe(t,e)
                      , s = function(t) {
                        for (var e = 0; Ne <= t; )
                            e |= 1 & t,
                            t >>= 1;
                        return t + e
                    }(a);
                    do {
                        if ((r = ze(t, i, n, e)) < s) {
                            var l = a;
                            s < l && (l = s),
                            Ve(t, i, i + l, i + r, e),
                            r = l
                        }
                        o.pushRun(i, r),
                        o.mergeRuns(),
                        a -= r,
                        i += r
                    } while (0 !== a);
                    o.forceMergeRuns()
                }
            }
        };
        function We(t, e) {
            return t.zlevel === e.zlevel ? t.z === e.z ? t.z2 - e.z2 : t.z - e.z : t.zlevel - e.zlevel
        }
        function Ze() {
            this._roots = [],
            this._displayList = [],
            this._displayListLen = 0
        }
        Ze.prototype = {
            constructor: Ze,
            traverse: function(t, e) {
                for (var i = 0; i < this._roots.length; i++)
                    this._roots[i].traverse(t, e)
            },
            getDisplayList: function(t, e) {
                return e = e || !1,
                t && this.updateDisplayList(e),
                this._displayList
            },
            updateDisplayList: function(t) {
                this._displayListLen = 0;
                for (var e = this._roots, i = this._displayList, n = 0, a = e.length; n < a; n++)
                    this._updateAndAddDisplayable(e[n], null, t);
                i.length = this._displayListLen,
                et.canvasSupported && He(i, We)
            },
            _updateAndAddDisplayable: function(t, e, i) {
                if (!t.ignore || i) {
                    t.beforeUpdate(),
                    t.__dirty && t.update(),
                    t.afterUpdate();
                    var n = t.clipPath;
                    if (n) {
                        e = e ? e.slice() : [];
                        for (var a = n, r = t; a; )
                            a.parent = r,
                            a.updateTransform(),
                            e.push(a),
                            a = (r = a).clipPath
                    }
                    if (t.isGroup) {
                        for (var o = t._children, s = 0; s < o.length; s++) {
                            var l = o[s];
                            t.__dirty && (l.__dirty = !0),
                            this._updateAndAddDisplayable(l, e, i)
                        }
                        t.__dirty = !1
                    } else
                        t.__clipPaths = e,
                        this._displayList[this._displayListLen++] = t
                }
            },
            addRoot: function(t) {
                t.__storage !== this && (t instanceof Re && t.addChildrenToStorage(this),
                this.addToStorage(t),
                this._roots.push(t))
            },
            delRoot: function(t) {
                if (null == t) {
                    for (var e = 0; e < this._roots.length; e++) {
                        var i = this._roots[e];
                        i instanceof Re && i.delChildrenFromStorage(this)
                    }
                    return this._roots = [],
                    this._displayList = [],
                    void (this._displayListLen = 0)
                }
                if (t instanceof Array) {
                    e = 0;
                    for (var n = t.length; e < n; e++)
                        this.delRoot(t[e])
                } else {
                    var a = it.indexOf(this._roots, t);
                    0 <= a && (this.delFromStorage(t),
                    this._roots.splice(a, 1),
                    t instanceof Re && t.delChildrenFromStorage(this))
                }
            },
            addToStorage: function(t) {
                return t && (t.__storage = this,
                t.dirty(!1)),
                this
            },
            delFromStorage: function(t) {
                return t && (t.__storage = null),
                this
            },
            dispose: function() {
                this._renderList = this._roots = null
            },
            displayableSortFunc: We
        };
        var Ue = Ze
          , Ye = {
            shadowBlur: 1,
            shadowOffsetX: 1,
            shadowOffsetY: 1,
            textShadowBlur: 1,
            textShadowOffsetX: 1,
            textShadowOffsetY: 1,
            textBoxShadowBlur: 1,
            textBoxShadowOffsetX: 1,
            textBoxShadowOffsetY: 1
        };
        function je(t) {
            this.extendFrom(t, !1)
        }
        var Xe = function(t, e, i) {
            return Ye.hasOwnProperty(e) ? i * t.dpr : i
        }
          , qe = {
            ContextCachedBy: {
                NONE: 0,
                STYLE_BIND: 1,
                PLAIN_TEXT: 2
            },
            WILL_BE_RESTORED: 9
        }
          , Ke = qe.ContextCachedBy
          , $e = [["shadowBlur", 0], ["shadowOffsetX", 0], ["shadowOffsetY", 0], ["shadowColor", "#000"], ["lineCap", "butt"], ["lineJoin", "miter"], ["miterLimit", 10]];
        function Je(t, e, i) {
            var n = null == e.x ? 0 : e.x
              , a = null == e.x2 ? 1 : e.x2
              , r = null == e.y ? 0 : e.y
              , o = null == e.y2 ? 0 : e.y2;
            return e.global || (n = n * i.width + i.x,
            a = a * i.width + i.x,
            r = r * i.height + i.y,
            o = o * i.height + i.y),
            n = isNaN(n) ? 0 : n,
            a = isNaN(a) ? 1 : a,
            r = isNaN(r) ? 0 : r,
            o = isNaN(o) ? 0 : o,
            t.createLinearGradient(n, r, a, o)
        }
        function Qe(t, e, i) {
            var n = i.width
              , a = i.height
              , r = Math.min(n, a)
              , o = null == e.x ? .5 : e.x
              , s = null == e.y ? .5 : e.y
              , l = null == e.r ? .5 : e.r;
            return e.global || (o = o * n + i.x,
            s = s * a + i.y,
            l *= r),
            t.createRadialGradient(o, s, 0, o, s, l)
        }
        for (var ti = je.prototype = {
            constructor: je,
            fill: "#000",
            stroke: null,
            opacity: 1,
            fillOpacity: null,
            strokeOpacity: null,
            lineDash: null,
            lineDashOffset: 0,
            shadowBlur: 0,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            lineWidth: 1,
            strokeNoScale: !1,
            text: null,
            font: null,
            textFont: null,
            fontStyle: null,
            fontWeight: null,
            fontSize: null,
            fontFamily: null,
            textTag: null,
            textFill: "#000",
            textStroke: null,
            textWidth: null,
            textHeight: null,
            textStrokeWidth: 0,
            textLineHeight: null,
            textPosition: "inside",
            textRect: null,
            textOffset: null,
            textAlign: null,
            textVerticalAlign: null,
            textDistance: 5,
            textShadowColor: "transparent",
            textShadowBlur: 0,
            textShadowOffsetX: 0,
            textShadowOffsetY: 0,
            textBoxShadowColor: "transparent",
            textBoxShadowBlur: 0,
            textBoxShadowOffsetX: 0,
            textBoxShadowOffsetY: 0,
            transformText: !1,
            textRotation: 0,
            textOrigin: null,
            textBackgroundColor: null,
            textBorderColor: null,
            textBorderWidth: 0,
            textBorderRadius: 0,
            textPadding: null,
            rich: null,
            truncate: null,
            blend: null,
            bind: function(t, e, i) {
                var n = this
                  , a = i && i.style
                  , r = !a || t.__attrCachedBy !== Ke.STYLE_BIND;
                t.__attrCachedBy = Ke.STYLE_BIND;
                for (var o = 0; o < $e.length; o++) {
                    var s = $e[o]
                      , l = s[0];
                    !r && n[l] === a[l] || (t[l] = Xe(t, l, n[l] || s[1]))
                }
                if (!r && n.fill === a.fill || (t.fillStyle = n.fill),
                !r && n.stroke === a.stroke || (t.strokeStyle = n.stroke),
                !r && n.opacity === a.opacity || (t.globalAlpha = null == n.opacity ? 1 : n.opacity),
                !r && n.blend === a.blend || (t.globalCompositeOperation = n.blend || "source-over"),
                this.hasStroke()) {
                    var u = n.lineWidth;
                    t.lineWidth = u / (this.strokeNoScale && e && e.getLineScale ? e.getLineScale() : 1)
                }
            },
            hasFill: function() {
                var t = this.fill;
                return null != t && "none" !== t
            },
            hasStroke: function() {
                var t = this.stroke;
                return null != t && "none" !== t && 0 < this.lineWidth
            },
            extendFrom: function(t, e) {
                if (t)
                    for (var i in t)
                        !t.hasOwnProperty(i) || !0 !== e && (!1 === e ? this.hasOwnProperty(i) : null == t[i]) || (this[i] = t[i])
            },
            set: function(t, e) {
                "string" == typeof t ? this[t] = e : this.extendFrom(t, !0)
            },
            clone: function() {
                var t = new this.constructor;
                return t.extendFrom(this, !0),
                t
            },
            getGradient: function(t, e, i) {
                for (var n = ("radial" === e.type ? Qe : Je)(t, e, i), a = e.colorStops, r = 0; r < a.length; r++)
                    n.addColorStop(a[r].offset, a[r].color);
                return n
            }
        }, ei = 0; ei < $e.length; ei++) {
            var ii = $e[ei];
            ii[0]in ti || (ti[ii[0]] = ii[1])
        }
        je.getGradient = ti.getGradient;
        function ni(t, e) {
            this.image = t,
            this.repeat = e,
            this.type = "pattern"
        }
        var ai = je;
        ni.prototype.getCanvasPattern = function(t) {
            return t.createPattern(this.image, this.repeat || "repeat")
        }
        ;
        var ri = ni
          , oi = de.devicePixelRatio;
        function si() {
            return !1
        }
        function li(t, e, i) {
            var n = it.createCanvas()
              , a = e.getWidth()
              , r = e.getHeight()
              , o = n.style;
            return o && (o.position = "absolute",
            o.left = 0,
            o.top = 0,
            o.width = a + "px",
            o.height = r + "px",
            n.setAttribute("data-zr-dom-id", t)),
            n.width = a * i,
            n.height = r * i,
            n
        }
        function ui(t, e, i) {
            var n;
            i = i || oi,
            "string" == typeof t ? n = li(t, e, i) : it.isObject(t) && (t = (n = t).id),
            this.id = t;
            var a = (this.dom = n).style;
            a && (n.onselectstart = si,
            a["-webkit-user-select"] = "none",
            a["user-select"] = "none",
            a["-webkit-touch-callout"] = "none",
            a["-webkit-tap-highlight-color"] = "rgba(0,0,0,0)",
            a.padding = 0,
            a.margin = 0,
            a["border-width"] = 0),
            this.domBack = null,
            this.ctxBack = null,
            this.painter = e,
            this.config = null,
            this.clearColor = 0,
            this.motionBlur = !1,
            this.lastFrameAlpha = .7,
            this.dpr = i
        }
        ui.prototype = {
            constructor: ui,
            __dirty: !0,
            __used: !1,
            __drawIndex: 0,
            __startIndex: 0,
            __endIndex: 0,
            incremental: !1,
            getElementCount: function() {
                return this.__endIndex - this.__startIndex
            },
            initContext: function() {
                this.ctx = this.dom.getContext("2d"),
                this.ctx.dpr = this.dpr
            },
            createBackBuffer: function() {
                var t = this.dpr;
                this.domBack = li("back-" + this.id, this.painter, t),
                this.ctxBack = this.domBack.getContext("2d"),
                1 !== t && this.ctxBack.scale(t, t)
            },
            resize: function(t, e) {
                var i = this.dpr
                  , n = this.dom
                  , a = n.style
                  , r = this.domBack;
                a && (a.width = t + "px",
                a.height = e + "px"),
                n.width = t * i,
                n.height = e * i,
                r && (r.width = t * i,
                r.height = e * i,
                1 !== i && this.ctxBack.scale(i, i))
            },
            clear: function(t, e) {
                var i, n = this.dom, a = this.ctx, r = n.width, o = n.height, s = (e = e || this.clearColor,
                this.motionBlur && !t), l = this.lastFrameAlpha, u = this.dpr;
                s && (this.domBack || this.createBackBuffer(),
                this.ctxBack.globalCompositeOperation = "copy",
                this.ctxBack.drawImage(n, 0, 0, r / u, o / u)),
                a.clearRect(0, 0, r, o),
                e && "transparent" !== e && (e.colorStops ? (i = e.__canvasGradient || ai.getGradient(a, e, {
                    x: 0,
                    y: 0,
                    width: r,
                    height: o
                }),
                e.__canvasGradient = i) : e.image && (i = ri.prototype.getCanvasPattern.call(e, a)),
                a.save(),
                a.fillStyle = i || e,
                a.fillRect(0, 0, r, o),
                a.restore());
                if (s) {
                    var h = this.domBack;
                    a.save(),
                    a.globalAlpha = l,
                    a.drawImage(h, 0, 0, r, o),
                    a.restore()
                }
            }
        };
        var hi = ui
          , ci = "undefined" != typeof window && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(t) {
            setTimeout(t, 16)
        }
          , di = new Dt(50);
        function pi() {
            var t = this.__cachedImgObj;
            this.onload = this.onerror = this.__cachedImgObj = null;
            for (var e = 0; e < t.pending.length; e++) {
                var i = t.pending[e]
                  , n = i.cb;
                n && n(this, i.cbPayload),
                i.hostEl.dirty()
            }
            t.pending.length = 0
        }
        function fi(t) {
            return t && t.width && t.height
        }
        var gi = {
            findExistImage: function(t) {
                if ("string" != typeof t)
                    return t;
                var e = di.get(t);
                return e && e.image
            },
            createOrUpdateImage: function(t, e, i, n, a) {
                if (t) {
                    if ("string" != typeof t)
                        return t;
                    if (e && e.__zrImageSrc === t || !i)
                        return e;
                    var r = di.get(t)
                      , o = {
                        hostEl: i,
                        cb: n,
                        cbPayload: a
                    };
                    return r ? fi(e = r.image) || r.pending.push(o) : ((e = new Image).onload = e.onerror = pi,
                    di.put(t, e.__cachedImgObj = {
                        image: e,
                        pending: [o]
                    }),
                    e.src = e.__zrImageSrc = t),
                    e
                }
                return e
            },
            isImageReady: fi
        }
          , mi = it.getContext
          , vi = it.extend
          , yi = it.retrieve2
          , xi = it.retrieve3
          , _i = it.trim
          , bi = {}
          , wi = 0
          , Si = 5e3
          , Mi = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g
          , Ii = "12px sans-serif"
          , Ai = {};
        function Ti(t, e) {
            var i = t + ":" + (e = e || Ii);
            if (bi[i])
                return bi[i];
            for (var n = (t + "").split("\n"), a = 0, r = 0, o = n.length; r < o; r++)
                a = Math.max(Ni(n[r], e).width, a);
            return Si < wi && (wi = 0,
            bi = {}),
            wi++,
            bi[i] = a
        }
        function Ci(t, e, i) {
            return "right" === i ? t -= e : "center" === i && (t -= e / 2),
            t
        }
        function Di(t, e, i) {
            return "middle" === i ? t -= e / 2 : "bottom" === i && (t -= e),
            t
        }
        function Li(t, e, i, n, a) {
            if (!e)
                return "";
            var r = (t + "").split("\n");
            a = Pi(e, i, n, a);
            for (var o = 0, s = r.length; o < s; o++)
                r[o] = ki(r[o], a);
            return r.join("\n")
        }
        function Pi(t, e, i, n) {
            (n = vi({}, n)).font = e;
            i = yi(i, "...");
            n.maxIterations = yi(n.maxIterations, 2);
            var a = n.minChar = yi(n.minChar, 0);
            n.cnCharWidth = Ti("", e);
            var r = n.ascCharWidth = Ti("a", e);
            n.placeholder = yi(n.placeholder, "");
            for (var o = t = Math.max(0, t - 1), s = 0; s < a && r <= o; s++)
                o -= r;
            var l = Ti(i, e);
            return o < l && (i = "",
            l = 0),
            o = t - l,
            n.ellipsis = i,
            n.ellipsisWidth = l,
            n.contentWidth = o,
            n.containerWidth = t,
            n
        }
        function ki(t, e) {
            var i = e.containerWidth
              , n = e.font
              , a = e.contentWidth;
            if (!i)
                return "";
            var r = Ti(t, n);
            if (r <= i)
                return t;
            for (var o = 0; ; o++) {
                if (r <= a || o >= e.maxIterations) {
                    t += e.ellipsis;
                    break
                }
                var s = 0 === o ? Oi(t, a, e.ascCharWidth, e.cnCharWidth) : 0 < r ? Math.floor(t.length * a / r) : 0;
                r = Ti(t = t.substr(0, s), n)
            }
            return "" === t && (t = e.placeholder),
            t
        }
        function Oi(t, e, i, n) {
            for (var a = 0, r = 0, o = t.length; r < o && a < e; r++) {
                var s = t.charCodeAt(r);
                a += 0 <= s && s <= 127 ? i : n
            }
            return r
        }
        function Ri(t) {
            return Ti("", t)
        }
        function Ni(t, e) {
            return Ai.measureText(t, e)
        }
        function Ei(t, e, i, n, a) {
            null != t && (t += "");
            var r = yi(n, Ri(e))
              , o = t ? t.split("\n") : []
              , s = o.length * r
              , l = s;
            if (i && (l += i[0] + i[2]),
            t && a) {
                var u = a.outerHeight
                  , h = a.outerWidth;
                if (null != u && u < l)
                    t = "",
                    o = [];
                else if (null != h)
                    for (var c = Pi(h - (i ? i[1] + i[3] : 0), e, a.ellipsis, {
                        minChar: a.minChar,
                        placeholder: a.placeholder
                    }), d = 0, p = o.length; d < p; d++)
                        o[d] = ki(o[d], c)
            }
            return {
                lines: o,
                height: s,
                outerHeight: l,
                lineHeight: r
            }
        }
        function zi(t, e) {
            var i = {
                lines: [],
                width: 0,
                height: 0
            };
            if (null != t && (t += ""),
            !t)
                return i;
            for (var n, a = Mi.lastIndex = 0; null != (n = Mi.exec(t)); ) {
                var r = n.index;
                a < r && Vi(i, t.substring(a, r)),
                Vi(i, n[2], n[1]),
                a = Mi.lastIndex
            }
            a < t.length && Vi(i, t.substring(a, t.length));
            var o = i.lines
              , s = 0
              , l = 0
              , u = []
              , h = e.textPadding
              , c = e.truncate
              , d = c && c.outerWidth
              , p = c && c.outerHeight;
            h && (null != d && (d -= h[1] + h[3]),
            null != p && (p -= h[0] + h[2]));
            for (var f = 0; f < o.length; f++) {
                for (var g = o[f], m = 0, v = 0, y = 0; y < g.tokens.length; y++) {
                    var x = (D = g.tokens[y]).styleName && e.rich[D.styleName] || {}
                      , _ = D.textPadding = x.textPadding
                      , b = D.font = x.font || e.font
                      , w = D.textHeight = yi(x.textHeight, Ri(b));
                    if (_ && (w += _[0] + _[2]),
                    D.height = w,
                    D.lineHeight = xi(x.textLineHeight, e.textLineHeight, w),
                    D.textAlign = x && x.textAlign || e.textAlign,
                    D.textVerticalAlign = x && x.textVerticalAlign || "middle",
                    null != p && s + D.lineHeight > p)
                        return {
                            lines: [],
                            width: 0,
                            height: 0
                        };
                    D.textWidth = Ti(D.text, b);
                    var S = x.textWidth
                      , M = null == S || "auto" === S;
                    if ("string" == typeof S && "%" === S.charAt(S.length - 1))
                        D.percentWidth = S,
                        u.push(D),
                        S = 0;
                    else {
                        if (M) {
                            S = D.textWidth;
                            var I = x.textBackgroundColor
                              , A = I && I.image;
                            A && (A = gi.findExistImage(A),
                            gi.isImageReady(A) && (S = Math.max(S, A.width * w / A.height)))
                        }
                        var T = _ ? _[1] + _[3] : 0;
                        S += T;
                        var C = null != d ? d - v : null;
                        null != C && C < S && (!M || C < T ? (D.text = "",
                        D.textWidth = S = 0) : (D.text = Li(D.text, C - T, b, c.ellipsis, {
                            minChar: c.minChar
                        }),
                        D.textWidth = Ti(D.text, b),
                        S = D.textWidth + T))
                    }
                    v += D.width = S,
                    x && (m = Math.max(m, D.lineHeight))
                }
                g.width = v,
                s += g.lineHeight = m,
                l = Math.max(l, v)
            }
            i.outerWidth = i.width = yi(e.textWidth, l),
            i.outerHeight = i.height = yi(e.textHeight, s),
            h && (i.outerWidth += h[1] + h[3],
            i.outerHeight += h[0] + h[2]);
            for (f = 0; f < u.length; f++) {
                var D, L = (D = u[f]).percentWidth;
                D.width = parseInt(L, 10) / 100 * l
            }
            return i
        }
        function Vi(t, e, i) {
            for (var n = "" === e, a = e.split("\n"), r = t.lines, o = 0; o < a.length; o++) {
                var s = a[o]
                  , l = {
                    styleName: i,
                    text: s,
                    isLineHolder: !s && !n
                };
                if (o)
                    r.push({
                        tokens: [l]
                    });
                else {
                    var u = (r[r.length - 1] || (r[0] = {
                        tokens: []
                    })).tokens
                      , h = u.length;
                    1 === h && u[0].isLineHolder ? u[0] = l : !s && h && !n || u.push(l)
                }
            }
        }
        Ai.measureText = function(t, e) {
            var i = mi();
            return i.font = e || Ii,
            i.measureText(t)
        }
        ;
        var Bi = {
            DEFAULT_FONT: Ii,
            $override: function(t, e) {
                Ai[t] = e
            },
            getWidth: Ti,
            getBoundingRect: function(t, e, i, n, a, r, o, s) {
                return o ? function(t, e, i, n, a, r, o, s) {
                    var l = zi(t, {
                        rich: o,
                        truncate: s,
                        font: e,
                        textAlign: i,
                        textPadding: a,
                        textLineHeight: r
                    })
                      , u = l.outerWidth
                      , h = l.outerHeight
                      , c = Ci(0, u, i)
                      , d = Di(0, h, n);
                    return new Oe(c,d,u,h)
                }(t, e, i, n, a, r, o, s) : function(t, e, i, n, a, r, o) {
                    var s = Ei(t, e, a, r, o)
                      , l = Ti(t, e);
                    a && (l += a[1] + a[3]);
                    var u = s.outerHeight
                      , h = Ci(0, l, i)
                      , c = Di(0, u, n)
                      , d = new Oe(h,c,l,u);
                    return d.lineHeight = s.lineHeight,
                    d
                }(t, e, i, n, a, r, s)
            },
            adjustTextX: Ci,
            adjustTextY: Di,
            adjustTextPositionOnRect: function(t, e, i) {
                var n = e.x
                  , a = e.y
                  , r = e.height
                  , o = e.width
                  , s = r / 2
                  , l = "left"
                  , u = "top";
                switch (t) {
                case "left":
                    n -= i,
                    a += s,
                    l = "right",
                    u = "middle";
                    break;
                case "right":
                    n += i + o,
                    a += s,
                    u = "middle";
                    break;
                case "top":
                    n += o / 2,
                    a -= i,
                    l = "center",
                    u = "bottom";
                    break;
                case "bottom":
                    n += o / 2,
                    a += r + i,
                    l = "center";
                    break;
                case "inside":
                    n += o / 2,
                    a += s,
                    l = "center",
                    u = "middle";
                    break;
                case "insideLeft":
                    n += i,
                    a += s,
                    u = "middle";
                    break;
                case "insideRight":
                    n += o - i,
                    a += s,
                    l = "right",
                    u = "middle";
                    break;
                case "insideTop":
                    n += o / 2,
                    a += i,
                    l = "center";
                    break;
                case "insideBottom":
                    n += o / 2,
                    a += r - i,
                    l = "center",
                    u = "bottom";
                    break;
                case "insideTopLeft":
                    n += i,
                    a += i;
                    break;
                case "insideTopRight":
                    n += o - i,
                    a += i,
                    l = "right";
                    break;
                case "insideBottomLeft":
                    n += i,
                    a += r - i,
                    u = "bottom";
                    break;
                case "insideBottomRight":
                    n += o - i,
                    a += r - i,
                    l = "right",
                    u = "bottom"
                }
                return {
                    x: n,
                    y: a,
                    textAlign: l,
                    textVerticalAlign: u
                }
            },
            truncateText: Li,
            getLineHeight: Ri,
            measureText: Ni,
            parsePlainText: Ei,
            parseRichText: zi,
            makeFont: function(t) {
                var e = (t.fontSize || t.fontFamily) && [t.fontStyle, t.fontWeight, (t.fontSize || 12) + "px", t.fontFamily || "sans-serif"].join(" ");
                return e && _i(e) || t.textFont || t.font
            }
        };
        var Gi = {
            buildPath: function(t, e) {
                var i, n, a, r, o, s = e.x, l = e.y, u = e.width, h = e.height, c = e.r;
                u < 0 && (s += u,
                u = -u),
                h < 0 && (l += h,
                h = -h),
                "number" == typeof c ? i = n = a = r = c : c instanceof Array ? 1 === c.length ? i = n = a = r = c[0] : 2 === c.length ? (i = a = c[0],
                n = r = c[1]) : 3 === c.length ? (i = c[0],
                n = r = c[1],
                a = c[2]) : (i = c[0],
                n = c[1],
                a = c[2],
                r = c[3]) : i = n = a = r = 0,
                u < i + n && (i *= u / (o = i + n),
                n *= u / o),
                u < a + r && (a *= u / (o = a + r),
                r *= u / o),
                h < n + a && (n *= h / (o = n + a),
                a *= h / o),
                h < i + r && (i *= h / (o = i + r),
                r *= h / o),
                t.moveTo(s + i, l),
                t.lineTo(s + u - n, l),
                0 !== n && t.arc(s + u - n, l + n, n, -Math.PI / 2, 0),
                t.lineTo(s + u, l + h - a),
                0 !== a && t.arc(s + u - a, l + h - a, a, 0, Math.PI / 2),
                t.lineTo(s + r, l + h),
                0 !== r && t.arc(s + r, l + h - r, r, Math.PI / 2, Math.PI),
                t.lineTo(s, l + i),
                0 !== i && t.arc(s + i, l + i, i, Math.PI, 1.5 * Math.PI)
            }
        }
          , Fi = it.retrieve2
          , Hi = it.retrieve3
          , Wi = it.each
          , Zi = it.normalizeCssArray
          , Ui = it.isString
          , Yi = it.isObject
          , ji = qe.ContextCachedBy
          , Xi = qe.WILL_BE_RESTORED
          , qi = Bi.DEFAULT_FONT
          , Ki = {
            left: 1,
            right: 1,
            center: 1
        }
          , $i = {
            top: 1,
            bottom: 1,
            middle: 1
        }
          , Ji = [["textShadowBlur", "shadowBlur", 0], ["textShadowOffsetX", "shadowOffsetX", 0], ["textShadowOffsetY", "shadowOffsetY", 0], ["textShadowColor", "shadowColor", "transparent"]];
        function Qi(t) {
            if (t) {
                t.font = Bi.makeFont(t);
                var e = t.textAlign;
                "middle" === e && (e = "center"),
                t.textAlign = null == e || Ki[e] ? e : "left";
                var i = t.textVerticalAlign || t.textBaseline;
                "center" === i && (i = "middle"),
                t.textVerticalAlign = null == i || $i[i] ? i : "top",
                t.textPadding && (t.textPadding = Zi(t.textPadding))
            }
        }
        function tn(t, e, i, n, a) {
            if (i && e.textRotation) {
                var r = e.textOrigin;
                "center" === r ? (n = i.width / 2 + i.x,
                a = i.height / 2 + i.y) : r && (n = r[0] + i.x,
                a = r[1] + i.y),
                t.translate(n, a),
                t.rotate(-e.textRotation),
                t.translate(-n, -a)
            }
        }
        function en(t, e, i, n, a, r, o, s) {
            var l = n.rich[i.styleName] || {};
            l.text = i.text;
            var u = i.textVerticalAlign
              , h = r + a / 2;
            "top" === u ? h = r + i.height / 2 : "bottom" === u && (h = r + a - i.height / 2),
            !i.isLineHolder && nn(l) && an(t, e, l, "right" === s ? o - i.width : "center" === s ? o - i.width / 2 : o, h - i.height / 2, i.width, i.height);
            var c = i.textPadding;
            c && (o = cn(o, s, c),
            h -= i.height / 2 - c[2] - i.textHeight / 2),
            sn(e, "shadowBlur", Hi(l.textShadowBlur, n.textShadowBlur, 0)),
            sn(e, "shadowColor", l.textShadowColor || n.textShadowColor || "transparent"),
            sn(e, "shadowOffsetX", Hi(l.textShadowOffsetX, n.textShadowOffsetX, 0)),
            sn(e, "shadowOffsetY", Hi(l.textShadowOffsetY, n.textShadowOffsetY, 0)),
            sn(e, "textAlign", s),
            sn(e, "textBaseline", "middle"),
            sn(e, "font", i.font || qi);
            var d = ln(l.textStroke || n.textStroke, f)
              , p = un(l.textFill || n.textFill)
              , f = Fi(l.textStrokeWidth, n.textStrokeWidth);
            d && (sn(e, "lineWidth", f),
            sn(e, "strokeStyle", d),
            e.strokeText(i.text, o, h)),
            p && (sn(e, "fillStyle", p),
            e.fillText(i.text, o, h))
        }
        function nn(t) {
            return !!(t.textBackgroundColor || t.textBorderWidth && t.textBorderColor)
        }
        function an(t, e, i, n, a, r, o) {
            var s = i.textBackgroundColor
              , l = i.textBorderWidth
              , u = i.textBorderColor
              , h = Ui(s);
            if (sn(e, "shadowBlur", i.textBoxShadowBlur || 0),
            sn(e, "shadowColor", i.textBoxShadowColor || "transparent"),
            sn(e, "shadowOffsetX", i.textBoxShadowOffsetX || 0),
            sn(e, "shadowOffsetY", i.textBoxShadowOffsetY || 0),
            h || l && u) {
                e.beginPath();
                var c = i.textBorderRadius;
                c ? Gi.buildPath(e, {
                    x: n,
                    y: a,
                    width: r,
                    height: o,
                    r: c
                }) : e.rect(n, a, r, o),
                e.closePath()
            }
            if (h)
                if (sn(e, "fillStyle", s),
                null != i.fillOpacity) {
                    var d = e.globalAlpha;
                    e.globalAlpha = i.fillOpacity * i.opacity,
                    e.fill(),
                    e.globalAlpha = d
                } else
                    e.fill();
            else if (Yi(s)) {
                var p = s.image;
                (p = gi.createOrUpdateImage(p, null, t, rn, s)) && gi.isImageReady(p) && e.drawImage(p, n, a, r, o)
            }
            if (l && u)
                if (sn(e, "lineWidth", l),
                sn(e, "strokeStyle", u),
                null != i.strokeOpacity) {
                    d = e.globalAlpha;
                    e.globalAlpha = i.strokeOpacity * i.opacity,
                    e.stroke(),
                    e.globalAlpha = d
                } else
                    e.stroke()
        }
        function rn(t, e) {
            e.image = t
        }
        function on(t, e, i) {
            var n = e.x || 0
              , a = e.y || 0
              , r = e.textAlign
              , o = e.textVerticalAlign;
            if (i) {
                var s = e.textPosition;
                if (s instanceof Array)
                    n = i.x + hn(s[0], i.width),
                    a = i.y + hn(s[1], i.height);
                else {
                    var l = Bi.adjustTextPositionOnRect(s, i, e.textDistance);
                    n = l.x,
                    a = l.y,
                    r = r || l.textAlign,
                    o = o || l.textVerticalAlign
                }
                var u = e.textOffset;
                u && (n += u[0],
                a += u[1])
            }
            return {
                baseX: n,
                baseY: a,
                textAlign: r,
                textVerticalAlign: o
            }
        }
        function sn(t, e, i) {
            return t[e] = Xe(t, e, i),
            t[e]
        }
        function ln(t, e) {
            return null == t || e <= 0 || "transparent" === t || "none" === t ? null : t.image || t.colorStops ? "#000" : t
        }
        function un(t) {
            return null == t || "none" === t ? null : t.image || t.colorStops ? "#000" : t
        }
        function hn(t, e) {
            return "string" == typeof t ? 0 <= t.lastIndexOf("%") ? parseFloat(t) / 100 * e : parseFloat(t) : t
        }
        function cn(t, e, i) {
            return "right" === e ? t - i[1] : "center" === e ? t + i[3] / 2 - i[1] / 2 : t + i[3]
        }
        function dn() {}
        var pn = {
            normalizeTextStyle: function(t) {
                return Qi(t),
                Wi(t.rich, Qi),
                t
            },
            renderText: function(t, e, i, n, a, r) {
                n.rich ? function(t, e, i, n, a, r) {
                    r !== Xi && (e.__attrCachedBy = ji.NONE);
                    var o = t.__textCotentBlock;
                    o && !t.__dirtyText || (o = t.__textCotentBlock = Bi.parseRichText(i, n));
                    !function(t, e, i, n, a) {
                        var r = i.width
                          , o = i.outerWidth
                          , s = i.outerHeight
                          , l = n.textPadding
                          , u = on(s, n, a)
                          , h = u.baseX
                          , c = u.baseY
                          , d = u.textAlign
                          , p = u.textVerticalAlign;
                        tn(e, n, a, h, c);
                        var f = Bi.adjustTextX(h, o, d)
                          , g = Bi.adjustTextY(c, s, p)
                          , m = f
                          , v = g;
                        l && (m += l[3],
                        v += l[0]);
                        var y = m + r;
                        nn(n) && an(t, e, n, f, g, o, s);
                        for (var x = 0; x < i.lines.length; x++) {
                            for (var _, b = i.lines[x], w = b.tokens, S = w.length, M = b.lineHeight, I = b.width, A = 0, T = m, C = y, D = S - 1; A < S && (!(_ = w[A]).textAlign || "left" === _.textAlign); )
                                en(t, e, _, n, M, v, T, "left"),
                                I -= _.width,
                                T += _.width,
                                A++;
                            for (; 0 <= D && "right" === (_ = w[D]).textAlign; )
                                en(t, e, _, n, M, v, C, "right"),
                                I -= _.width,
                                C -= _.width,
                                D--;
                            for (T += (r - (T - m) - (y - C) - I) / 2; A <= D; )
                                _ = w[A],
                                en(t, e, _, n, M, v, T + _.width / 2, "center"),
                                T += _.width,
                                A++;
                            v += M
                        }
                    }(t, e, o, n, a)
                }(t, e, i, n, a, r) : function(t, e, i, n, a, r) {
                    var o, s = nn(n), l = !1, u = e.__attrCachedBy === ji.PLAIN_TEXT;
                    r !== Xi ? (r && (o = r.style,
                    l = !s && u && o),
                    e.__attrCachedBy = s ? ji.NONE : ji.PLAIN_TEXT) : u && (e.__attrCachedBy = ji.NONE);
                    var h = n.font || qi;
                    l && h === (o.font || qi) || (e.font = h);
                    var c = t.__computedFont;
                    t.__styleFont !== h && (t.__styleFont = h,
                    c = t.__computedFont = e.font);
                    var d = n.textPadding
                      , p = n.textLineHeight
                      , f = t.__textCotentBlock;
                    f && !t.__dirtyText || (f = t.__textCotentBlock = Bi.parsePlainText(i, c, d, p, n.truncate));
                    var g = f.outerHeight
                      , m = f.lines
                      , v = f.lineHeight
                      , y = on(g, n, a)
                      , x = y.baseX
                      , _ = y.baseY
                      , b = y.textAlign || "left"
                      , w = y.textVerticalAlign;
                    tn(e, n, a, x, _);
                    var S = Bi.adjustTextY(_, g, w)
                      , M = x
                      , I = S;
                    if (s || d) {
                        var A = Bi.getWidth(i, c);
                        d && (A += d[1] + d[3]);
                        var T = Bi.adjustTextX(x, A, b);
                        s && an(t, e, n, T, S, A, g),
                        d && (M = cn(x, b, d),
                        I += d[0])
                    }
                    e.textAlign = b,
                    e.textBaseline = "middle",
                    e.globalAlpha = n.opacity || 1;
                    for (var C = 0; C < Ji.length; C++) {
                        var D = Ji[C]
                          , L = D[0]
                          , P = D[1]
                          , k = n[L];
                        l && k === o[L] || (e[P] = Xe(e, P, k || D[2]))
                    }
                    I += v / 2;
                    var O = n.textStrokeWidth
                      , R = l ? o.textStrokeWidth : null
                      , N = !l || O !== R
                      , E = !l || N || n.textStroke !== o.textStroke
                      , z = ln(n.textStroke, O)
                      , V = un(n.textFill);
                    z && (N && (e.lineWidth = O),
                    E && (e.strokeStyle = z));
                    V && (l && n.textFill === o.textFill || (e.fillStyle = V));
                    if (1 === m.length)
                        z && e.strokeText(m[0], M, I),
                        V && e.fillText(m[0], M, I);
                    else
                        for (C = 0; C < m.length; C++)
                            z && e.strokeText(m[C], M, I),
                            V && e.fillText(m[C], M, I),
                            I += v
                }(t, e, i, n, a, r)
            },
            getStroke: ln,
            getFill: un,
            needDrawText: function(t, e) {
                return null != t && (t || e.textBackgroundColor || e.textBorderWidth && e.textBorderColor || e.textPadding)
            }
        }
          , fn = qe.WILL_BE_RESTORED
          , gn = new Oe;
        dn.prototype = {
            constructor: dn,
            drawRectText: function(t, e) {
                var i = this.style;
                e = i.textRect || e,
                this.__dirty && pn.normalizeTextStyle(i, !0);
                var n = i.text;
                if (null != n && (n += ""),
                pn.needDrawText(n, i)) {
                    t.save();
                    var a = this.transform;
                    i.transformText ? this.setTransform(t) : a && (gn.copy(e),
                    gn.applyTransform(a),
                    e = gn),
                    pn.renderText(this, t, n, i, e, fn),
                    t.restore()
                }
            }
        };
        var mn = dn;
        function vn(t) {
            for (var e in t = t || {},
            Te.call(this, t),
            t)
                t.hasOwnProperty(e) && "style" !== e && (this[e] = t[e]);
            this.style = new ai(t.style,this),
            this._rect = null,
            this.__clipPaths = []
        }
        vn.prototype = {
            constructor: vn,
            type: "displayable",
            __dirty: !0,
            invisible: !1,
            z: 0,
            z2: 0,
            zlevel: 0,
            draggable: !1,
            dragging: !1,
            silent: !1,
            culling: !1,
            cursor: "pointer",
            rectHover: !1,
            progressive: !1,
            incremental: !1,
            globalScaleRatio: 1,
            beforeBrush: function(t) {},
            afterBrush: function(t) {},
            brush: function(t, e) {},
            getBoundingRect: function() {},
            contain: function(t, e) {
                return this.rectContain(t, e)
            },
            traverse: function(t, e) {
                t.call(e, this)
            },
            rectContain: function(t, e) {
                var i = this.transformCoordToLocal(t, e);
                return this.getBoundingRect().contain(i[0], i[1])
            },
            dirty: function() {
                this.__dirty = this.__dirtyText = !0,
                this._rect = null,
                this.__zr && this.__zr.refresh()
            },
            animateStyle: function(t) {
                return this.animate("style", t)
            },
            attrKV: function(t, e) {
                "style" !== t ? Te.prototype.attrKV.call(this, t, e) : this.style.set(e)
            },
            setStyle: function(t, e) {
                return this.style.set(t, e),
                this.dirty(!1),
                this
            },
            useStyle: function(t) {
                return this.style = new ai(t,this),
                this.dirty(!1),
                this
            }
        },
        it.inherits(vn, Te),
        it.mixin(vn, mn);
        var yn = vn;
        function xn(t) {
            yn.call(this, t)
        }
        xn.prototype = {
            constructor: xn,
            type: "image",
            brush: function(t, e) {
                var i = this.style
                  , n = i.image;
                i.bind(t, this, e);
                var a = this._image = gi.createOrUpdateImage(n, this._image, this, this.onload);
                if (a && gi.isImageReady(a)) {
                    var r = i.x || 0
                      , o = i.y || 0
                      , s = i.width
                      , l = i.height
                      , u = a.width / a.height;
                    if (null == s && null != l ? s = l * u : null == l && null != s ? l = s / u : null == s && null == l && (s = a.width,
                    l = a.height),
                    this.setTransform(t),
                    i.sWidth && i.sHeight) {
                        var h = i.sx || 0
                          , c = i.sy || 0;
                        t.drawImage(a, h, c, i.sWidth, i.sHeight, r, o, s, l)
                    } else if (i.sx && i.sy) {
                        var d = s - (h = i.sx)
                          , p = l - (c = i.sy);
                        t.drawImage(a, h, c, d, p, r, o, s, l)
                    } else
                        t.drawImage(a, r, o, s, l);
                    null != i.text && (this.restoreTransform(t),
                    this.drawRectText(t, this.getBoundingRect()))
                }
            },
            getBoundingRect: function() {
                var t = this.style;
                return this._rect || (this._rect = new Oe(t.x || 0,t.y || 0,t.width || 0,t.height || 0)),
                this._rect
            }
        },
        it.inherits(xn, yn);
        var _n = xn
          , bn = de.devicePixelRatio
          , wn = 314159;
        function Sn(t) {
            return parseInt(t, 10)
        }
        var Mn = new Oe(0,0,0,0)
          , In = new Oe(0,0,0,0);
        function An(t, e, i) {
            this.type = "canvas";
            var n = !t.nodeName || "CANVAS" === t.nodeName.toUpperCase();
            this._opts = i = it.extend({}, i || {}),
            this.dpr = i.devicePixelRatio || bn,
            this._singleCanvas = n;
            var a = (this.root = t).style;
            a && (a["-webkit-tap-highlight-color"] = "transparent",
            a["-webkit-user-select"] = a["user-select"] = a["-webkit-touch-callout"] = "none",
            t.innerHTML = ""),
            this.storage = e;
            var r = this._zlevelList = []
              , o = this._layers = {};
            if (this._layerConfig = {},
            this._needsManuallyCompositing = !1,
            n) {
                var s = t.width
                  , l = t.height;
                null != i.width && (s = i.width),
                null != i.height && (l = i.height),
                this.dpr = i.devicePixelRatio || 1,
                t.width = s * this.dpr,
                t.height = l * this.dpr,
                this._width = s,
                this._height = l;
                var u = new hi(t,this,this.dpr);
                u.__builtin__ = !0,
                u.initContext(),
                (o[wn] = u).zlevel = wn,
                r.push(wn),
                this._domRoot = t
            } else {
                this._width = this._getSize(0),
                this._height = this._getSize(1);
                var h = this._domRoot = function(t, e) {
                    var i = document.createElement("div");
                    return i.style.cssText = ["position:relative", "overflow:hidden", "width:" + t + "px", "height:" + e + "px", "padding:0", "margin:0", "border-width:0"].join(";") + ";",
                    i
                }(this._width, this._height);
                t.appendChild(h)
            }
            this._hoverlayer = null,
            this._hoverElements = []
        }
        An.prototype = {
            constructor: An,
            getType: function() {
                return "canvas"
            },
            isSingleCanvas: function() {
                return this._singleCanvas
            },
            getViewportRoot: function() {
                return this._domRoot
            },
            getViewportRootOffset: function() {
                var t = this.getViewportRoot();
                if (t)
                    return {
                        offsetLeft: t.offsetLeft || 0,
                        offsetTop: t.offsetTop || 0
                    }
            },
            refresh: function(t) {
                var e = this.storage.getDisplayList(!0)
                  , i = this._zlevelList;
                this._redrawId = Math.random(),
                this._paintList(e, t, this._redrawId);
                for (var n = 0; n < i.length; n++) {
                    var a = i[n]
                      , r = this._layers[a];
                    if (!r.__builtin__ && r.refresh) {
                        var o = 0 === n ? this._backgroundColor : null;
                        r.refresh(o)
                    }
                }
                return this.refreshHover(),
                this
            },
            addHover: function(t, e) {
                if (!t.__hoverMir) {
                    var i = new t.constructor({
                        style: t.style,
                        shape: t.shape,
                        z: t.z,
                        z2: t.z2,
                        silent: t.silent
                    });
                    return (i.__from = t).__hoverMir = i,
                    e && i.setStyle(e),
                    this._hoverElements.push(i),
                    i
                }
            },
            removeHover: function(t) {
                var e = t.__hoverMir
                  , i = this._hoverElements
                  , n = it.indexOf(i, e);
                0 <= n && i.splice(n, 1),
                t.__hoverMir = null
            },
            clearHover: function(t) {
                for (var e = this._hoverElements, i = 0; i < e.length; i++) {
                    var n = e[i].__from;
                    n && (n.__hoverMir = null)
                }
                e.length = 0
            },
            refreshHover: function() {
                var t = this._hoverElements
                  , e = t.length
                  , i = this._hoverlayer;
                if (i && i.clear(),
                e) {
                    He(t, this.storage.displayableSortFunc);
                    var n = {};
                    (i = i || (this._hoverlayer = this.getLayer(1e5))).ctx.save();
                    for (var a = 0; a < e; ) {
                        var r = t[a]
                          , o = r.__from;
                        o && o.__zr ? (a++,
                        o.invisible || (r.transform = o.transform,
                        r.invTransform = o.invTransform,
                        r.__clipPaths = o.__clipPaths,
                        this._doPaintEl(r, i, !0, n))) : (t.splice(a, 1),
                        o.__hoverMir = null,
                        e--)
                    }
                    i.ctx.restore()
                }
            },
            getHoverLayer: function() {
                return this.getLayer(1e5)
            },
            _paintList: function(t, e, i) {
                if (this._redrawId === i) {
                    e = e || !1,
                    this._updateLayerStatus(t);
                    var n = this._doPaintList(t, e);
                    if (this._needsManuallyCompositing && this._compositeManually(),
                    !n) {
                        var a = this;
                        ci(function() {
                            a._paintList(t, e, i)
                        })
                    }
                }
            },
            _compositeManually: function() {
                var e = this.getLayer(wn).ctx
                  , i = this._domRoot.width
                  , n = this._domRoot.height;
                e.clearRect(0, 0, i, n),
                this.eachBuiltinLayer(function(t) {
                    t.virtual && e.drawImage(t.dom, 0, 0, i, n)
                })
            },
            _doPaintList: function(t, e) {
                for (var i = [], n = 0; n < this._zlevelList.length; n++) {
                    var a = this._zlevelList[n];
                    (s = this._layers[a]).__builtin__ && s !== this._hoverlayer && (s.__dirty || e) && i.push(s)
                }
                for (var r = !0, o = 0; o < i.length; o++) {
                    var s, l = (s = i[o]).ctx, u = {};
                    l.save();
                    var h = e ? s.__startIndex : s.__drawIndex
                      , c = !e && s.incremental && Date.now
                      , d = c && Date.now()
                      , p = s.zlevel === this._zlevelList[0] ? this._backgroundColor : null;
                    if (s.__startIndex === s.__endIndex)
                        s.clear(!1, p);
                    else if (h === s.__startIndex) {
                        var f = t[h];
                        f.incremental && f.notClear && !e || s.clear(!1, p)
                    }
                    -1 === h && (console.error("For some unknown reason. drawIndex is -1"),
                    h = s.__startIndex);
                    for (var g = h; g < s.__endIndex; g++) {
                        var m = t[g];
                        if (this._doPaintEl(m, s, e, u),
                        m.__dirty = m.__dirtyText = !1,
                        c)
                            if (15 < Date.now() - d)
                                break
                    }
                    s.__drawIndex = g,
                    s.__drawIndex < s.__endIndex && (r = !1),
                    u.prevElClipPaths && l.restore(),
                    l.restore()
                }
                return et.wxa && it.each(this._layers, function(t) {
                    t && t.ctx && t.ctx.draw && t.ctx.draw()
                }),
                r
            },
            _doPaintEl: function(t, e, i, n) {
                var a = e.ctx
                  , r = t.transform;
                if ((e.__dirty || i) && !t.invisible && 0 !== t.style.opacity && (!r || r[0] || r[3]) && (!t.culling || !function(t, e, i) {
                    return Mn.copy(t.getBoundingRect()),
                    t.transform && Mn.applyTransform(t.transform),
                    In.width = e,
                    In.height = i,
                    !Mn.intersect(In)
                }(t, this._width, this._height))) {
                    var o = t.__clipPaths;
                    n.prevElClipPaths && !function(t, e) {
                        if (t === e)
                            return !1;
                        if (!t || !e || t.length !== e.length)
                            return !0;
                        for (var i = 0; i < t.length; i++)
                            if (t[i] !== e[i])
                                return !0
                    }(o, n.prevElClipPaths) || (n.prevElClipPaths && (e.ctx.restore(),
                    n.prevElClipPaths = null,
                    n.prevEl = null),
                    o && (a.save(),
                    function(t, e) {
                        for (var i = 0; i < t.length; i++) {
                            var n = t[i];
                            n.setTransform(e),
                            e.beginPath(),
                            n.buildPath(e, n.shape),
                            e.clip(),
                            n.restoreTransform(e)
                        }
                    }(o, a),
                    n.prevElClipPaths = o)),
                    t.beforeBrush && t.beforeBrush(a),
                    t.brush(a, n.prevEl || null),
                    (n.prevEl = t).afterBrush && t.afterBrush(a)
                }
            },
            getLayer: function(t, e) {
                this._singleCanvas && !this._needsManuallyCompositing && (t = wn);
                var i = this._layers[t];
                return i || ((i = new hi("zr_" + t,this,this.dpr)).zlevel = t,
                i.__builtin__ = !0,
                this._layerConfig[t] && it.merge(i, this._layerConfig[t], !0),
                e && (i.virtual = e),
                this.insertLayer(t, i),
                i.initContext()),
                i
            },
            insertLayer: function(t, e) {
                var i = this._layers
                  , n = this._zlevelList
                  , a = n.length
                  , r = null
                  , o = -1
                  , s = this._domRoot;
                if (i[t])
                    pe("ZLevel " + t + " has been used already");
                else if (function(t) {
                    return !!t && (!!t.__builtin__ || "function" == typeof t.resize && "function" == typeof t.refresh)
                }(e)) {
                    if (0 < a && t > n[0]) {
                        for (o = 0; o < a - 1 && !(n[o] < t && n[o + 1] > t); o++)
                            ;
                        r = i[n[o]]
                    }
                    if (n.splice(o + 1, 0, t),
                    !(i[t] = e).virtual)
                        if (r) {
                            var l = r.dom;
                            l.nextSibling ? s.insertBefore(e.dom, l.nextSibling) : s.appendChild(e.dom)
                        } else
                            s.firstChild ? s.insertBefore(e.dom, s.firstChild) : s.appendChild(e.dom)
                } else
                    pe("Layer of zlevel " + t + " is not valid")
            },
            eachLayer: function(t, e) {
                var i, n, a = this._zlevelList;
                for (n = 0; n < a.length; n++)
                    i = a[n],
                    t.call(e, this._layers[i], i)
            },
            eachBuiltinLayer: function(t, e) {
                var i, n, a, r = this._zlevelList;
                for (a = 0; a < r.length; a++)
                    n = r[a],
                    (i = this._layers[n]).__builtin__ && t.call(e, i, n)
            },
            eachOtherLayer: function(t, e) {
                var i, n, a, r = this._zlevelList;
                for (a = 0; a < r.length; a++)
                    n = r[a],
                    (i = this._layers[n]).__builtin__ || t.call(e, i, n)
            },
            getLayers: function() {
                return this._layers
            },
            _updateLayerStatus: function(t) {
                function e(t) {
                    n && (n.__endIndex !== t && (n.__dirty = !0),
                    n.__endIndex = t)
                }
                if (this.eachBuiltinLayer(function(t, e) {
                    t.__dirty = t.__used = !1
                }),
                this._singleCanvas)
                    for (var i = 1; i < t.length; i++) {
                        if ((r = t[i]).zlevel !== t[i - 1].zlevel || r.incremental) {
                            this._needsManuallyCompositing = !0;
                            break
                        }
                    }
                var n = null
                  , a = 0;
                for (i = 0; i < t.length; i++) {
                    var r, o, s = (r = t[i]).zlevel;
                    r.incremental ? ((o = this.getLayer(s + .001, this._needsManuallyCompositing)).incremental = !0,
                    a = 1) : o = this.getLayer(s + (0 < a ? .01 : 0), this._needsManuallyCompositing),
                    o.__builtin__ || pe("ZLevel " + s + " has been used by unkown layer " + o.id),
                    o !== n && (o.__used = !0,
                    o.__startIndex !== i && (o.__dirty = !0),
                    o.__startIndex = i,
                    o.incremental ? o.__drawIndex = -1 : o.__drawIndex = i,
                    e(i),
                    n = o),
                    r.__dirty && (o.__dirty = !0,
                    o.incremental && o.__drawIndex < 0 && (o.__drawIndex = i))
                }
                e(i),
                this.eachBuiltinLayer(function(t, e) {
                    !t.__used && 0 < t.getElementCount() && (t.__dirty = !0,
                    t.__startIndex = t.__endIndex = t.__drawIndex = 0),
                    t.__dirty && t.__drawIndex < 0 && (t.__drawIndex = t.__startIndex)
                })
            },
            clear: function() {
                return this.eachBuiltinLayer(this._clearLayer),
                this
            },
            _clearLayer: function(t) {
                t.clear()
            },
            setBackgroundColor: function(t) {
                this._backgroundColor = t
            },
            configLayer: function(t, e) {
                if (e) {
                    var i = this._layerConfig;
                    i[t] ? it.merge(i[t], e, !0) : i[t] = e;
                    for (var n = 0; n < this._zlevelList.length; n++) {
                        var a = this._zlevelList[n];
                        if (a === t || a === t + .01) {
                            var r = this._layers[a];
                            it.merge(r, i[t], !0)
                        }
                    }
                }
            },
            delLayer: function(t) {
                var e = this._layers
                  , i = this._zlevelList
                  , n = e[t];
                n && (n.dom.parentNode.removeChild(n.dom),
                delete e[t],
                i.splice(it.indexOf(i, t), 1))
            },
            resize: function(e, i) {
                if (this._domRoot.style) {
                    var t = this._domRoot;
                    t.style.display = "none";
                    var n = this._opts;
                    if (null != e && (n.width = e),
                    null != i && (n.height = i),
                    e = this._getSize(0),
                    i = this._getSize(1),
                    t.style.display = "",
                    this._width !== e || i !== this._height) {
                        for (var a in t.style.width = e + "px",
                        t.style.height = i + "px",
                        this._layers)
                            this._layers.hasOwnProperty(a) && this._layers[a].resize(e, i);
                        it.each(this._progressiveLayers, function(t) {
                            t.resize(e, i)
                        }),
                        this.refresh(!0)
                    }
                    this._width = e,
                    this._height = i
                } else {
                    if (null == e || null == i)
                        return;
                    this._width = e,
                    this._height = i,
                    this.getLayer(wn).resize(e, i)
                }
                return this
            },
            clearLayer: function(t) {
                var e = this._layers[t];
                e && e.clear()
            },
            dispose: function() {
                this.root.innerHTML = "",
                this.root = this.storage = this._domRoot = this._layers = null
            },
            getRenderedCanvas: function(t) {
                if (t = t || {},
                this._singleCanvas && !this._compositeManually)
                    return this._layers[wn].dom;
                var e = new hi("image",this,t.pixelRatio || this.dpr);
                if (e.initContext(),
                e.clear(!1, t.backgroundColor || this._backgroundColor),
                t.pixelRatio <= this.dpr) {
                    this.refresh();
                    var i = e.dom.width
                      , n = e.dom.height
                      , a = e.ctx;
                    this.eachLayer(function(t) {
                        t.__builtin__ ? a.drawImage(t.dom, 0, 0, i, n) : t.renderToCanvas && (e.ctx.save(),
                        t.renderToCanvas(e.ctx),
                        e.ctx.restore())
                    })
                } else
                    for (var r = {}, o = this.storage.getDisplayList(!0), s = 0; s < o.length; s++) {
                        var l = o[s];
                        this._doPaintEl(l, e, !0, r)
                    }
                return e.dom
            },
            getWidth: function() {
                return this._width
            },
            getHeight: function() {
                return this._height
            },
            _getSize: function(t) {
                var e = this._opts
                  , i = ["width", "height"][t]
                  , n = ["clientWidth", "clientHeight"][t]
                  , a = ["paddingLeft", "paddingTop"][t]
                  , r = ["paddingRight", "paddingBottom"][t];
                if (null != e[i] && "auto" !== e[i])
                    return parseFloat(e[i]);
                var o = this.root
                  , s = document.defaultView.getComputedStyle(o);
                return (o[n] || Sn(s[i]) || Sn(o.style[i])) - (Sn(s[a]) || 0) - (Sn(s[r]) || 0) | 0
            },
            pathToImage: function(t, e) {
                e = e || this.dpr;
                var i = document.createElement("canvas")
                  , n = i.getContext("2d")
                  , a = t.getBoundingRect()
                  , r = t.style
                  , o = r.shadowBlur * e
                  , s = r.shadowOffsetX * e
                  , l = r.shadowOffsetY * e
                  , u = r.hasStroke() ? r.lineWidth : 0
                  , h = Math.max(u / 2, o - s)
                  , c = Math.max(u / 2, s + o)
                  , d = Math.max(u / 2, o - l)
                  , p = Math.max(u / 2, l + o)
                  , f = a.width + h + c
                  , g = a.height + d + p;
                i.width = f * e,
                i.height = g * e,
                n.scale(e, e),
                n.clearRect(0, 0, f, g),
                n.dpr = e;
                var m = {
                    position: t.position,
                    rotation: t.rotation,
                    scale: t.scale
                };
                t.position = [h - a.x, d - a.y],
                t.rotation = 0,
                t.scale = [1, 1],
                t.updateTransform(),
                t && t.brush(n);
                var v = new _n({
                    style: {
                        x: 0,
                        y: 0,
                        image: i
                    }
                });
                return null != m.position && (v.position = t.position = m.position),
                null != m.rotation && (v.rotation = t.rotation = m.rotation),
                null != m.scale && (v.scale = t.scale = m.scale),
                v
            }
        };
        function Tn(t) {
            t = t || {},
            this.stage = t.stage || {},
            this.onframe = t.onframe || function() {}
            ,
            this._clips = [],
            this._running = !1,
            this._time,
            this._pausedTime,
            this._pauseStart,
            this._paused = !1,
            Dn.call(this)
        }
        var Cn = An
          , Dn = j.Dispatcher;
        Tn.prototype = {
            constructor: Tn,
            addClip: function(t) {
                this._clips.push(t)
            },
            addAnimator: function(t) {
                t.animation = this;
                for (var e = t.getClips(), i = 0; i < e.length; i++)
                    this.addClip(e[i])
            },
            removeClip: function(t) {
                var e = it.indexOf(this._clips, t);
                0 <= e && this._clips.splice(e, 1)
            },
            removeAnimator: function(t) {
                for (var e = t.getClips(), i = 0; i < e.length; i++)
                    this.removeClip(e[i]);
                t.animation = null
            },
            _update: function() {
                for (var t = (new Date).getTime() - this._pausedTime, e = t - this._time, i = this._clips, n = i.length, a = [], r = [], o = 0; o < n; o++) {
                    var s = i[o]
                      , l = s.step(t, e);
                    l && (a.push(l),
                    r.push(s))
                }
                for (o = 0; o < n; )
                    i[o]._needsRemove ? (i[o] = i[n - 1],
                    i.pop(),
                    n--) : o++;
                n = a.length;
                for (o = 0; o < n; o++)
                    r[o].fire(a[o]);
                this._time = t,
                this.onframe(e),
                this.trigger("frame", e),
                this.stage.update && this.stage.update()
            },
            _startLoop: function() {
                var e = this;
                this._running = !0,
                ci(function t() {
                    e._running && (ci(t),
                    e._paused || e._update())
                })
            },
            start: function() {
                this._time = (new Date).getTime(),
                this._pausedTime = 0,
                this._startLoop()
            },
            stop: function() {
                this._running = !1
            },
            pause: function() {
                this._paused || (this._pauseStart = (new Date).getTime(),
                this._paused = !0)
            },
            resume: function() {
                this._paused && (this._pausedTime += (new Date).getTime() - this._pauseStart,
                this._paused = !1)
            },
            clear: function() {
                this._clips = []
            },
            isFinished: function() {
                return !this._clips.length
            },
            animate: function(t, e) {
                var i = new ue(t,(e = e || {}).loop,e.getter,e.setter);
                return this.addAnimator(i),
                i
            }
        },
        it.mixin(Tn, Dn);
        var Ln = Tn
          , Pn = j.addEventListener
          , kn = j.removeEventListener
          , On = j.normalizeEvent
          , Rn = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"]
          , Nn = ["touchstart", "touchend", "touchmove"]
          , En = {
            pointerdown: 1,
            pointerup: 1,
            pointermove: 1,
            pointerout: 1
        }
          , zn = it.map(Rn, function(t) {
            var e = t.replace("mouse", "pointer");
            return En[e] ? e : t
        });
        function Vn(t) {
            return "mousewheel" === t && et.browser.firefox ? "DOMMouseScroll" : t
        }
        function Bn(t) {
            t._touching = !0,
            clearTimeout(t._touchTimer),
            t._touchTimer = setTimeout(function() {
                t._touching = !1
            }, 700)
        }
        var Gn = {
            mousemove: function(t) {
                t = On(this.dom, t),
                this.trigger("mousemove", t)
            },
            mouseout: function(t) {
                var e = (t = On(this.dom, t)).toElement || t.relatedTarget;
                if (e !== this.dom)
                    for (; e && 9 !== e.nodeType; ) {
                        if (e === this.dom)
                            return;
                        e = e.parentNode
                    }
                this.trigger("mouseout", t)
            },
            touchstart: function(t) {
                (t = On(this.dom, t)).zrByTouch = !0,
                this._lastTouchMoment = new Date,
                this.handler.processGesture(this, t, "start"),
                Gn.mousemove.call(this, t),
                Gn.mousedown.call(this, t),
                Bn(this)
            },
            touchmove: function(t) {
                (t = On(this.dom, t)).zrByTouch = !0,
                this.handler.processGesture(this, t, "change"),
                Gn.mousemove.call(this, t),
                Bn(this)
            },
            touchend: function(t) {
                (t = On(this.dom, t)).zrByTouch = !0,
                this.handler.processGesture(this, t, "end"),
                Gn.mouseup.call(this, t),
                +new Date - this._lastTouchMoment < 300 && Gn.click.call(this, t),
                Bn(this)
            },
            pointerdown: function(t) {
                Gn.mousedown.call(this, t)
            },
            pointermove: function(t) {
                Fn(t) || Gn.mousemove.call(this, t)
            },
            pointerup: function(t) {
                Gn.mouseup.call(this, t)
            },
            pointerout: function(t) {
                Fn(t) || Gn.mouseout.call(this, t)
            }
        };
        function Fn(t) {
            var e = t.pointerType;
            return "pen" === e || "touch" === e
        }
        function Hn(i) {
            function t(t, e) {
                it.each(t, function(t) {
                    Pn(i, Vn(t), e._handlers[t])
                }, e)
            }
            nt.call(this),
            this.dom = i,
            this._touching = !1,
            this._touchTimer,
            this._handlers = {},
            function(e) {
                it.each(Nn, function(t) {
                    e._handlers[t] = it.bind(Gn[t], e)
                }),
                it.each(zn, function(t) {
                    e._handlers[t] = it.bind(Gn[t], e)
                }),
                it.each(Rn, function(t) {
                    e._handlers[t] = function(t, e) {
                        return function() {
                            if (!e._touching)
                                return t.apply(e, arguments)
                        }
                    }(Gn[t], e)
                })
            }(this),
            et.pointerEventsSupported ? t(zn, this) : (et.touchEventsSupported && t(Nn, this),
            t(Rn, this))
        }
        it.each(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(e) {
            Gn[e] = function(t) {
                t = On(this.dom, t),
                this.trigger(e, t)
            }
        });
        var Wn = Hn.prototype;
        Wn.dispose = function() {
            for (var t = Rn.concat(Nn), e = 0; e < t.length; e++) {
                var i = t[e];
                kn(this.dom, Vn(i), this._handlers[i])
            }
        }
        ,
        Wn.setCursor = function(t) {
            this.dom.style && (this.dom.style.cursor = t || "default")
        }
        ,
        it.mixin(Hn, nt);
        var Zn = Hn
          , Un = !et.canvasSupported
          , Yn = {
            canvas: Cn
        }
          , jn = {};
        function Xn(t, e, i) {
            i = i || {},
            this.dom = e,
            this.id = t;
            var n = this
              , a = new Ue
              , r = i.renderer;
            if (Un) {
                if (!Yn.vml)
                    throw new Error("You need to require 'zrender/vml/vml' to support IE8");
                r = "vml"
            } else
                r && Yn[r] || (r = "canvas");
            var o = new Yn[r](e,a,i,t);
            this.storage = a,
            this.painter = o;
            var s = et.node || et.worker ? null : new Zn(o.getViewportRoot());
            this.handler = new ot(a,o,s,o.root),
            this.animation = new Ln({
                stage: {
                    update: it.bind(this.flush, this)
                }
            }),
            this.animation.start(),
            this._needsRefresh;
            var l = a.delFromStorage
              , u = a.addToStorage;
            a.delFromStorage = function(t) {
                l.call(a, t),
                t && t.removeSelfFromZr(n)
            }
            ,
            a.addToStorage = function(t) {
                u.call(a, t),
                t.addSelfToZr(n)
            }
        }
        Xn.prototype = {
            constructor: Xn,
            getId: function() {
                return this.id
            },
            add: function(t) {
                this.storage.addRoot(t),
                this._needsRefresh = !0
            },
            remove: function(t) {
                this.storage.delRoot(t),
                this._needsRefresh = !0
            },
            configLayer: function(t, e) {
                this.painter.configLayer && this.painter.configLayer(t, e),
                this._needsRefresh = !0
            },
            setBackgroundColor: function(t) {
                this.painter.setBackgroundColor && this.painter.setBackgroundColor(t),
                this._needsRefresh = !0
            },
            refreshImmediately: function() {
                this._needsRefresh = !1,
                this.painter.refresh(),
                this._needsRefresh = !1
            },
            refresh: function() {
                this._needsRefresh = !0
            },
            flush: function() {
                var t;
                this._needsRefresh && (t = !0,
                this.refreshImmediately()),
                this._needsRefreshHover && (t = !0,
                this.refreshHoverImmediately()),
                t && this.trigger("rendered")
            },
            addHover: function(t, e) {
                if (this.painter.addHover) {
                    var i = this.painter.addHover(t, e);
                    return this.refreshHover(),
                    i
                }
            },
            removeHover: function(t) {
                this.painter.removeHover && (this.painter.removeHover(t),
                this.refreshHover())
            },
            clearHover: function() {
                this.painter.clearHover && (this.painter.clearHover(),
                this.refreshHover())
            },
            refreshHover: function() {
                this._needsRefreshHover = !0
            },
            refreshHoverImmediately: function() {
                this._needsRefreshHover = !1,
                this.painter.refreshHover && this.painter.refreshHover()
            },
            resize: function(t) {
                t = t || {},
                this.painter.resize(t.width, t.height),
                this.handler.resize()
            },
            clearAnimation: function() {
                this.animation.clear()
            },
            getWidth: function() {
                return this.painter.getWidth()
            },
            getHeight: function() {
                return this.painter.getHeight()
            },
            pathToImage: function(t, e) {
                return this.painter.pathToImage(t, e)
            },
            setCursorStyle: function(t) {
                this.handler.setCursorStyle(t)
            },
            findHover: function(t, e) {
                return this.handler.findHover(t, e)
            },
            on: function(t, e, i) {
                this.handler.on(t, e, i)
            },
            off: function(t, e) {
                this.handler.off(t, e)
            },
            trigger: function(t, e) {
                this.handler.trigger(t, e)
            },
            clear: function() {
                this.storage.delRoot(),
                this.painter.clear()
            },
            dispose: function() {
                this.animation.stop(),
                this.clear(),
                this.storage.dispose(),
                this.painter.dispose(),
                this.handler.dispose(),
                this.animation = this.storage = this.painter = this.handler = null,
                function(t) {
                    delete jn[t]
                }(this.id)
            }
        };
        var qn = {
            version: "4.0.7",
            init: function(t, e) {
                var i = new Xn(a(),t,e);
                return jn[i.id] = i
            },
            dispose: function(t) {
                if (t)
                    t.dispose();
                else {
                    for (var e in jn)
                        jn.hasOwnProperty(e) && jn[e].dispose();
                    jn = {}
                }
                return this
            },
            getInstance: function(t) {
                return jn[t]
            },
            registerPainter: function(t, e) {
                Yn[t] = e
            }
        }
          , Kn = it.each
          , $n = it.isObject
          , Jn = it.isArray
          , Qn = "series\0";
        function ta(t) {
            return t instanceof Array ? t : null == t ? [] : [t]
        }
        function ea(t) {
            return $n(t) && t.id && 0 === (t.id + "").indexOf("\0_ec_\0")
        }
        var ia = 0;
        function na(t, e) {
            return t && t.hasOwnProperty(e)
        }
        var aa = {
            normalizeToArray: ta,
            defaultEmphasis: function(t, e, i) {
                if (t) {
                    t[e] = t[e] || {},
                    t.emphasis = t.emphasis || {},
                    t.emphasis[e] = t.emphasis[e] || {};
                    for (var n = 0, a = i.length; n < a; n++) {
                        var r = i[n];
                        !t.emphasis[e].hasOwnProperty(r) && t[e].hasOwnProperty(r) && (t.emphasis[e][r] = t[e][r])
                    }
                }
            },
            TEXT_STYLE_OPTIONS: ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"],
            getDataItemValue: function(t) {
                return !$n(t) || Jn(t) || t instanceof Date ? t : t.value
            },
            isDataItemOption: function(t) {
                return $n(t) && !(t instanceof Array)
            },
            mappingToExists: function(t, a) {
                a = (a || []).slice();
                var r = it.map(t || [], function(t, e) {
                    return {
                        exist: t
                    }
                });
                return Kn(a, function(t, e) {
                    if ($n(t)) {
                        for (var i = 0; i < r.length; i++)
                            if (!r[i].option && null != t.id && r[i].exist.id === t.id + "")
                                return r[i].option = t,
                                void (a[e] = null);
                        for (i = 0; i < r.length; i++) {
                            var n = r[i].exist;
                            if (!(r[i].option || null != n.id && null != t.id || null == t.name || ea(t) || ea(n) || n.name !== t.name + ""))
                                return r[i].option = t,
                                void (a[e] = null)
                        }
                    }
                }),
                Kn(a, function(t, e) {
                    if ($n(t)) {
                        for (var i = 0; i < r.length; i++) {
                            var n = r[i].exist;
                            if (!r[i].option && !ea(n) && null == t.id) {
                                r[i].option = t;
                                break
                            }
                        }
                        i >= r.length && r.push({
                            option: t
                        })
                    }
                }),
                r
            },
            makeIdAndName: function(t) {
                var o = it.createHashMap();
                Kn(t, function(t, e) {
                    var i = t.exist;
                    i && o.set(i.id, t)
                }),
                Kn(t, function(t, e) {
                    var i = t.option;
                    it.assert(!i || null == i.id || !o.get(i.id) || o.get(i.id) === t, "id duplicates: " + (i && i.id)),
                    i && null != i.id && o.set(i.id, t),
                    t.keyInfo || (t.keyInfo = {})
                }),
                Kn(t, function(t, e) {
                    var i = t.exist
                      , n = t.option
                      , a = t.keyInfo;
                    if ($n(n)) {
                        if (a.name = null != n.name ? n.name + "" : i ? i.name : Qn + e,
                        i)
                            a.id = i.id;
                        else if (null != n.id)
                            a.id = n.id + "";
                        else
                            for (var r = 0; a.id = "\0" + a.name + "\0" + r++,
                            o.get(a.id); )
                                ;
                        o.set(a.id, t)
                    }
                })
            },
            isNameSpecified: function(t) {
                var e = t.name;
                return !(!e || !e.indexOf(Qn))
            },
            isIdInner: ea,
            compressBatches: function(t, e) {
                var i = {}
                  , n = {};
                return a(t || [], i),
                a(e || [], n, i),
                [r(i), r(n)];
                function a(t, e, i) {
                    for (var n = 0, a = t.length; n < a; n++)
                        for (var r = t[n].seriesId, o = ta(t[n].dataIndex), s = i && i[r], l = 0, u = o.length; l < u; l++) {
                            var h = o[l];
                            s && s[h] ? s[h] = null : (e[r] || (e[r] = {}))[h] = 1
                        }
                }
                function r(t, e) {
                    var i = [];
                    for (var n in t)
                        if (t.hasOwnProperty(n) && null != t[n])
                            if (e)
                                i.push(+n);
                            else {
                                var a = r(t[n], !0);
                                a.length && i.push({
                                    seriesId: n,
                                    dataIndex: a
                                })
                            }
                    return i
                }
            },
            queryDataIndex: function(e, t) {
                return null != t.dataIndexInside ? t.dataIndexInside : null != t.dataIndex ? it.isArray(t.dataIndex) ? it.map(t.dataIndex, function(t) {
                    return e.indexOfRawIndex(t)
                }) : e.indexOfRawIndex(t.dataIndex) : null != t.name ? it.isArray(t.name) ? it.map(t.name, function(t) {
                    return e.indexOfName(t)
                }) : e.indexOfName(t.name) : void 0
            },
            makeInner: function() {
                var e = "__\0ec_inner_" + ia++ + "_" + Math.random().toFixed(5);
                return function(t) {
                    return t[e] || (t[e] = {})
                }
            },
            parseFinder: function(s, l, u) {
                if (it.isString(l)) {
                    var t = {};
                    t[l + "Index"] = 0,
                    l = t
                }
                var e = u && u.defaultMainType;
                !e || na(l, e + "Index") || na(l, e + "Id") || na(l, e + "Name") || (l[e + "Index"] = 0);
                var h = {};
                return Kn(l, function(t, e) {
                    t = l[e];
                    if ("dataIndex" !== e && "dataIndexInside" !== e) {
                        var i = e.match(/^(\w+)(Index|Id|Name)$/) || []
                          , n = i[1]
                          , a = (i[2] || "").toLowerCase();
                        if (!(!n || !a || null == t || "index" === a && "none" === t || u && u.includeMainTypes && it.indexOf(u.includeMainTypes, n) < 0)) {
                            var r = {
                                mainType: n
                            };
                            "index" === a && "all" === t || (r[a] = t);
                            var o = s.queryComponents(r);
                            h[n + "Models"] = o,
                            h[n + "Model"] = o[0]
                        }
                    } else
                        h[e] = t
                }),
                h
            },
            setAttribute: function(t, e, i) {
                t.setAttribute ? t.setAttribute(e, i) : t[e] = i
            },
            getAttribute: function(t, e) {
                return t.getAttribute ? t.getAttribute(e) : t[e]
            },
            getTooltipRenderMode: function(t) {
                return "auto" === t ? et.domSupported ? "html" : "richText" : t || "html"
            },
            groupData: function(t, i) {
                var n = it.createHashMap()
                  , a = [];
                return it.each(t, function(t) {
                    var e = i(t);
                    (n.get(e) || (a.push(e),
                    n.set(e, []))).push(t)
                }),
                {
                    keys: a,
                    buckets: n
                }
            }
        }
          , ra = "."
          , oa = "___EC__COMPONENT__CONTAINER___";
        function sa(t) {
            var e = {
                main: "",
                sub: ""
            };
            return t && (t = t.split(ra),
            e.main = t[0] || "",
            e.sub = t[1] || ""),
            e
        }
        var la = 0;
        function ua(t, e) {
            var i = it.slice(arguments, 2);
            return this.superClass.prototype[e].apply(t, i)
        }
        function ha(t, e, i) {
            return this.superClass.prototype[e].apply(t, i)
        }
        var ca = {
            parseClassType: sa,
            enableClassExtend: function(t, e) {
                (t.$constructor = t).extend = function(t) {
                    function e() {
                        t.$constructor ? t.$constructor.apply(this, arguments) : i.apply(this, arguments)
                    }
                    var i = this;
                    return it.extend(e.prototype, t),
                    e.extend = this.extend,
                    e.superCall = ua,
                    e.superApply = ha,
                    it.inherits(e, this),
                    e.superClass = i,
                    e
                }
            },
            enableClassCheck: function(t) {
                var e = ["__\0is_clz", la++, Math.random().toFixed(3)].join("_");
                t.prototype[e] = !0,
                t.isInstance = function(t) {
                    return !(!t || !t[e])
                }
            },
            enableClassManagement: function(i, t) {
                t = t || {};
                var a = {};
                if (i.registerClass = function(t, e) {
                    if (e)
                        if (function(t) {
                            it.assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(t), 'componentType "' + t + '" illegal')
                        }(e),
                        (e = sa(e)).sub) {
                            if (e.sub !== oa) {
                                (function(t) {
                                    var e = a[t.main];
                                    e && e[oa] || ((e = a[t.main] = {})[oa] = !0);
                                    return e
                                }
                                )(e)[e.sub] = t
                            }
                        } else
                            a[e.main] = t;
                    return t
                }
                ,
                i.getClass = function(t, e, i) {
                    var n = a[t];
                    if (n && n[oa] && (n = e ? n[e] : null),
                    i && !n)
                        throw new Error(e ? "Component " + t + "." + (e || "") + " not exists. Load it first." : t + ".type should be specified.");
                    return n
                }
                ,
                i.getClassesByMainType = function(t) {
                    t = sa(t);
                    var i = []
                      , e = a[t.main];
                    return e && e[oa] ? it.each(e, function(t, e) {
                        e !== oa && i.push(t)
                    }) : i.push(e),
                    i
                }
                ,
                i.hasClass = function(t) {
                    return t = sa(t),
                    !!a[t.main]
                }
                ,
                i.getAllClassMainTypes = function() {
                    var i = [];
                    return it.each(a, function(t, e) {
                        i.push(e)
                    }),
                    i
                }
                ,
                i.hasSubTypes = function(t) {
                    t = sa(t);
                    var e = a[t.main];
                    return e && e[oa]
                }
                ,
                i.parseClassType = sa,
                t.registerWhenExtend) {
                    var n = i.extend;
                    n && (i.extend = function(t) {
                        var e = n.call(this, t);
                        return i.registerClass(e, t.type)
                    }
                    )
                }
                return i
            },
            setReadOnly: function(t, e) {}
        };
        var da = function(s) {
            for (var t = 0; t < s.length; t++)
                s[t][1] || (s[t][1] = s[t][0]);
            return function(t, e, i) {
                for (var n = {}, a = 0; a < s.length; a++) {
                    var r = s[a][1];
                    if (!(e && 0 <= it.indexOf(e, r) || i && it.indexOf(i, r) < 0)) {
                        var o = t.getShallow(r);
                        null != o && (n[s[a][0]] = o)
                    }
                }
                return n
            }
        }
          , pa = da([["lineWidth", "width"], ["stroke", "color"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]])
          , fa = {
            getLineStyle: function(t) {
                var e = pa(this, t)
                  , i = this.getLineDash(e.lineWidth);
                return i && (e.lineDash = i),
                e
            },
            getLineDash: function(t) {
                null == t && (t = 1);
                var e = this.get("type")
                  , i = Math.max(t, 2)
                  , n = 4 * t;
                return "solid" === e || null == e ? null : "dashed" === e ? [n, n] : [i, i]
            }
        }
          , ga = da([["fill", "color"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["opacity"], ["shadowColor"]])
          , ma = {
            getAreaStyle: function(t, e) {
                return ga(this, t, e)
            }
        }
          , va = R.create
          , ya = R.distSquare
          , xa = Math.pow
          , _a = Math.sqrt
          , ba = 1e-8
          , wa = _a(3)
          , Sa = va()
          , Ma = va()
          , Ia = va();
        function Aa(t) {
            return -ba < t && t < ba
        }
        function Ta(t) {
            return ba < t || t < -ba
        }
        function Ca(t, e, i, n, a) {
            var r = 1 - a;
            return r * r * (r * t + 3 * a * e) + a * a * (a * n + 3 * r * i)
        }
        function Da(t, e, i, n) {
            var a = 1 - n;
            return a * (a * t + 2 * n * e) + n * n * i
        }
        var La = {
            cubicAt: Ca,
            cubicDerivativeAt: function(t, e, i, n, a) {
                var r = 1 - a;
                return 3 * (((e - t) * r + 2 * (i - e) * a) * r + (n - i) * a * a)
            },
            cubicRootAt: function(t, e, i, n, a, r) {
                var o = n + 3 * (e - i) - t
                  , s = 3 * (i - 2 * e + t)
                  , l = 3 * (e - t)
                  , u = t - a
                  , h = s * s - 3 * o * l
                  , c = s * l - 9 * o * u
                  , d = l * l - 3 * s * u
                  , p = 0;
                if (Aa(h) && Aa(c)) {
                    if (Aa(s))
                        r[0] = 0;
                    else
                        0 <= (M = -l / s) && M <= 1 && (r[p++] = M)
                } else {
                    var f = c * c - 4 * h * d;
                    if (Aa(f)) {
                        var g = c / h
                          , m = -g / 2;
                        0 <= (M = -s / o + g) && M <= 1 && (r[p++] = M),
                        0 <= m && m <= 1 && (r[p++] = m)
                    } else if (0 < f) {
                        var v = _a(f)
                          , y = h * s + 1.5 * o * (-c + v)
                          , x = h * s + 1.5 * o * (-c - v);
                        0 <= (M = (-s - ((y = y < 0 ? -xa(-y, 1 / 3) : xa(y, 1 / 3)) + (x = x < 0 ? -xa(-x, 1 / 3) : xa(x, 1 / 3)))) / (3 * o)) && M <= 1 && (r[p++] = M)
                    } else {
                        var _ = (2 * h * s - 3 * o * c) / (2 * _a(h * h * h))
                          , b = Math.acos(_) / 3
                          , w = _a(h)
                          , S = Math.cos(b)
                          , M = (-s - 2 * w * S) / (3 * o)
                          , I = (m = (-s + w * (S + wa * Math.sin(b))) / (3 * o),
                        (-s + w * (S - wa * Math.sin(b))) / (3 * o));
                        0 <= M && M <= 1 && (r[p++] = M),
                        0 <= m && m <= 1 && (r[p++] = m),
                        0 <= I && I <= 1 && (r[p++] = I)
                    }
                }
                return p
            },
            cubicExtrema: function(t, e, i, n, a) {
                var r = 6 * i - 12 * e + 6 * t
                  , o = 9 * e + 3 * n - 3 * t - 9 * i
                  , s = 3 * e - 3 * t
                  , l = 0;
                if (Aa(o)) {
                    if (Ta(r))
                        0 <= (h = -s / r) && h <= 1 && (a[l++] = h)
                } else {
                    var u = r * r - 4 * o * s;
                    if (Aa(u))
                        a[0] = -r / (2 * o);
                    else if (0 < u) {
                        var h, c = _a(u), d = (-r - c) / (2 * o);
                        0 <= (h = (-r + c) / (2 * o)) && h <= 1 && (a[l++] = h),
                        0 <= d && d <= 1 && (a[l++] = d)
                    }
                }
                return l
            },
            cubicSubdivide: function(t, e, i, n, a, r) {
                var o = (e - t) * a + t
                  , s = (i - e) * a + e
                  , l = (n - i) * a + i
                  , u = (s - o) * a + o
                  , h = (l - s) * a + s
                  , c = (h - u) * a + u;
                r[0] = t,
                r[1] = o,
                r[2] = u,
                r[3] = c,
                r[4] = c,
                r[5] = h,
                r[6] = l,
                r[7] = n
            },
            cubicProjectPoint: function(t, e, i, n, a, r, o, s, l, u, h) {
                var c, d, p, f, g, m = .005, v = 1 / 0;
                Sa[0] = l,
                Sa[1] = u;
                for (var y = 0; y < 1; y += .05)
                    Ma[0] = Ca(t, i, a, o, y),
                    Ma[1] = Ca(e, n, r, s, y),
                    (f = ya(Sa, Ma)) < v && (c = y,
                    v = f);
                v = 1 / 0;
                for (var x = 0; x < 32 && !(m < 1e-4); x++)
                    d = c - m,
                    p = c + m,
                    Ma[0] = Ca(t, i, a, o, d),
                    Ma[1] = Ca(e, n, r, s, d),
                    f = ya(Ma, Sa),
                    0 <= d && f < v ? (c = d,
                    v = f) : (Ia[0] = Ca(t, i, a, o, p),
                    Ia[1] = Ca(e, n, r, s, p),
                    g = ya(Ia, Sa),
                    p <= 1 && g < v ? (c = p,
                    v = g) : m *= .5);
                return h && (h[0] = Ca(t, i, a, o, c),
                h[1] = Ca(e, n, r, s, c)),
                _a(v)
            },
            quadraticAt: Da,
            quadraticDerivativeAt: function(t, e, i, n) {
                return 2 * ((1 - n) * (e - t) + n * (i - e))
            },
            quadraticRootAt: function(t, e, i, n, a) {
                var r = t - 2 * e + i
                  , o = 2 * (e - t)
                  , s = t - n
                  , l = 0;
                if (Aa(r)) {
                    if (Ta(o))
                        0 <= (h = -s / o) && h <= 1 && (a[l++] = h)
                } else {
                    var u = o * o - 4 * r * s;
                    if (Aa(u))
                        0 <= (h = -o / (2 * r)) && h <= 1 && (a[l++] = h);
                    else if (0 < u) {
                        var h, c = _a(u), d = (-o - c) / (2 * r);
                        0 <= (h = (-o + c) / (2 * r)) && h <= 1 && (a[l++] = h),
                        0 <= d && d <= 1 && (a[l++] = d)
                    }
                }
                return l
            },
            quadraticExtremum: function(t, e, i) {
                var n = t + i - 2 * e;
                return 0 == n ? .5 : (t - e) / n
            },
            quadraticSubdivide: function(t, e, i, n, a) {
                var r = (e - t) * n + t
                  , o = (i - e) * n + e
                  , s = (o - r) * n + r;
                a[0] = t,
                a[1] = r,
                a[2] = s,
                a[3] = s,
                a[4] = o,
                a[5] = i
            },
            quadraticProjectPoint: function(t, e, i, n, a, r, o, s, l) {
                var u, h = .005, c = 1 / 0;
                Sa[0] = o,
                Sa[1] = s;
                for (var d = 0; d < 1; d += .05) {
                    Ma[0] = Da(t, i, a, d),
                    Ma[1] = Da(e, n, r, d),
                    (m = ya(Sa, Ma)) < c && (u = d,
                    c = m)
                }
                c = 1 / 0;
                for (var p = 0; p < 32 && !(h < 1e-4); p++) {
                    var f = u - h
                      , g = u + h;
                    Ma[0] = Da(t, i, a, f),
                    Ma[1] = Da(e, n, r, f);
                    var m = ya(Ma, Sa);
                    if (0 <= f && m < c)
                        u = f,
                        c = m;
                    else {
                        Ia[0] = Da(t, i, a, g),
                        Ia[1] = Da(e, n, r, g);
                        var v = ya(Ia, Sa);
                        g <= 1 && v < c ? (u = g,
                        c = v) : h *= .5
                    }
                }
                return l && (l[0] = Da(t, i, a, u),
                l[1] = Da(e, n, r, u)),
                _a(c)
            }
        }
          , Pa = Math.min
          , ka = Math.max
          , Oa = Math.sin
          , Ra = Math.cos
          , Na = 2 * Math.PI
          , Ea = R.create()
          , za = R.create()
          , Va = R.create();
        var Ba = []
          , Ga = [];
        function Fa(t) {
            this._saveData = !t,
            this._saveData && (this.data = []),
            this._ctx = null
        }
        var Ha = {
            fromPoints: function(t, e, i) {
                if (0 !== t.length) {
                    var n, a = t[0], r = a[0], o = a[0], s = a[1], l = a[1];
                    for (n = 1; n < t.length; n++)
                        a = t[n],
                        r = Pa(r, a[0]),
                        o = ka(o, a[0]),
                        s = Pa(s, a[1]),
                        l = ka(l, a[1]);
                    e[0] = r,
                    e[1] = s,
                    i[0] = o,
                    i[1] = l
                }
            },
            fromLine: function(t, e, i, n, a, r) {
                a[0] = Pa(t, i),
                a[1] = Pa(e, n),
                r[0] = ka(t, i),
                r[1] = ka(e, n)
            },
            fromCubic: function(t, e, i, n, a, r, o, s, l, u) {
                var h, c = La.cubicExtrema, d = La.cubicAt, p = c(t, i, a, o, Ba);
                for (l[0] = 1 / 0,
                l[1] = 1 / 0,
                u[0] = -1 / 0,
                u[1] = -1 / 0,
                h = 0; h < p; h++) {
                    var f = d(t, i, a, o, Ba[h]);
                    l[0] = Pa(f, l[0]),
                    u[0] = ka(f, u[0])
                }
                for (p = c(e, n, r, s, Ga),
                h = 0; h < p; h++) {
                    var g = d(e, n, r, s, Ga[h]);
                    l[1] = Pa(g, l[1]),
                    u[1] = ka(g, u[1])
                }
                l[0] = Pa(t, l[0]),
                u[0] = ka(t, u[0]),
                l[0] = Pa(o, l[0]),
                u[0] = ka(o, u[0]),
                l[1] = Pa(e, l[1]),
                u[1] = ka(e, u[1]),
                l[1] = Pa(s, l[1]),
                u[1] = ka(s, u[1])
            },
            fromQuadratic: function(t, e, i, n, a, r, o, s) {
                var l = La.quadraticExtremum
                  , u = La.quadraticAt
                  , h = ka(Pa(l(t, i, a), 1), 0)
                  , c = ka(Pa(l(e, n, r), 1), 0)
                  , d = u(t, i, a, h)
                  , p = u(e, n, r, c);
                o[0] = Pa(t, a, d),
                o[1] = Pa(e, r, p),
                s[0] = ka(t, a, d),
                s[1] = ka(e, r, p)
            },
            fromArc: function(t, e, i, n, a, r, o, s, l) {
                var u = R.min
                  , h = R.max
                  , c = Math.abs(a - r);
                if (c % Na < 1e-4 && 1e-4 < c)
                    return s[0] = t - i,
                    s[1] = e - n,
                    l[0] = t + i,
                    void (l[1] = e + n);
                if (Ea[0] = Ra(a) * i + t,
                Ea[1] = Oa(a) * n + e,
                za[0] = Ra(r) * i + t,
                za[1] = Oa(r) * n + e,
                u(s, Ea, za),
                h(l, Ea, za),
                (a %= Na) < 0 && (a += Na),
                (r %= Na) < 0 && (r += Na),
                r < a && !o ? r += Na : a < r && o && (a += Na),
                o) {
                    var d = r;
                    r = a,
                    a = d
                }
                for (var p = 0; p < r; p += Math.PI / 2)
                    a < p && (Va[0] = Ra(p) * i + t,
                    Va[1] = Oa(p) * n + e,
                    u(s, Va, s),
                    h(l, Va, l))
            }
        }
          , Wa = de.devicePixelRatio
          , Za = {
            M: 1,
            L: 2,
            C: 3,
            Q: 4,
            A: 5,
            Z: 6,
            R: 7
        }
          , Ua = []
          , Ya = []
          , ja = []
          , Xa = []
          , qa = Math.min
          , Ka = Math.max
          , $a = Math.cos
          , Ja = Math.sin
          , Qa = Math.sqrt
          , tr = Math.abs
          , er = "undefined" != typeof Float32Array;
        Fa.prototype = {
            constructor: Fa,
            _xi: 0,
            _yi: 0,
            _x0: 0,
            _y0: 0,
            _ux: 0,
            _uy: 0,
            _len: 0,
            _lineDash: null,
            _dashOffset: 0,
            _dashIdx: 0,
            _dashSum: 0,
            setScale: function(t, e) {
                this._ux = tr(1 / Wa / t) || 0,
                this._uy = tr(1 / Wa / e) || 0
            },
            getContext: function() {
                return this._ctx
            },
            beginPath: function(t) {
                return (this._ctx = t) && t.beginPath(),
                t && (this.dpr = t.dpr),
                this._saveData && (this._len = 0),
                this._lineDash && (this._lineDash = null,
                this._dashOffset = 0),
                this
            },
            moveTo: function(t, e) {
                return this.addData(Za.M, t, e),
                this._ctx && this._ctx.moveTo(t, e),
                this._x0 = t,
                this._y0 = e,
                this._xi = t,
                this._yi = e,
                this
            },
            lineTo: function(t, e) {
                var i = tr(t - this._xi) > this._ux || tr(e - this._yi) > this._uy || this._len < 5;
                return this.addData(Za.L, t, e),
                this._ctx && i && (this._needsDash() ? this._dashedLineTo(t, e) : this._ctx.lineTo(t, e)),
                i && (this._xi = t,
                this._yi = e),
                this
            },
            bezierCurveTo: function(t, e, i, n, a, r) {
                return this.addData(Za.C, t, e, i, n, a, r),
                this._ctx && (this._needsDash() ? this._dashedBezierTo(t, e, i, n, a, r) : this._ctx.bezierCurveTo(t, e, i, n, a, r)),
                this._xi = a,
                this._yi = r,
                this
            },
            quadraticCurveTo: function(t, e, i, n) {
                return this.addData(Za.Q, t, e, i, n),
                this._ctx && (this._needsDash() ? this._dashedQuadraticTo(t, e, i, n) : this._ctx.quadraticCurveTo(t, e, i, n)),
                this._xi = i,
                this._yi = n,
                this
            },
            arc: function(t, e, i, n, a, r) {
                return this.addData(Za.A, t, e, i, i, n, a - n, 0, r ? 0 : 1),
                this._ctx && this._ctx.arc(t, e, i, n, a, r),
                this._xi = $a(a) * i + t,
                this._yi = Ja(a) * i + e,
                this
            },
            arcTo: function(t, e, i, n, a) {
                return this._ctx && this._ctx.arcTo(t, e, i, n, a),
                this
            },
            rect: function(t, e, i, n) {
                return this._ctx && this._ctx.rect(t, e, i, n),
                this.addData(Za.R, t, e, i, n),
                this
            },
            closePath: function() {
                this.addData(Za.Z);
                var t = this._ctx
                  , e = this._x0
                  , i = this._y0;
                return t && (this._needsDash() && this._dashedLineTo(e, i),
                t.closePath()),
                this._xi = e,
                this._yi = i,
                this
            },
            fill: function(t) {
                t && t.fill(),
                this.toStatic()
            },
            stroke: function(t) {
                t && t.stroke(),
                this.toStatic()
            },
            setLineDash: function(t) {
                if (t instanceof Array) {
                    this._lineDash = t;
                    for (var e = this._dashIdx = 0, i = 0; i < t.length; i++)
                        e += t[i];
                    this._dashSum = e
                }
                return this
            },
            setLineDashOffset: function(t) {
                return this._dashOffset = t,
                this
            },
            len: function() {
                return this._len
            },
            setData: function(t) {
                var e = t.length;
                this.data && this.data.length === e || !er || (this.data = new Float32Array(e));
                for (var i = 0; i < e; i++)
                    this.data[i] = t[i];
                this._len = e
            },
            appendPath: function(t) {
                t instanceof Array || (t = [t]);
                for (var e = t.length, i = 0, n = this._len, a = 0; a < e; a++)
                    i += t[a].len();
                er && this.data instanceof Float32Array && (this.data = new Float32Array(n + i));
                for (a = 0; a < e; a++)
                    for (var r = t[a].data, o = 0; o < r.length; o++)
                        this.data[n++] = r[o];
                this._len = n
            },
            addData: function(t) {
                if (this._saveData) {
                    var e = this.data;
                    this._len + arguments.length > e.length && (this._expandData(),
                    e = this.data);
                    for (var i = 0; i < arguments.length; i++)
                        e[this._len++] = arguments[i];
                    this._prevCmd = t
                }
            },
            _expandData: function() {
                if (!(this.data instanceof Array)) {
                    for (var t = [], e = 0; e < this._len; e++)
                        t[e] = this.data[e];
                    this.data = t
                }
            },
            _needsDash: function() {
                return this._lineDash
            },
            _dashedLineTo: function(t, e) {
                var i, n, a = this._dashSum, r = this._dashOffset, o = this._lineDash, s = this._ctx, l = this._xi, u = this._yi, h = t - l, c = e - u, d = Qa(h * h + c * c), p = l, f = u, g = o.length;
                for (r < 0 && (r = a + r),
                p -= (r %= a) * (h /= d),
                f -= r * (c /= d); 0 < h && p <= t || h < 0 && t <= p || 0 === h && (0 < c && f <= e || c < 0 && e <= f); )
                    p += h * (i = o[n = this._dashIdx]),
                    f += c * i,
                    this._dashIdx = (n + 1) % g,
                    0 < h && p < l || h < 0 && l < p || 0 < c && f < u || c < 0 && u < f || s[n % 2 ? "moveTo" : "lineTo"](0 <= h ? qa(p, t) : Ka(p, t), 0 <= c ? qa(f, e) : Ka(f, e));
                h = p - t,
                c = f - e,
                this._dashOffset = -Qa(h * h + c * c)
            },
            _dashedBezierTo: function(t, e, i, n, a, r) {
                var o, s, l, u, h, c = this._dashSum, d = this._dashOffset, p = this._lineDash, f = this._ctx, g = this._xi, m = this._yi, v = La.cubicAt, y = 0, x = this._dashIdx, _ = p.length, b = 0;
                for (d < 0 && (d = c + d),
                d %= c,
                o = 0; o < 1; o += .1)
                    s = v(g, t, i, a, o + .1) - v(g, t, i, a, o),
                    l = v(m, e, n, r, o + .1) - v(m, e, n, r, o),
                    y += Qa(s * s + l * l);
                for (; x < _ && !(d < (b += p[x])); x++)
                    ;
                for (o = (b - d) / y; o <= 1; )
                    u = v(g, t, i, a, o),
                    h = v(m, e, n, r, o),
                    x % 2 ? f.moveTo(u, h) : f.lineTo(u, h),
                    o += p[x] / y,
                    x = (x + 1) % _;
                x % 2 != 0 && f.lineTo(a, r),
                s = a - u,
                l = r - h,
                this._dashOffset = -Qa(s * s + l * l)
            },
            _dashedQuadraticTo: function(t, e, i, n) {
                var a = i
                  , r = n;
                i = (i + 2 * t) / 3,
                n = (n + 2 * e) / 3,
                t = (this._xi + 2 * t) / 3,
                e = (this._yi + 2 * e) / 3,
                this._dashedBezierTo(t, e, i, n, a, r)
            },
            toStatic: function() {
                var t = this.data;
                t instanceof Array && (t.length = this._len,
                er && (this.data = new Float32Array(t)))
            },
            getBoundingRect: function() {
                Ua[0] = Ua[1] = ja[0] = ja[1] = Number.MAX_VALUE,
                Ya[0] = Ya[1] = Xa[0] = Xa[1] = -Number.MAX_VALUE;
                for (var t = this.data, e = 0, i = 0, n = 0, a = 0, r = 0; r < t.length; ) {
                    var o = t[r++];
                    switch (1 === r && (n = e = t[r],
                    a = i = t[r + 1]),
                    o) {
                    case Za.M:
                        e = n = t[r++],
                        i = a = t[r++],
                        ja[0] = n,
                        ja[1] = a,
                        Xa[0] = n,
                        Xa[1] = a;
                        break;
                    case Za.L:
                        Ha.fromLine(e, i, t[r], t[r + 1], ja, Xa),
                        e = t[r++],
                        i = t[r++];
                        break;
                    case Za.C:
                        Ha.fromCubic(e, i, t[r++], t[r++], t[r++], t[r++], t[r], t[r + 1], ja, Xa),
                        e = t[r++],
                        i = t[r++];
                        break;
                    case Za.Q:
                        Ha.fromQuadratic(e, i, t[r++], t[r++], t[r], t[r + 1], ja, Xa),
                        e = t[r++],
                        i = t[r++];
                        break;
                    case Za.A:
                        var s = t[r++]
                          , l = t[r++]
                          , u = t[r++]
                          , h = t[r++]
                          , c = t[r++]
                          , d = t[r++] + c;
                        r += 1;
                        var p = 1 - t[r++];
                        1 === r && (n = $a(c) * u + s,
                        a = Ja(c) * h + l),
                        Ha.fromArc(s, l, u, h, c, d, p, ja, Xa),
                        e = $a(d) * u + s,
                        i = Ja(d) * h + l;
                        break;
                    case Za.R:
                        n = e = t[r++],
                        a = i = t[r++];
                        var f = t[r++]
                          , g = t[r++];
                        Ha.fromLine(n, a, n + f, a + g, ja, Xa);
                        break;
                    case Za.Z:
                        e = n,
                        i = a
                    }
                    R.min(Ua, Ua, ja),
                    R.max(Ya, Ya, Xa)
                }
                return 0 === r && (Ua[0] = Ua[1] = Ya[0] = Ya[1] = 0),
                new Oe(Ua[0],Ua[1],Ya[0] - Ua[0],Ya[1] - Ua[1])
            },
            rebuildPath: function(t) {
                for (var e, i, n, a, r, o, s = this.data, l = this._ux, u = this._uy, h = this._len, c = 0; c < h; ) {
                    var d = s[c++];
                    switch (1 === c && (e = n = s[c],
                    i = a = s[c + 1]),
                    d) {
                    case Za.M:
                        e = n = s[c++],
                        i = a = s[c++],
                        t.moveTo(n, a);
                        break;
                    case Za.L:
                        r = s[c++],
                        o = s[c++],
                        (tr(r - n) > l || tr(o - a) > u || c === h - 1) && (t.lineTo(r, o),
                        n = r,
                        a = o);
                        break;
                    case Za.C:
                        t.bezierCurveTo(s[c++], s[c++], s[c++], s[c++], s[c++], s[c++]),
                        n = s[c - 2],
                        a = s[c - 1];
                        break;
                    case Za.Q:
                        t.quadraticCurveTo(s[c++], s[c++], s[c++], s[c++]),
                        n = s[c - 2],
                        a = s[c - 1];
                        break;
                    case Za.A:
                        var p = s[c++]
                          , f = s[c++]
                          , g = s[c++]
                          , m = s[c++]
                          , v = s[c++]
                          , y = s[c++]
                          , x = s[c++]
                          , _ = s[c++]
                          , b = m < g ? g : m
                          , w = m < g ? 1 : g / m
                          , S = m < g ? m / g : 1
                          , M = v + y;
                        .001 < Math.abs(g - m) ? (t.translate(p, f),
                        t.rotate(x),
                        t.scale(w, S),
                        t.arc(0, 0, b, v, M, 1 - _),
                        t.scale(1 / w, 1 / S),
                        t.rotate(-x),
                        t.translate(-p, -f)) : t.arc(p, f, b, v, M, 1 - _),
                        1 === c && (e = $a(v) * g + p,
                        i = Ja(v) * m + f),
                        n = $a(M) * g + p,
                        a = Ja(M) * m + f;
                        break;
                    case Za.R:
                        e = n = s[c],
                        i = a = s[c + 1],
                        t.rect(s[c++], s[c++], s[c++], s[c++]);
                        break;
                    case Za.Z:
                        t.closePath(),
                        n = e,
                        a = i
                    }
                }
            }
        },
        Fa.CMD = Za;
        var ir = Fa;
        var nr = {
            containStroke: function(t, e, i, n, a, r, o) {
                if (0 === a)
                    return !1;
                var s = a
                  , l = 0;
                if (e + s < o && n + s < o || o < e - s && o < n - s || t + s < r && i + s < r || r < t - s && r < i - s)
                    return !1;
                if (t === i)
                    return Math.abs(r - t) <= s / 2;
                var u = (l = (e - n) / (t - i)) * r - o + (t * n - i * e) / (t - i);
                return u * u / (l * l + 1) <= s / 2 * s / 2
            }
        };
        var ar = {
            containStroke: function(t, e, i, n, a, r, o, s, l, u, h) {
                if (0 === l)
                    return !1;
                var c = l;
                return !(e + c < h && n + c < h && r + c < h && s + c < h || h < e - c && h < n - c && h < r - c && h < s - c || t + c < u && i + c < u && a + c < u && o + c < u || u < t - c && u < i - c && u < a - c && u < o - c) && La.cubicProjectPoint(t, e, i, n, a, r, o, s, u, h, null) <= c / 2
            }
        }
          , rr = La.quadraticProjectPoint;
        var or = {
            containStroke: function(t, e, i, n, a, r, o, s, l) {
                if (0 === o)
                    return !1;
                var u = o;
                return !(e + u < l && n + u < l && r + u < l || l < e - u && l < n - u && l < r - u || t + u < s && i + u < s && a + u < s || s < t - u && s < i - u && s < a - u) && rr(t, e, i, n, a, r, s, l, null) <= u / 2
            }
        }
          , sr = 2 * Math.PI;
        var lr = {
            normalizeRadian: function(t) {
                return (t %= sr) < 0 && (t += sr),
                t
            }
        }
          , ur = lr.normalizeRadian
          , hr = 2 * Math.PI;
        var cr = {
            containStroke: function(t, e, i, n, a, r, o, s, l) {
                if (0 === o)
                    return !1;
                var u = o;
                s -= t,
                l -= e;
                var h = Math.sqrt(s * s + l * l);
                if (i < h - u || h + u < i)
                    return !1;
                if (Math.abs(n - a) % hr < 1e-4)
                    return !0;
                if (r) {
                    var c = n;
                    n = ur(a),
                    a = ur(c)
                } else
                    n = ur(n),
                    a = ur(a);
                a < n && (a += hr);
                var d = Math.atan2(l, s);
                return d < 0 && (d += hr),
                n <= d && d <= a || n <= d + hr && d + hr <= a
            }
        };
        var dr = function(t, e, i, n, a, r) {
            if (e < r && n < r || r < e && r < n)
                return 0;
            if (n === e)
                return 0;
            var o = n < e ? 1 : -1
              , s = (r - e) / (n - e);
            1 != s && 0 != s || (o = n < e ? .5 : -.5);
            var l = s * (i - t) + t;
            return l === a ? 1 / 0 : a < l ? o : 0
        }
          , pr = lr.normalizeRadian
          , fr = ir.CMD
          , gr = 2 * Math.PI
          , mr = 1e-4;
        var vr = [-1, -1, -1]
          , yr = [-1, -1];
        function xr(t, e, i, n, a, r, o, s, l, u) {
            if (e < u && n < u && r < u && s < u || u < e && u < n && u < r && u < s)
                return 0;
            var h, c = La.cubicRootAt(e, n, r, s, u, vr);
            if (0 === c)
                return 0;
            for (var d, p, f = 0, g = -1, m = 0; m < c; m++) {
                var v = vr[m]
                  , y = 0 === v || 1 === v ? .5 : 1;
                La.cubicAt(t, i, a, o, v) < l || (g < 0 && (g = La.cubicExtrema(e, n, r, s, yr),
                yr[1] < yr[0] && 1 < g && (void 0,
                h = yr[0],
                yr[0] = yr[1],
                yr[1] = h),
                d = La.cubicAt(e, n, r, s, yr[0]),
                1 < g && (p = La.cubicAt(e, n, r, s, yr[1]))),
                2 === g ? v < yr[0] ? f += d < e ? y : -y : v < yr[1] ? f += p < d ? y : -y : f += s < p ? y : -y : v < yr[0] ? f += d < e ? y : -y : f += s < d ? y : -y)
            }
            return f
        }
        function _r(t, e, i, n, a, r, o, s) {
            if (e < s && n < s && r < s || s < e && s < n && s < r)
                return 0;
            var l = La.quadraticRootAt(e, n, r, s, vr);
            if (0 === l)
                return 0;
            var u = La.quadraticExtremum(e, n, r);
            if (0 <= u && u <= 1) {
                for (var h = 0, c = La.quadraticAt(e, n, r, u), d = 0; d < l; d++) {
                    var p = 0 === vr[d] || 1 === vr[d] ? .5 : 1;
                    La.quadraticAt(t, i, a, vr[d]) < o || (vr[d] < u ? h += c < e ? p : -p : h += r < c ? p : -p)
                }
                return h
            }
            p = 0 === vr[0] || 1 === vr[0] ? .5 : 1;
            return La.quadraticAt(t, i, a, vr[0]) < o ? 0 : r < e ? p : -p
        }
        function br(t, e, i, n, a, r, o, s) {
            if (i < (s -= e) || s < -i)
                return 0;
            var l = Math.sqrt(i * i - s * s);
            vr[0] = -l,
            vr[1] = l;
            var u = Math.abs(n - a);
            if (u < 1e-4)
                return 0;
            if (u % gr < 1e-4) {
                a = gr;
                var h = r ? 1 : -1;
                return o >= vr[n = 0] + t && o <= vr[1] + t ? h : 0
            }
            if (r) {
                l = n;
                n = pr(a),
                a = pr(l)
            } else
                n = pr(n),
                a = pr(a);
            a < n && (a += gr);
            for (var c = 0, d = 0; d < 2; d++) {
                var p = vr[d];
                if (o < p + t) {
                    var f = Math.atan2(s, p);
                    h = r ? 1 : -1;
                    f < 0 && (f = gr + f),
                    (n <= f && f <= a || n <= f + gr && f + gr <= a) && (f > Math.PI / 2 && f < 1.5 * Math.PI && (h = -h),
                    c += h)
                }
            }
            return c
        }
        function wr(t, e, i, n, a) {
            for (var r = 0, o = 0, s = 0, l = 0, u = 0, h = 0; h < t.length; ) {
                var c = t[h++];
                switch (c === fr.M && 1 < h && (i || (r += dr(o, s, l, u, n, a))),
                1 === h && (l = o = t[h],
                u = s = t[h + 1]),
                c) {
                case fr.M:
                    o = l = t[h++],
                    s = u = t[h++];
                    break;
                case fr.L:
                    if (i) {
                        if (nr.containStroke(o, s, t[h], t[h + 1], e, n, a))
                            return !0
                    } else
                        r += dr(o, s, t[h], t[h + 1], n, a) || 0;
                    o = t[h++],
                    s = t[h++];
                    break;
                case fr.C:
                    if (i) {
                        if (ar.containStroke(o, s, t[h++], t[h++], t[h++], t[h++], t[h], t[h + 1], e, n, a))
                            return !0
                    } else
                        r += xr(o, s, t[h++], t[h++], t[h++], t[h++], t[h], t[h + 1], n, a) || 0;
                    o = t[h++],
                    s = t[h++];
                    break;
                case fr.Q:
                    if (i) {
                        if (or.containStroke(o, s, t[h++], t[h++], t[h], t[h + 1], e, n, a))
                            return !0
                    } else
                        r += _r(o, s, t[h++], t[h++], t[h], t[h + 1], n, a) || 0;
                    o = t[h++],
                    s = t[h++];
                    break;
                case fr.A:
                    var d = t[h++]
                      , p = t[h++]
                      , f = t[h++]
                      , g = t[h++]
                      , m = t[h++]
                      , v = t[h++];
                    h += 1;
                    var y = 1 - t[h++]
                      , x = Math.cos(m) * f + d
                      , _ = Math.sin(m) * g + p;
                    1 < h ? r += dr(o, s, x, _, n, a) : (l = x,
                    u = _);
                    var b = (n - d) * g / f + d;
                    if (i) {
                        if (cr.containStroke(d, p, g, m, m + v, y, e, b, a))
                            return !0
                    } else
                        r += br(d, p, g, m, m + v, y, b, a);
                    o = Math.cos(m + v) * f + d,
                    s = Math.sin(m + v) * g + p;
                    break;
                case fr.R:
                    l = o = t[h++],
                    u = s = t[h++];
                    x = l + t[h++],
                    _ = u + t[h++];
                    if (i) {
                        if (nr.containStroke(l, u, x, u, e, n, a) || nr.containStroke(x, u, x, _, e, n, a) || nr.containStroke(x, _, l, _, e, n, a) || nr.containStroke(l, _, l, u, e, n, a))
                            return !0
                    } else
                        r += dr(x, u, x, _, n, a),
                        r += dr(l, _, l, u, n, a);
                    break;
                case fr.Z:
                    if (i) {
                        if (nr.containStroke(o, s, l, u, e, n, a))
                            return !0
                    } else
                        r += dr(o, s, l, u, n, a);
                    o = l,
                    s = u
                }
            }
            return i || function(t, e) {
                return Math.abs(t - e) < mr
            }(s, u) || (r += dr(o, s, l, u, n, a) || 0),
            0 !== r
        }
        var Sr = {
            contain: function(t, e, i) {
                return wr(t, 0, !1, e, i)
            },
            containStroke: function(t, e, i, n) {
                return wr(t, e, !0, i, n)
            }
        }
          , Mr = ri.prototype.getCanvasPattern
          , Ir = Math.abs
          , Ar = new ir(!0);
        function Tr(t) {
            yn.call(this, t),
            this.path = null
        }
        Tr.prototype = {
            constructor: Tr,
            type: "path",
            __dirtyPath: !0,
            strokeContainThreshold: 5,
            subPixelOptimize: !1,
            brush: function(t, e) {
                var i, n = this.style, a = this.path || Ar, r = n.hasStroke(), o = n.hasFill(), s = n.fill, l = n.stroke, u = o && !!s.colorStops, h = r && !!l.colorStops, c = o && !!s.image, d = r && !!l.image;
                n.bind(t, this, e),
                this.setTransform(t),
                this.__dirty && (u && (i = i || this.getBoundingRect(),
                this._fillGradient = n.getGradient(t, s, i)),
                h && (i = i || this.getBoundingRect(),
                this._strokeGradient = n.getGradient(t, l, i)));
                u ? t.fillStyle = this._fillGradient : c && (t.fillStyle = Mr.call(s, t)),
                h ? t.strokeStyle = this._strokeGradient : d && (t.strokeStyle = Mr.call(l, t));
                var p = n.lineDash
                  , f = n.lineDashOffset
                  , g = !!t.setLineDash
                  , m = this.getGlobalScale();
                if (a.setScale(m[0], m[1]),
                this.__dirtyPath || p && !g && r ? (a.beginPath(t),
                p && !g && (a.setLineDash(p),
                a.setLineDashOffset(f)),
                this.buildPath(a, this.shape, !1),
                this.path && (this.__dirtyPath = !1)) : (t.beginPath(),
                this.path.rebuildPath(t)),
                o)
                    if (null != n.fillOpacity) {
                        var v = t.globalAlpha;
                        t.globalAlpha = n.fillOpacity * n.opacity,
                        a.fill(t),
                        t.globalAlpha = v
                    } else
                        a.fill(t);
                if (p && g && (t.setLineDash(p),
                t.lineDashOffset = f),
                r)
                    if (null != n.strokeOpacity) {
                        v = t.globalAlpha;
                        t.globalAlpha = n.strokeOpacity * n.opacity,
                        a.stroke(t),
                        t.globalAlpha = v
                    } else
                        a.stroke(t);
                p && g && t.setLineDash([]),
                null != n.text && (this.restoreTransform(t),
                this.drawRectText(t, this.getBoundingRect()))
            },
            buildPath: function(t, e, i) {},
            createPathProxy: function() {
                this.path = new ir
            },
            getBoundingRect: function() {
                var t = this._rect
                  , e = this.style
                  , i = !t;
                if (i) {
                    var n = this.path;
                    n = n || (this.path = new ir),
                    this.__dirtyPath && (n.beginPath(),
                    this.buildPath(n, this.shape, !1)),
                    t = n.getBoundingRect()
                }
                if (this._rect = t,
                e.hasStroke()) {
                    var a = this._rectWithStroke || (this._rectWithStroke = t.clone());
                    if (this.__dirty || i) {
                        a.copy(t);
                        var r = e.lineWidth
                          , o = e.strokeNoScale ? this.getLineScale() : 1;
                        e.hasFill() || (r = Math.max(r, this.strokeContainThreshold || 4)),
                        1e-10 < o && (a.width += r / o,
                        a.height += r / o,
                        a.x -= r / o / 2,
                        a.y -= r / o / 2)
                    }
                    return a
                }
                return t
            },
            contain: function(t, e) {
                var i = this.transformCoordToLocal(t, e)
                  , n = this.getBoundingRect()
                  , a = this.style;
                if (t = i[0],
                e = i[1],
                n.contain(t, e)) {
                    var r = this.path.data;
                    if (a.hasStroke()) {
                        var o = a.lineWidth
                          , s = a.strokeNoScale ? this.getLineScale() : 1;
                        if (1e-10 < s && (a.hasFill() || (o = Math.max(o, this.strokeContainThreshold)),
                        Sr.containStroke(r, o / s, t, e)))
                            return !0
                    }
                    if (a.hasFill())
                        return Sr.contain(r, t, e)
                }
                return !1
            },
            dirty: function(t) {
                null == t && (t = !0),
                t && (this.__dirtyPath = t,
                this._rect = null),
                this.__dirty = this.__dirtyText = !0,
                this.__zr && this.__zr.refresh(),
                this.__clipTarget && this.__clipTarget.dirty()
            },
            animateShape: function(t) {
                return this.animate("shape", t)
            },
            attrKV: function(t, e) {
                "shape" === t ? (this.setShape(e),
                this.__dirtyPath = !0,
                this._rect = null) : yn.prototype.attrKV.call(this, t, e)
            },
            setShape: function(t, e) {
                var i = this.shape;
                if (i) {
                    if (it.isObject(t))
                        for (var n in t)
                            t.hasOwnProperty(n) && (i[n] = t[n]);
                    else
                        i[t] = e;
                    this.dirty(!0)
                }
                return this
            },
            getLineScale: function() {
                var t = this.transform;
                return t && 1e-10 < Ir(t[0] - 1) && 1e-10 < Ir(t[3] - 1) ? Math.sqrt(Ir(t[0] * t[3] - t[2] * t[1])) : 1
            }
        },
        Tr.extend = function(a) {
            function t(t) {
                Tr.call(this, t),
                a.style && this.style.extendFrom(a.style, !1);
                var e = a.shape;
                if (e) {
                    this.shape = this.shape || {};
                    var i = this.shape;
                    for (var n in e)
                        !i.hasOwnProperty(n) && e.hasOwnProperty(n) && (i[n] = e[n])
                }
                a.init && a.init.call(this, t)
            }
            for (var e in it.inherits(t, Tr),
            a)
                "style" !== e && "shape" !== e && (t.prototype[e] = a[e]);
            return t
        }
        ,
        it.inherits(Tr, yn);
        var Cr = Tr
          , Dr = R.applyTransform
          , Lr = ir.CMD
          , Pr = [[], [], []]
          , kr = Math.sqrt
          , Or = Math.atan2;
        function Rr(t) {
            return Math.sqrt(t[0] * t[0] + t[1] * t[1])
        }
        var Nr = function(t, e) {
            var i, n, a, r, o, s = t.data, l = Lr.M, u = Lr.C, h = Lr.L, c = Lr.R, d = Lr.A, p = Lr.Q;
            for (r = a = 0; a < s.length; ) {
                switch (i = s[a++],
                r = a,
                n = 0,
                i) {
                case l:
                case h:
                    n = 1;
                    break;
                case u:
                    n = 3;
                    break;
                case p:
                    n = 2;
                    break;
                case d:
                    var f = e[4]
                      , g = e[5]
                      , m = kr(e[0] * e[0] + e[1] * e[1])
                      , v = kr(e[2] * e[2] + e[3] * e[3])
                      , y = Or(-e[1] / v, e[0] / m);
                    s[a] *= m,
                    s[a++] += f,
                    s[a] *= v,
                    s[a++] += g,
                    s[a++] *= m,
                    s[a++] *= v,
                    s[a++] += y,
                    s[a++] += y,
                    r = a += 2;
                    break;
                case c:
                    x[0] = s[a++],
                    x[1] = s[a++],
                    Dr(x, x, e),
                    s[r++] = x[0],
                    s[r++] = x[1],
                    x[0] += s[a++],
                    x[1] += s[a++],
                    Dr(x, x, e),
                    s[r++] = x[0],
                    s[r++] = x[1]
                }
                for (o = 0; o < n; o++) {
                    var x;
                    (x = Pr[o])[0] = s[a++],
                    x[1] = s[a++],
                    Dr(x, x, e),
                    s[r++] = x[0],
                    s[r++] = x[1]
                }
            }
        }
          , Er = Math.sqrt
          , zr = Math.sin
          , Vr = Math.cos
          , Br = Math.PI
          , Gr = function(t, e) {
            return (t[0] * e[0] + t[1] * e[1]) / (Rr(t) * Rr(e))
        }
          , Fr = function(t, e) {
            return (t[0] * e[1] < t[1] * e[0] ? -1 : 1) * Math.acos(Gr(t, e))
        };
        function Hr(t, e, i, n, a, r, o, s, l, u, h) {
            var c = l * (Br / 180)
              , d = Vr(c) * (t - i) / 2 + zr(c) * (e - n) / 2
              , p = -1 * zr(c) * (t - i) / 2 + Vr(c) * (e - n) / 2
              , f = d * d / (o * o) + p * p / (s * s);
            1 < f && (o *= Er(f),
            s *= Er(f));
            var g = (a === r ? -1 : 1) * Er((o * o * (s * s) - o * o * (p * p) - s * s * (d * d)) / (o * o * (p * p) + s * s * (d * d))) || 0
              , m = g * o * p / s
              , v = g * -s * d / o
              , y = (t + i) / 2 + Vr(c) * m - zr(c) * v
              , x = (e + n) / 2 + zr(c) * m + Vr(c) * v
              , _ = Fr([1, 0], [(d - m) / o, (p - v) / s])
              , b = [(d - m) / o, (p - v) / s]
              , w = [(-1 * d - m) / o, (-1 * p - v) / s]
              , S = Fr(b, w);
            Gr(b, w) <= -1 && (S = Br),
            1 <= Gr(b, w) && (S = 0),
            0 === r && 0 < S && (S -= 2 * Br),
            1 === r && S < 0 && (S += 2 * Br),
            h.addData(u, y, x, o, s, _, S, c, r)
        }
        var Wr = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/gi
          , Zr = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
        function Ur(t, e) {
            var i = function(t) {
                if (!t)
                    return new ir;
                for (var e, i = 0, n = 0, a = i, r = n, o = new ir, s = ir.CMD, l = t.match(Wr), u = 0; u < l.length; u++) {
                    for (var h, c = l[u], d = c.charAt(0), p = c.match(Zr) || [], f = p.length, g = 0; g < f; g++)
                        p[g] = parseFloat(p[g]);
                    for (var m = 0; m < f; ) {
                        var v, y, x, _, b, w, S, M = i, I = n;
                        switch (d) {
                        case "l":
                            i += p[m++],
                            n += p[m++],
                            h = s.L,
                            o.addData(h, i, n);
                            break;
                        case "L":
                            i = p[m++],
                            n = p[m++],
                            h = s.L,
                            o.addData(h, i, n);
                            break;
                        case "m":
                            i += p[m++],
                            n += p[m++],
                            h = s.M,
                            o.addData(h, i, n),
                            a = i,
                            r = n,
                            d = "l";
                            break;
                        case "M":
                            i = p[m++],
                            n = p[m++],
                            h = s.M,
                            o.addData(h, i, n),
                            a = i,
                            r = n,
                            d = "L";
                            break;
                        case "h":
                            i += p[m++],
                            h = s.L,
                            o.addData(h, i, n);
                            break;
                        case "H":
                            i = p[m++],
                            h = s.L,
                            o.addData(h, i, n);
                            break;
                        case "v":
                            n += p[m++],
                            h = s.L,
                            o.addData(h, i, n);
                            break;
                        case "V":
                            n = p[m++],
                            h = s.L,
                            o.addData(h, i, n);
                            break;
                        case "C":
                            h = s.C,
                            o.addData(h, p[m++], p[m++], p[m++], p[m++], p[m++], p[m++]),
                            i = p[m - 2],
                            n = p[m - 1];
                            break;
                        case "c":
                            h = s.C,
                            o.addData(h, p[m++] + i, p[m++] + n, p[m++] + i, p[m++] + n, p[m++] + i, p[m++] + n),
                            i += p[m - 2],
                            n += p[m - 1];
                            break;
                        case "S":
                            v = i,
                            y = n;
                            var A = o.len()
                              , T = o.data;
                            e === s.C && (v += i - T[A - 4],
                            y += n - T[A - 3]),
                            h = s.C,
                            M = p[m++],
                            I = p[m++],
                            i = p[m++],
                            n = p[m++],
                            o.addData(h, v, y, M, I, i, n);
                            break;
                        case "s":
                            v = i,
                            y = n;
                            A = o.len(),
                            T = o.data;
                            e === s.C && (v += i - T[A - 4],
                            y += n - T[A - 3]),
                            h = s.C,
                            M = i + p[m++],
                            I = n + p[m++],
                            i += p[m++],
                            n += p[m++],
                            o.addData(h, v, y, M, I, i, n);
                            break;
                        case "Q":
                            M = p[m++],
                            I = p[m++],
                            i = p[m++],
                            n = p[m++],
                            h = s.Q,
                            o.addData(h, M, I, i, n);
                            break;
                        case "q":
                            M = p[m++] + i,
                            I = p[m++] + n,
                            i += p[m++],
                            n += p[m++],
                            h = s.Q,
                            o.addData(h, M, I, i, n);
                            break;
                        case "T":
                            v = i,
                            y = n;
                            A = o.len(),
                            T = o.data;
                            e === s.Q && (v += i - T[A - 4],
                            y += n - T[A - 3]),
                            i = p[m++],
                            n = p[m++],
                            h = s.Q,
                            o.addData(h, v, y, i, n);
                            break;
                        case "t":
                            v = i,
                            y = n;
                            A = o.len(),
                            T = o.data;
                            e === s.Q && (v += i - T[A - 4],
                            y += n - T[A - 3]),
                            i += p[m++],
                            n += p[m++],
                            h = s.Q,
                            o.addData(h, v, y, i, n);
                            break;
                        case "A":
                            x = p[m++],
                            _ = p[m++],
                            b = p[m++],
                            w = p[m++],
                            S = p[m++],
                            Hr(M = i, I = n, i = p[m++], n = p[m++], w, S, x, _, b, h = s.A, o);
                            break;
                        case "a":
                            x = p[m++],
                            _ = p[m++],
                            b = p[m++],
                            w = p[m++],
                            S = p[m++],
                            Hr(M = i, I = n, i += p[m++], n += p[m++], w, S, x, _, b, h = s.A, o)
                        }
                    }
                    "z" !== d && "Z" !== d || (h = s.Z,
                    o.addData(h),
                    i = a,
                    n = r),
                    e = h
                }
                return o.toStatic(),
                o
            }(t);
            return (e = e || {}).buildPath = function(t) {
                if (t.setData) {
                    t.setData(i.data),
                    (e = t.getContext()) && t.rebuildPath(e)
                } else {
                    var e = t;
                    i.rebuildPath(e)
                }
            }
            ,
            e.applyTransform = function(t) {
                Nr(i, t),
                this.dirty(!0)
            }
            ,
            e
        }
        function Yr(t) {
            yn.call(this, t)
        }
        var jr = {
            createFromString: function(t, e) {
                return new Cr(Ur(t, e))
            },
            extendFromString: function(t, e) {
                return Cr.extend(Ur(t, e))
            },
            mergePath: function(t, e) {
                for (var i = [], n = t.length, a = 0; a < n; a++) {
                    var r = t[a];
                    r.path || r.createPathProxy(),
                    r.__dirtyPath && r.buildPath(r.path, r.shape, !0),
                    i.push(r.path)
                }
                var o = new Cr(e);
                return o.createPathProxy(),
                o.buildPath = function(t) {
                    t.appendPath(i);
                    var e = t.getContext();
                    e && t.rebuildPath(e)
                }
                ,
                o
            }
        }
          , Xr = qe.ContextCachedBy;
        Yr.prototype = {
            constructor: Yr,
            type: "text",
            brush: function(t, e) {
                var i = this.style;
                this.__dirty && pn.normalizeTextStyle(i, !0),
                i.fill = i.stroke = i.shadowBlur = i.shadowColor = i.shadowOffsetX = i.shadowOffsetY = null;
                var n = i.text;
                null != n && (n += ""),
                pn.needDrawText(n, i) ? (this.setTransform(t),
                pn.renderText(this, t, n, i, null, e),
                this.restoreTransform(t)) : t.__attrCachedBy = Xr.NONE
            },
            getBoundingRect: function() {
                var t = this.style;
                if (this.__dirty && pn.normalizeTextStyle(t, !0),
                !this._rect) {
                    var e = t.text;
                    null != e ? e += "" : e = "";
                    var i = Bi.getBoundingRect(t.text + "", t.font, t.textAlign, t.textVerticalAlign, t.textPadding, t.textLineHeight, t.rich);
                    if (i.x += t.x || 0,
                    i.y += t.y || 0,
                    pn.getStroke(t.textStroke, t.textStrokeWidth)) {
                        var n = t.textStrokeWidth;
                        i.x -= n / 2,
                        i.y -= n / 2,
                        i.width += n,
                        i.height += n
                    }
                    this._rect = i
                }
                return this._rect
            }
        },
        it.inherits(Yr, yn);
        var qr = Yr
          , Kr = Cr.extend({
            type: "circle",
            shape: {
                cx: 0,
                cy: 0,
                r: 0
            },
            buildPath: function(t, e, i) {
                i && t.moveTo(e.cx + e.r, e.cy),
                t.arc(e.cx, e.cy, e.r, 0, 2 * Math.PI, !0)
            }
        })
          , $r = [["shadowBlur", 0], ["shadowColor", "#000"], ["shadowOffsetX", 0], ["shadowOffsetY", 0]];
        var Jr = function(l) {
            return et.browser.ie && 11 <= et.browser.version ? function() {
                var t, e = this.__clipPaths, i = this.style;
                if (e)
                    for (var n = 0; n < e.length; n++) {
                        var a = e[n]
                          , r = a && a.shape
                          , o = a && a.type;
                        if (r && ("sector" === o && r.startAngle === r.endAngle || "rect" === o && (!r.width || !r.height))) {
                            for (var s = 0; s < $r.length; s++)
                                $r[s][2] = i[$r[s][0]],
                                i[$r[s][0]] = $r[s][1];
                            t = !0;
                            break
                        }
                    }
                if (l.apply(this, arguments),
                t)
                    for (s = 0; s < $r.length; s++)
                        i[$r[s][0]] = $r[s][2]
            }
            : l
        }
          , Qr = Cr.extend({
            type: "sector",
            shape: {
                cx: 0,
                cy: 0,
                r0: 0,
                r: 0,
                startAngle: 0,
                endAngle: 2 * Math.PI,
                clockwise: !0
            },
            brush: Jr(Cr.prototype.brush),
            buildPath: function(t, e) {
                var i = e.cx
                  , n = e.cy
                  , a = Math.max(e.r0 || 0, 0)
                  , r = Math.max(e.r, 0)
                  , o = e.startAngle
                  , s = e.endAngle
                  , l = e.clockwise
                  , u = Math.cos(o)
                  , h = Math.sin(o);
                t.moveTo(u * a + i, h * a + n),
                t.lineTo(u * r + i, h * r + n),
                t.arc(i, n, r, o, s, !l),
                t.lineTo(Math.cos(s) * a + i, Math.sin(s) * a + n),
                0 !== a && t.arc(i, n, a, s, o, l),
                t.closePath()
            }
        })
          , to = Cr.extend({
            type: "ring",
            shape: {
                cx: 0,
                cy: 0,
                r: 0,
                r0: 0
            },
            buildPath: function(t, e) {
                var i = e.cx
                  , n = e.cy
                  , a = 2 * Math.PI;
                t.moveTo(i + e.r, n),
                t.arc(i, n, e.r, 0, a, !1),
                t.moveTo(i + e.r0, n),
                t.arc(i, n, e.r0, 0, a, !0)
            }
        })
          , eo = R.distance;
        function io(t, e, i, n, a, r, o) {
            var s = .5 * (i - t)
              , l = .5 * (n - e);
            return (2 * (e - i) + s + l) * o + (-3 * (e - i) - 2 * s - l) * r + s * a + e
        }
        var no = function(t, e) {
            for (var i = t.length, n = [], a = 0, r = 1; r < i; r++)
                a += eo(t[r - 1], t[r]);
            var o = a / 2;
            for (o = o < i ? i : o,
            r = 0; r < o; r++) {
                var s, l, u, h = r / (o - 1) * (e ? i : i - 1), c = Math.floor(h), d = h - c, p = t[c % i];
                u = e ? (s = t[(c - 1 + i) % i],
                l = t[(c + 1) % i],
                t[(c + 2) % i]) : (s = t[0 === c ? c : c - 1],
                l = t[i - 2 < c ? i - 1 : c + 1],
                t[i - 3 < c ? i - 1 : c + 2]);
                var f = d * d
                  , g = d * f;
                n.push([io(s[0], p[0], l[0], u[0], d, f, g), io(s[1], p[1], l[1], u[1], d, f, g)])
            }
            return n
        }
          , ao = R.min
          , ro = R.max
          , oo = R.scale
          , so = R.distance
          , lo = R.add
          , uo = R.clone
          , ho = R.sub;
        var co = function(t, e, i, n) {
            var a, r, o, s, l = [], u = [], h = [], c = [];
            if (n) {
                o = [1 / 0, 1 / 0],
                s = [-1 / 0, -1 / 0];
                for (var d = 0, p = t.length; d < p; d++)
                    ao(o, o, t[d]),
                    ro(s, s, t[d]);
                ao(o, o, n[0]),
                ro(s, s, n[1])
            }
            for (d = 0,
            p = t.length; d < p; d++) {
                var f = t[d];
                if (i)
                    a = t[d ? d - 1 : p - 1],
                    r = t[(d + 1) % p];
                else {
                    if (0 === d || d === p - 1) {
                        l.push(uo(t[d]));
                        continue
                    }
                    a = t[d - 1],
                    r = t[d + 1]
                }
                ho(u, r, a),
                oo(u, u, e);
                var g = so(f, a)
                  , m = so(f, r)
                  , v = g + m;
                0 !== v && (g /= v,
                m /= v),
                oo(h, u, -g),
                oo(c, u, m);
                var y = lo([], f, h)
                  , x = lo([], f, c);
                n && (ro(y, y, o),
                ao(y, y, s),
                ro(x, x, o),
                ao(x, x, s)),
                l.push(y),
                l.push(x)
            }
            return i && l.push(l.shift()),
            l
        };
        var po = {
            buildPath: function(t, e, i) {
                var n = e.points
                  , a = e.smooth;
                if (n && 2 <= n.length) {
                    if (a && "spline" !== a) {
                        var r = co(n, a, i, e.smoothConstraint);
                        t.moveTo(n[0][0], n[0][1]);
                        for (var o = n.length, s = 0; s < (i ? o : o - 1); s++) {
                            var l = r[2 * s]
                              , u = r[2 * s + 1]
                              , h = n[(s + 1) % o];
                            t.bezierCurveTo(l[0], l[1], u[0], u[1], h[0], h[1])
                        }
                    } else {
                        "spline" === a && (n = no(n, i)),
                        t.moveTo(n[0][0], n[0][1]);
                        s = 1;
                        for (var c = n.length; s < c; s++)
                            t.lineTo(n[s][0], n[s][1])
                    }
                    i && t.closePath()
                }
            }
        }
          , fo = Cr.extend({
            type: "polygon",
            shape: {
                points: null,
                smooth: !1,
                smoothConstraint: null
            },
            buildPath: function(t, e) {
                po.buildPath(t, e, !0)
            }
        })
          , go = Cr.extend({
            type: "polyline",
            shape: {
                points: null,
                smooth: !1,
                smoothConstraint: null
            },
            style: {
                stroke: "#000",
                fill: null
            },
            buildPath: function(t, e) {
                po.buildPath(t, e, !1)
            }
        })
          , mo = Math.round;
        function vo(t, e, i) {
            var n = mo(2 * t);
            return (n + mo(e)) % 2 == 0 ? n / 2 : (n + (i ? 1 : -1)) / 2
        }
        var yo = {
            subPixelOptimizeLine: function(t, e, i) {
                var n = i && i.lineWidth;
                if (e && n) {
                    var a = e.x1
                      , r = e.x2
                      , o = e.y1
                      , s = e.y2;
                    mo(2 * a) === mo(2 * r) ? t.x1 = t.x2 = vo(a, n, !0) : (t.x1 = a,
                    t.x2 = r),
                    mo(2 * o) === mo(2 * s) ? t.y1 = t.y2 = vo(o, n, !0) : (t.y1 = o,
                    t.y2 = s)
                }
            },
            subPixelOptimizeRect: function(t, e, i) {
                var n = i && i.lineWidth;
                if (e && n) {
                    var a = e.x
                      , r = e.y
                      , o = e.width
                      , s = e.height;
                    t.x = vo(a, n, !0),
                    t.y = vo(r, n, !0),
                    t.width = Math.max(vo(a + o, n, !1) - t.x, 0 === o ? 0 : 1),
                    t.height = Math.max(vo(r + s, n, !1) - t.y, 0 === s ? 0 : 1)
                }
            },
            subPixelOptimize: vo
        }
          , xo = yo.subPixelOptimizeRect
          , _o = {}
          , bo = Cr.extend({
            type: "rect",
            shape: {
                r: 0,
                x: 0,
                y: 0,
                width: 0,
                height: 0
            },
            buildPath: function(t, e) {
                var i, n, a, r;
                this.subPixelOptimize ? (xo(_o, e, this.style),
                i = _o.x,
                n = _o.y,
                a = _o.width,
                r = _o.height,
                _o.r = e.r,
                e = _o) : (i = e.x,
                n = e.y,
                a = e.width,
                r = e.height),
                e.r ? Gi.buildPath(t, e) : t.rect(i, n, a, r),
                t.closePath()
            }
        })
          , wo = yo.subPixelOptimizeLine
          , So = {}
          , Mo = Cr.extend({
            type: "line",
            shape: {
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                percent: 1
            },
            style: {
                stroke: "#000",
                fill: null
            },
            buildPath: function(t, e) {
                var i, n, a, r;
                r = this.subPixelOptimize ? (wo(So, e, this.style),
                i = So.x1,
                n = So.y1,
                a = So.x2,
                So.y2) : (i = e.x1,
                n = e.y1,
                a = e.x2,
                e.y2);
                var o = e.percent;
                0 !== o && (t.moveTo(i, n),
                o < 1 && (a = i * (1 - o) + a * o,
                r = n * (1 - o) + r * o),
                t.lineTo(a, r))
            },
            pointAt: function(t) {
                var e = this.shape;
                return [e.x1 * (1 - t) + e.x2 * t, e.y1 * (1 - t) + e.y2 * t]
            }
        })
          , Io = La.quadraticSubdivide
          , Ao = La.cubicSubdivide
          , To = La.quadraticAt
          , Co = La.cubicAt
          , Do = La.quadraticDerivativeAt
          , Lo = La.cubicDerivativeAt
          , Po = [];
        function ko(t, e, i) {
            var n = t.cpx2
              , a = t.cpy2;
            return null === n || null === a ? [(i ? Lo : Co)(t.x1, t.cpx1, t.cpx2, t.x2, e), (i ? Lo : Co)(t.y1, t.cpy1, t.cpy2, t.y2, e)] : [(i ? Do : To)(t.x1, t.cpx1, t.x2, e), (i ? Do : To)(t.y1, t.cpy1, t.y2, e)]
        }
        function Oo(t) {
            this.colorStops = t || []
        }
        var Ro = Cr.extend({
            type: "bezier-curve",
            shape: {
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                cpx1: 0,
                cpy1: 0,
                percent: 1
            },
            style: {
                stroke: "#000",
                fill: null
            },
            buildPath: function(t, e) {
                var i = e.x1
                  , n = e.y1
                  , a = e.x2
                  , r = e.y2
                  , o = e.cpx1
                  , s = e.cpy1
                  , l = e.cpx2
                  , u = e.cpy2
                  , h = e.percent;
                0 !== h && (t.moveTo(i, n),
                null == l || null == u ? (h < 1 && (Io(i, o, a, h, Po),
                o = Po[1],
                a = Po[2],
                Io(n, s, r, h, Po),
                s = Po[1],
                r = Po[2]),
                t.quadraticCurveTo(o, s, a, r)) : (h < 1 && (Ao(i, o, l, a, h, Po),
                o = Po[1],
                l = Po[2],
                a = Po[3],
                Ao(n, s, u, r, h, Po),
                s = Po[1],
                u = Po[2],
                r = Po[3]),
                t.bezierCurveTo(o, s, l, u, a, r)))
            },
            pointAt: function(t) {
                return ko(this.shape, t, !1)
            },
            tangentAt: function(t) {
                var e = ko(this.shape, t, !0);
                return R.normalize(e, e)
            }
        })
          , No = Cr.extend({
            type: "arc",
            shape: {
                cx: 0,
                cy: 0,
                r: 0,
                startAngle: 0,
                endAngle: 2 * Math.PI,
                clockwise: !0
            },
            style: {
                stroke: "#000",
                fill: null
            },
            buildPath: function(t, e) {
                var i = e.cx
                  , n = e.cy
                  , a = Math.max(e.r, 0)
                  , r = e.startAngle
                  , o = e.endAngle
                  , s = e.clockwise
                  , l = Math.cos(r)
                  , u = Math.sin(r);
                t.moveTo(l * a + i, u * a + n),
                t.arc(i, n, a, r, o, !s)
            }
        })
          , Eo = Cr.extend({
            type: "compound",
            shape: {
                paths: null
            },
            _updatePathDirty: function() {
                for (var t = this.__dirtyPath, e = this.shape.paths, i = 0; i < e.length; i++)
                    t = t || e[i].__dirtyPath;
                this.__dirtyPath = t,
                this.__dirty = this.__dirty || t
            },
            beforeBrush: function() {
                this._updatePathDirty();
                for (var t = this.shape.paths || [], e = this.getGlobalScale(), i = 0; i < t.length; i++)
                    t[i].path || t[i].createPathProxy(),
                    t[i].path.setScale(e[0], e[1])
            },
            buildPath: function(t, e) {
                for (var i = e.paths || [], n = 0; n < i.length; n++)
                    i[n].buildPath(t, i[n].shape, !0)
            },
            afterBrush: function() {
                for (var t = this.shape.paths || [], e = 0; e < t.length; e++)
                    t[e].__dirtyPath = !1
            },
            getBoundingRect: function() {
                return this._updatePathDirty(),
                Cr.prototype.getBoundingRect.call(this)
            }
        });
        Oo.prototype = {
            constructor: Oo,
            addColorStop: function(t, e) {
                this.colorStops.push({
                    offset: t,
                    color: e
                })
            }
        };
        function zo(t, e, i, n, a, r) {
            this.x = null == t ? 0 : t,
            this.y = null == e ? 0 : e,
            this.x2 = null == i ? 1 : i,
            this.y2 = null == n ? 0 : n,
            this.type = "linear",
            this.global = r || !1,
            Vo.call(this, a)
        }
        var Vo = Oo;
        zo.prototype = {
            constructor: zo
        },
        it.inherits(zo, Vo);
        function Bo(t, e, i, n, a) {
            this.x = null == t ? .5 : t,
            this.y = null == e ? .5 : e,
            this.r = null == i ? .5 : i,
            this.type = "radial",
            this.global = a || !1,
            Vo.call(this, n)
        }
        var Go = zo;
        Bo.prototype = {
            constructor: Bo
        },
        it.inherits(Bo, Vo);
        var Fo = Bo
          , Ho = it.inherits;
        function Wo(t) {
            yn.call(this, t),
            this._displayables = [],
            this._temporaryDisplayables = [],
            this._cursor = 0,
            this.notClear = !0
        }
        Wo.prototype.incremental = !0,
        Wo.prototype.clearDisplaybles = function() {
            this._displayables = [],
            this._temporaryDisplayables = [],
            this._cursor = 0,
            this.dirty(),
            this.notClear = !1
        }
        ,
        Wo.prototype.addDisplayable = function(t, e) {
            e ? this._temporaryDisplayables.push(t) : this._displayables.push(t),
            this.dirty()
        }
        ,
        Wo.prototype.addDisplayables = function(t, e) {
            e = e || !1;
            for (var i = 0; i < t.length; i++)
                this.addDisplayable(t[i], e)
        }
        ,
        Wo.prototype.eachPendingDisplayable = function(t) {
            for (var e = this._cursor; e < this._displayables.length; e++)
                t && t(this._displayables[e]);
            for (e = 0; e < this._temporaryDisplayables.length; e++)
                t && t(this._temporaryDisplayables[e])
        }
        ,
        Wo.prototype.update = function() {
            this.updateTransform();
            for (var t = this._cursor; t < this._displayables.length; t++) {
                (e = this._displayables[t]).parent = this,
                e.update(),
                e.parent = null
            }
            for (t = 0; t < this._temporaryDisplayables.length; t++) {
                var e;
                (e = this._temporaryDisplayables[t]).parent = this,
                e.update(),
                e.parent = null
            }
        }
        ,
        Wo.prototype.brush = function(t, e) {
            for (var i = this._cursor; i < this._displayables.length; i++) {
                (n = this._displayables[i]).beforeBrush && n.beforeBrush(t),
                n.brush(t, i === this._cursor ? null : this._displayables[i - 1]),
                n.afterBrush && n.afterBrush(t)
            }
            this._cursor = i;
            for (i = 0; i < this._temporaryDisplayables.length; i++) {
                var n;
                (n = this._temporaryDisplayables[i]).beforeBrush && n.beforeBrush(t),
                n.brush(t, 0 === i ? null : this._temporaryDisplayables[i - 1]),
                n.afterBrush && n.afterBrush(t)
            }
            this._temporaryDisplayables = [],
            this.notClear = !0
        }
        ;
        var Zo = [];
        Wo.prototype.getBoundingRect = function() {
            if (!this._rect) {
                for (var t = new Oe(1 / 0,1 / 0,-1 / 0,-1 / 0), e = 0; e < this._displayables.length; e++) {
                    var i = this._displayables[e]
                      , n = i.getBoundingRect().clone();
                    i.needLocalTransform() && n.applyTransform(i.getLocalTransform(Zo)),
                    t.union(n)
                }
                this._rect = t
            }
            return this._rect
        }
        ,
        Wo.prototype.contain = function(t, e) {
            var i = this.transformCoordToLocal(t, e);
            if (this.getBoundingRect().contain(i[0], i[1]))
                for (var n = 0; n < this._displayables.length; n++) {
                    if (this._displayables[n].contain(t, e))
                        return !0
                }
            return !1
        }
        ,
        Ho(Wo, yn);
        var Uo = Wo
          , Yo = _n
          , jo = Re
          , Xo = qr
          , qo = Kr
          , Ko = Qr
          , $o = to
          , Jo = fo
          , Qo = go
          , ts = bo
          , es = Mo
          , is = Ro
          , ns = No
          , as = Eo
          , rs = Go
          , os = Fo
          , ss = Oe
          , ls = Uo
          , us = Math.round
          , hs = Math.max
          , cs = Math.min
          , ds = {}
          , ps = 1;
        function fs(t, e, i, n) {
            var a = jr.createFromString(t, e);
            return i && ("center" === n && (i = gs(i, a.getBoundingRect())),
            vs(a, i)),
            a
        }
        function gs(t, e) {
            var i, n = e.width / e.height, a = t.height * n;
            return i = a <= t.width ? t.height : (a = t.width) / n,
            {
                x: t.x + t.width / 2 - a / 2,
                y: t.y + t.height / 2 - i / 2,
                width: a,
                height: i
            }
        }
        var ms = jr.mergePath;
        function vs(t, e) {
            if (t.applyTransform) {
                var i = t.getBoundingRect().calculateTransform(e);
                t.applyTransform(i)
            }
        }
        function ys(t, e, i) {
            var n = us(2 * t);
            return (n + us(e)) % 2 == 0 ? n / 2 : (n + (i ? 1 : -1)) / 2
        }
        function xs(t) {
            return null != t && "none" !== t
        }
        var _s = it.createHashMap()
          , bs = 0;
        function ws(t) {
            var e = t.__hoverStl;
            if (e && !t.__highlighted) {
                var i = t.useHoverLayer;
                t.__highlighted = i ? "layer" : "plain";
                var n = t.__zr;
                if (n || !i) {
                    var a = t
                      , r = t.style;
                    i && (r = (a = n.addHover(t)).style),
                    zs(r),
                    i || function(t) {
                        if (t.__hoverStlDirty) {
                            t.__hoverStlDirty = !1;
                            var e = t.__hoverStl;
                            if (e) {
                                var i = t.__cachedNormalStl = {};
                                t.__cachedNormalZ2 = t.z2;
                                var n = t.style;
                                for (var a in e)
                                    null != e[a] && (i[a] = n[a]);
                                i.fill = n.fill,
                                i.stroke = n.stroke
                            } else
                                t.__cachedNormalStl = t.__cachedNormalZ2 = null
                        }
                    }(a),
                    r.extendFrom(e),
                    Ss(r, e, "fill"),
                    Ss(r, e, "stroke"),
                    Es(r),
                    i || (t.dirty(!1),
                    t.z2 += ps)
                }
            }
        }
        function Ss(t, e, i) {
            !xs(e[i]) && xs(t[i]) && (t[i] = function(t) {
                if ("string" != typeof t)
                    return t;
                var e = _s.get(t);
                return e || (e = jt.lift(t, -.1),
                bs < 1e4 && (_s.set(t, e),
                bs++)),
                e
            }(t[i]))
        }
        function Ms(t) {
            var e = t.__highlighted;
            if (e)
                if (t.__highlighted = !1,
                "layer" === e)
                    t.__zr && t.__zr.removeHover(t);
                else if (e) {
                    var i = t.style
                      , n = t.__cachedNormalStl;
                    n && (zs(i),
                    t.setStyle(n),
                    Es(i));
                    var a = t.__cachedNormalZ2;
                    null != a && t.z2 - a === ps && (t.z2 = a)
                }
        }
        function Is(t, e) {
            t.isGroup ? t.traverse(function(t) {
                t.isGroup || e(t)
            }) : e(t)
        }
        function As(t, e) {
            e = t.__hoverStl = !1 !== e && (e || {}),
            t.__hoverStlDirty = !0,
            t.__highlighted && (t.__cachedNormalStl = null,
            Ms(t),
            ws(t))
        }
        function Ts(t) {
            this.__hoverSilentOnTouch && t.zrByTouch || this.__isEmphasisEntered || Is(this, ws)
        }
        function Cs(t) {
            this.__hoverSilentOnTouch && t.zrByTouch || this.__isEmphasisEntered || Is(this, Ms)
        }
        function Ds() {
            this.__isEmphasisEntered = !0,
            Is(this, ws)
        }
        function Ls() {
            this.__isEmphasisEntered = !1,
            Is(this, Ms)
        }
        function Ps(t, e) {
            var i = !1 === e;
            if (t.__hoverSilentOnTouch = null != e && e.hoverSilentOnTouch,
            !i || t.__hoverStyleTrigger) {
                var n = i ? "off" : "on";
                t[n]("mouseover", Ts)[n]("mouseout", Cs),
                t[n]("emphasis", Ds)[n]("normal", Ls),
                t.__hoverStyleTrigger = !i
            }
        }
        function ks(t, e, i, n, a) {
            return Os(t, e, n, a),
            i && it.extend(t, i),
            t
        }
        function Os(t, e, i, n) {
            if ((i = i || ds).isRectText) {
                var a = e.getShallow("position") || (n ? null : "inside");
                "outside" === a && (a = "top"),
                t.textPosition = a,
                t.textOffset = e.getShallow("offset");
                var r = e.getShallow("rotate");
                null != r && (r *= Math.PI / 180),
                t.textRotation = r,
                t.textDistance = it.retrieve2(e.getShallow("distance"), n ? null : 5)
            }
            var o, s = e.ecModel, l = s && s.option.textStyle, u = function(t) {
                var e;
                for (; t && t !== t.ecModel; ) {
                    var i = (t.option || ds).rich;
                    if (i)
                        for (var n in e = e || {},
                        i)
                            i.hasOwnProperty(n) && (e[n] = 1);
                    t = t.parentModel
                }
                return e
            }(e);
            if (u)
                for (var h in o = {},
                u)
                    if (u.hasOwnProperty(h)) {
                        var c = e.getModel(["rich", h]);
                        Rs(o[h] = {}, c, l, i, n)
                    }
            return t.rich = o,
            Rs(t, e, l, i, n, !0),
            i.forceRich && !i.textStyle && (i.textStyle = {}),
            t
        }
        function Rs(t, e, i, n, a, r) {
            i = !a && i || ds,
            t.textFill = Ns(e.getShallow("color"), n) || i.color,
            t.textStroke = Ns(e.getShallow("textBorderColor"), n) || i.textBorderColor,
            t.textStrokeWidth = it.retrieve2(e.getShallow("textBorderWidth"), i.textBorderWidth),
            t.insideRawTextPosition = t.textPosition,
            a || (r && (t.insideRollbackOpt = n,
            Es(t)),
            null == t.textFill && (t.textFill = n.autoColor)),
            t.fontStyle = e.getShallow("fontStyle") || i.fontStyle,
            t.fontWeight = e.getShallow("fontWeight") || i.fontWeight,
            t.fontSize = e.getShallow("fontSize") || i.fontSize,
            t.fontFamily = e.getShallow("fontFamily") || i.fontFamily,
            t.textAlign = e.getShallow("align"),
            t.textVerticalAlign = e.getShallow("verticalAlign") || e.getShallow("baseline"),
            t.textLineHeight = e.getShallow("lineHeight"),
            t.textWidth = e.getShallow("width"),
            t.textHeight = e.getShallow("height"),
            t.textTag = e.getShallow("tag"),
            r && n.disableBox || (t.textBackgroundColor = Ns(e.getShallow("backgroundColor"), n),
            t.textPadding = e.getShallow("padding"),
            t.textBorderColor = Ns(e.getShallow("borderColor"), n),
            t.textBorderWidth = e.getShallow("borderWidth"),
            t.textBorderRadius = e.getShallow("borderRadius"),
            t.textBoxShadowColor = e.getShallow("shadowColor"),
            t.textBoxShadowBlur = e.getShallow("shadowBlur"),
            t.textBoxShadowOffsetX = e.getShallow("shadowOffsetX"),
            t.textBoxShadowOffsetY = e.getShallow("shadowOffsetY")),
            t.textShadowColor = e.getShallow("textShadowColor") || i.textShadowColor,
            t.textShadowBlur = e.getShallow("textShadowBlur") || i.textShadowBlur,
            t.textShadowOffsetX = e.getShallow("textShadowOffsetX") || i.textShadowOffsetX,
            t.textShadowOffsetY = e.getShallow("textShadowOffsetY") || i.textShadowOffsetY
        }
        function Ns(t, e) {
            return "auto" !== t ? t : e && e.autoColor ? e.autoColor : null
        }
        function Es(t) {
            var e = t.insideRollbackOpt;
            if (e && null == t.textFill) {
                var i, n = e.useInsideStyle, a = t.insideRawTextPosition, r = e.autoColor;
                !1 !== n && (!0 === n || e.isRectText && a && "string" == typeof a && 0 <= a.indexOf("inside")) ? (i = {
                    textFill: null,
                    textStroke: t.textStroke,
                    textStrokeWidth: t.textStrokeWidth
                },
                t.textFill = "#fff",
                null == t.textStroke && (t.textStroke = r,
                null == t.textStrokeWidth && (t.textStrokeWidth = 2))) : null != r && (i = {
                    textFill: null
                },
                t.textFill = r),
                i && (t.insideRollback = i)
            }
        }
        function zs(t) {
            var e = t.insideRollback;
            e && (t.textFill = e.textFill,
            t.textStroke = e.textStroke,
            t.textStrokeWidth = e.textStrokeWidth,
            t.insideRollback = null)
        }
        function Vs(t, e, i, n, a, r) {
            if ("function" == typeof a && (r = a,
            a = null),
            n && n.isAnimationEnabled()) {
                var o = t ? "Update" : ""
                  , s = n.getShallow("animationDuration" + o)
                  , l = n.getShallow("animationEasing" + o)
                  , u = n.getShallow("animationDelay" + o);
                "function" == typeof u && (u = u(a, n.getAnimationDelayParams ? n.getAnimationDelayParams(e, a) : null)),
                "function" == typeof s && (s = s(a)),
                0 < s ? e.animateTo(i, s, u || 0, l, r, !!r) : (e.stopAnimation(),
                e.attr(i),
                r && r())
            } else
                e.stopAnimation(),
                e.attr(i),
                r && r()
        }
        function Bs(t, e, i, n, a) {
            Vs(!0, t, e, i, n, a)
        }
        function Gs(t, e, i) {
            return e && !it.isArrayLike(e) && (e = xt.getLocalTransform(e)),
            i && (e = ct.invert([], e)),
            R.applyTransform([], t, e)
        }
        var Fs = {
            Image: Yo,
            Group: jo,
            Text: Xo,
            Circle: qo,
            Sector: Ko,
            Ring: $o,
            Polygon: Jo,
            Polyline: Qo,
            Rect: ts,
            Line: es,
            BezierCurve: is,
            Arc: ns,
            CompoundPath: as,
            LinearGradient: rs,
            RadialGradient: os,
            BoundingRect: ss,
            IncrementalDisplayable: ls,
            Z2_EMPHASIS_LIFT: ps,
            extendShape: function(t) {
                return Cr.extend(t)
            },
            extendPath: function(t, e) {
                return jr.extendFromString(t, e)
            },
            makePath: fs,
            makeImage: function(t, i, n) {
                var a = new _n({
                    style: {
                        image: t,
                        x: i.x,
                        y: i.y,
                        width: i.width,
                        height: i.height
                    },
                    onload: function(t) {
                        if ("center" === n) {
                            var e = {
                                width: t.width,
                                height: t.height
                            };
                            a.setStyle(gs(i, e))
                        }
                    }
                });
                return a
            },
            mergePath: ms,
            resizePath: vs,
            subPixelOptimizeLine: function(t) {
                var e = t.shape
                  , i = t.style.lineWidth;
                return us(2 * e.x1) === us(2 * e.x2) && (e.x1 = e.x2 = ys(e.x1, i, !0)),
                us(2 * e.y1) === us(2 * e.y2) && (e.y1 = e.y2 = ys(e.y1, i, !0)),
                t
            },
            subPixelOptimizeRect: function(t) {
                var e = t.shape
                  , i = t.style.lineWidth
                  , n = e.x
                  , a = e.y
                  , r = e.width
                  , o = e.height;
                return e.x = ys(e.x, i, !0),
                e.y = ys(e.y, i, !0),
                e.width = Math.max(ys(n + r, i, !1) - e.x, 0 === r ? 0 : 1),
                e.height = Math.max(ys(a + o, i, !1) - e.y, 0 === o ? 0 : 1),
                t
            },
            subPixelOptimize: ys,
            setElementHoverStyle: As,
            isInEmphasis: function(t) {
                return t && t.__isEmphasisEntered
            },
            setHoverStyle: function(t, e, i) {
                t.isGroup ? t.traverse(function(t) {
                    t.isGroup || As(t, t.hoverStyle || e)
                }) : As(t, t.hoverStyle || e),
                Ps(t, i)
            },
            setAsHoverStyleTrigger: Ps,
            setLabelStyle: function(t, e, i, n, a, r, o) {
                var s, l = (a = a || ds).labelFetcher, u = a.labelDataIndex, h = a.labelDimIndex, c = i.getShallow("show"), d = n.getShallow("show");
                (c || d) && (l && (s = l.getFormattedLabel(u, "normal", null, h)),
                null == s && (s = it.isFunction(a.defaultText) ? a.defaultText(u, a) : a.defaultText));
                var p = c ? s : null
                  , f = d ? it.retrieve2(l ? l.getFormattedLabel(u, "emphasis", null, h) : null, s) : null;
                null == p && null == f || (ks(t, i, r, a),
                ks(e, n, o, a, !0)),
                t.text = p,
                e.text = f
            },
            setTextStyle: ks,
            setText: function(t, e, i) {
                var n, a = {
                    isRectText: !0
                };
                !1 === i ? n = !0 : a.autoColor = i,
                Os(t, e, a, n)
            },
            getFont: function(t, e) {
                var i = e || e.getModel("textStyle");
                return it.trim([t.fontStyle || i && i.getShallow("fontStyle") || "", t.fontWeight || i && i.getShallow("fontWeight") || "", (t.fontSize || i && i.getShallow("fontSize") || 12) + "px", t.fontFamily || i && i.getShallow("fontFamily") || "sans-serif"].join(" "))
            },
            updateProps: Bs,
            initProps: function(t, e, i, n, a) {
                Vs(!1, t, e, i, n, a)
            },
            getTransform: function(t, e) {
                for (var i = ct.identity([]); t && t !== e; )
                    ct.mul(i, t.getLocalTransform(), i),
                    t = t.parent;
                return i
            },
            applyTransform: Gs,
            transformDirection: function(t, e, i) {
                var n = 0 === e[4] || 0 === e[5] || 0 === e[0] ? 1 : Math.abs(2 * e[4] / e[0])
                  , a = 0 === e[4] || 0 === e[5] || 0 === e[2] ? 1 : Math.abs(2 * e[4] / e[2])
                  , r = ["left" === t ? -n : "right" === t ? n : 0, "top" === t ? -a : "bottom" === t ? a : 0];
                return r = Gs(r, e, i),
                Math.abs(r[0]) > Math.abs(r[1]) ? 0 < r[0] ? "right" : "left" : 0 < r[1] ? "bottom" : "top"
            },
            groupTransition: function(t, e, n, i) {
                if (t && e) {
                    var a, r = (a = {},
                    t.traverse(function(t) {
                        !t.isGroup && t.anid && (a[t.anid] = t)
                    }),
                    a);
                    e.traverse(function(t) {
                        if (!t.isGroup && t.anid) {
                            var e = r[t.anid];
                            if (e) {
                                var i = o(t);
                                t.attr(o(e)),
                                Bs(t, i, n, t.dataIndex)
                            }
                        }
                    })
                }
                function o(t) {
                    var e = {
                        position: R.clone(t.position),
                        rotation: t.rotation
                    };
                    return t.shape && (e.shape = it.extend({}, t.shape)),
                    e
                }
            },
            clipPointsByRect: function(t, n) {
                return it.map(t, function(t) {
                    var e = t[0];
                    e = hs(e, n.x),
                    e = cs(e, n.x + n.width);
                    var i = t[1];
                    return i = hs(i, n.y),
                    [e, i = cs(i, n.y + n.height)]
                })
            },
            clipRectByRect: function(t, e) {
                var i = hs(t.x, e.x)
                  , n = cs(t.x + t.width, e.x + e.width)
                  , a = hs(t.y, e.y)
                  , r = cs(t.y + t.height, e.y + e.height);
                if (i <= n && a <= r)
                    return {
                        x: i,
                        y: a,
                        width: n - i,
                        height: r - a
                    }
            },
            createIcon: function(t, e, i) {
                var n = (e = it.extend({
                    rectHover: !0
                }, e)).style = {
                    strokeNoScale: !0
                };
                if (i = i || {
                    x: -1,
                    y: -1,
                    width: 2,
                    height: 2
                },
                t)
                    return 0 === t.indexOf("image://") ? (n.image = t.slice(8),
                    it.defaults(n, i),
                    new _n(e)) : fs(t.replace("path://", ""), e, i, "center")
            }
        }
          , Hs = ["textStyle", "color"]
          , Ws = {
            getTextColor: function(t) {
                var e = this.ecModel;
                return this.getShallow("color") || (!t && e ? e.get(Hs) : null)
            },
            getFont: function() {
                return Fs.getFont({
                    fontStyle: this.getShallow("fontStyle"),
                    fontWeight: this.getShallow("fontWeight"),
                    fontSize: this.getShallow("fontSize"),
                    fontFamily: this.getShallow("fontFamily")
                }, this.ecModel)
            },
            getTextRect: function(t) {
                return Bi.getBoundingRect(t, this.getFont(), this.getShallow("align"), this.getShallow("verticalAlign") || this.getShallow("baseline"), this.getShallow("padding"), this.getShallow("lineHeight"), this.getShallow("rich"), this.getShallow("truncateText"))
            }
        }
          , Zs = da([["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"], ["textPosition"], ["textAlign"]])
          , Us = {
            getItemStyle: function(t, e) {
                var i = Zs(this, t, e)
                  , n = this.getBorderLineDash();
                return n && (i.lineDash = n),
                i
            },
            getBorderLineDash: function() {
                var t = this.get("borderType");
                return "solid" === t || null == t ? null : "dashed" === t ? [5, 5] : [1, 1]
            }
        }
          , Ys = aa.makeInner
          , js = ca.enableClassExtend
          , Xs = ca.enableClassCheck
          , qs = it.mixin
          , Ks = Ys();
        function $s(t, e, i) {
            this.parentModel = e,
            this.ecModel = i,
            this.option = t
        }
        function Js(t, e, i) {
            for (var n = 0; n < e.length && (!e[n] || null != (t = t && "object" == typeof t ? t[e[n]] : null)); n++)
                ;
            return null == t && i && (t = i.get(e)),
            t
        }
        function Qs(t, e) {
            var i = Ks(t).getParent;
            return i ? i.call(t, e) : t.parentModel
        }
        $s.prototype = {
            constructor: $s,
            init: null,
            mergeOption: function(t) {
                it.merge(this.option, t, !0)
            },
            get: function(t, e) {
                return null == t ? this.option : Js(this.option, this.parsePath(t), !e && Qs(this, t))
            },
            getShallow: function(t, e) {
                var i = this.option
                  , n = null == i ? i : i[t]
                  , a = !e && Qs(this, t);
                return null == n && a && (n = a.getShallow(t)),
                n
            },
            getModel: function(t, e) {
                var i;
                return new $s(null == t ? this.option : Js(this.option, t = this.parsePath(t)),e = e || (i = Qs(this, t)) && i.getModel(t),this.ecModel)
            },
            isEmpty: function() {
                return null == this.option
            },
            restoreData: function() {},
            clone: function() {
                return new this.constructor(it.clone(this.option))
            },
            setReadOnly: function(t) {},
            parsePath: function(t) {
                return "string" == typeof t && (t = t.split(".")),
                t
            },
            customizeGetParent: function(t) {
                Ks(this).getParent = t
            },
            isAnimationEnabled: function() {
                if (!et.node) {
                    if (null != this.option.animation)
                        return !!this.option.animation;
                    if (this.parentModel)
                        return this.parentModel.isAnimationEnabled()
                }
            }
        },
        js($s),
        Xs($s),
        qs($s, fa),
        qs($s, ma),
        qs($s, Ws),
        qs($s, Us);
        var tl = $s
          , el = ca.parseClassType
          , il = 0;
        var nl = {
            getUID: function(t) {
                return [t || "", il++, Math.random().toFixed(5)].join("_")
            },
            enableSubTypeDefaulter: function(a) {
                var r = {};
                return a.registerSubTypeDefaulter = function(t, e) {
                    t = el(t),
                    r[t.main] = e
                }
                ,
                a.determineSubType = function(t, e) {
                    var i = e.type;
                    if (!i) {
                        var n = el(t).main;
                        a.hasSubTypes(t) && r[n] && (i = r[n](e))
                    }
                    return i
                }
                ,
                a
            },
            enableTopologicalTravel: function(t, p) {
                function f(t, e) {
                    return t[e] || (t[e] = {
                        predecessor: [],
                        successor: []
                    }),
                    t[e]
                }
                t.topologicalTravel = function(t, e, i, n) {
                    if (t.length) {
                        var a = function(e) {
                            var a = {}
                              , r = [];
                            return it.each(e, function(i) {
                                var n = f(a, i)
                                  , t = function(t, e) {
                                    var i = [];
                                    return it.each(t, function(t) {
                                        0 <= it.indexOf(e, t) && i.push(t)
                                    }),
                                    i
                                }(n.originalDeps = p(i), e);
                                n.entryCount = t.length,
                                0 === n.entryCount && r.push(i),
                                it.each(t, function(t) {
                                    it.indexOf(n.predecessor, t) < 0 && n.predecessor.push(t);
                                    var e = f(a, t);
                                    it.indexOf(e.successor, t) < 0 && e.successor.push(i)
                                })
                            }),
                            {
                                graph: a,
                                noEntryList: r
                            }
                        }(e)
                          , r = a.graph
                          , o = a.noEntryList
                          , s = {};
                        for (it.each(t, function(t) {
                            s[t] = !0
                        }); o.length; ) {
                            var l = o.pop()
                              , u = r[l]
                              , h = !!s[l];
                            h && (i.call(n, l, u.originalDeps.slice()),
                            delete s[l]),
                            it.each(u.successor, h ? d : c)
                        }
                        it.each(s, function() {
                            throw new Error("Circle dependency may exists")
                        })
                    }
                    function c(t) {
                        r[t].entryCount--,
                        0 === r[t].entryCount && o.push(t)
                    }
                    function d(t) {
                        s[t] = !0,
                        c(t)
                    }
                }
            }
        };
        var al = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d\d)(?::(\d\d)(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
        function rl(t) {
            return Math.floor(Math.log(t) / Math.LN10)
        }
        var ol = {
            linearMap: function(t, e, i, n) {
                var a = e[1] - e[0]
                  , r = i[1] - i[0];
                if (0 == a)
                    return 0 == r ? i[0] : (i[0] + i[1]) / 2;
                if (n)
                    if (0 < a) {
                        if (t <= e[0])
                            return i[0];
                        if (t >= e[1])
                            return i[1]
                    } else {
                        if (t >= e[0])
                            return i[0];
                        if (t <= e[1])
                            return i[1]
                    }
                else {
                    if (t === e[0])
                        return i[0];
                    if (t === e[1])
                        return i[1]
                }
                return (t - e[0]) / a * r + i[0]
            },
            parsePercent: function(t, e) {
                switch (t) {
                case "center":
                case "middle":
                    t = "50%";
                    break;
                case "left":
                case "top":
                    t = "0%";
                    break;
                case "right":
                case "bottom":
                    t = "100%"
                }
                return "string" == typeof t ? function(t) {
                    return t.replace(/^\s+/, "").replace(/\s+$/, "")
                }(t).match(/%$/) ? parseFloat(t) / 100 * e : parseFloat(t) : null == t ? NaN : +t
            },
            round: function(t, e, i) {
                return null == e && (e = 10),
                e = Math.min(Math.max(0, e), 20),
                t = (+t).toFixed(e),
                i ? t : +t
            },
            asc: function(t) {
                return t.sort(function(t, e) {
                    return t - e
                }),
                t
            },
            getPrecision: function(t) {
                if (t = +t,
                isNaN(t))
                    return 0;
                for (var e = 1, i = 0; Math.round(t * e) / e !== t; )
                    e *= 10,
                    i++;
                return i
            },
            getPrecisionSafe: function(t) {
                var e = t.toString()
                  , i = e.indexOf("e");
                if (0 < i) {
                    var n = +e.slice(i + 1);
                    return n < 0 ? -n : 0
                }
                var a = e.indexOf(".");
                return a < 0 ? 0 : e.length - 1 - a
            },
            getPixelPrecision: function(t, e) {
                var i = Math.log
                  , n = Math.LN10
                  , a = Math.floor(i(t[1] - t[0]) / n)
                  , r = Math.round(i(Math.abs(e[1] - e[0])) / n)
                  , o = Math.min(Math.max(-a + r, 0), 20);
                return isFinite(o) ? o : 20
            },
            getPercentWithPrecision: function(t, e, i) {
                if (!t[e])
                    return 0;
                var n = it.reduce(t, function(t, e) {
                    return t + (isNaN(e) ? 0 : e)
                }, 0);
                if (0 === n)
                    return 0;
                for (var a = Math.pow(10, i), r = it.map(t, function(t) {
                    return (isNaN(t) ? 0 : t) / n * a * 100
                }), o = 100 * a, s = it.map(r, function(t) {
                    return Math.floor(t)
                }), l = it.reduce(s, function(t, e) {
                    return t + e
                }, 0), u = it.map(r, function(t, e) {
                    return t - s[e]
                }); l < o; ) {
                    for (var h = Number.NEGATIVE_INFINITY, c = null, d = 0, p = u.length; d < p; ++d)
                        u[d] > h && (h = u[d],
                        c = d);
                    ++s[c],
                    u[c] = 0,
                    ++l
                }
                return s[e] / a
            },
            MAX_SAFE_INTEGER: 9007199254740991,
            remRadian: function(t) {
                var e = 2 * Math.PI;
                return (t % e + e) % e
            },
            isRadianAroundZero: function(t) {
                return -1e-4 < t && t < 1e-4
            },
            parseDate: function(t) {
                if (t instanceof Date)
                    return t;
                if ("string" != typeof t)
                    return null == t ? new Date(NaN) : new Date(Math.round(t));
                var e = al.exec(t);
                if (!e)
                    return new Date(NaN);
                if (e[8]) {
                    var i = +e[4] || 0;
                    return "Z" !== e[8].toUpperCase() && (i -= e[8].slice(0, 3)),
                    new Date(Date.UTC(+e[1], +(e[2] || 1) - 1, +e[3] || 1, i, +(e[5] || 0), +e[6] || 0, +e[7] || 0))
                }
                return new Date(+e[1],+(e[2] || 1) - 1,+e[3] || 1,+e[4] || 0,+(e[5] || 0),+e[6] || 0,+e[7] || 0)
            },
            quantity: function(t) {
                return Math.pow(10, rl(t))
            },
            nice: function(t, e) {
                var i = rl(t)
                  , n = Math.pow(10, i)
                  , a = t / n;
                return t = (e ? a < 1.5 ? 1 : a < 2.5 ? 2 : a < 4 ? 3 : a < 7 ? 5 : 10 : a < 1 ? 1 : a < 2 ? 2 : a < 3 ? 3 : a < 5 ? 5 : 10) * n,
                -20 <= i ? +t.toFixed(i < 0 ? -i : 0) : t
            },
            quantile: function(t, e) {
                var i = (t.length - 1) * e + 1
                  , n = Math.floor(i)
                  , a = +t[n - 1]
                  , r = i - n;
                return r ? a + r * (t[n] - a) : a
            },
            reformIntervals: function(t) {
                t.sort(function(t, e) {
                    return function t(e, i, n) {
                        return e.interval[n] < i.interval[n] || e.interval[n] === i.interval[n] && (e.close[n] - i.close[n] == (n ? -1 : 1) || !n && t(e, i, 1))
                    }(t, e, 0) ? -1 : 1
                });
                for (var e = -1 / 0, i = 1, n = 0; n < t.length; ) {
                    for (var a = t[n].interval, r = t[n].close, o = 0; o < 2; o++)
                        a[o] <= e && (a[o] = e,
                        r[o] = o ? 1 : 1 - i),
                        e = a[o],
                        i = r[o];
                    a[0] === a[1] && r[0] * r[1] != 1 ? t.splice(n, 1) : n++
                }
                return t
            },
            isNumeric: function(t) {
                return 0 <= t - parseFloat(t)
            }
        };
        var sl = it.normalizeCssArray
          , ll = /([&<>"'])/g
          , ul = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;"
        };
        function hl(t) {
            return null == t ? "" : (t + "").replace(ll, function(t, e) {
                return ul[e]
            })
        }
        function cl(t, e) {
            return "{" + t + (null == e ? "" : e) + "}"
        }
        var dl = ["a", "b", "c", "d", "e", "f", "g"];
        function pl(t, e) {
            return "0000".substr(0, e - (t += "").length) + t
        }
        var fl = {
            addCommas: function(t) {
                return isNaN(t) ? "-" : (t = (t + "").split("."))[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (1 < t.length ? "." + t[1] : "")
            },
            toCamelCase: function(t, e) {
                return t = (t || "").toLowerCase().replace(/-(.)/g, function(t, e) {
                    return e.toUpperCase()
                }),
                e && t && (t = t.charAt(0).toUpperCase() + t.slice(1)),
                t
            },
            normalizeCssArray: sl,
            encodeHTML: hl,
            formatTpl: function(t, e, i) {
                it.isArray(e) || (e = [e]);
                var n = e.length;
                if (!n)
                    return "";
                for (var a = e[0].$vars || [], r = 0; r < a.length; r++) {
                    var o = dl[r];
                    t = t.replace(cl(o), cl(o, 0))
                }
                for (var s = 0; s < n; s++)
                    for (var l = 0; l < a.length; l++) {
                        var u = e[s][a[l]];
                        t = t.replace(cl(dl[l], s), i ? hl(u) : u)
                    }
                return t
            },
            formatTplSimple: function(i, t, n) {
                return it.each(t, function(t, e) {
                    i = i.replace("{" + e + "}", n ? hl(t) : t)
                }),
                i
            },
            getTooltipMarker: function(t, e) {
                var i = (t = it.isString(t) ? {
                    color: t,
                    extraCssText: e
                } : t || {}).color
                  , n = t.type
                  , a = (e = t.extraCssText,
                t.renderMode || "html")
                  , r = t.markerId || "X";
                return i ? "html" === a ? "subItem" === n ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + hl(i) + ";" + (e || "") + '"></span>' : '<span style="display:inline-block;margin-right:5px;border-radius:10px;width:10px;height:10px;background-color:' + hl(i) + ";" + (e || "") + '"></span>' : {
                    renderMode: a,
                    content: "{marker" + r + "|}  ",
                    style: {
                        color: i
                    }
                } : ""
            },
            formatTime: function(t, e, i) {
                "week" !== t && "month" !== t && "quarter" !== t && "half-year" !== t && "year" !== t || (t = "MM-dd\nyyyy");
                var n = ol.parseDate(e)
                  , a = i ? "UTC" : ""
                  , r = n["get" + a + "FullYear"]()
                  , o = n["get" + a + "Month"]() + 1
                  , s = n["get" + a + "Date"]()
                  , l = n["get" + a + "Hours"]()
                  , u = n["get" + a + "Minutes"]()
                  , h = n["get" + a + "Seconds"]()
                  , c = n["get" + a + "Milliseconds"]();
                return t = t.replace("MM", pl(o, 2)).replace("M", o).replace("yyyy", r).replace("yy", r % 100).replace("dd", pl(s, 2)).replace("d", s).replace("hh", pl(l, 2)).replace("h", l).replace("mm", pl(u, 2)).replace("m", u).replace("ss", pl(h, 2)).replace("s", h).replace("SSS", pl(c, 3))
            },
            capitalFirst: function(t) {
                return t ? t.charAt(0).toUpperCase() + t.substr(1) : t
            },
            truncateText: Bi.truncateText,
            getTextBoundingRect: function(t) {
                return Bi.getBoundingRect(t.text, t.font, t.textAlign, t.textVerticalAlign, t.textPadding, t.textLineHeight, t.rich, t.truncate)
            },
            getTextRect: function(t, e, i, n, a, r, o, s) {
                return Bi.getBoundingRect(t, e, i, n, a, s, r, o)
            }
        }
          , gl = ol.parsePercent
          , ml = it.each
          , vl = ["left", "right", "top", "bottom", "width", "height"]
          , yl = [["width", "left", "right"], ["height", "top", "bottom"]];
        function xl(h, c, d, p, f) {
            var g = 0
              , m = 0;
            null == p && (p = 1 / 0),
            null == f && (f = 1 / 0);
            var v = 0;
            c.eachChild(function(t, e) {
                var i, n, a = t.position, r = t.getBoundingRect(), o = c.childAt(e + 1), s = o && o.getBoundingRect();
                if ("horizontal" === h) {
                    var l = r.width + (s ? -s.x + r.x : 0);
                    v = p < (i = g + l) || t.newline ? (g = 0,
                    i = l,
                    m += v + d,
                    r.height) : Math.max(v, r.height)
                } else {
                    var u = r.height + (s ? -s.y + r.y : 0);
                    v = f < (n = m + u) || t.newline ? (g += v + d,
                    m = 0,
                    n = u,
                    r.width) : Math.max(v, r.width)
                }
                t.newline || (a[0] = g,
                a[1] = m,
                "horizontal" === h ? g = i + d : m = n + d)
            })
        }
        var _l = xl
          , bl = it.curry(xl, "vertical")
          , wl = it.curry(xl, "horizontal");
        function Sl(t, e, i) {
            i = fl.normalizeCssArray(i || 0);
            var n = e.width
              , a = e.height
              , r = gl(t.left, n)
              , o = gl(t.top, a)
              , s = gl(t.right, n)
              , l = gl(t.bottom, a)
              , u = gl(t.width, n)
              , h = gl(t.height, a)
              , c = i[2] + i[0]
              , d = i[1] + i[3]
              , p = t.aspect;
            switch (isNaN(u) && (u = n - s - d - r),
            isNaN(h) && (h = a - l - c - o),
            null != p && (isNaN(u) && isNaN(h) && (n / a < p ? u = .8 * n : h = .8 * a),
            isNaN(u) && (u = p * h),
            isNaN(h) && (h = u / p)),
            isNaN(r) && (r = n - s - u - d),
            isNaN(o) && (o = a - l - h - c),
            t.left || t.right) {
            case "center":
                r = n / 2 - u / 2 - i[3];
                break;
            case "right":
                r = n - u - d
            }
            switch (t.top || t.bottom) {
            case "middle":
            case "center":
                o = a / 2 - h / 2 - i[0];
                break;
            case "bottom":
                o = a - h - c
            }
            r = r || 0,
            o = o || 0,
            isNaN(u) && (u = n - d - r - (s || 0)),
            isNaN(h) && (h = a - c - o - (l || 0));
            var f = new Oe(r + i[3],o + i[0],u,h);
            return f.margin = i,
            f
        }
        function Ml(e, i) {
            return i && e && ml(vl, function(t) {
                i.hasOwnProperty(t) && (e[t] = i[t])
            }),
            e
        }
        var Il = {
            LOCATION_PARAMS: vl,
            HV_NAMES: yl,
            box: _l,
            vbox: bl,
            hbox: wl,
            getAvailableSize: function(t, e, i) {
                var n = e.width
                  , a = e.height
                  , r = gl(t.x, n)
                  , o = gl(t.y, a)
                  , s = gl(t.x2, n)
                  , l = gl(t.y2, a);
                return (isNaN(r) || isNaN(parseFloat(t.x))) && (r = 0),
                (isNaN(s) || isNaN(parseFloat(t.x2))) && (s = n),
                (isNaN(o) || isNaN(parseFloat(t.y))) && (o = 0),
                (isNaN(l) || isNaN(parseFloat(t.y2))) && (l = a),
                i = fl.normalizeCssArray(i || 0),
                {
                    width: Math.max(s - r - i[1] - i[3], 0),
                    height: Math.max(l - o - i[0] - i[2], 0)
                }
            },
            getLayoutRect: Sl,
            positionElement: function(t, e, i, n, a) {
                var r = !a || !a.hv || a.hv[0]
                  , o = !a || !a.hv || a.hv[1]
                  , s = a && a.boundingMode || "all";
                if (r || o) {
                    var l;
                    if ("raw" === s)
                        l = "group" === t.type ? new Oe(0,0,+e.width || 0,+e.height || 0) : t.getBoundingRect();
                    else if (l = t.getBoundingRect(),
                    t.needLocalTransform()) {
                        var u = t.getLocalTransform();
                        (l = l.clone()).applyTransform(u)
                    }
                    e = Sl(it.defaults({
                        width: l.width,
                        height: l.height
                    }, e), i, n);
                    var h = t.position
                      , c = r ? e.x - l.x : 0
                      , d = o ? e.y - l.y : 0;
                    t.attr("position", "raw" === s ? [c, d] : [h[0] + c, h[1] + d])
                }
            },
            sizeCalculable: function(t, e) {
                return null != t[yl[e][0]] || null != t[yl[e][1]] && null != t[yl[e][2]]
            },
            mergeLayoutParam: function(l, u, t) {
                it.isObject(t) || (t = {});
                var h = t.ignoreSize;
                it.isArray(h) || (h = [h, h]);
                var e = n(yl[0], 0)
                  , i = n(yl[1], 1);
                function n(t, e) {
                    var i = {}
                      , n = 0
                      , a = {}
                      , r = 0;
                    if (ml(t, function(t) {
                        a[t] = l[t]
                    }),
                    ml(t, function(t) {
                        c(u, t) && (i[t] = a[t] = u[t]),
                        d(i, t) && n++,
                        d(a, t) && r++
                    }),
                    h[e])
                        return d(u, t[1]) ? a[t[2]] = null : d(u, t[2]) && (a[t[1]] = null),
                        a;
                    if (2 !== r && n) {
                        if (2 <= n)
                            return i;
                        for (var o = 0; o < t.length; o++) {
                            var s = t[o];
                            if (!c(i, s) && c(l, s)) {
                                i[s] = l[s];
                                break
                            }
                        }
                        return i
                    }
                    return a
                }
                function c(t, e) {
                    return t.hasOwnProperty(e)
                }
                function d(t, e) {
                    return null != t[e] && "auto" !== t[e]
                }
                function a(t, e, i) {
                    ml(t, function(t) {
                        e[t] = i[t]
                    })
                }
                a(yl[0], l, e),
                a(yl[1], l, i)
            },
            getLayoutParams: function(t) {
                return Ml({}, t)
            },
            copyLayoutParams: Ml
        }
          , Al = {
            getBoxLayoutParams: function() {
                return {
                    left: this.get("left"),
                    top: this.get("top"),
                    right: this.get("right"),
                    bottom: this.get("bottom"),
                    width: this.get("width"),
                    height: this.get("height")
                }
            }
        }
          , Tl = ca.enableClassManagement
          , Cl = ca.parseClassType
          , Dl = (0,
        aa.makeInner)()
          , Ll = tl.extend({
            type: "component",
            id: "",
            name: "",
            mainType: "",
            subType: "",
            componentIndex: 0,
            defaultOption: null,
            ecModel: null,
            dependentModels: [],
            uid: null,
            layoutMode: null,
            $constructor: function(t, e, i, n) {
                tl.call(this, t, e, i, n),
                this.uid = nl.getUID("ec_cpt_model")
            },
            init: function(t, e, i, n) {
                this.mergeDefaultAndTheme(t, i)
            },
            mergeDefaultAndTheme: function(t, e) {
                var i = this.layoutMode
                  , n = i ? Il.getLayoutParams(t) : {}
                  , a = e.getTheme();
                it.merge(t, a.get(this.mainType)),
                it.merge(t, this.getDefaultOption()),
                i && Il.mergeLayoutParam(t, n, i)
            },
            mergeOption: function(t, e) {
                it.merge(this.option, t, !0);
                var i = this.layoutMode;
                i && Il.mergeLayoutParam(this.option, t, i)
            },
            optionUpdated: function(t, e) {},
            getDefaultOption: function() {
                var t = Dl(this);
                if (!t.defaultOption) {
                    for (var e = [], i = this.constructor; i; ) {
                        var n = i.prototype.defaultOption;
                        n && e.push(n),
                        i = i.superClass
                    }
                    for (var a = {}, r = e.length - 1; 0 <= r; r--)
                        a = it.merge(a, e[r], !0);
                    t.defaultOption = a
                }
                return t.defaultOption
            },
            getReferringComponents: function(t) {
                return this.ecModel.queryComponents({
                    mainType: t,
                    index: this.get(t + "Index", !0),
                    id: this.get(t + "Id", !0)
                })
            }
        });
        Tl(Ll, {
            registerWhenExtend: !0
        }),
        nl.enableSubTypeDefaulter(Ll),
        nl.enableTopologicalTravel(Ll, function(t) {
            var e = [];
            it.each(Ll.getClassesByMainType(t), function(t) {
                e = e.concat(t.prototype.dependencies || [])
            }),
            e = it.map(e, function(t) {
                return Cl(t).main
            }),
            "dataset" !== t && it.indexOf(e, "dataset") <= 0 && e.unshift("dataset");
            return e
        }),
        it.mixin(Ll, Al);
        var Pl = Ll
          , kl = "";
        "undefined" != typeof navigator && (kl = navigator.platform || "");
        var Ol = {
            color: ["#c23531", "#2f4554", "#61a0a8", "#d48265", "#91c7ae", "#749f83", "#ca8622", "#bda29a", "#6e7074", "#546570", "#c4ccd3"],
            gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
            textStyle: {
                fontFamily: kl.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
                fontSize: 12,
                fontStyle: "normal",
                fontWeight: "normal"
            },
            blendMode: null,
            animation: "auto",
            animationDuration: 1e3,
            animationDurationUpdate: 300,
            animationEasing: "exponentialOut",
            animationEasingUpdate: "cubicOut",
            animationThreshold: 2e3,
            progressiveThreshold: 3e3,
            progressive: 400,
            hoverLayerThreshold: 3e3,
            useUTC: !1
        }
          , Rl = aa.makeInner
          , Nl = aa.normalizeToArray
          , El = Rl();
        var zl = {
            clearColorPalette: function() {
                El(this).colorIdx = 0,
                El(this).colorNameMap = {}
            },
            getColorFromPalette: function(t, e, i) {
                var n = El(e = e || this)
                  , a = n.colorIdx || 0
                  , r = n.colorNameMap = n.colorNameMap || {};
                if (r.hasOwnProperty(t))
                    return r[t];
                var o = Nl(this.get("color", !0))
                  , s = this.get("colorLayer", !0)
                  , l = null != i && s ? function(t, e) {
                    for (var i = t.length, n = 0; n < i; n++)
                        if (t[n].length > e)
                            return t[n];
                    return t[i - 1]
                }(s, i) : o;
                if ((l = l || o) && l.length) {
                    var u = l[a];
                    return t && (r[t] = u),
                    n.colorIdx = (a + 1) % l.length,
                    u
                }
            }
        }
          , Vl = it.createHashMap
          , Bl = it.each;
        var Gl = {
            cartesian2d: function(t, e, i, n) {
                var a = t.getReferringComponents("xAxis")[0]
                  , r = t.getReferringComponents("yAxis")[0];
                e.coordSysDims = ["x", "y"],
                i.set("x", a),
                i.set("y", r),
                Fl(a) && (n.set("x", a),
                e.firstCategoryDimIndex = 0),
                Fl(r) && (n.set("y", r),
                e.firstCategoryDimIndex = 1)
            },
            singleAxis: function(t, e, i, n) {
                var a = t.getReferringComponents("singleAxis")[0];
                e.coordSysDims = ["single"],
                i.set("single", a),
                Fl(a) && (n.set("single", a),
                e.firstCategoryDimIndex = 0)
            },
            polar: function(t, e, i, n) {
                var a = t.getReferringComponents("polar")[0]
                  , r = a.findAxisModel("radiusAxis")
                  , o = a.findAxisModel("angleAxis");
                e.coordSysDims = ["radius", "angle"],
                i.set("radius", r),
                i.set("angle", o),
                Fl(r) && (n.set("radius", r),
                e.firstCategoryDimIndex = 0),
                Fl(o) && (n.set("angle", o),
                e.firstCategoryDimIndex = 1)
            },
            geo: function(t, e, i, n) {
                e.coordSysDims = ["lng", "lat"]
            },
            parallel: function(t, a, r, o) {
                var s = t.ecModel
                  , e = s.getComponent("parallel", t.get("parallelIndex"))
                  , l = a.coordSysDims = e.dimensions.slice();
                Bl(e.parallelAxisIndex, function(t, e) {
                    var i = s.getComponent("parallelAxis", t)
                      , n = l[e];
                    r.set(n, i),
                    Fl(i) && null == a.firstCategoryDimIndex && (o.set(n, i),
                    a.firstCategoryDimIndex = e)
                })
            }
        };
        function Fl(t) {
            return "category" === t.get("type")
        }
        var Hl = {
            getCoordSysDefineBySeries: function(t) {
                var e = t.get("coordinateSystem")
                  , i = {
                    coordSysName: e,
                    coordSysDims: [],
                    axisMap: Vl(),
                    categoryAxisMap: Vl()
                }
                  , n = Gl[e];
                if (n)
                    return n(t, i, i.axisMap, i.categoryAxisMap),
                    i
            }
        }
          , Wl = {
            SOURCE_FORMAT_ORIGINAL: "original",
            SOURCE_FORMAT_ARRAY_ROWS: "arrayRows",
            SOURCE_FORMAT_OBJECT_ROWS: "objectRows",
            SOURCE_FORMAT_KEYED_COLUMNS: "keyedColumns",
            SOURCE_FORMAT_UNKNOWN: "unknown",
            SOURCE_FORMAT_TYPED_ARRAY: "typedArray",
            SERIES_LAYOUT_BY_COLUMN: "column",
            SERIES_LAYOUT_BY_ROW: "row"
        }
          , Zl = it.createHashMap
          , Ul = it.isTypedArray
          , Yl = ca.enableClassCheck
          , jl = Wl.SOURCE_FORMAT_ORIGINAL
          , Xl = Wl.SERIES_LAYOUT_BY_COLUMN
          , ql = Wl.SOURCE_FORMAT_UNKNOWN
          , Kl = Wl.SOURCE_FORMAT_TYPED_ARRAY
          , $l = Wl.SOURCE_FORMAT_KEYED_COLUMNS;
        function Jl(t) {
            this.fromDataset = t.fromDataset,
            this.data = t.data || (t.sourceFormat === $l ? {} : []),
            this.sourceFormat = t.sourceFormat || ql,
            this.seriesLayoutBy = t.seriesLayoutBy || Xl,
            this.dimensionsDefine = t.dimensionsDefine,
            this.encodeDefine = t.encodeDefine && Zl(t.encodeDefine),
            this.startIndex = t.startIndex || 0,
            this.dimensionsDetectCount = t.dimensionsDetectCount
        }
        Jl.seriesDataToSource = function(t) {
            return new Jl({
                data: t,
                sourceFormat: Ul(t) ? Kl : jl,
                fromDataset: !1
            })
        }
        ,
        Yl(Jl);
        var Ql = Jl
          , tu = aa.makeInner
          , eu = aa.getDataItemValue
          , iu = Hl.getCoordSysDefineBySeries
          , nu = it.createHashMap
          , au = it.each
          , ru = it.map
          , ou = it.isArray
          , su = it.isString
          , lu = it.isObject
          , uu = it.isTypedArray
          , hu = it.isArrayLike
          , cu = it.extend
          , du = Wl.SOURCE_FORMAT_ORIGINAL
          , pu = Wl.SOURCE_FORMAT_ARRAY_ROWS
          , fu = Wl.SOURCE_FORMAT_OBJECT_ROWS
          , gu = Wl.SOURCE_FORMAT_KEYED_COLUMNS
          , mu = Wl.SOURCE_FORMAT_UNKNOWN
          , vu = Wl.SOURCE_FORMAT_TYPED_ARRAY
          , yu = Wl.SERIES_LAYOUT_BY_ROW
          , xu = tu();
        function _u(t) {
            if (t) {
                var n = nu();
                return ru(t, function(t, e) {
                    if (null == (t = cu({}, lu(t) ? t : {
                        name: t
                    })).name)
                        return t;
                    t.name += "",
                    null == t.displayName && (t.displayName = t.name);
                    var i = n.get(t.name);
                    return i ? t.name += "-" + i.count++ : n.set(t.name, {
                        count: 1
                    }),
                    t
                })
            }
        }
        function bu(t, e, i, n) {
            if (null == n && (n = 1 / 0),
            e === yu)
                for (var a = 0; a < i.length && a < n; a++)
                    t(i[a] ? i[a][0] : null, a);
            else {
                var r = i[0] || [];
                for (a = 0; a < r.length && a < n; a++)
                    t(r[a], a)
            }
        }
        function wu(t, e, i, n, a, r) {
            var o, s;
            if (uu(t))
                return !1;
            if (n && (s = n[r],
            s = lu(s) ? s.name : s),
            e === pu)
                if (i === yu) {
                    for (var l = t[r], u = 0; u < (l || []).length && u < 5; u++)
                        if (null != (o = p(l[a + u])))
                            return o
                } else
                    for (u = 0; u < t.length && u < 5; u++) {
                        var h = t[a + u];
                        if (h && null != (o = p(h[r])))
                            return o
                    }
            else if (e === fu) {
                if (!s)
                    return;
                for (u = 0; u < t.length && u < 5; u++) {
                    if ((c = t[u]) && null != (o = p(c[s])))
                        return o
                }
            } else if (e === gu) {
                if (!s)
                    return;
                if (!(l = t[s]) || uu(l))
                    return !1;
                for (u = 0; u < l.length && u < 5; u++)
                    if (null != (o = p(l[u])))
                        return o
            } else if (e === du)
                for (u = 0; u < t.length && u < 5; u++) {
                    var c = t[u]
                      , d = eu(c);
                    if (!ou(d))
                        return !1;
                    if (null != (o = p(d[r])))
                        return o
                }
            function p(t) {
                return (null == t || !isFinite(t) || "" === t) && (!(!su(t) || "-" === t) || void 0)
            }
            return !1
        }
        var Su = {
            detectSourceFormat: function(t) {
                var e = t.option.source
                  , i = mu;
                if (uu(e))
                    i = vu;
                else if (ou(e)) {
                    0 === e.length && (i = pu);
                    for (var n = 0, a = e.length; n < a; n++) {
                        var r = e[n];
                        if (null != r) {
                            if (ou(r)) {
                                i = pu;
                                break
                            }
                            if (lu(r)) {
                                i = fu;
                                break
                            }
                        }
                    }
                } else if (lu(e)) {
                    for (var o in e)
                        if (e.hasOwnProperty(o) && hu(e[o])) {
                            i = gu;
                            break
                        }
                } else if (null != e)
                    throw new Error("Invalid data");
                xu(t).sourceFormat = i
            },
            getSource: function(t) {
                return xu(t).source
            },
            resetSourceDefaulter: function(t) {
                xu(t).datasetMap = nu()
            },
            prepareSource: function(t) {
                var e = t.option
                  , i = e.data
                  , n = uu(i) ? vu : du
                  , a = !1
                  , r = e.seriesLayoutBy
                  , o = e.sourceHeader
                  , s = e.dimensions
                  , l = function(t) {
                    var e = t.option;
                    if (!e.data)
                        return t.ecModel.getComponent("dataset", e.datasetIndex || 0)
                }(t);
                if (l) {
                    var u = l.option;
                    i = u.source,
                    n = xu(l).sourceFormat,
                    a = !0,
                    r = r || u.seriesLayoutBy,
                    null == o && (o = u.sourceHeader),
                    s = s || u.dimensions
                }
                var h = function(t, e, i, n, a) {
                    if (!t)
                        return {
                            dimensionsDefine: _u(a)
                        };
                    var r, o, s, l;
                    if (e === pu)
                        "auto" === n || null == n ? bu(function(t) {
                            null != t && "-" !== t && (su(t) ? null == o && (o = 1) : o = 0)
                        }, i, t, 10) : o = n ? 1 : 0,
                        a || 1 !== o || (a = [],
                        bu(function(t, e) {
                            a[e] = null != t ? t : ""
                        }, i, t)),
                        r = a ? a.length : i === yu ? t.length : t[0] ? t[0].length : null;
                    else if (e === fu)
                        a || (a = function(t) {
                            var e, i = 0;
                            for (; i < t.length && !(e = t[i++]); )
                                ;
                            if (e) {
                                var n = [];
                                return au(e, function(t, e) {
                                    n.push(e)
                                }),
                                n
                            }
                        }(t),
                        s = !0);
                    else if (e === gu)
                        a || (a = [],
                        s = !0,
                        au(t, function(t, e) {
                            a.push(e)
                        }));
                    else if (e === du) {
                        var u = eu(t[0]);
                        r = ou(u) && u.length || 1
                    }
                    s && au(a, function(t, e) {
                        "name" === (lu(t) ? t.name : t) && (l = e)
                    });
                    return {
                        startIndex: o,
                        dimensionsDefine: _u(a),
                        dimensionsDetectCount: r,
                        potentialNameDimIndex: l
                    }
                }(i, n, r, o, s)
                  , c = e.encode;
                !c && l && (c = function(t, e, i, n, a, r) {
                    var o = iu(t)
                      , s = {}
                      , l = []
                      , u = []
                      , h = t.subType
                      , c = nu(["pie", "map", "funnel"])
                      , d = nu(["line", "bar", "pictorialBar", "scatter", "effectScatter", "candlestick", "boxplot"]);
                    if (o && null != d.get(h)) {
                        var p = t.ecModel
                          , f = xu(p).datasetMap
                          , g = e.uid + "_" + a
                          , m = f.get(g) || f.set(g, {
                            categoryWayDim: 1,
                            valueWayDim: 0
                        });
                        au(o.coordSysDims, function(t) {
                            if (null == o.firstCategoryDimIndex) {
                                var e = m.valueWayDim++;
                                s[t] = e,
                                u.push(e)
                            } else if (o.categoryAxisMap.get(t))
                                s[t] = 0,
                                l.push(0);
                            else {
                                e = m.categoryWayDim++;
                                s[t] = e,
                                u.push(e)
                            }
                        })
                    } else if (null != c.get(h)) {
                        for (var v, y = 0; y < 5 && null == v; y++)
                            wu(i, n, a, r.dimensionsDefine, r.startIndex, y) || (v = y);
                        if (null != v) {
                            s.value = v;
                            var x = r.potentialNameDimIndex || Math.max(v - 1, 0);
                            u.push(x),
                            l.push(x)
                        }
                    }
                    return l.length && (s.itemName = l),
                    u.length && (s.seriesName = u),
                    s
                }(t, l, i, n, r, h)),
                xu(t).source = new Ql({
                    data: i,
                    fromDataset: a,
                    seriesLayoutBy: r,
                    sourceFormat: n,
                    dimensionsDefine: h.dimensionsDefine,
                    startIndex: h.startIndex,
                    dimensionsDetectCount: h.dimensionsDetectCount,
                    encodeDefine: c
                })
            },
            guessOrdinal: function(t, e) {
                return wu(t.data, t.sourceFormat, t.seriesLayoutBy, t.dimensionsDefine, t.startIndex, e)
            }
        }
          , Mu = it.each
          , Iu = it.filter
          , Au = it.map
          , Tu = it.isArray
          , Cu = it.indexOf
          , Du = it.isObject
          , Lu = it.isString
          , Pu = it.createHashMap
          , ku = it.assert
          , Ou = it.clone
          , Ru = it.merge
          , Nu = it.extend
          , Eu = it.mixin
          , zu = Su.resetSourceDefaulter
          , Vu = "\0_ec_inner"
          , Bu = tl.extend({
            init: function(t, e, i, n) {
                i = i || {},
                this.option = null,
                this._theme = new tl(i),
                this._optionManager = n
            },
            setOption: function(t, e) {
                ku(!(Vu in t), "please use chart.getOption()"),
                this._optionManager.setOption(t, e),
                this.resetOption(null)
            },
            resetOption: function(t) {
                var e = !1
                  , i = this._optionManager;
                if (!t || "recreate" === t) {
                    var n = i.mountOption("recreate" === t);
                    this.option && "recreate" !== t ? (this.restoreData(),
                    this.mergeOption(n)) : function(t) {
                        t = t,
                        this.option = {},
                        this.option[Vu] = 1,
                        this._componentsMap = Pu({
                            series: []
                        }),
                        this._seriesIndices,
                        this._seriesIndicesMap,
                        function(i, t) {
                            var n = i.color && !i.colorLayer;
                            Mu(t, function(t, e) {
                                "colorLayer" === e && n || Pl.hasClass(e) || ("object" == typeof t ? i[e] = i[e] ? Ru(i[e], t, !1) : Ou(t) : null == i[e] && (i[e] = t))
                            })
                        }(t, this._theme.option),
                        Ru(t, Ol, !1),
                        this.mergeOption(t)
                    }
                    .call(this, n),
                    e = !0
                }
                if ("timeline" !== t && "media" !== t || this.restoreData(),
                !t || "recreate" === t || "timeline" === t) {
                    var a = i.getTimelineOption(this);
                    a && (this.mergeOption(a),
                    e = !0)
                }
                if (!t || "recreate" === t || "media" === t) {
                    var r = i.getMediaOption(this, this._api);
                    r.length && Mu(r, function(t) {
                        this.mergeOption(t, e = !0)
                    }, this)
                }
                return e
            },
            mergeOption: function(n) {
                var l = this.option
                  , u = this._componentsMap
                  , i = [];
                zu(this),
                Mu(n, function(t, e) {
                    null != t && (Pl.hasClass(e) ? e && i.push(e) : l[e] = null == l[e] ? Ou(t) : Ru(l[e], t, !0))
                }),
                Pl.topologicalTravel(i, Pl.getAllClassMainTypes(), function(o, t) {
                    var e = aa.normalizeToArray(n[o])
                      , i = aa.mappingToExists(u.get(o), e);
                    aa.makeIdAndName(i),
                    Mu(i, function(t, e) {
                        var i = t.option;
                        Du(i) && (t.keyInfo.mainType = o,
                        t.keyInfo.subType = function(t, e, i) {
                            return e.type ? e.type : i ? i.subType : Pl.determineSubType(t, e)
                        }(o, i, t.exist))
                    });
                    var s = function(e, t) {
                        Tu(t) || (t = t ? [t] : []);
                        var i = {};
                        return Mu(t, function(t) {
                            i[t] = (e.get(t) || []).slice()
                        }),
                        i
                    }(u, t);
                    l[o] = [],
                    u.set(o, []),
                    Mu(i, function(t, e) {
                        var i = t.exist
                          , n = t.option;
                        if (ku(Du(n) || i, "Empty component definition"),
                        n) {
                            var a = Pl.getClass(o, t.keyInfo.subType, !0);
                            if (i && i instanceof a)
                                i.name = t.keyInfo.name,
                                i.mergeOption(n, this),
                                i.optionUpdated(n, !1);
                            else {
                                var r = Nu({
                                    dependentModels: s,
                                    componentIndex: e
                                }, t.keyInfo);
                                i = new a(n,this,this,r),
                                Nu(i, r),
                                i.init(n, this, this, r),
                                i.optionUpdated(null, !0)
                            }
                        } else
                            i.mergeOption({}, this),
                            i.optionUpdated({}, !1);
                        u.get(o)[e] = i,
                        l[o][e] = i.option
                    }, this),
                    "series" === o && Gu(this, u.get("series"))
                }, this),
                this._seriesIndicesMap = Pu(this._seriesIndices = this._seriesIndices || [])
            },
            getOption: function() {
                var n = Ou(this.option);
                return Mu(n, function(t, e) {
                    if (Pl.hasClass(e)) {
                        for (var i = (t = aa.normalizeToArray(t)).length - 1; 0 <= i; i--)
                            aa.isIdInner(t[i]) && t.splice(i, 1);
                        n[e] = t
                    }
                }),
                delete n[Vu],
                n
            },
            getTheme: function() {
                return this._theme
            },
            getComponent: function(t, e) {
                var i = this._componentsMap.get(t);
                if (i)
                    return i[e || 0]
            },
            queryComponents: function(t) {
                var e = t.mainType;
                if (!e)
                    return [];
                var i, n = t.index, a = t.id, r = t.name, o = this._componentsMap.get(e);
                if (!o || !o.length)
                    return [];
                if (null != n)
                    Tu(n) || (n = [n]),
                    i = Iu(Au(n, function(t) {
                        return o[t]
                    }), function(t) {
                        return !!t
                    });
                else if (null != a) {
                    var s = Tu(a);
                    i = Iu(o, function(t) {
                        return s && 0 <= Cu(a, t.id) || !s && t.id === a
                    })
                } else if (null != r) {
                    var l = Tu(r);
                    i = Iu(o, function(t) {
                        return l && 0 <= Cu(r, t.name) || !l && t.name === r
                    })
                } else
                    i = o.slice();
                return Fu(i, t)
            },
            findComponents: function(t) {
                var e, i, n, a, r, o = t.query, s = t.mainType, l = (i = s + "Index",
                n = s + "Id",
                a = s + "Name",
                !(e = o) || null == e[i] && null == e[n] && null == e[a] ? null : {
                    mainType: s,
                    index: e[i],
                    id: e[n],
                    name: e[a]
                }), u = l ? this.queryComponents(l) : this._componentsMap.get(s);
                return r = Fu(u, t),
                t.filter ? Iu(r, t.filter) : r
            },
            eachComponent: function(t, n, a) {
                var e = this._componentsMap;
                if ("function" == typeof t)
                    a = n,
                    n = t,
                    e.each(function(t, i) {
                        Mu(t, function(t, e) {
                            n.call(a, i, t, e)
                        })
                    });
                else if (Lu(t))
                    Mu(e.get(t), n, a);
                else if (Du(t)) {
                    var i = this.findComponents(t);
                    Mu(i, n, a)
                }
            },
            getSeriesByName: function(e) {
                var t = this._componentsMap.get("series");
                return Iu(t, function(t) {
                    return t.name === e
                })
            },
            getSeriesByIndex: function(t) {
                return this._componentsMap.get("series")[t]
            },
            getSeriesByType: function(e) {
                var t = this._componentsMap.get("series");
                return Iu(t, function(t) {
                    return t.subType === e
                })
            },
            getSeries: function() {
                return this._componentsMap.get("series").slice()
            },
            getSeriesCount: function() {
                return this._componentsMap.get("series").length
            },
            eachSeries: function(i, n) {
                Mu(this._seriesIndices, function(t) {
                    var e = this._componentsMap.get("series")[t];
                    i.call(n, e, t)
                }, this)
            },
            eachRawSeries: function(t, e) {
                Mu(this._componentsMap.get("series"), t, e)
            },
            eachSeriesByType: function(i, n, a) {
                Mu(this._seriesIndices, function(t) {
                    var e = this._componentsMap.get("series")[t];
                    e.subType === i && n.call(a, e, t)
                }, this)
            },
            eachRawSeriesByType: function(t, e, i) {
                return Mu(this.getSeriesByType(t), e, i)
            },
            isSeriesFiltered: function(t) {
                return null == this._seriesIndicesMap.get(t.componentIndex)
            },
            getCurrentSeriesIndices: function() {
                return (this._seriesIndices || []).slice()
            },
            filterSeries: function(t, e) {
                var i = Iu(this._componentsMap.get("series"), t, e);
                Gu(this, i)
            },
            restoreData: function(i) {
                var n = this._componentsMap;
                Gu(this, n.get("series"));
                var a = [];
                n.each(function(t, e) {
                    a.push(e)
                }),
                Pl.topologicalTravel(a, Pl.getAllClassMainTypes(), function(e, t) {
                    Mu(n.get(e), function(t) {
                        "series" === e && function(t, e) {
                            if (e) {
                                var i = e.seiresIndex
                                  , n = e.seriesId
                                  , a = e.seriesName;
                                return null != i && t.componentIndex !== i || null != n && t.id !== n || null != a && t.name !== a
                            }
                        }(t, i) || t.restoreData()
                    })
                })
            }
        });
        function Gu(t, e) {
            t._seriesIndicesMap = Pu(t._seriesIndices = Au(e, function(t) {
                return t.componentIndex
            }) || [])
        }
        function Fu(t, e) {
            return e.hasOwnProperty("subType") ? Iu(t, function(t) {
                return t.subType === e.subType
            }) : t
        }
        Eu(Bu, zl);
        var Hu = Bu
          , Wu = ["getDom", "getZr", "getWidth", "getHeight", "getDevicePixelRatio", "dispatchAction", "isDisposed", "on", "off", "getDataURL", "getConnectedDataURL", "getModel", "getOption", "getViewOfComponentModel", "getViewOfSeriesModel"];
        var Zu = function(e) {
            it.each(Wu, function(t) {
                this[t] = it.bind(e[t], e)
            }, this)
        }
          , Uu = {};
        function Yu() {
            this._coordinateSystems = []
        }
        Yu.prototype = {
            constructor: Yu,
            create: function(n, a) {
                var r = [];
                it.each(Uu, function(t, e) {
                    var i = t.create(n, a);
                    r = r.concat(i || [])
                }),
                this._coordinateSystems = r
            },
            update: function(e, i) {
                it.each(this._coordinateSystems, function(t) {
                    t.update && t.update(e, i)
                })
            },
            getCoordinateSystems: function() {
                return this._coordinateSystems.slice()
            }
        },
        Yu.register = function(t, e) {
            Uu[t] = e
        }
        ,
        Yu.get = function(t) {
            return Uu[t]
        }
        ;
        var ju = Yu
          , Xu = it.each
          , qu = it.clone
          , Ku = it.map
          , $u = it.merge
          , Ju = /^(min|max)?(.+)$/;
        function Qu(t) {
            this._api = t,
            this._timelineOptions = [],
            this._mediaList = [],
            this._mediaDefault,
            this._currentMediaIndices = [],
            this._optionBackup,
            this._newBaseOption
        }
        function th(t, e, i) {
            var r = {
                width: e,
                height: i,
                aspectratio: e / i
            }
              , o = !0;
            return it.each(t, function(t, e) {
                var i = e.match(Ju);
                if (i && i[1] && i[2]) {
                    var n = i[1]
                      , a = i[2].toLowerCase();
                    !function(t, e, i) {
                        return "min" === i ? e <= t : "max" === i ? t <= e : t === e
                    }(r[a], t, n) && (o = !1)
                }
            }),
            o
        }
        Qu.prototype = {
            constructor: Qu,
            setOption: function(t, e) {
                t && it.each(aa.normalizeToArray(t.series), function(t) {
                    t && t.data && it.isTypedArray(t.data) && it.setAsPrimitive(t.data)
                }),
                t = qu(t, !0);
                var i = this._optionBackup
                  , n = function(t, i, n) {
                    var e, a, r = [], o = [], s = t.timeline;
                    t.baseOption && (a = t.baseOption);
                    (s || t.options) && (a = a || {},
                    r = (t.options || []).slice());
                    if (t.media) {
                        a = a || {};
                        var l = t.media;
                        Xu(l, function(t) {
                            t && t.option && (t.query ? o.push(t) : e = e || t)
                        })
                    }
                    a = a || t;
                    a.timeline || (a.timeline = s);
                    return Xu([a].concat(r).concat(it.map(o, function(t) {
                        return t.option
                    })), function(e) {
                        Xu(i, function(t) {
                            t(e, n)
                        })
                    }),
                    {
                        baseOption: a,
                        timelineOptions: r,
                        mediaDefault: e,
                        mediaList: o
                    }
                }
                .call(this, t, e, !i);
                this._newBaseOption = n.baseOption,
                i ? (function(a, t) {
                    Xu(t = t || {}, function(t, e) {
                        if (null != t) {
                            var i = a[e];
                            if (Pl.hasClass(e)) {
                                t = aa.normalizeToArray(t),
                                i = aa.normalizeToArray(i);
                                var n = aa.mappingToExists(i, t);
                                a[e] = Ku(n, function(t) {
                                    return t.option && t.exist ? $u(t.exist, t.option, !0) : t.exist || t.option
                                })
                            } else
                                a[e] = $u(i, t, !0)
                        }
                    })
                }(i.baseOption, n.baseOption),
                n.timelineOptions.length && (i.timelineOptions = n.timelineOptions),
                n.mediaList.length && (i.mediaList = n.mediaList),
                n.mediaDefault && (i.mediaDefault = n.mediaDefault)) : this._optionBackup = n
            },
            mountOption: function(t) {
                var e = this._optionBackup;
                return this._timelineOptions = Ku(e.timelineOptions, qu),
                this._mediaList = Ku(e.mediaList, qu),
                this._mediaDefault = qu(e.mediaDefault),
                this._currentMediaIndices = [],
                qu(t ? e.baseOption : this._newBaseOption)
            },
            getTimelineOption: function(t) {
                var e, i = this._timelineOptions;
                if (i.length) {
                    var n = t.getComponent("timeline");
                    n && (e = qu(i[n.getCurrentIndex()], !0))
                }
                return e
            },
            getMediaOption: function(t) {
                var e = this._api.getWidth()
                  , i = this._api.getHeight()
                  , n = this._mediaList
                  , a = this._mediaDefault
                  , r = []
                  , o = [];
                if (!n.length && !a)
                    return o;
                for (var s = 0, l = n.length; s < l; s++)
                    th(n[s].query, e, i) && r.push(s);
                return !r.length && a && (r = [-1]),
                r.length && !function(t, e) {
                    return t.join(",") === e.join(",")
                }(r, this._currentMediaIndices) && (o = Ku(r, function(t) {
                    return qu(-1 === t ? a.option : n[t].option)
                })),
                this._currentMediaIndices = r,
                o
            }
        };
        var eh = Qu
          , ih = it.each
          , nh = it.isObject
          , ah = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
        function rh(t) {
            var e = t && t.itemStyle;
            if (e)
                for (var i = 0, n = ah.length; i < n; i++) {
                    var a = ah[i]
                      , r = e.normal
                      , o = e.emphasis;
                    r && r[a] && (t[a] = t[a] || {},
                    t[a].normal ? it.merge(t[a].normal, r[a]) : t[a].normal = r[a],
                    r[a] = null),
                    o && o[a] && (t[a] = t[a] || {},
                    t[a].emphasis ? it.merge(t[a].emphasis, o[a]) : t[a].emphasis = o[a],
                    o[a] = null)
                }
        }
        function oh(t, e, i) {
            if (t && t[e] && (t[e].normal || t[e].emphasis)) {
                var n = t[e].normal
                  , a = t[e].emphasis;
                n && (i ? (t[e].normal = t[e].emphasis = null,
                it.defaults(t[e], n)) : t[e] = n),
                a && (t.emphasis = t.emphasis || {},
                t.emphasis[e] = a)
            }
        }
        function sh(t) {
            oh(t, "itemStyle"),
            oh(t, "lineStyle"),
            oh(t, "areaStyle"),
            oh(t, "label"),
            oh(t, "labelLine"),
            oh(t, "upperLabel"),
            oh(t, "edgeLabel")
        }
        function lh(t, e) {
            var i = nh(t) && t[e]
              , n = nh(i) && i.textStyle;
            if (n)
                for (var a = 0, r = aa.TEXT_STYLE_OPTIONS.length; a < r; a++) {
                    e = aa.TEXT_STYLE_OPTIONS[a];
                    n.hasOwnProperty(e) && (i[e] = n[e])
                }
        }
        function uh(t) {
            t && (sh(t),
            lh(t, "label"),
            t.emphasis && lh(t.emphasis, "label"))
        }
        function hh(t) {
            return it.isArray(t) ? t : t ? [t] : []
        }
        function ch(t) {
            return (it.isArray(t) ? t[0] : t) || {}
        }
        var dh = function(e, t) {
            ih(hh(e.series), function(t) {
                nh(t) && function(t) {
                    if (nh(t)) {
                        rh(t),
                        sh(t),
                        lh(t, "label"),
                        lh(t, "upperLabel"),
                        lh(t, "edgeLabel"),
                        t.emphasis && (lh(t.emphasis, "label"),
                        lh(t.emphasis, "upperLabel"),
                        lh(t.emphasis, "edgeLabel")),
                        (i = t.markPoint) && (rh(i),
                        uh(i)),
                        (n = t.markLine) && (rh(n),
                        uh(n));
                        var e = t.markArea;
                        e && uh(e);
                        var i, n, a = t.data;
                        if ("graph" === t.type) {
                            a = a || t.nodes;
                            var r = t.links || t.edges;
                            if (r && !it.isTypedArray(r))
                                for (var o = 0; o < r.length; o++)
                                    uh(r[o]);
                            it.each(t.categories, function(t) {
                                sh(t)
                            })
                        }
                        if (a && !it.isTypedArray(a))
                            for (o = 0; o < a.length; o++)
                                uh(a[o]);
                        if ((i = t.markPoint) && i.data) {
                            var s = i.data;
                            for (o = 0; o < s.length; o++)
                                uh(s[o])
                        }
                        if ((n = t.markLine) && n.data) {
                            var l = n.data;
                            for (o = 0; o < l.length; o++)
                                it.isArray(l[o]) ? (uh(l[o][0]),
                                uh(l[o][1])) : uh(l[o])
                        }
                        "gauge" === t.type ? (lh(t, "axisLabel"),
                        lh(t, "title"),
                        lh(t, "detail")) : "treemap" === t.type ? (oh(t.breadcrumb, "itemStyle"),
                        it.each(t.levels, function(t) {
                            sh(t)
                        })) : "tree" === t.type && sh(t.leaves)
                    }
                }(t)
            });
            var i = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
            t && i.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"),
            ih(i, function(t) {
                ih(hh(e[t]), function(t) {
                    t && (lh(t, "axisLabel"),
                    lh(t.axisPointer, "label"))
                })
            }),
            ih(hh(e.parallel), function(t) {
                var e = t && t.parallelAxisDefault;
                lh(e, "axisLabel"),
                lh(e && e.axisPointer, "label")
            }),
            ih(hh(e.calendar), function(t) {
                oh(t, "itemStyle"),
                lh(t, "dayLabel"),
                lh(t, "monthLabel"),
                lh(t, "yearLabel")
            }),
            ih(hh(e.radar), function(t) {
                lh(t, "name")
            }),
            ih(hh(e.geo), function(t) {
                nh(t) && (uh(t),
                ih(hh(t.regions), function(t) {
                    uh(t)
                }))
            }),
            ih(hh(e.timeline), function(t) {
                uh(t),
                oh(t, "label"),
                oh(t, "itemStyle"),
                oh(t, "controlStyle", !0);
                var e = t.data;
                it.isArray(e) && it.each(e, function(t) {
                    it.isObject(t) && (oh(t, "label"),
                    oh(t, "itemStyle"))
                })
            }),
            ih(hh(e.toolbox), function(t) {
                oh(t, "iconStyle"),
                ih(t.feature, function(t) {
                    oh(t, "iconStyle")
                })
            }),
            lh(ch(e.axisPointer), "label"),
            lh(ch(e.tooltip).axisPointer, "label")
        }
          , ph = it.each
          , fh = it.isArray
          , gh = it.isObject
          , mh = aa.normalizeToArray;
        function vh(e) {
            ph(yh, function(t) {
                t[0]in e && !(t[1]in e) && (e[t[1]] = e[t[0]])
            })
        }
        var yh = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]]
          , xh = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"];
        var _h = function(i, t) {
            dh(i, t),
            i.series = mh(i.series),
            ph(i.series, function(t) {
                if (gh(t)) {
                    var e = t.type;
                    if ("pie" !== e && "gauge" !== e || null != t.clockWise && (t.clockwise = t.clockWise),
                    "gauge" === e) {
                        var i = function(t, e) {
                            e = e.split(",");
                            for (var i = t, n = 0; n < e.length && null != (i = i && i[e[n]]); n++)
                                ;
                            return i
                        }(t, "pointer.color");
                        null != i && function(t, e, i, n) {
                            e = e.split(",");
                            for (var a, r = t, o = 0; o < e.length - 1; o++)
                                null == r[a = e[o]] && (r[a] = {}),
                                r = r[a];
                            !n && null != r[e[o]] || (r[e[o]] = i)
                        }(t, "itemStyle.normal.color", i)
                    }
                    vh(t)
                }
            }),
            i.dataRange && (i.visualMap = i.dataRange),
            ph(xh, function(t) {
                var e = i[t];
                e && (fh(e) || (e = [e]),
                ph(e, function(t) {
                    vh(t)
                }))
            })
        }
          , bh = it.createHashMap
          , wh = it.each;
        function Sh(m) {
            wh(m, function(h, c) {
                var d = []
                  , p = [NaN, NaN]
                  , t = [h.stackResultDimension, h.stackedOverDimension]
                  , f = h.data
                  , g = h.isStackedByIndex
                  , e = f.map(t, function(t, e, i) {
                    var n, a, r = f.get(h.stackedDimension, i);
                    if (isNaN(r))
                        return p;
                    g ? a = f.getRawIndex(i) : n = f.get(h.stackedByDimension, i);
                    for (var o = NaN, s = c - 1; 0 <= s; s--) {
                        var l = m[s];
                        if (g || (a = l.data.rawIndexOf(l.stackedByDimension, n)),
                        0 <= a) {
                            var u = l.data.getByRawIndex(l.stackResultDimension, a);
                            if (0 <= r && 0 < u || r <= 0 && u < 0) {
                                r += u,
                                o = u;
                                break
                            }
                        }
                    }
                    return d[0] = r,
                    d[1] = o,
                    d
                });
                f.hostModel.setData(e),
                h.data = e
            })
        }
        function Mh(t) {
            var r = bh();
            t.eachSeries(function(t) {
                var e = t.get("stack");
                if (e) {
                    var i = r.get(e) || r.set(e, [])
                      , n = t.getData()
                      , a = {
                        stackResultDimension: n.getCalculationInfo("stackResultDimension"),
                        stackedOverDimension: n.getCalculationInfo("stackedOverDimension"),
                        stackedDimension: n.getCalculationInfo("stackedDimension"),
                        stackedByDimension: n.getCalculationInfo("stackedByDimension"),
                        isStackedByIndex: n.getCalculationInfo("isStackedByIndex"),
                        data: n,
                        seriesModel: t
                    };
                    if (!a.stackedDimension || !a.isStackedByIndex && !a.stackedByDimension)
                        return;
                    i.length && n.setCalculationInfo("stackedOnSeries", i[i.length - 1].seriesModel),
                    i.push(a)
                }
            }),
            r.each(Sh)
        }
        var Ih = it.extend
          , Ah = it.each
          , Th = it.isObject
          , Ch = aa.getDataItemValue
          , Dh = aa.isDataItemOption
          , Lh = ol.parseDate
          , Ph = Wl.SOURCE_FORMAT_TYPED_ARRAY
          , kh = Wl.SOURCE_FORMAT_ARRAY_ROWS
          , Oh = Wl.SOURCE_FORMAT_ORIGINAL
          , Rh = Wl.SOURCE_FORMAT_OBJECT_ROWS;
        function Nh(t, e) {
            Ql.isInstance(t) || (t = Ql.seriesDataToSource(t)),
            this._source = t;
            var i = this._data = t.data
              , n = t.sourceFormat;
            n === Ph && (this._offset = 0,
            this._dimSize = e,
            this._data = i);
            var a = zh[n === kh ? n + "_" + t.seriesLayoutBy : n];
            Ih(this, a)
        }
        var Eh = Nh.prototype;
        Eh.pure = !1;
        var zh = {
            arrayRows_column: {
                pure: Eh.persistent = !0,
                count: function() {
                    return Math.max(0, this._data.length - this._source.startIndex)
                },
                getItem: function(t) {
                    return this._data[t + this._source.startIndex]
                },
                appendData: Gh
            },
            arrayRows_row: {
                pure: !0,
                count: function() {
                    var t = this._data[0];
                    return t ? Math.max(0, t.length - this._source.startIndex) : 0
                },
                getItem: function(t) {
                    t += this._source.startIndex;
                    for (var e = [], i = this._data, n = 0; n < i.length; n++) {
                        var a = i[n];
                        e.push(a ? a[t] : null)
                    }
                    return e
                },
                appendData: function() {
                    throw new Error('Do not support appendData when set seriesLayoutBy: "row".')
                }
            },
            objectRows: {
                pure: !0,
                count: Vh,
                getItem: Bh,
                appendData: Gh
            },
            keyedColumns: {
                pure: !0,
                count: function() {
                    var t = this._source.dimensionsDefine[0].name
                      , e = this._data[t];
                    return e ? e.length : 0
                },
                getItem: function(t) {
                    for (var e = [], i = this._source.dimensionsDefine, n = 0; n < i.length; n++) {
                        var a = this._data[i[n].name];
                        e.push(a ? a[t] : null)
                    }
                    return e
                },
                appendData: function(t) {
                    var a = this._data;
                    Ah(t, function(t, e) {
                        for (var i = a[e] || (a[e] = []), n = 0; n < (t || []).length; n++)
                            i.push(t[n])
                    })
                }
            },
            original: {
                count: Vh,
                getItem: Bh,
                appendData: Gh
            },
            typedArray: {
                persistent: !(Eh.getSource = function() {
                    return this._source
                }
                ),
                pure: !0,
                count: function() {
                    return this._data ? this._data.length / this._dimSize : 0
                },
                getItem: function(t, e) {
                    t -= this._offset,
                    e = e || [];
                    for (var i = this._dimSize * t, n = 0; n < this._dimSize; n++)
                        e[n] = this._data[i + n];
                    return e
                },
                appendData: function(t) {
                    this._data = t
                },
                clean: function() {
                    this._offset += this.count(),
                    this._data = null
                }
            }
        };
        function Vh() {
            return this._data.length
        }
        function Bh(t) {
            return this._data[t]
        }
        function Gh(t) {
            for (var e = 0; e < t.length; e++)
                this._data.push(t[e])
        }
        var Fh = {
            arrayRows: Hh,
            objectRows: function(t, e, i, n) {
                return null != i ? t[n] : t
            },
            keyedColumns: Hh,
            original: function(t, e, i, n) {
                var a = Ch(t);
                return null != i && a instanceof Array ? a[i] : a
            },
            typedArray: Hh
        };
        function Hh(t, e, i, n) {
            return null != i ? t[i] : t
        }
        function Wh(t, e, i, n) {
            return Zh(t[n], this._dimensionInfos[e])
        }
        function Zh(t, e) {
            var i = e && e.type;
            if ("ordinal" !== i)
                return "time" === i && "number" != typeof t && null != t && "-" !== t && (t = +Lh(t)),
                null == t || "" === t ? NaN : +t;
            var n = e && e.ordinalMeta;
            return n ? n.parseAndCollect(t) : t
        }
        var Uh = {
            DefaultDataProvider: Nh,
            defaultDimValueGetters: {
                arrayRows: Wh,
                objectRows: function(t, e, i, n) {
                    return Zh(t[e], this._dimensionInfos[e])
                },
                keyedColumns: Wh,
                original: function(t, e, i, n) {
                    var a = t && (null == t.value ? t : t.value);
                    return !this._rawData.pure && Dh(t) && (this.hasItemOption = !0),
                    Zh(a instanceof Array ? a[n] : a, this._dimensionInfos[e])
                },
                typedArray: function(t, e, i, n) {
                    return t[n]
                }
            },
            retrieveRawValue: function(t, e, i) {
                if (t) {
                    var n = t.getRawDataItem(e);
                    if (null != n) {
                        var a, r, o = t.getProvider().getSource().sourceFormat, s = t.getDimensionInfo(i);
                        return s && (a = s.name,
                        r = s.index),
                        Fh[o](n, e, r, a)
                    }
                }
            },
            retrieveRawAttr: function(t, e, i) {
                if (t) {
                    var n = t.getProvider().getSource().sourceFormat;
                    if (n === Oh || n === Rh) {
                        var a = t.getRawDataItem(e);
                        return n !== Oh || Th(a) || (a = null),
                        a ? a[i] : void 0
                    }
                }
            }
        }
          , Yh = Uh.retrieveRawValue
          , jh = fl.getTooltipMarker
          , Xh = fl.formatTpl
          , qh = aa.getTooltipRenderMode
          , Kh = /\{@(.+?)\}/g
          , $h = {
            getDataParams: function(t, e) {
                var i = this.getData(e)
                  , n = this.getRawValue(t, e)
                  , a = i.getRawIndex(t)
                  , r = i.getName(t)
                  , o = i.getRawDataItem(t)
                  , s = i.getItemVisual(t, "color")
                  , l = this.ecModel.getComponent("tooltip")
                  , u = l && l.get("renderMode")
                  , h = qh(u)
                  , c = this.mainType
                  , d = "series" === c;
                return {
                    componentType: c,
                    componentSubType: this.subType,
                    componentIndex: this.componentIndex,
                    seriesType: d ? this.subType : null,
                    seriesIndex: this.seriesIndex,
                    seriesId: d ? this.id : null,
                    seriesName: d ? this.name : null,
                    name: r,
                    dataIndex: a,
                    data: o,
                    dataType: e,
                    value: n,
                    color: s,
                    marker: jh({
                        color: s,
                        renderMode: h
                    }),
                    $vars: ["seriesName", "name", "value"]
                }
            },
            getFormattedLabel: function(n, t, e, i, a) {
                t = t || "normal";
                var r = this.getData(e)
                  , o = r.getItemModel(n)
                  , s = this.getDataParams(n, e);
                null != i && s.value instanceof Array && (s.value = s.value[i]);
                var l = o.get("normal" === t ? [a || "label", "formatter"] : [t, a || "label", "formatter"]);
                return "function" == typeof l ? (s.status = t,
                l(s)) : "string" == typeof l ? Xh(l, s).replace(Kh, function(t, e) {
                    var i = e.length;
                    return "[" === e.charAt(0) && "]" === e.charAt(i - 1) && (e = +e.slice(1, i - 1)),
                    Yh(r, n, e)
                }) : void 0
            },
            getRawValue: function(t, e) {
                return Yh(this.getData(e), t)
            },
            formatTooltip: function() {}
        }
          , Jh = it.isArray;
        function Qh(t) {
            t = t || {},
            this._reset = t.reset,
            this._plan = t.plan,
            this._count = t.count,
            this._onDirty = t.onDirty,
            this._dirty = !0,
            this.context
        }
        var tc = Qh.prototype;
        tc.perform = function(t) {
            var e, i = this._upstream, n = t && t.skip;
            if (this._dirty && i) {
                var a = this.context;
                a.data = a.outputData = i.context.outputData
            }
            this.__pipeline && (this.__pipeline.currentTask = this),
            this._plan && !n && (e = this._plan(this.context));
            var r, o = h(this._modBy), s = this._modDataCount || 0, l = h(t && t.modBy), u = t && t.modDataCount || 0;
            function h(t) {
                return 1 <= t || (t = 1),
                t
            }
            o === l && s === u || (e = "reset"),
            !this._dirty && "reset" !== e || (this._dirty = !1,
            r = function(t, e) {
                var i, n;
                t._dueIndex = t._outputDueEnd = t._dueEnd = 0,
                t._settedOutputEnd = null,
                !e && t._reset && ((i = t._reset(t.context)) && i.progress && (n = i.forceFirstProgress,
                i = i.progress),
                Jh(i) && !i.length && (i = null));
                t._progress = i,
                t._modBy = t._modDataCount = null;
                var a = t._downstream;
                return a && a.dirty(),
                n
            }(this, n)),
            this._modBy = l,
            this._modDataCount = u;
            var c = t && t.step;
            if (this._dueEnd = i ? i._outputDueEnd : this._count ? this._count(this.context) : 1 / 0,
            this._progress) {
                var d = this._dueIndex
                  , p = Math.min(null != c ? this._dueIndex + c : 1 / 0, this._dueEnd);
                if (!n && (r || d < p)) {
                    var f = this._progress;
                    if (Jh(f))
                        for (var g = 0; g < f.length; g++)
                            hc(this, f[g], d, p, l, u);
                    else
                        hc(this, f, d, p, l, u)
                }
                this._dueIndex = p;
                var m = null != this._settedOutputEnd ? this._settedOutputEnd : p;
                this._outputDueEnd = m
            } else
                this._dueIndex = this._outputDueEnd = null != this._settedOutputEnd ? this._settedOutputEnd : this._dueEnd;
            return this.unfinished()
        }
        ;
        var ec, ic, nc, ac, rc, oc, sc = oc = {
            reset: function(t, e, i, n) {
                ic = t,
                ec = e,
                nc = i,
                ac = n,
                rc = Math.ceil(ac / nc),
                oc.next = 1 < nc && 0 < ac ? uc : lc
            }
        };
        function lc() {
            return ic < ec ? ic++ : null
        }
        function uc() {
            var t = ic % rc * nc + Math.ceil(ic / rc)
              , e = ec <= ic ? null : t < ac ? t : ic;
            return ic++,
            e
        }
        function hc(t, e, i, n, a, r) {
            sc.reset(i, n, a, r),
            t._callingProgress = e,
            t._callingProgress({
                start: i,
                end: n,
                count: n - i,
                next: sc.next
            }, t.context)
        }
        tc.dirty = function() {
            this._dirty = !0,
            this._onDirty && this._onDirty(this.context)
        }
        ,
        tc.unfinished = function() {
            return this._progress && this._dueIndex < this._dueEnd
        }
        ,
        tc.pipe = function(t) {
            this._downstream === t && !this._dirty || ((this._downstream = t)._upstream = this,
            t.dirty())
        }
        ,
        tc.dispose = function() {
            this._disposed || (this._upstream && (this._upstream._downstream = null),
            this._downstream && (this._downstream._upstream = null),
            this._dirty = !1,
            this._disposed = !0)
        }
        ,
        tc.getUpstream = function() {
            return this._upstream
        }
        ,
        tc.getDownstream = function() {
            return this._downstream
        }
        ,
        tc.setOutputEnd = function(t) {
            this._outputDueEnd = this._settedOutputEnd = t
        }
        ;
        var cc = {
            createTask: function(t) {
                return new Qh(t)
            }
        }
          , dc = fl.formatTime
          , pc = fl.encodeHTML
          , fc = fl.addCommas
          , gc = fl.getTooltipMarker
          , mc = Il.getLayoutParams
          , vc = Il.mergeLayoutParam
          , yc = cc.createTask
          , xc = Su.prepareSource
          , _c = Su.getSource
          , bc = Uh.retrieveRawValue
          , wc = aa.makeInner()
          , Sc = Pl.extend({
            type: "series.__base__",
            seriesIndex: 0,
            coordinateSystem: null,
            defaultOption: null,
            legendDataProvider: null,
            visualColorAccessPath: "itemStyle.color",
            layoutMode: null,
            init: function(t, e, i, n) {
                this.seriesIndex = this.componentIndex,
                this.dataTask = yc({
                    count: Ic,
                    reset: Ac
                }),
                this.dataTask.context = {
                    model: this
                },
                this.mergeDefaultAndTheme(t, i),
                xc(this);
                var a = this.getInitialData(t, i);
                Cc(a, this),
                this.dataTask.context.data = a,
                wc(this).dataBeforeProcessed = a,
                Mc(this)
            },
            mergeDefaultAndTheme: function(t, e) {
                var i = this.layoutMode
                  , n = i ? mc(t) : {}
                  , a = this.subType;
                Pl.hasClass(a) && (a += "Series"),
                it.merge(t, e.getTheme().get(this.subType)),
                it.merge(t, this.getDefaultOption()),
                aa.defaultEmphasis(t, "label", ["show"]),
                this.fillDataTextStyle(t.data),
                i && vc(t, n, i)
            },
            mergeOption: function(t, e) {
                t = it.merge(this.option, t, !0),
                this.fillDataTextStyle(t.data);
                var i = this.layoutMode;
                i && vc(this.option, t, i),
                xc(this);
                var n = this.getInitialData(t, e);
                Cc(n, this),
                this.dataTask.dirty(),
                this.dataTask.context.data = n,
                wc(this).dataBeforeProcessed = n,
                Mc(this)
            },
            fillDataTextStyle: function(t) {
                if (t && !it.isTypedArray(t))
                    for (var e = ["show"], i = 0; i < t.length; i++)
                        t[i] && t[i].label && aa.defaultEmphasis(t[i], "label", e)
            },
            getInitialData: function() {},
            appendData: function(t) {
                this.getRawData().appendData(t.data)
            },
            getData: function(t) {
                var e = Lc(this);
                if (e) {
                    var i = e.context.data;
                    return null == t ? i : i.getLinkedData(t)
                }
                return wc(this).data
            },
            setData: function(t) {
                var e = Lc(this);
                if (e) {
                    var i = e.context;
                    i.data !== t && e.modifyOutputEnd && e.setOutputEnd(t.count()),
                    i.outputData = t,
                    e !== this.dataTask && (i.data = t)
                }
                wc(this).data = t
            },
            getSource: function() {
                return _c(this)
            },
            getRawData: function() {
                return wc(this).dataBeforeProcessed
            },
            getBaseAxis: function() {
                var t = this.coordinateSystem;
                return t && t.getBaseAxis && t.getBaseAxis()
            },
            formatTooltip: function(a, h, t, c) {
                var d = this
                  , e = "html" === (c = c || "html") ? "<br/>" : "\n"
                  , p = "richText" === c
                  , f = {}
                  , g = 0;
                function i(t) {
                    return {
                        renderMode: c,
                        content: pc(fc(t)),
                        style: f
                    }
                }
                var m = this.getData()
                  , r = m.mapDimension("defaultedTooltip", !0)
                  , n = r.length
                  , o = this.getRawValue(a)
                  , s = it.isArray(o)
                  , v = m.getItemVisual(a, "color");
                it.isObject(v) && v.colorStops && (v = (v.colorStops[0] || {}).color),
                v = v || "transparent";
                var l = (1 < n || s && !n ? function(t) {
                    var l = it.reduce(t, function(t, e, i) {
                        var n = m.getDimensionInfo(i);
                        return t | (n && !1 !== n.tooltip && null != n.displayName)
                    }, 0)
                      , u = [];
                    function e(t, e) {
                        var i = m.getDimensionInfo(e);
                        if (i && !1 !== i.otherDims.tooltip) {
                            var n = i.type
                              , a = "sub" + d.seriesIndex + "at" + g
                              , r = gc({
                                color: v,
                                type: "subItem",
                                renderMode: c,
                                markerId: a
                            })
                              , o = "string" == typeof r ? r : r.content
                              , s = (l ? o + pc(i.displayName || "-") + ": " : "") + pc("ordinal" === n ? t + "" : "time" === n ? h ? "" : dc("yyyy/MM/dd hh:mm:ss", t) : fc(t));
                            s && u.push(s),
                            p && (f[a] = v,
                            ++g)
                        }
                    }
                    r.length ? it.each(r, function(t) {
                        e(bc(m, a, t), t)
                    }) : it.each(t, e);
                    var i = l ? p ? "\n" : "<br/>" : ""
                      , n = i + u.join(i || ", ");
                    return {
                        renderMode: c,
                        content: n,
                        style: f
                    }
                }(o) : i(n ? bc(m, a, r[0]) : s ? o[0] : o)).content
                  , u = d.seriesIndex + "at" + g
                  , y = gc({
                    color: v,
                    type: "item",
                    renderMode: c,
                    markerId: u
                });
                f[u] = v,
                ++g;
                var x = m.getName(a)
                  , _ = this.name;
                aa.isNameSpecified(this) || (_ = ""),
                _ = _ ? pc(_) + (h ? ": " : e) : "";
                var b = "string" == typeof y ? y : y.content;
                return {
                    html: h ? b + _ + l : _ + b + (x ? pc(x) + ": " + l : l),
                    markers: f
                }
            },
            isAnimationEnabled: function() {
                if (et.node)
                    return !1;
                var t = this.getShallow("animation");
                return t && this.getData().count() > this.getShallow("animationThreshold") && (t = !1),
                t
            },
            restoreData: function() {
                this.dataTask.dirty()
            },
            getColorFromPalette: function(t, e, i) {
                var n = this.ecModel
                  , a = zl.getColorFromPalette.call(this, t, e, i);
                return a = a || n.getColorFromPalette(t, e, i)
            },
            coordDimToDataDim: function(t) {
                return this.getRawData().mapDimension(t, !0)
            },
            getProgressive: function() {
                return this.get("progressive")
            },
            getProgressiveThreshold: function() {
                return this.get("progressiveThreshold")
            },
            getAxisTooltipData: null,
            getTooltipPosition: null,
            pipeTask: null,
            preventIncremental: null,
            pipelineContext: null
        });
        function Mc(t) {
            var e = t.name;
            aa.isNameSpecified(t) || (t.name = function(t) {
                var i = t.getRawData()
                  , e = i.mapDimension("seriesName", !0)
                  , n = [];
                return it.each(e, function(t) {
                    var e = i.getDimensionInfo(t);
                    e.displayName && n.push(e.displayName)
                }),
                n.join(" ")
            }(t) || e)
        }
        function Ic(t) {
            return t.model.getRawData().count()
        }
        function Ac(t) {
            var e = t.model;
            return e.setData(e.getRawData().cloneShallow()),
            Tc
        }
        function Tc(t, e) {
            t.end > e.outputData.count() && e.model.getRawData().cloneShallow(e.outputData)
        }
        function Cc(e, i) {
            it.each(e.CHANGABLE_METHODS, function(t) {
                e.wrapMethod(t, it.curry(Dc, i))
            })
        }
        function Dc(t) {
            var e = Lc(t);
            e && e.setOutputEnd(this.count())
        }
        function Lc(t) {
            var e = (t.ecModel || {}).scheduler
              , i = e && e.getPipeline(t.uid);
            if (i) {
                var n = i.currentTask;
                if (n) {
                    var a = n.agentStubMap;
                    a && (n = a.get(t.uid))
                }
                return n
            }
        }
        it.mixin(Sc, $h),
        it.mixin(Sc, zl);
        function Pc() {
            this.group = new Re,
            this.uid = nl.getUID("viewComponent")
        }
        var kc = Sc
          , Oc = Pc.prototype = {
            constructor: Pc,
            init: function(t, e) {},
            render: function(t, e, i, n) {},
            dispose: function() {},
            filterForExposedEvent: null
        };
        Oc.updateView = Oc.updateLayout = Oc.updateVisual = function(t, e, i, n) {}
        ,
        ca.enableClassExtend(Pc),
        ca.enableClassManagement(Pc, {
            registerWhenExtend: !0
        });
        var Rc = Pc
          , Nc = aa.makeInner;
        var Ec = function() {
            var s = Nc();
            return function(t) {
                var e = s(t)
                  , i = t.pipelineContext
                  , n = e.large
                  , a = e.progressiveRender
                  , r = e.large = i.large
                  , o = e.progressiveRender = i.progressiveRender;
                return !!(n ^ r || a ^ o) && "reset"
            }
        }
          , zc = it.each
          , Vc = cc.createTask
          , Bc = aa.makeInner()
          , Gc = Ec();
        function Fc() {
            this.group = new Re,
            this.uid = nl.getUID("viewChart"),
            this.renderTask = Vc({
                plan: Uc,
                reset: Yc
            }),
            this.renderTask.context = {
                view: this
            }
        }
        var Hc = Fc.prototype = {
            type: "chart",
            init: function(t, e) {},
            render: function(t, e, i, n) {},
            highlight: function(t, e, i, n) {
                Zc(t.getData(), n, "emphasis")
            },
            downplay: function(t, e, i, n) {
                Zc(t.getData(), n, "normal")
            },
            remove: function(t, e) {
                this.group.removeAll()
            },
            dispose: function() {},
            incrementalPrepareRender: null,
            incrementalRender: null,
            updateTransform: null,
            filterForExposedEvent: null
        };
        function Wc(t, e) {
            if (t && (t.trigger(e),
            "group" === t.type))
                for (var i = 0; i < t.childCount(); i++)
                    Wc(t.childAt(i), e)
        }
        function Zc(e, t, i) {
            var n = aa.queryDataIndex(e, t);
            null != n ? zc(aa.normalizeToArray(n), function(t) {
                Wc(e.getItemGraphicEl(t), i)
            }) : e.eachItemGraphicEl(function(t) {
                Wc(t, i)
            })
        }
        function Uc(t) {
            return Gc(t.model)
        }
        function Yc(t) {
            var e = t.model
              , i = t.ecModel
              , n = t.api
              , a = t.payload
              , r = e.pipelineContext.progressiveRender
              , o = t.view
              , s = a && Bc(a).updateMethod
              , l = r ? "incrementalPrepareRender" : s && o[s] ? s : "render";
            return "render" !== l && o[l](e, i, n, a),
            jc[l]
        }
        Hc.updateView = Hc.updateLayout = Hc.updateVisual = function(t, e, i, n) {
            this.render(t, e, i, n)
        }
        ,
        ca.enableClassExtend(Fc, ["dispose"]),
        ca.enableClassManagement(Fc, {
            registerWhenExtend: !0
        }),
        Fc.markUpdateMethod = function(t, e) {
            Bc(t).updateMethod = e
        }
        ;
        var jc = {
            incrementalPrepareRender: {
                progress: function(t, e) {
                    e.view.incrementalRender(t, e.model, e.ecModel, e.api, e.payload)
                }
            },
            render: {
                forceFirstProgress: !0,
                progress: function(t, e) {
                    e.view.render(e.model, e.ecModel, e.api, e.payload)
                }
            }
        }
          , Xc = Fc
          , qc = "\0__throttleOriginMethod"
          , Kc = "\0__throttleRate"
          , $c = "\0__throttleType";
        function Jc(t, i, n) {
            var a, r, o, s, l, u = 0, h = 0, c = null;
            function d() {
                h = (new Date).getTime(),
                c = null,
                t.apply(o, s || [])
            }
            i = i || 0;
            function e() {
                a = (new Date).getTime(),
                o = this,
                s = arguments;
                var t = l || i
                  , e = l || n;
                l = null,
                r = a - (e ? u : h) - t,
                clearTimeout(c),
                e ? c = setTimeout(d, t) : 0 <= r ? d() : c = setTimeout(d, -r),
                u = a
            }
            return e.clear = function() {
                c && (clearTimeout(c),
                c = null)
            }
            ,
            e.debounceNextCall = function(t) {
                l = t
            }
            ,
            e
        }
        var Qc = {
            throttle: Jc,
            createOrUpdate: function(t, e, i, n) {
                var a = t[e];
                if (a) {
                    var r = a[qc] || a
                      , o = a[$c];
                    if (a[Kc] !== i || o !== n) {
                        if (null == i || !n)
                            return t[e] = r;
                        (a = t[e] = Jc(r, i, "debounce" === n))[qc] = r,
                        a[$c] = n,
                        a[Kc] = i
                    }
                    return a
                }
            },
            clear: function(t, e) {
                var i = t[e];
                i && i[qc] && (t[e] = i[qc])
            }
        }
          , td = {
            createOnAllSeries: !0,
            performRawSeries: !0,
            reset: function(e, t) {
                var i = e.getData()
                  , n = (e.visualColorAccessPath || "itemStyle.color").split(".")
                  , a = e.get(n) || e.getColorFromPalette(e.name, null, t.getSeriesCount());
                if (i.setVisual("color", a),
                !t.isSeriesFiltered(e)) {
                    "function" != typeof a || a instanceof Vo || i.each(function(t) {
                        i.setItemVisual(t, "color", a(e.getDataParams(t)))
                    });
                    return {
                        dataEach: i.hasItemOption ? function(t, e) {
                            var i = t.getItemModel(e).get(n, !0);
                            null != i && t.setItemVisual(e, "color", i)
                        }
                        : null
                    }
                }
            }
        }
          , ed = {
            toolbox: {
                brush: {
                    title: {
                        rect: "",
                        polygon: "",
                        lineX: "",
                        lineY: "",
                        keep: "",
                        clear: ""
                    }
                },
                dataView: {
                    title: "",
                    lang: ["", "", ""]
                },
                dataZoom: {
                    title: {
                        zoom: "",
                        back: ""
                    }
                },
                magicType: {
                    title: {
                        line: "",
                        bar: "",
                        stack: "",
                        tiled: ""
                    }
                },
                restore: {
                    title: ""
                },
                saveAsImage: {
                    title: "",
                    lang: [""]
                }
            },
            series: {
                typeNames: {
                    pie: "",
                    bar: "",
                    line: "",
                    scatter: "",
                    effectScatter: "",
                    radar: "",
                    tree: "",
                    treemap: "",
                    boxplot: "",
                    candlestick: "K",
                    k: "K",
                    heatmap: "",
                    map: "",
                    parallel: "",
                    lines: "",
                    graph: "",
                    sankey: "",
                    funnel: "",
                    gauge: "",
                    pictorialBar: "",
                    themeRiver: "",
                    sunburst: ""
                }
            },
            aria: {
                general: {
                    withTitle: "{title}",
                    withoutTitle: ""
                },
                series: {
                    single: {
                        prefix: "",
                        withName: "{seriesType}{seriesName}",
                        withoutName: "{seriesType}"
                    },
                    multiple: {
                        prefix: "{seriesCount}",
                        withName: "{seriesId}{seriesName}{seriesType}",
                        withoutName: "{seriesId}{seriesType}",
                        separator: {
                            middle: "",
                            end: ""
                        }
                    }
                },
                data: {
                    allData: "",
                    partialData: "{displayCnt}",
                    withName: "{name}{value}",
                    withoutName: "{value}",
                    separator: {
                        middle: "",
                        end: ""
                    }
                }
            }
        }
          , id = Uh.retrieveRawValue;
        var nd = function(t, e) {
            var r = e.getModel("aria");
            if (r.get("show"))
                if (r.get("description"))
                    t.setAttribute("aria-label", r.get("description"));
                else {
                    var h = 0;
                    e.eachSeries(function(t, e) {
                        ++h
                    }, this);
                    var i, c = r.get("data.maxCount") || 10, n = r.get("series.maxCount") || 10, d = Math.min(h, n);
                    if (!(h < 1)) {
                        var a = function() {
                            var t = e.getModel("title").option;
                            t && t.length && (t = t[0]);
                            return t && t.text
                        }();
                        i = a ? f(g("general.withTitle"), {
                            title: a
                        }) : g("general.withoutTitle");
                        var p = [];
                        i += f(g(1 < h ? "series.multiple.prefix" : "series.single.prefix"), {
                            seriesCount: h
                        }),
                        e.eachSeries(function(t, e) {
                            if (e < d) {
                                var i, n = t.get("name"), a = "series." + (1 < h ? "multiple" : "single") + ".";
                                i = f(i = g(n ? a + "withName" : a + "withoutName"), {
                                    seriesId: t.seriesIndex,
                                    seriesName: t.get("name"),
                                    seriesType: function(t) {
                                        return ed.series.typeNames[t] || ""
                                    }(t.subType)
                                });
                                var r = t.getData();
                                (window.data = r).count() > c ? i += f(g("data.partialData"), {
                                    displayCnt: c
                                }) : i += g("data.allData");
                                for (var o = [], s = 0; s < r.count(); s++)
                                    if (s < c) {
                                        var l = r.getName(s)
                                          , u = id(r, s);
                                        o.push(f(g(l ? "data.withName" : "data.withoutName"), {
                                            name: l,
                                            value: u
                                        }))
                                    }
                                i += o.join(g("data.separator.middle")) + g("data.separator.end"),
                                p.push(i)
                            }
                        }),
                        i += p.join(g("series.multiple.separator.middle")) + g("series.multiple.separator.end"),
                        t.setAttribute("aria-label", i)
                    }
                }
            function f(t, e) {
                if ("string" != typeof t)
                    return t;
                var i = t;
                return it.each(e, function(t, e) {
                    i = i.replace(new RegExp("\\{\\s*" + e + "\\s*\\}","g"), t)
                }),
                i
            }
            function g(t) {
                var e = r.get(t);
                if (null != e)
                    return e;
                for (var i = t.split("."), n = ed.aria, a = 0; a < i.length; ++a)
                    n = n[i[a]];
                return n
            }
        }
          , ad = Math.PI;
        function rd(n, t) {
            t = t || {},
            it.defaults(t, {
                text: "loading",
                color: "#c23531",
                textColor: "#000",
                maskColor: "rgba(255, 255, 255, 0.8)",
                zlevel: 0
            });
            var a = new Fs.Rect({
                style: {
                    fill: t.maskColor
                },
                zlevel: t.zlevel,
                z: 1e4
            })
              , r = new Fs.Arc({
                shape: {
                    startAngle: -ad / 2,
                    endAngle: -ad / 2 + .1,
                    r: 10
                },
                style: {
                    stroke: t.color,
                    lineCap: "round",
                    lineWidth: 5
                },
                zlevel: t.zlevel,
                z: 10001
            })
              , o = new Fs.Rect({
                style: {
                    fill: "none",
                    text: t.text,
                    textPosition: "right",
                    textDistance: 10,
                    textFill: t.textColor
                },
                zlevel: t.zlevel,
                z: 10001
            });
            r.animateShape(!0).when(1e3, {
                endAngle: 3 * ad / 2
            }).start("circularInOut"),
            r.animateShape(!0).when(1e3, {
                startAngle: 3 * ad / 2
            }).delay(300).start("circularInOut");
            var e = new Fs.Group;
            return e.add(r),
            e.add(o),
            e.add(a),
            e.resize = function() {
                var t = n.getWidth() / 2
                  , e = n.getHeight() / 2;
                r.setShape({
                    cx: t,
                    cy: e
                });
                var i = r.shape.r;
                o.setShape({
                    x: t - i,
                    y: e - i,
                    width: 2 * i,
                    height: 2 * i
                }),
                a.setShape({
                    x: 0,
                    y: 0,
                    width: n.getWidth(),
                    height: n.getHeight()
                })
            }
            ,
            e.resize(),
            e
        }
        var od = it.each
          , sd = it.map
          , ld = it.isFunction
          , ud = it.createHashMap
          , hd = it.noop
          , cd = cc.createTask
          , dd = nl.getUID
          , pd = aa.normalizeToArray;
        function fd(t, e, i, n) {
            this.ecInstance = t,
            this.api = e,
            this.unfinished;
            i = this._dataProcessorHandlers = i.slice(),
            n = this._visualHandlers = n.slice();
            this._allHandlers = i.concat(n),
            this._stageTaskMap = ud()
        }
        var gd = fd.prototype;
        function md(l, t, u, h, c) {
            var d;
            function p(t, e) {
                return t.setDirty && (!t.dirtyMap || t.dirtyMap.get(e.__pipeline.id))
            }
            c = c || {},
            od(t, function(n, t) {
                if (!c.visualType || c.visualType === n.visualType) {
                    var e = l._stageTaskMap.get(n.uid)
                      , i = e.seriesTaskMap
                      , a = e.overallTask;
                    if (a) {
                        var r, o = a.agentStubMap;
                        o.each(function(t) {
                            p(c, t) && (t.dirty(),
                            r = !0)
                        }),
                        r && a.dirty(),
                        vd(a, h);
                        var s = l.getPerformArgs(a, c.block);
                        o.each(function(t) {
                            t.perform(s)
                        }),
                        d |= a.perform(s)
                    } else
                        i && i.each(function(t, e) {
                            p(c, t) && t.dirty();
                            var i = l.getPerformArgs(t, c.block);
                            i.skip = !n.performRawSeries && u.isSeriesFiltered(t.context.model),
                            vd(t, h),
                            d |= t.perform(i)
                        })
                }
            }),
            l.unfinished |= d
        }
        gd.restoreData = function(t, e) {
            t.restoreData(e),
            this._stageTaskMap.each(function(t) {
                var e = t.overallTask;
                e && e.dirty()
            })
        }
        ,
        gd.getPerformArgs = function(t, e) {
            if (t.__pipeline) {
                var i = this._pipelineMap.get(t.__pipeline.id)
                  , n = i.context
                  , a = !e && i.progressiveEnabled && (!n || n.progressiveRender) && t.__idxInPipeline > i.blockIndex ? i.step : null
                  , r = n && n.modDataCount;
                return {
                    step: a,
                    modBy: null != r ? Math.ceil(r / a) : null,
                    modDataCount: r
                }
            }
        }
        ,
        gd.getPipeline = function(t) {
            return this._pipelineMap.get(t)
        }
        ,
        gd.updateStreamModes = function(t, e) {
            var i = this._pipelineMap.get(t.uid)
              , n = t.getData().count()
              , a = i.progressiveEnabled && e.incrementalPrepareRender && n >= i.threshold
              , r = t.get("large") && n >= t.get("largeThreshold")
              , o = "mod" === t.get("progressiveChunkMode") ? n : null;
            t.pipelineContext = i.context = {
                progressiveRender: a,
                modDataCount: o,
                large: r
            }
        }
        ,
        gd.restorePipelines = function(t) {
            var n = this
              , a = n._pipelineMap = ud();
            t.eachSeries(function(t) {
                var e = t.getProgressive()
                  , i = t.uid;
                a.set(i, {
                    id: i,
                    head: null,
                    tail: null,
                    threshold: t.getProgressiveThreshold(),
                    progressiveEnabled: e && !(t.preventIncremental && t.preventIncremental()),
                    blockIndex: -1,
                    step: Math.round(e || 700),
                    count: 0
                }),
                Td(n, t, t.dataTask)
            })
        }
        ,
        gd.prepareStageTasks = function() {
            var i = this._stageTaskMap
              , n = this.ecInstance.getModel()
              , a = this.api;
            od(this._allHandlers, function(t) {
                var e = i.get(t.uid) || i.set(t.uid, []);
                t.reset && function(n, a, t, r, o) {
                    var s = t.seriesTaskMap || (t.seriesTaskMap = ud())
                      , e = a.seriesType
                      , i = a.getTargetSeries;
                    a.createOnAllSeries ? r.eachRawSeries(l) : e ? r.eachRawSeriesByType(e, l) : i && i(r, o).each(l);
                    function l(t) {
                        var e = t.uid
                          , i = s.get(e) || s.set(e, cd({
                            plan: wd,
                            reset: Sd,
                            count: Ad
                        }));
                        i.context = {
                            model: t,
                            ecModel: r,
                            api: o,
                            useClearVisual: a.isVisual && !a.isLayout,
                            plan: a.plan,
                            reset: a.reset,
                            scheduler: n
                        },
                        Td(n, t, i)
                    }
                    var u = n._pipelineMap;
                    s.each(function(t, e) {
                        u.get(e) || (t.dispose(),
                        s.removeKey(e))
                    })
                }(this, t, e, n, a),
                t.overallReset && function(n, t, e, i, a) {
                    var r = e.overallTask = e.overallTask || cd({
                        reset: yd
                    });
                    r.context = {
                        ecModel: i,
                        api: a,
                        overallReset: t.overallReset,
                        scheduler: n
                    };
                    var o = r.agentStubMap = r.agentStubMap || ud()
                      , s = t.seriesType
                      , l = t.getTargetSeries
                      , u = !0
                      , h = t.modifyOutputEnd;
                    s ? i.eachRawSeriesByType(s, c) : l ? l(i, a).each(c) : (u = !1,
                    od(i.getSeries(), c));
                    function c(t) {
                        var e = t.uid
                          , i = o.get(e);
                        i || (i = o.set(e, cd({
                            reset: xd,
                            onDirty: bd
                        })),
                        r.dirty()),
                        i.context = {
                            model: t,
                            overallProgress: u,
                            modifyOutputEnd: h
                        },
                        i.agent = r,
                        i.__block = u,
                        Td(n, t, i)
                    }
                    var d = n._pipelineMap;
                    o.each(function(t, e) {
                        d.get(e) || (t.dispose(),
                        r.dirty(),
                        o.removeKey(e))
                    })
                }(this, t, e, n, a)
            }, this)
        }
        ,
        gd.prepareView = function(t, e, i, n) {
            var a = t.renderTask
              , r = a.context;
            r.model = e,
            r.ecModel = i,
            r.api = n,
            a.__block = !t.incrementalPrepareRender,
            Td(this, e, a)
        }
        ,
        gd.performDataProcessorTasks = function(t, e) {
            md(this, this._dataProcessorHandlers, t, e, {
                block: !0
            })
        }
        ,
        gd.performVisualTasks = function(t, e, i) {
            md(this, this._visualHandlers, t, e, i)
        }
        ,
        gd.performSeriesTasks = function(t) {
            var e;
            t.eachSeries(function(t) {
                e |= t.dataTask.perform()
            }),
            this.unfinished |= e
        }
        ,
        gd.plan = function() {
            this._pipelineMap.each(function(t) {
                var e = t.tail;
                do {
                    if (e.__block) {
                        t.blockIndex = e.__idxInPipeline;
                        break
                    }
                    e = e.getUpstream()
                } while (e)
            })
        }
        ;
        var vd = gd.updatePayload = function(t, e) {
            "remain" !== e && (t.context.payload = e)
        }
        ;
        function yd(t) {
            t.overallReset(t.ecModel, t.api, t.payload)
        }
        function xd(t, e) {
            return t.overallProgress && _d
        }
        function _d() {
            this.agent.dirty(),
            this.getDownstream().dirty()
        }
        function bd() {
            this.agent && this.agent.dirty()
        }
        function wd(t) {
            return t.plan && t.plan(t.model, t.ecModel, t.api, t.payload)
        }
        function Sd(t) {
            t.useClearVisual && t.data.clearAllVisual();
            var e = t.resetDefines = pd(t.reset(t.model, t.ecModel, t.api, t.payload));
            return 1 < e.length ? sd(e, function(t, e) {
                return Id(e)
            }) : Md
        }
        var Md = Id(0);
        function Id(r) {
            return function(t, e) {
                var i = e.data
                  , n = e.resetDefines[r];
                if (n && n.dataEach)
                    for (var a = t.start; a < t.end; a++)
                        n.dataEach(i, a);
                else
                    n && n.progress && n.progress(t, i)
            }
        }
        function Ad(t) {
            return t.data.count()
        }
        function Td(t, e, i) {
            var n = e.uid
              , a = t._pipelineMap.get(n);
            a.head || (a.head = i),
            a.tail && a.tail.pipe(i),
            (a.tail = i).__idxInPipeline = a.count++,
            i.__pipeline = a
        }
        fd.wrapStageHandler = function(t, e) {
            return ld(t) && (t = {
                overallReset: t,
                seriesType: function(t) {
                    Cd = null;
                    try {
                        t(Dd, Ld)
                    } catch (t) {}
                    return Cd
                }(t)
            }),
            t.uid = dd("stageHandler"),
            e && (t.visualType = e),
            t
        }
        ;
        var Cd, Dd = {}, Ld = {};
        function Pd(t, e) {
            for (var i in e.prototype)
                t[i] = hd
        }
        Pd(Dd, Hu),
        Pd(Ld, Zu),
        Dd.eachSeriesByType = Dd.eachRawSeriesByType = function(t) {
            Cd = t
        }
        ,
        Dd.eachComponent = function(t) {
            "series" === t.mainType && t.subType && (Cd = t.subType)
        }
        ;
        function kd() {
            return {
                axisLine: {
                    lineStyle: {
                        color: Ed
                    }
                },
                axisTick: {
                    lineStyle: {
                        color: Ed
                    }
                },
                axisLabel: {
                    textStyle: {
                        color: Ed
                    }
                },
                splitLine: {
                    lineStyle: {
                        type: "dashed",
                        color: "#aaa"
                    }
                },
                splitArea: {
                    areaStyle: {
                        color: Ed
                    }
                }
            }
        }
        var Od = fd
          , Rd = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"]
          , Nd = {
            color: Rd,
            colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], Rd]
        }
          , Ed = "#eee"
          , zd = ["#dd6b66", "#759aa0", "#e69d87", "#8dc1a9", "#ea7e53", "#eedd78", "#73a373", "#73b9bc", "#7289ab", "#91ca8c", "#f49f42"]
          , Vd = {
            color: zd,
            backgroundColor: "#333",
            tooltip: {
                axisPointer: {
                    lineStyle: {
                        color: Ed
                    },
                    crossStyle: {
                        color: Ed
                    }
                }
            },
            legend: {
                textStyle: {
                    color: Ed
                }
            },
            textStyle: {
                color: Ed
            },
            title: {
                textStyle: {
                    color: Ed
                }
            },
            toolbox: {
                iconStyle: {
                    normal: {
                        borderColor: Ed
                    }
                }
            },
            dataZoom: {
                textStyle: {
                    color: Ed
                }
            },
            visualMap: {
                textStyle: {
                    color: Ed
                }
            },
            timeline: {
                lineStyle: {
                    color: Ed
                },
                itemStyle: {
                    normal: {
                        color: zd[1]
                    }
                },
                label: {
                    normal: {
                        textStyle: {
                            color: Ed
                        }
                    }
                },
                controlStyle: {
                    normal: {
                        color: Ed,
                        borderColor: Ed
                    }
                }
            },
            timeAxis: kd(),
            logAxis: kd(),
            valueAxis: kd(),
            categoryAxis: kd(),
            line: {
                symbol: "circle"
            },
            graph: {
                color: zd
            },
            gauge: {
                title: {
                    textStyle: {
                        color: Ed
                    }
                }
            },
            candlestick: {
                itemStyle: {
                    normal: {
                        color: "#FD1050",
                        color0: "#0CF49B",
                        borderColor: "#FD1050",
                        borderColor0: "#0CF49B"
                    }
                }
            }
        };
        Vd.categoryAxis.splitLine.show = !1;
        var Bd = Vd
          , Gd = Su.detectSourceFormat
          , Fd = Wl.SERIES_LAYOUT_BY_COLUMN;
        Pl.extend({
            type: "dataset",
            defaultOption: {
                seriesLayoutBy: Fd,
                sourceHeader: null,
                dimensions: null,
                source: null
            },
            optionUpdated: function() {
                Gd(this)
            }
        }),
        Rc.extend({
            type: "dataset"
        });
        var Hd = Cr.extend({
            type: "ellipse",
            shape: {
                cx: 0,
                cy: 0,
                rx: 0,
                ry: 0
            },
            buildPath: function(t, e) {
                var i = e.cx
                  , n = e.cy
                  , a = e.rx
                  , r = e.ry
                  , o = .5522848 * a
                  , s = .5522848 * r;
                t.moveTo(i - a, n),
                t.bezierCurveTo(i - a, n - s, i - o, n - r, i, n - r),
                t.bezierCurveTo(i + o, n - r, i + a, n - s, i + a, n),
                t.bezierCurveTo(i + a, n + s, i + o, n + r, i, n + r),
                t.bezierCurveTo(i - o, n + r, i - a, n + s, i - a, n),
                t.closePath()
            }
        })
          , Wd = jr.createFromString
          , Zd = it.isString
          , Ud = it.extend
          , Yd = it.defaults
          , jd = it.trim
          , Xd = it.each
          , qd = /[\s,]+/;
        function Kd(t) {
            Zd(t) && (t = (new DOMParser).parseFromString(t, "text/xml"));
            for (9 === t.nodeType && (t = t.firstChild); "svg" !== t.nodeName.toLowerCase() || 1 !== t.nodeType; )
                t = t.nextSibling;
            return t
        }
        function $d() {
            this._defs = {},
            this._root = null,
            this._isDefine = !1,
            this._isText = !1
        }
        $d.prototype.parse = function(t, e) {
            e = e || {};
            var i = Kd(t);
            if (!i)
                throw new Error("Illegal svg");
            var n = new Re;
            this._root = n;
            var a = i.getAttribute("viewBox") || ""
              , r = parseFloat(i.getAttribute("width") || e.width)
              , o = parseFloat(i.getAttribute("height") || e.height);
            isNaN(r) && (r = null),
            isNaN(o) && (o = null),
            np(i, n, null, !0);
            for (var s, l, u = i.firstChild; u; )
                this._parseNode(u, n),
                u = u.nextSibling;
            if (a) {
                var h = jd(a).split(qd);
                4 <= h.length && (s = {
                    x: parseFloat(h[0] || 0),
                    y: parseFloat(h[1] || 0),
                    width: parseFloat(h[2]),
                    height: parseFloat(h[3])
                })
            }
            if (s && null != r && null != o && (l = lp(s, r, o),
            !e.ignoreViewBox)) {
                var c = n;
                (n = new Re).add(c),
                c.scale = l.scale.slice(),
                c.position = l.position.slice()
            }
            return e.ignoreRootClip || null == r || null == o || n.setClipPath(new bo({
                shape: {
                    x: 0,
                    y: 0,
                    width: r,
                    height: o
                }
            })),
            {
                root: n,
                width: r,
                height: o,
                viewBoxRect: s,
                viewBoxTransform: l
            }
        }
        ,
        $d.prototype._parseNode = function(t, e) {
            var i, n, a = t.nodeName.toLowerCase();
            if ("defs" === a ? this._isDefine = !0 : "text" === a && (this._isText = !0),
            this._isDefine) {
                if (n = Qd[a]) {
                    var r = n.call(this, t)
                      , o = t.getAttribute("id");
                    o && (this._defs[o] = r)
                }
            } else
                (n = Jd[a]) && (i = n.call(this, t, e),
                e.add(i));
            for (var s = t.firstChild; s; )
                1 === s.nodeType && this._parseNode(s, i),
                3 === s.nodeType && this._isText && this._parseText(s, i),
                s = s.nextSibling;
            "defs" === a ? this._isDefine = !1 : "text" === a && (this._isText = !1)
        }
        ,
        $d.prototype._parseText = function(t, e) {
            if (1 === t.nodeType) {
                var i = t.getAttribute("dx") || 0
                  , n = t.getAttribute("dy") || 0;
                this._textX += parseFloat(i),
                this._textY += parseFloat(n)
            }
            var a = new qr({
                style: {
                    text: t.textContent,
                    transformText: !0
                },
                position: [this._textX || 0, this._textY || 0]
            });
            tp(e, a),
            np(t, a, this._defs);
            var r = a.style.fontSize;
            r && r < 9 && (a.style.fontSize = 9,
            a.scale = a.scale || [1, 1],
            a.scale[0] *= r / 9,
            a.scale[1] *= r / 9);
            var o = a.getBoundingRect();
            return this._textX += o.width,
            e.add(a),
            a
        }
        ;
        var Jd = {
            g: function(t, e) {
                var i = new Re;
                return tp(e, i),
                np(t, i, this._defs),
                i
            },
            rect: function(t, e) {
                var i = new bo;
                return tp(e, i),
                np(t, i, this._defs),
                i.setShape({
                    x: parseFloat(t.getAttribute("x") || 0),
                    y: parseFloat(t.getAttribute("y") || 0),
                    width: parseFloat(t.getAttribute("width") || 0),
                    height: parseFloat(t.getAttribute("height") || 0)
                }),
                i
            },
            circle: function(t, e) {
                var i = new Kr;
                return tp(e, i),
                np(t, i, this._defs),
                i.setShape({
                    cx: parseFloat(t.getAttribute("cx") || 0),
                    cy: parseFloat(t.getAttribute("cy") || 0),
                    r: parseFloat(t.getAttribute("r") || 0)
                }),
                i
            },
            line: function(t, e) {
                var i = new Mo;
                return tp(e, i),
                np(t, i, this._defs),
                i.setShape({
                    x1: parseFloat(t.getAttribute("x1") || 0),
                    y1: parseFloat(t.getAttribute("y1") || 0),
                    x2: parseFloat(t.getAttribute("x2") || 0),
                    y2: parseFloat(t.getAttribute("y2") || 0)
                }),
                i
            },
            ellipse: function(t, e) {
                var i = new Hd;
                return tp(e, i),
                np(t, i, this._defs),
                i.setShape({
                    cx: parseFloat(t.getAttribute("cx") || 0),
                    cy: parseFloat(t.getAttribute("cy") || 0),
                    rx: parseFloat(t.getAttribute("rx") || 0),
                    ry: parseFloat(t.getAttribute("ry") || 0)
                }),
                i
            },
            polygon: function(t, e) {
                var i = t.getAttribute("points");
                i = i && ep(i);
                var n = new fo({
                    shape: {
                        points: i || []
                    }
                });
                return tp(e, n),
                np(t, n, this._defs),
                n
            },
            polyline: function(t, e) {
                var i = new Cr;
                tp(e, i),
                np(t, i, this._defs);
                var n = t.getAttribute("points");
                return n = n && ep(n),
                new go({
                    shape: {
                        points: n || []
                    }
                })
            },
            image: function(t, e) {
                var i = new _n;
                return tp(e, i),
                np(t, i, this._defs),
                i.setStyle({
                    image: t.getAttribute("xlink:href"),
                    x: t.getAttribute("x"),
                    y: t.getAttribute("y"),
                    width: t.getAttribute("width"),
                    height: t.getAttribute("height")
                }),
                i
            },
            text: function(t, e) {
                var i = t.getAttribute("x") || 0
                  , n = t.getAttribute("y") || 0
                  , a = t.getAttribute("dx") || 0
                  , r = t.getAttribute("dy") || 0;
                this._textX = parseFloat(i) + parseFloat(a),
                this._textY = parseFloat(n) + parseFloat(r);
                var o = new Re;
                return tp(e, o),
                np(t, o, this._defs),
                o
            },
            tspan: function(t, e) {
                var i = t.getAttribute("x")
                  , n = t.getAttribute("y");
                null != i && (this._textX = parseFloat(i)),
                null != n && (this._textY = parseFloat(n));
                var a = t.getAttribute("dx") || 0
                  , r = t.getAttribute("dy") || 0
                  , o = new Re;
                return tp(e, o),
                np(t, o, this._defs),
                this._textX += a,
                this._textY += r,
                o
            },
            path: function(t, e) {
                var i = t.getAttribute("d") || ""
                  , n = Wd(i);
                return tp(e, n),
                np(t, n, this._defs),
                n
            }
        }
          , Qd = {
            lineargradient: function(t) {
                var e = parseInt(t.getAttribute("x1") || 0, 10)
                  , i = parseInt(t.getAttribute("y1") || 0, 10)
                  , n = parseInt(t.getAttribute("x2") || 10, 10)
                  , a = parseInt(t.getAttribute("y2") || 0, 10)
                  , r = new Go(e,i,n,a);
                return function(t, e) {
                    var i = t.firstChild;
                    for (; i; ) {
                        if (1 === i.nodeType) {
                            var n = i.getAttribute("offset");
                            n = 0 < n.indexOf("%") ? parseInt(n, 10) / 100 : n ? parseFloat(n) : 0;
                            var a = i.getAttribute("stop-color") || "#000000";
                            e.addColorStop(n, a)
                        }
                        i = i.nextSibling
                    }
                }(t, r),
                r
            },
            radialgradient: function(t) {}
        };
        function tp(t, e) {
            t && t.__inheritedStyle && (e.__inheritedStyle || (e.__inheritedStyle = {}),
            Yd(e.__inheritedStyle, t.__inheritedStyle))
        }
        function ep(t) {
            for (var e = jd(t).split(qd), i = [], n = 0; n < e.length; n += 2) {
                var a = parseFloat(e[n])
                  , r = parseFloat(e[n + 1]);
                i.push([a, r])
            }
            return i
        }
        var ip = {
            fill: "fill",
            stroke: "stroke",
            "stroke-width": "lineWidth",
            opacity: "opacity",
            "fill-opacity": "fillOpacity",
            "stroke-opacity": "strokeOpacity",
            "stroke-dasharray": "lineDash",
            "stroke-dashoffset": "lineDashOffset",
            "stroke-linecap": "lineCap",
            "stroke-linejoin": "lineJoin",
            "stroke-miterlimit": "miterLimit",
            "font-family": "fontFamily",
            "font-size": "fontSize",
            "font-style": "fontStyle",
            "font-weight": "fontWeight",
            "text-align": "textAlign",
            "alignment-baseline": "textBaseline"
        };
        function np(t, e, i, n) {
            var a = e.__inheritedStyle || {}
              , r = "text" === e.type;
            if (1 === t.nodeType && (function(t, e) {
                var i = t.getAttribute("transform");
                if (i) {
                    i = i.replace(/,/g, " ");
                    var n = null
                      , a = [];
                    i.replace(op, function(t, e, i) {
                        a.push(e, i)
                    });
                    for (var r = a.length - 1; 0 < r; r -= 2) {
                        var o = a[r]
                          , s = a[r - 1];
                        switch (n = n || ct.create(),
                        s) {
                        case "translate":
                            o = jd(o).split(qd),
                            ct.translate(n, n, [parseFloat(o[0]), parseFloat(o[1] || 0)]);
                            break;
                        case "scale":
                            o = jd(o).split(qd),
                            ct.scale(n, n, [parseFloat(o[0]), parseFloat(o[1] || o[0])]);
                            break;
                        case "rotate":
                            o = jd(o).split(qd),
                            ct.rotate(n, n, parseFloat(o[0]));
                            break;
                        case "skew":
                            o = jd(o).split(qd),
                            console.warn("Skew transform is not supported yet");
                            break;
                        case "matrix":
                            o = jd(o).split(qd);
                            n[0] = parseFloat(o[0]),
                            n[1] = parseFloat(o[1]),
                            n[2] = parseFloat(o[2]),
                            n[3] = parseFloat(o[3]),
                            n[4] = parseFloat(o[4]),
                            n[5] = parseFloat(o[5])
                        }
                    }
                    e.setLocalTransform(n)
                }
            }(t, e),
            Ud(a, function(t) {
                var e = t.getAttribute("style")
                  , i = {};
                if (!e)
                    return i;
                var n, a = {};
                sp.lastIndex = 0;
                for (; null != (n = sp.exec(e)); )
                    a[n[1]] = n[2];
                for (var r in ip)
                    ip.hasOwnProperty(r) && null != a[r] && (i[ip[r]] = a[r]);
                return i
            }(t)),
            !n))
                for (var o in ip)
                    if (ip.hasOwnProperty(o)) {
                        var s = t.getAttribute(o);
                        null != s && (a[ip[o]] = s)
                    }
            var l = r ? "textFill" : "fill"
              , u = r ? "textStroke" : "stroke";
            e.style = e.style || new ai;
            var h = e.style;
            null != a.fill && h.set(l, rp(a.fill, i)),
            null != a.stroke && h.set(u, rp(a.stroke, i)),
            Xd(["lineWidth", "opacity", "fillOpacity", "strokeOpacity", "miterLimit", "fontSize"], function(t) {
                var e = "lineWidth" === t && r ? "textStrokeWidth" : t;
                null != a[t] && h.set(e, parseFloat(a[t]))
            }),
            a.textBaseline && "auto" !== a.textBaseline || (a.textBaseline = "alphabetic"),
            "alphabetic" === a.textBaseline && (a.textBaseline = "bottom"),
            "start" === a.textAlign && (a.textAlign = "left"),
            "end" === a.textAlign && (a.textAlign = "right"),
            Xd(["lineDashOffset", "lineCap", "lineJoin", "fontWeight", "fontFamily", "fontStyle", "textAlign", "textBaseline"], function(t) {
                null != a[t] && h.set(t, a[t])
            }),
            a.lineDash && (e.style.lineDash = jd(a.lineDash).split(qd)),
            h[u] && "none" !== h[u] && (e[u] = !0),
            e.__inheritedStyle = a
        }
        var ap = /url\(\s*#(.*?)\)/;
        function rp(t, e) {
            var i = e && t && t.match(ap);
            return i ? e[jd(i[1])] : t
        }
        var op = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.e,]*)\)/g;
        var sp = /([^\s:;]+)\s*:\s*([^:;]+)/g;
        function lp(t, e, i) {
            var n = e / t.width
              , a = i / t.height
              , r = Math.min(n, a);
            return {
                scale: [r, r],
                position: [-(t.x + t.width / 2) * r + e / 2, -(t.y + t.height / 2) * r + i / 2]
            }
        }
        var up = {
            parseXML: Kd,
            makeViewBoxTransform: lp,
            parseSVG: function(t, e) {
                return (new $d).parse(t, e)
            }
        }
          , hp = it.createHashMap
          , cp = it.isString
          , dp = it.isArray
          , pp = it.each
          , fp = up.parseXML
          , gp = hp()
          , mp = {
            registerMap: function(t, e, i) {
                var n;
                return n = dp(e) ? e : e.svg ? [{
                    type: "svg",
                    source: e.svg,
                    specialAreas: e.specialAreas
                }] : (e.geoJson && !e.features && (i = e.specialAreas,
                e = e.geoJson),
                [{
                    type: "geoJSON",
                    source: e,
                    specialAreas: i
                }]),
                pp(n, function(t) {
                    var e = t.type;
                    "geoJson" === e && (e = t.type = "geoJSON"),
                    (0,
                    vp[e])(t)
                }),
                gp.set(t, n)
            },
            retrieveMap: function(t) {
                return gp.get(t)
            }
        }
          , vp = {
            geoJSON: function(t) {
                var e = t.source;
                t.geoJSON = cp(e) ? "undefined" != typeof JSON && JSON.parse ? JSON.parse(e) : new Function("return (" + e + ");")() : e
            },
            svg: function(t) {
                t.svgXML = fp(t.source)
            }
        }
          , yp = mp;
        function xp(t) {
            return t
        }
        function _p(t, e, i, n, a) {
            this._old = t,
            this._new = e,
            this._oldKeyGetter = i || xp,
            this._newKeyGetter = n || xp,
            this.context = a
        }
        function bp(t, e, i, n, a) {
            for (var r = 0; r < t.length; r++) {
                var o = "_ec_" + a[n](t[r], r)
                  , s = e[o];
                null == s ? (i.push(o),
                e[o] = r) : (s.length || (e[o] = s = [s]),
                s.push(r))
            }
        }
        _p.prototype = {
            constructor: _p,
            add: function(t) {
                return this._add = t,
                this
            },
            update: function(t) {
                return this._update = t,
                this
            },
            remove: function(t) {
                return this._remove = t,
                this
            },
            execute: function() {
                var t = this._old
                  , e = this._new
                  , i = {}
                  , n = []
                  , a = [];
                for (bp(t, {}, n, "_oldKeyGetter", this),
                bp(e, i, a, "_newKeyGetter", this),
                r = 0; r < t.length; r++) {
                    if (null != (s = i[o = n[r]]))
                        (u = s.length) ? (1 === u && (i[o] = null),
                        s = s.unshift()) : i[o] = null,
                        this._update && this._update(s, r);
                    else
                        this._remove && this._remove(r)
                }
                for (var r = 0; r < a.length; r++) {
                    var o = a[r];
                    if (i.hasOwnProperty(o)) {
                        var s;
                        if (null == (s = i[o]))
                            continue;
                        if (s.length)
                            for (var l = 0, u = s.length; l < u; l++)
                                this._add && this._add(s[l]);
                        else
                            this._add && this._add(s)
                    }
                }
            }
        };
        var wp = _p
          , Sp = it.each
          , Mp = it.createHashMap
          , Ip = Mp(["tooltip", "label", "itemName", "itemId", "seriesName"]);
        var Ap = {
            OTHER_DIMENSIONS: Ip,
            summarizeDimensions: function(n) {
                var t = {}
                  , r = t.encode = {}
                  , o = Mp()
                  , s = []
                  , l = [];
                Sp(n.dimensions, function(t) {
                    var a = n.getDimensionInfo(t)
                      , e = a.coordDim;
                    if (e) {
                        var i = r[e];
                        r.hasOwnProperty(e) || (i = r[e] = []),
                        i[a.coordDimIndex] = t,
                        a.isExtraCoord || (o.set(e, 1),
                        function(t) {
                            return !("ordinal" === t || "time" === t)
                        }(a.type) && (s[0] = t)),
                        a.defaultTooltip && l.push(t)
                    }
                    Ip.each(function(t, e) {
                        var i = r[e];
                        r.hasOwnProperty(e) || (i = r[e] = []);
                        var n = a.otherDims[e];
                        null != n && !1 !== n && (i[n] = a.name)
                    })
                });
                var a = []
                  , u = {};
                o.each(function(t, e) {
                    var i = r[e];
                    u[e] = i[0],
                    a = a.concat(i)
                }),
                t.dataDimsOnCoord = a,
                t.encodeFirstDimNotExtra = u;
                var e = r.label;
                e && e.length && (s = e.slice());
                var i = r.tooltip;
                return i && i.length ? l = i.slice() : l.length || (l = s.slice()),
                r.defaultedLabel = s,
                r.defaultedTooltip = l,
                t
            },
            getDimensionTypeByAxis: function(t) {
                return "category" === t ? "ordinal" : "time" === t ? "time" : "float"
            }
        }
          , Tp = Uh.defaultDimValueGetters
          , Cp = Uh.DefaultDataProvider
          , Dp = Ap.summarizeDimensions
          , Lp = it.isObject
          , Pp = "undefined"
          , kp = {
            float: typeof Float64Array == Pp ? Array : Float64Array,
            int: typeof Int32Array == Pp ? Array : Int32Array,
            ordinal: Array,
            number: Array,
            time: Array
        }
          , Op = typeof Uint32Array == Pp ? Array : Uint32Array
          , Rp = typeof Int32Array == Pp ? Array : Int32Array
          , Np = typeof Uint16Array == Pp ? Array : Uint16Array;
        function Ep(t) {
            return 65535 < t._rawCount ? Op : Np
        }
        var zp = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_rawData", "_chunkSize", "_chunkCount", "_dimValueGetter", "_count", "_rawCount", "_nameDimIdx", "_idDimIdx"]
          , Vp = ["_extent", "_approximateExtent", "_rawExtent"];
        function Bp(e, i) {
            it.each(zp.concat(i.__wrappedMethods || []), function(t) {
                i.hasOwnProperty(t) && (e[t] = i[t])
            }),
            e.__wrappedMethods = i.__wrappedMethods,
            it.each(Vp, function(t) {
                e[t] = it.clone(i[t])
            }),
            e._calculationInfo = it.extend(i._calculationInfo)
        }
        function Gp(t, e) {
            t = t || ["x", "y"];
            for (var i = {}, n = [], a = {}, r = 0; r < t.length; r++) {
                var o = t[r];
                it.isString(o) && (o = {
                    name: o
                });
                var s = o.name;
                o.type = o.type || "float",
                o.coordDim || (o.coordDim = s,
                o.coordDimIndex = 0),
                o.otherDims = o.otherDims || {},
                n.push(s),
                (i[s] = o).index = r,
                o.createInvertedIndices && (a[s] = [])
            }
            this.dimensions = n,
            this._dimensionInfos = i,
            this.hostModel = e,
            this.dataType,
            this._indices = null,
            this._count = 0,
            this._rawCount = 0,
            this._storage = {},
            this._nameList = [],
            this._idList = [],
            this._optionModels = [],
            this._visual = {},
            this._layout = {},
            this._itemVisuals = [],
            this.hasItemVisual = {},
            this._itemLayouts = [],
            this._graphicEls = [],
            this._chunkSize = 1e5,
            this._chunkCount = 0,
            this._rawData,
            this._rawExtent = {},
            this._extent = {},
            this._approximateExtent = {},
            this._dimensionsSummary = Dp(this),
            this._invertedIndicesMap = a,
            this._calculationInfo = {}
        }
        var Fp = Gp.prototype;
        function Hp(t, e, i, n, a) {
            var r = kp[e.type]
              , o = n - 1
              , s = e.name
              , l = t[s][o];
            if (l && l.length < i) {
                for (var u = new r(Math.min(a - o * i, i)), h = 0; h < l.length; h++)
                    u[h] = l[h];
                t[s][o] = u
            }
            for (var c = n * i; c < a; c += i)
                t[s].push(new r(Math.min(a - c, i)))
        }
        function Wp(a) {
            var r = a._invertedIndicesMap;
            it.each(r, function(t, e) {
                var i = a._dimensionInfos[e].ordinalMeta;
                if (i) {
                    t = r[e] = new Rp(i.categories.length);
                    for (var n = 0; n < t.length; n++)
                        t[n] = -1;
                    for (n = 0; n < a._count; n++)
                        t[a.get(e, n)] = n
                }
            })
        }
        function Zp(t, e, i) {
            var n;
            if (null != e) {
                var a = t._chunkSize
                  , r = Math.floor(i / a)
                  , o = i % a
                  , s = t.dimensions[e]
                  , l = t._storage[s][r];
                if (l) {
                    n = l[o];
                    var u = t._dimensionInfos[s].ordinalMeta;
                    u && u.categories.length && (n = u.categories[n])
                }
            }
            return n
        }
        function Up(t) {
            return t
        }
        function Yp(t) {
            return t < this._count && 0 <= t ? this._indices[t] : -1
        }
        function jp(t, e) {
            var i = t._idList[e];
            return null == i && (i = Zp(t, t._idDimIdx, e)),
            null == i && (i = "e\0\0" + e),
            i
        }
        function Xp(t) {
            return it.isArray(t) || (t = [t]),
            t
        }
        function qp(t, e) {
            var i = t.dimensions
              , n = new Gp(it.map(i, t.getDimensionInfo, t),t.hostModel);
            Bp(n, t);
            for (var a = n._storage = {}, r = t._storage, o = 0; o < i.length; o++) {
                var s = i[o];
                r[s] && (0 <= it.indexOf(e, s) ? (a[s] = Kp(r[s]),
                n._rawExtent[s] = $p(),
                n._extent[s] = null) : a[s] = r[s])
            }
            return n
        }
        function Kp(t) {
            for (var e, i, n = new Array(t.length), a = 0; a < t.length; a++)
                n[a] = (e = t[a],
                i = void 0,
                (i = e.constructor) === Array ? e.slice() : new i(e));
            return n
        }
        function $p() {
            return [1 / 0, -1 / 0]
        }
        Fp.type = "list",
        Fp.hasItemOption = !0,
        Fp.getDimension = function(t) {
            return isNaN(t) || (t = this.dimensions[t] || t),
            t
        }
        ,
        Fp.getDimensionInfo = function(t) {
            return this._dimensionInfos[this.getDimension(t)]
        }
        ,
        Fp.getDimensionsOnCoord = function() {
            return this._dimensionsSummary.dataDimsOnCoord.slice()
        }
        ,
        Fp.mapDimension = function(t, e) {
            var i = this._dimensionsSummary;
            if (null == e)
                return i.encodeFirstDimNotExtra[t];
            var n = i.encode[t];
            return !0 === e ? (n || []).slice() : n && n[e]
        }
        ,
        Fp.initData = function(t, e, i) {
            (Ql.isInstance(t) || it.isArrayLike(t)) && (t = new Cp(t,this.dimensions.length)),
            this._rawData = t,
            this._storage = {},
            this._indices = null,
            this._nameList = e || [],
            this._idList = [],
            this._nameRepeatCount = {},
            i || (this.hasItemOption = !1),
            this.defaultDimValueGetter = Tp[this._rawData.getSource().sourceFormat],
            this._dimValueGetter = i = i || this.defaultDimValueGetter,
            this._dimValueGetterArrayRows = Tp.arrayRows,
            this._rawExtent = {},
            this._initDataFromProvider(0, t.count()),
            t.pure && (this.hasItemOption = !1)
        }
        ,
        Fp.getProvider = function() {
            return this._rawData
        }
        ,
        Fp.appendData = function(t) {
            var e = this._rawData
              , i = this.count();
            e.appendData(t);
            var n = e.count();
            e.persistent || (n += i),
            this._initDataFromProvider(i, n)
        }
        ,
        Fp.appendValues = function(t, e) {
            for (var i = this._chunkSize, n = this._storage, a = this.dimensions, r = a.length, o = this._rawExtent, s = this.count(), l = s + Math.max(t.length, e ? e.length : 0), u = this._chunkCount, h = 0; h < r; h++) {
                o[v = a[h]] || (o[v] = $p()),
                n[v] || (n[v] = []),
                Hp(n, this._dimensionInfos[v], i, u, l),
                this._chunkCount = n[v].length
            }
            for (var c = new Array(r), d = s; d < l; d++) {
                for (var p = d - s, f = Math.floor(d / i), g = d % i, m = 0; m < r; m++) {
                    var v = a[m]
                      , y = this._dimValueGetterArrayRows(t[p] || c, v, p, m);
                    n[v][f][g] = y;
                    var x = o[v];
                    y < x[0] && (x[0] = y),
                    y > x[1] && (x[1] = y)
                }
                e && (this._nameList[d] = e[p])
            }
            this._rawCount = this._count = l,
            this._extent = {},
            Wp(this)
        }
        ,
        Fp._initDataFromProvider = function(t, e) {
            if (!(e <= t)) {
                for (var i, n = this._chunkSize, a = this._rawData, r = this._storage, o = this.dimensions, s = o.length, l = this._dimensionInfos, u = this._nameList, h = this._idList, c = this._rawExtent, d = this._nameRepeatCount = {}, p = this._chunkCount, f = 0; f < s; f++) {
                    c[b = o[f]] || (c[b] = $p());
                    var g = l[b];
                    0 === g.otherDims.itemName && (i = this._nameDimIdx = f),
                    0 === g.otherDims.itemId && (this._idDimIdx = f),
                    r[b] || (r[b] = []),
                    Hp(r, g, n, p, e),
                    this._chunkCount = r[b].length
                }
                for (var m = new Array(s), v = t; v < e; v++) {
                    m = a.getItem(v, m);
                    for (var y = Math.floor(v / n), x = v % n, _ = 0; _ < s; _++) {
                        var b, w = r[b = o[_]][y], S = this._dimValueGetter(m, b, v, _);
                        w[x] = S;
                        var M = c[b];
                        S < M[0] && (M[0] = S),
                        S > M[1] && (M[1] = S)
                    }
                    if (!a.pure) {
                        var I = u[v];
                        if (m && null == I)
                            if (null != m.name)
                                u[v] = I = m.name;
                            else if (null != i) {
                                var A = o[i]
                                  , T = r[A][y];
                                if (T) {
                                    I = T[x];
                                    var C = l[A].ordinalMeta;
                                    C && C.categories.length && (I = C.categories[I])
                                }
                            }
                        var D = null == m ? null : m.id;
                        null == D && null != I && (d[I] = d[I] || 0,
                        0 < d[D = I] && (D += "__ec__" + d[I]),
                        d[I]++),
                        null != D && (h[v] = D)
                    }
                }
                !a.persistent && a.clean && a.clean(),
                this._rawCount = this._count = e,
                this._extent = {},
                Wp(this)
            }
        }
        ,
        Fp.count = function() {
            return this._count
        }
        ,
        Fp.getIndices = function() {
            var t = this._indices;
            if (t) {
                var e = t.constructor
                  , i = this._count;
                if (e === Array) {
                    a = new e(i);
                    for (var n = 0; n < i; n++)
                        a[n] = t[n]
                } else
                    a = new e(t.buffer,0,i)
            } else {
                var a = new (e = Ep(this))(this.count());
                for (n = 0; n < a.length; n++)
                    a[n] = n
            }
            return a
        }
        ,
        Fp.get = function(t, e) {
            if (!(0 <= e && e < this._count))
                return NaN;
            var i = this._storage;
            if (!i[t])
                return NaN;
            e = this.getRawIndex(e);
            var n = Math.floor(e / this._chunkSize)
              , a = e % this._chunkSize;
            return i[t][n][a]
        }
        ,
        Fp.getByRawIndex = function(t, e) {
            if (!(0 <= e && e < this._rawCount))
                return NaN;
            var i = this._storage[t];
            if (!i)
                return NaN;
            var n = Math.floor(e / this._chunkSize)
              , a = e % this._chunkSize;
            return i[n][a]
        }
        ,
        Fp._getFast = function(t, e) {
            var i = Math.floor(e / this._chunkSize)
              , n = e % this._chunkSize;
            return this._storage[t][i][n]
        }
        ,
        Fp.getValues = function(t, e) {
            var i = [];
            it.isArray(t) || (e = t,
            t = this.dimensions);
            for (var n = 0, a = t.length; n < a; n++)
                i.push(this.get(t[n], e));
            return i
        }
        ,
        Fp.hasValue = function(t) {
            for (var e = this._dimensionsSummary.dataDimsOnCoord, i = this._dimensionInfos, n = 0, a = e.length; n < a; n++)
                if ("ordinal" !== i[e[n]].type && isNaN(this.get(e[n], t)))
                    return !1;
            return !0
        }
        ,
        Fp.getDataExtent = function(t) {
            t = this.getDimension(t);
            var e = this._storage[t]
              , i = $p();
            if (!e)
                return i;
            var n, a = this.count();
            if (!this._indices)
                return this._rawExtent[t].slice();
            if (n = this._extent[t])
                return n.slice();
            for (var r = (n = i)[0], o = n[1], s = 0; s < a; s++) {
                var l = this._getFast(t, this.getRawIndex(s));
                l < r && (r = l),
                o < l && (o = l)
            }
            return n = [r, o],
            this._extent[t] = n
        }
        ,
        Fp.getApproximateExtent = function(t) {
            return t = this.getDimension(t),
            this._approximateExtent[t] || this.getDataExtent(t)
        }
        ,
        Fp.setApproximateExtent = function(t, e) {
            e = this.getDimension(e),
            this._approximateExtent[e] = t.slice()
        }
        ,
        Fp.getCalculationInfo = function(t) {
            return this._calculationInfo[t]
        }
        ,
        Fp.setCalculationInfo = function(t, e) {
            Lp(t) ? it.extend(this._calculationInfo, t) : this._calculationInfo[t] = e
        }
        ,
        Fp.getSum = function(t) {
            var e = 0;
            if (this._storage[t])
                for (var i = 0, n = this.count(); i < n; i++) {
                    var a = this.get(t, i);
                    isNaN(a) || (e += a)
                }
            return e
        }
        ,
        Fp.getMedian = function(t) {
            var i = [];
            this.each(t, function(t, e) {
                isNaN(t) || i.push(t)
            });
            var e = [].concat(i).sort(function(t, e) {
                return t - e
            })
              , n = this.count();
            return 0 === n ? 0 : n % 2 == 1 ? e[(n - 1) / 2] : (e[n / 2] + e[n / 2 - 1]) / 2
        }
        ,
        Fp.rawIndexOf = function(t, e) {
            var i = (t && this._invertedIndicesMap[t])[e];
            return null == i || isNaN(i) ? -1 : i
        }
        ,
        Fp.indexOfName = function(t) {
            for (var e = 0, i = this.count(); e < i; e++)
                if (this.getName(e) === t)
                    return e;
            return -1
        }
        ,
        Fp.indexOfRawIndex = function(t) {
            if (!this._indices)
                return t;
            if (t >= this._rawCount || t < 0)
                return -1;
            var e = this._indices
              , i = e[t];
            if (null != i && i < this._count && i === t)
                return t;
            for (var n = 0, a = this._count - 1; n <= a; ) {
                var r = (n + a) / 2 | 0;
                if (e[r] < t)
                    n = 1 + r;
                else {
                    if (!(e[r] > t))
                        return r;
                    a = r - 1
                }
            }
            return -1
        }
        ,
        Fp.indicesOfNearest = function(t, e, i) {
            var n = [];
            if (!this._storage[t])
                return n;
            null == i && (i = 1 / 0);
            for (var a = Number.MAX_VALUE, r = -1, o = 0, s = this.count(); o < s; o++) {
                var l = e - this.get(t, o)
                  , u = Math.abs(l);
                l <= i && u <= a && ((u < a || 0 <= l && r < 0) && (a = u,
                r = l,
                n.length = 0),
                n.push(o))
            }
            return n
        }
        ,
        Fp.getRawIndex = Up,
        Fp.getRawDataItem = function(t) {
            if (this._rawData.persistent)
                return this._rawData.getItem(this.getRawIndex(t));
            for (var e = [], i = 0; i < this.dimensions.length; i++) {
                var n = this.dimensions[i];
                e.push(this.get(n, t))
            }
            return e
        }
        ,
        Fp.getName = function(t) {
            var e = this.getRawIndex(t);
            return this._nameList[e] || Zp(this, this._nameDimIdx, e) || ""
        }
        ,
        Fp.getId = function(t) {
            return jp(this, this.getRawIndex(t))
        }
        ,
        Fp.each = function(t, e, i, n) {
            if (this._count) {
                "function" == typeof t && (n = i,
                i = e,
                e = t,
                t = []),
                i = i || n || this;
                for (var a = (t = it.map(Xp(t), this.getDimension, this)).length, r = 0; r < this.count(); r++)
                    switch (a) {
                    case 0:
                        e.call(i, r);
                        break;
                    case 1:
                        e.call(i, this.get(t[0], r), r);
                        break;
                    case 2:
                        e.call(i, this.get(t[0], r), this.get(t[1], r), r);
                        break;
                    default:
                        for (var o = 0, s = []; o < a; o++)
                            s[o] = this.get(t[o], r);
                        s[o] = r,
                        e.apply(i, s)
                    }
            }
        }
        ,
        Fp.filterSelf = function(t, e, i, n) {
            if (this._count) {
                "function" == typeof t && (n = i,
                i = e,
                e = t,
                t = []),
                i = i || n || this,
                t = it.map(Xp(t), this.getDimension, this);
                for (var a = this.count(), r = new (Ep(this))(a), o = [], s = t.length, l = 0, u = t[0], h = 0; h < a; h++) {
                    var c, d = this.getRawIndex(h);
                    if (0 === s)
                        c = e.call(i, h);
                    else if (1 === s) {
                        var p = this._getFast(u, d);
                        c = e.call(i, p, h)
                    } else {
                        for (var f = 0; f < s; f++)
                            o[f] = this._getFast(u, d);
                        o[f] = h,
                        c = e.apply(i, o)
                    }
                    c && (r[l++] = d)
                }
                return l < a && (this._indices = r),
                this._count = l,
                this._extent = {},
                this.getRawIndex = this._indices ? Yp : Up,
                this
            }
        }
        ,
        Fp.selectRange = function(t) {
            if (this._count) {
                var e = [];
                for (var i in t)
                    t.hasOwnProperty(i) && e.push(i);
                var n = e.length;
                if (n) {
                    var a = this.count()
                      , r = new (Ep(this))(a)
                      , o = 0
                      , s = e[0]
                      , l = t[s][0]
                      , u = t[s][1]
                      , h = !1;
                    if (!this._indices) {
                        var c = 0;
                        if (1 === n) {
                            for (var d = this._storage[e[0]], p = 0; p < this._chunkCount; p++)
                                for (var f = d[p], g = Math.min(this._count - p * this._chunkSize, this._chunkSize), m = 0; m < g; m++) {
                                    (l <= (b = f[m]) && b <= u || isNaN(b)) && (r[o++] = c),
                                    c++
                                }
                            h = !0
                        } else if (2 === n) {
                            d = this._storage[s];
                            var v = this._storage[e[1]]
                              , y = t[e[1]][0]
                              , x = t[e[1]][1];
                            for (p = 0; p < this._chunkCount; p++) {
                                f = d[p];
                                var _ = v[p];
                                for (g = Math.min(this._count - p * this._chunkSize, this._chunkSize),
                                m = 0; m < g; m++) {
                                    var b = f[m]
                                      , w = _[m];
                                    (l <= b && b <= u || isNaN(b)) && (y <= w && w <= x || isNaN(w)) && (r[o++] = c),
                                    c++
                                }
                            }
                            h = !0
                        }
                    }
                    if (!h)
                        if (1 === n)
                            for (m = 0; m < a; m++) {
                                var S = this.getRawIndex(m);
                                (l <= (b = this._getFast(s, S)) && b <= u || isNaN(b)) && (r[o++] = S)
                            }
                        else
                            for (m = 0; m < a; m++) {
                                var M = !0;
                                for (S = this.getRawIndex(m),
                                p = 0; p < n; p++) {
                                    var I = e[p];
                                    ((b = this._getFast(i, S)) < t[I][0] || b > t[I][1]) && (M = !1)
                                }
                                M && (r[o++] = this.getRawIndex(m))
                            }
                    return o < a && (this._indices = r),
                    this._count = o,
                    this._extent = {},
                    this.getRawIndex = this._indices ? Yp : Up,
                    this
                }
            }
        }
        ,
        Fp.mapArray = function(t, e, i, n) {
            "function" == typeof t && (n = i,
            i = e,
            e = t,
            t = []),
            i = i || n || this;
            var a = [];
            return this.each(t, function() {
                a.push(e && e.apply(this, arguments))
            }, i),
            a
        }
        ,
        Fp.map = function(t, e, i, n) {
            i = i || n || this;
            var a = qp(this, t = it.map(Xp(t), this.getDimension, this));
            a._indices = this._indices,
            a.getRawIndex = a._indices ? Yp : Up;
            for (var r = a._storage, o = [], s = this._chunkSize, l = t.length, u = this.count(), h = [], c = a._rawExtent, d = 0; d < u; d++) {
                for (var p = 0; p < l; p++)
                    h[p] = this.get(t[p], d);
                h[l] = d;
                var f = e && e.apply(i, h);
                if (null != f) {
                    "object" != typeof f && (o[0] = f,
                    f = o);
                    for (var g = this.getRawIndex(d), m = Math.floor(g / s), v = g % s, y = 0; y < f.length; y++) {
                        var x = t[y]
                          , _ = f[y]
                          , b = c[x]
                          , w = r[x];
                        w && (w[m][v] = _),
                        _ < b[0] && (b[0] = _),
                        _ > b[1] && (b[1] = _)
                    }
                }
            }
            return a
        }
        ,
        Fp.downSample = function(t, e, i, n) {
            for (var a = qp(this, [t]), r = a._storage, o = [], s = Math.floor(1 / e), l = r[t], u = this.count(), h = this._chunkSize, c = a._rawExtent[t], d = new (Ep(this))(u), p = 0, f = 0; f < u; f += s) {
                u - f < s && (s = u - f,
                o.length = s);
                for (var g = 0; g < s; g++) {
                    var m = this.getRawIndex(f + g)
                      , v = Math.floor(m / h)
                      , y = m % h;
                    o[g] = l[v][y]
                }
                var x = i(o)
                  , _ = this.getRawIndex(Math.min(f + n(o, x) || 0, u - 1))
                  , b = _ % h;
                (l[Math.floor(_ / h)][b] = x) < c[0] && (c[0] = x),
                x > c[1] && (c[1] = x),
                d[p++] = _
            }
            return a._count = p,
            a._indices = d,
            a.getRawIndex = Yp,
            a
        }
        ,
        Fp.getItemModel = function(t) {
            var e = this.hostModel;
            return new tl(this.getRawDataItem(t),e,e && e.ecModel)
        }
        ,
        Fp.diff = function(e) {
            var i = this;
            return new wp(e ? e.getIndices() : [],this.getIndices(),function(t) {
                return jp(e, t)
            }
            ,function(t) {
                return jp(i, t)
            }
            )
        }
        ,
        Fp.getVisual = function(t) {
            var e = this._visual;
            return e && e[t]
        }
        ,
        Fp.setVisual = function(t, e) {
            if (Lp(t))
                for (var i in t)
                    t.hasOwnProperty(i) && this.setVisual(i, t[i]);
            else
                this._visual = this._visual || {},
                this._visual[t] = e
        }
        ,
        Fp.setLayout = function(t, e) {
            if (Lp(t))
                for (var i in t)
                    t.hasOwnProperty(i) && this.setLayout(i, t[i]);
            else
                this._layout[t] = e
        }
        ,
        Fp.getLayout = function(t) {
            return this._layout[t]
        }
        ,
        Fp.getItemLayout = function(t) {
            return this._itemLayouts[t]
        }
        ,
        Fp.setItemLayout = function(t, e, i) {
            this._itemLayouts[t] = i ? it.extend(this._itemLayouts[t] || {}, e) : e
        }
        ,
        Fp.clearItemLayouts = function() {
            this._itemLayouts.length = 0
        }
        ,
        Fp.getItemVisual = function(t, e, i) {
            var n = this._itemVisuals[t]
              , a = n && n[e];
            return null != a || i ? a : this.getVisual(e)
        }
        ,
        Fp.setItemVisual = function(t, e, i) {
            var n = this._itemVisuals[t] || {}
              , a = this.hasItemVisual;
            if (this._itemVisuals[t] = n,
            Lp(e))
                for (var r in e)
                    e.hasOwnProperty(r) && (n[r] = e[r],
                    a[r] = !0);
            else
                n[e] = i,
                a[e] = !0
        }
        ,
        Fp.clearAllVisual = function() {
            this._visual = {},
            this._itemVisuals = [],
            this.hasItemVisual = {}
        }
        ;
        function Jp(t) {
            t.seriesIndex = this.seriesIndex,
            t.dataIndex = this.dataIndex,
            t.dataType = this.dataType
        }
        Fp.setItemGraphicEl = function(t, e) {
            var i = this.hostModel;
            e && (e.dataIndex = t,
            e.dataType = this.dataType,
            e.seriesIndex = i && i.seriesIndex,
            "group" === e.type && e.traverse(Jp, e)),
            this._graphicEls[t] = e
        }
        ,
        Fp.getItemGraphicEl = function(t) {
            return this._graphicEls[t]
        }
        ,
        Fp.eachItemGraphicEl = function(i, n) {
            it.each(this._graphicEls, function(t, e) {
                t && i && i.call(n, t, e)
            })
        }
        ,
        Fp.cloneShallow = function(t) {
            if (!t) {
                var e = it.map(this.dimensions, this.getDimensionInfo, this);
                t = new Gp(e,this.hostModel)
            }
            if (t._storage = this._storage,
            Bp(t, this),
            this._indices) {
                var i = this._indices.constructor;
                t._indices = new i(this._indices)
            } else
                t._indices = null;
            return t.getRawIndex = t._indices ? Yp : Up,
            t
        }
        ,
        Fp.wrapMethod = function(t, e) {
            var i = this[t];
            "function" == typeof i && (this.__wrappedMethods = this.__wrappedMethods || [],
            this.__wrappedMethods.push(t),
            this[t] = function() {
                var t = i.apply(this, arguments);
                return e.apply(this, [t].concat(it.slice(arguments)))
            }
            )
        }
        ,
        Fp.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "map"],
        Fp.CHANGABLE_METHODS = ["filterSelf", "selectRange"];
        var Qp = Gp
          , tf = it.createHashMap
          , ef = it.each
          , nf = it.isString
          , af = it.defaults
          , rf = it.extend
          , of = it.isObject
          , sf = it.clone
          , lf = aa.normalizeToArray
          , uf = Su.guessOrdinal
          , hf = Ap.OTHER_DIMENSIONS;
        function cf(t, e, i) {
            if (i || null != e.get(t)) {
                for (var n = 0; null != e.get(t + n); )
                    n++;
                t += n
            }
            return e.set(t, !0),
            t
        }
        var df = function(t, e, i) {
            Ql.isInstance(e) || (e = Ql.seriesDataToSource(e)),
            i = i || {},
            t = (t || []).slice();
            for (var n = (i.dimsDef || []).slice(), l = tf(i.encodeDef), a = tf(), r = tf(), u = [], o = function(t, e, i, n) {
                var a = Math.max(t.dimensionsDetectCount || 1, e.length, i.length, n || 0);
                return ef(e, function(t) {
                    var e = t.dimsDef;
                    e && (a = Math.max(a, e.length))
                }),
                a
            }(e, t, n, i.dimCount), s = 0; s < o; s++) {
                var h = n[s] = rf({}, of(n[s]) ? n[s] : {
                    name: n[s]
                })
                  , c = h.name
                  , d = u[s] = {
                    otherDims: {}
                };
                null != c && null == a.get(c) && (d.name = d.displayName = c,
                a.set(c, s)),
                null != h.type && (d.type = h.type),
                null != h.displayName && (d.displayName = h.displayName)
            }
            l.each(function(t, i) {
                if (1 === (t = lf(t).slice()).length && t[0] < 0)
                    l.set(i, !1);
                else {
                    var n = l.set(i, []);
                    ef(t, function(t, e) {
                        nf(t) && (t = a.get(t)),
                        null != t && t < o && (n[e] = t,
                        f(u[t], i, e))
                    })
                }
            });
            var p = 0;
            function f(t, e, i) {
                null != hf.get(e) ? t.otherDims[e] = i : (t.coordDim = e,
                t.coordDimIndex = i,
                r.set(e, !0))
            }
            ef(t, function(a, t) {
                var r, o, s;
                if (nf(a))
                    r = a,
                    a = {};
                else {
                    r = a.name;
                    var e = a.ordinalMeta;
                    a.ordinalMeta = null,
                    (a = sf(a)).ordinalMeta = e,
                    o = a.dimsDef,
                    s = a.otherDims,
                    a.name = a.coordDim = a.coordDimIndex = a.dimsDef = a.otherDims = null
                }
                if (!1 !== (i = l.get(r))) {
                    var i;
                    if (!(i = lf(i)).length)
                        for (var n = 0; n < (o && o.length || 1); n++) {
                            for (; p < u.length && null != u[p].coordDim; )
                                p++;
                            p < u.length && i.push(p++)
                        }
                    ef(i, function(t, e) {
                        var i = u[t];
                        if (f(af(i, a), r, e),
                        null == i.name && o) {
                            var n = o[e];
                            of(n) || (n = {
                                name: n
                            }),
                            i.name = i.displayName = n.name,
                            i.defaultTooltip = n.defaultTooltip
                        }
                        s && af(i.otherDims, s)
                    })
                }
            });
            var g = i.generateCoord
              , m = i.generateCoordCount
              , v = null != m;
            m = g ? m || 1 : 0;
            for (var y = g || "value", x = 0; x < o; x++) {
                null == (d = u[x] = u[x] || {}).coordDim && (d.coordDim = cf(y, r, v),
                d.coordDimIndex = 0,
                (!g || m <= 0) && (d.isExtraCoord = !0),
                m--),
                null == d.name && (d.name = cf(d.coordDim, a)),
                null == d.type && uf(e, x, d.name) && (d.type = "ordinal")
            }
            return u
        };
        var pf = function(t, e) {
            return df((e = e || {}).coordDimensions || [], t, {
                dimsDef: e.dimensionsDefine || t.dimensionsDefine,
                encodeDef: e.encodeDefine || t.encodeDefine,
                dimCount: e.dimensionsCount,
                generateCoord: e.generateCoord,
                generateCoordCount: e.generateCoordCount
            })
        }
          , ff = it.each
          , gf = it.isString;
        function mf(t, e) {
            return !!e && e === t.getCalculationInfo("stackedDimension")
        }
        var vf = {
            enableDataStack: function(t, i, e) {
                var n, a, r, o, s = (e = e || {}).byIndex, l = e.stackedCoordDimension, u = !(!t || !t.get("stack"));
                if (ff(i, function(t, e) {
                    gf(t) && (i[e] = t = {
                        name: t
                    }),
                    u && !t.isExtraCoord && (s || n || !t.ordinalMeta || (n = t),
                    a || "ordinal" === t.type || "time" === t.type || l && l !== t.coordDim || (a = t))
                }),
                !a || s || n || (s = !0),
                a) {
                    r = "__\0ecstackresult",
                    o = "__\0ecstackedover",
                    n && (n.createInvertedIndices = !0);
                    var h = a.coordDim
                      , c = a.type
                      , d = 0;
                    ff(i, function(t) {
                        t.coordDim === h && d++
                    }),
                    i.push({
                        name: r,
                        coordDim: h,
                        coordDimIndex: d,
                        type: c,
                        isExtraCoord: !0,
                        isCalculationCoord: !0
                    }),
                    d++,
                    i.push({
                        name: o,
                        coordDim: o,
                        coordDimIndex: d,
                        type: c,
                        isExtraCoord: !0,
                        isCalculationCoord: !0
                    })
                }
                return {
                    stackedDimension: a && a.name,
                    stackedByDimension: n && n.name,
                    isStackedByIndex: s,
                    stackedOverDimension: o,
                    stackResultDimension: r
                }
            },
            isDimensionStacked: mf,
            getStackedDimension: function(t, e) {
                return mf(t, e) ? t.getCalculationInfo("stackResultDimension") : e
            }
        }
          , yf = Wl.SOURCE_FORMAT_ORIGINAL
          , xf = Ap.getDimensionTypeByAxis
          , _f = aa.getDataItemValue
          , bf = Hl.getCoordSysDefineBySeries
          , wf = vf.enableDataStack;
        var Sf = function(t, e, i) {
            i = i || {},
            Ql.isInstance(t) || (t = Ql.seriesDataToSource(t));
            var n, a = e.get("coordinateSystem"), r = ju.get(a), o = bf(e);
            o && (n = it.map(o.coordSysDims, function(t) {
                var e = {
                    name: t
                }
                  , i = o.axisMap.get(t);
                if (i) {
                    var n = i.get("type");
                    e.type = xf(n)
                }
                return e
            })),
            n = n || (r && (r.getDimensionsInfo ? r.getDimensionsInfo() : r.dimensions.slice()) || ["x", "y"]);
            var s, l, u = pf(t, {
                coordDimensions: n,
                generateCoord: i.generateCoord
            });
            o && it.each(u, function(t, e) {
                var i = t.coordDim
                  , n = o.categoryAxisMap.get(i);
                n && (null == s && (s = e),
                t.ordinalMeta = n.getOrdinalMeta()),
                null != t.otherDims.itemName && (l = !0)
            }),
            l || null == s || (u[s].otherDims.itemName = 0);
            var h = wf(e, u)
              , c = new Qp(u,e);
            c.setCalculationInfo(h);
            var d = null != s && function(t) {
                if (t.sourceFormat === yf) {
                    var e = function(t) {
                        var e = 0;
                        for (; e < t.length && null == t[e]; )
                            e++;
                        return t[e]
                    }(t.data || []);
                    return null != e && !it.isArray(_f(e))
                }
            }(t) ? function(t, e, i, n) {
                return n === s ? i : this.defaultDimValueGetter(t, e, i, n)
            }
            : null;
            return c.hasItemOption = !1,
            c.initData(t, null, d),
            c
        };
        function Mf(t) {
            this._setting = t || {},
            this._extent = [1 / 0, -1 / 0],
            this._interval = 0,
            this.init && this.init.apply(this, arguments)
        }
        Mf.prototype.parse = function(t) {
            return t
        }
        ,
        Mf.prototype.getSetting = function(t) {
            return this._setting[t]
        }
        ,
        Mf.prototype.contain = function(t) {
            var e = this._extent;
            return t >= e[0] && t <= e[1]
        }
        ,
        Mf.prototype.normalize = function(t) {
            var e = this._extent;
            return e[1] === e[0] ? .5 : (t - e[0]) / (e[1] - e[0])
        }
        ,
        Mf.prototype.scale = function(t) {
            var e = this._extent;
            return t * (e[1] - e[0]) + e[0]
        }
        ,
        Mf.prototype.unionExtent = function(t) {
            var e = this._extent;
            t[0] < e[0] && (e[0] = t[0]),
            t[1] > e[1] && (e[1] = t[1])
        }
        ,
        Mf.prototype.unionExtentFromData = function(t, e) {
            this.unionExtent(t.getApproximateExtent(e))
        }
        ,
        Mf.prototype.getExtent = function() {
            return this._extent.slice()
        }
        ,
        Mf.prototype.setExtent = function(t, e) {
            var i = this._extent;
            isNaN(t) || (i[0] = t),
            isNaN(e) || (i[1] = e)
        }
        ,
        Mf.prototype.isBlank = function() {
            return this._isBlank
        }
        ,
        Mf.prototype.setBlank = function(t) {
            this._isBlank = t
        }
        ,
        Mf.prototype.getLabel = null,
        ca.enableClassExtend(Mf),
        ca.enableClassManagement(Mf, {
            registerWhenExtend: !0
        });
        var If = Mf
          , Af = it.createHashMap
          , Tf = it.isObject
          , Cf = it.map;
        function Df(t) {
            this.categories = t.categories || [],
            this._needCollect = t.needCollect,
            this._deduplication = t.deduplication,
            this._map
        }
        Df.createByAxisModel = function(t) {
            var e = t.option
              , i = e.data
              , n = i && Cf(i, kf);
            return new Df({
                categories: n,
                needCollect: !n,
                deduplication: !1 !== e.dedplication
            })
        }
        ;
        var Lf = Df.prototype;
        function Pf(t) {
            return t._map || (t._map = Af(t.categories))
        }
        function kf(t) {
            return Tf(t) && null != t.value ? t.value : t + ""
        }
        Lf.getOrdinal = function(t) {
            return Pf(this).get(t)
        }
        ,
        Lf.parseAndCollect = function(t) {
            var e, i = this._needCollect;
            if ("string" != typeof t && !i)
                return t;
            if (i && !this._deduplication)
                return e = this.categories.length,
                this.categories[e] = t,
                e;
            var n = Pf(this);
            return null == (e = n.get(t)) && (i ? (e = this.categories.length,
            this.categories[e] = t,
            n.set(t, e)) : e = NaN),
            e
        }
        ;
        var Of = Df
          , Rf = If.prototype
          , Nf = If.extend({
            type: "ordinal",
            init: function(t, e) {
                t && !it.isArray(t) || (t = new Of({
                    categories: t
                })),
                this._ordinalMeta = t,
                this._extent = e || [0, t.categories.length - 1]
            },
            parse: function(t) {
                return "string" == typeof t ? this._ordinalMeta.getOrdinal(t) : Math.round(t)
            },
            contain: function(t) {
                return t = this.parse(t),
                Rf.contain.call(this, t) && null != this._ordinalMeta.categories[t]
            },
            normalize: function(t) {
                return Rf.normalize.call(this, this.parse(t))
            },
            scale: function(t) {
                return Math.round(Rf.scale.call(this, t))
            },
            getTicks: function() {
                for (var t = [], e = this._extent, i = e[0]; i <= e[1]; )
                    t.push(i),
                    i++;
                return t
            },
            getLabel: function(t) {
                if (!this.isBlank())
                    return this._ordinalMeta.categories[t]
            },
            count: function() {
                return this._extent[1] - this._extent[0] + 1
            },
            unionExtentFromData: function(t, e) {
                this.unionExtent(t.getApproximateExtent(e))
            },
            getOrdinalMeta: function() {
                return this._ordinalMeta
            },
            niceTicks: it.noop,
            niceExtent: it.noop
        });
        Nf.create = function() {
            return new Nf
        }
        ;
        var Ef = Nf
          , zf = ol.round;
        function Vf(t) {
            return ol.getPrecisionSafe(t) + 2
        }
        function Bf(t, e, i) {
            t[e] = Math.max(Math.min(t[e], i[1]), i[0])
        }
        function Gf(t, e) {
            isFinite(t[0]) || (t[0] = e[0]),
            isFinite(t[1]) || (t[1] = e[1]),
            Bf(t, 0, e),
            Bf(t, 1, e),
            t[0] > t[1] && (t[0] = t[1])
        }
        var Ff = {
            intervalScaleNiceTicks: function(t, e, i, n) {
                var a = {}
                  , r = t[1] - t[0]
                  , o = a.interval = ol.nice(r / e, !0);
                null != i && o < i && (o = a.interval = i),
                null != n && n < o && (o = a.interval = n);
                var s = a.intervalPrecision = Vf(o);
                return Gf(a.niceTickExtent = [zf(Math.ceil(t[0] / o) * o, s), zf(Math.floor(t[1] / o) * o, s)], t),
                a
            },
            getIntervalPrecision: Vf,
            fixExtent: Gf,
            intervalScaleGetTicks: function(t, e, i, n) {
                var a = [];
                if (!t)
                    return a;
                e[0] < i[0] && a.push(e[0]);
                for (var r = i[0]; r <= i[1] && (a.push(r),
                (r = zf(r + t, n)) !== a[a.length - 1]); )
                    if (1e4 < a.length)
                        return [];
                return e[1] > (a.length ? a[a.length - 1] : i[1]) && a.push(e[1]),
                a
            }
        }
          , Hf = ol.round
          , Wf = If.extend({
            type: "interval",
            _interval: 0,
            _intervalPrecision: 2,
            setExtent: function(t, e) {
                var i = this._extent;
                isNaN(t) || (i[0] = parseFloat(t)),
                isNaN(e) || (i[1] = parseFloat(e))
            },
            unionExtent: function(t) {
                var e = this._extent;
                t[0] < e[0] && (e[0] = t[0]),
                t[1] > e[1] && (e[1] = t[1]),
                Wf.prototype.setExtent.call(this, e[0], e[1])
            },
            getInterval: function() {
                return this._interval
            },
            setInterval: function(t) {
                this._interval = t,
                this._niceExtent = this._extent.slice(),
                this._intervalPrecision = Ff.getIntervalPrecision(t)
            },
            getTicks: function() {
                return Ff.intervalScaleGetTicks(this._interval, this._extent, this._niceExtent, this._intervalPrecision)
            },
            getLabel: function(t, e) {
                if (null == t)
                    return "";
                var i = e && e.precision;
                return null == i ? i = ol.getPrecisionSafe(t) || 0 : "auto" === i && (i = this._intervalPrecision),
                t = Hf(t, i, !0),
                fl.addCommas(t)
            },
            niceTicks: function(t, e, i) {
                t = t || 5;
                var n = this._extent
                  , a = n[1] - n[0];
                if (isFinite(a)) {
                    a < 0 && (a = -a,
                    n.reverse());
                    var r = Ff.intervalScaleNiceTicks(n, t, e, i);
                    this._intervalPrecision = r.intervalPrecision,
                    this._interval = r.interval,
                    this._niceExtent = r.niceTickExtent
                }
            },
            niceExtent: function(t) {
                var e = this._extent;
                if (e[0] === e[1])
                    if (0 !== e[0]) {
                        var i = e[0];
                        t.fixMax || (e[1] += i / 2),
                        e[0] -= i / 2
                    } else
                        e[1] = 1;
                var n = e[1] - e[0];
                isFinite(n) || (e[0] = 0,
                e[1] = 1),
                this.niceTicks(t.splitNumber, t.minInterval, t.maxInterval);
                var a = this._interval;
                t.fixMin || (e[0] = Hf(Math.floor(e[0] / a) * a)),
                t.fixMax || (e[1] = Hf(Math.ceil(e[1] / a) * a))
            }
        });
        Wf.create = function() {
            return new Wf
        }
        ;
        var Zf = Wf
          , Uf = ol.parsePercent
          , Yf = vf.isDimensionStacked
          , jf = "__ec_stack_"
          , Xf = "undefined" != typeof Float32Array ? Float32Array : Array;
        function qf(t) {
            return t.get("stack") || jf + t.seriesIndex
        }
        function Kf(t) {
            return t.dim + t.index
        }
        function $f(t, e) {
            var i = [];
            return e.eachSeriesByType(t, function(t) {
                ig(t) && !ng(t) && i.push(t)
            }),
            i
        }
        function Jf(t) {
            var u = [];
            return it.each(t, function(t) {
                var e = t.getData()
                  , i = t.coordinateSystem.getBaseAxis()
                  , n = i.getExtent()
                  , a = "category" === i.type ? i.getBandWidth() : Math.abs(n[1] - n[0]) / e.count()
                  , r = Uf(t.get("barWidth"), a)
                  , o = Uf(t.get("barMaxWidth"), a)
                  , s = t.get("barGap")
                  , l = t.get("barCategoryGap");
                u.push({
                    bandWidth: a,
                    barWidth: r,
                    barMaxWidth: o,
                    barGap: s,
                    barCategoryGap: l,
                    axisKey: Kf(i),
                    stackId: qf(t)
                })
            }),
            Qf(u)
        }
        function Qf(t) {
            var c = {};
            it.each(t, function(t, e) {
                var i = t.axisKey
                  , n = t.bandWidth
                  , a = c[i] || {
                    bandWidth: n,
                    remainedWidth: n,
                    autoWidthCount: 0,
                    categoryGap: "20%",
                    gap: "30%",
                    stacks: {}
                }
                  , r = a.stacks;
                c[i] = a;
                var o = t.stackId;
                r[o] || a.autoWidthCount++,
                r[o] = r[o] || {
                    width: 0,
                    maxWidth: 0
                };
                var s = t.barWidth;
                s && !r[o].width && (r[o].width = s,
                s = Math.min(a.remainedWidth, s),
                a.remainedWidth -= s);
                var l = t.barMaxWidth;
                l && (r[o].maxWidth = l);
                var u = t.barGap;
                null != u && (a.gap = u);
                var h = t.barCategoryGap;
                null != h && (a.categoryGap = h)
            });
            var d = {};
            return it.each(c, function(t, i) {
                d[i] = {};
                var e = t.stacks
                  , n = t.bandWidth
                  , a = Uf(t.categoryGap, n)
                  , r = Uf(t.gap, 1)
                  , o = t.remainedWidth
                  , s = t.autoWidthCount
                  , l = (o - a) / (s + (s - 1) * r);
                l = Math.max(l, 0),
                it.each(e, function(t, e) {
                    var i = t.maxWidth;
                    i && i < l && (i = Math.min(i, o),
                    t.width && (i = Math.min(i, t.width)),
                    o -= i,
                    t.width = i,
                    s--)
                }),
                l = (o - a) / (s + (s - 1) * r),
                l = Math.max(l, 0);
                var u, h = 0;
                it.each(e, function(t, e) {
                    t.width || (t.width = l),
                    h += (u = t).width * (1 + r)
                }),
                u && (h -= u.width * r);
                var c = -h / 2;
                it.each(e, function(t, e) {
                    d[i][e] = d[i][e] || {
                        offset: c,
                        width: t.width
                    },
                    c += t.width * (1 + r)
                })
            }),
            d
        }
        function tg(t, e, i) {
            if (t && e) {
                var n = t[Kf(e)];
                return null != n && null != i && (n = n[qf(i)]),
                n
            }
        }
        var eg = {
            seriesType: "bar",
            plan: Ec(),
            reset: function(t) {
                if (ig(t) && ng(t)) {
                    var e = t.getData()
                      , s = t.coordinateSystem
                      , l = s.getBaseAxis()
                      , u = s.getOtherAxis(l)
                      , h = e.mapDimension(u.dim)
                      , c = e.mapDimension(l.dim)
                      , d = u.isHorizontal()
                      , p = d ? 0 : 1
                      , f = tg(Jf([t]), l, t).width;
                    return .5 < f || (f = .5),
                    {
                        progress: function(t, e) {
                            var i, n = new Xf(2 * t.count), a = [], r = [], o = 0;
                            for (; null != (i = t.next()); )
                                r[p] = e.get(h, i),
                                r[1 - p] = e.get(c, i),
                                a = s.dataToPoint(r, null, a),
                                n[o++] = a[0],
                                n[o++] = a[1];
                            e.setLayout({
                                largePoints: n,
                                barWidth: f,
                                valueAxisStart: ag(l, u),
                                valueAxisHorizontal: d
                            })
                        }
                    }
                }
            }
        };
        function ig(t) {
            return t.coordinateSystem && "cartesian2d" === t.coordinateSystem.type
        }
        function ng(t) {
            return t.pipelineContext && t.pipelineContext.large
        }
        function ag(t, e) {
            var i, n, a = e.getGlobalExtent();
            n = a[0] > a[1] ? (i = a[1],
            a[0]) : (i = a[0],
            a[1]);
            var r = e.toGlobalCoord(e.dataToCoord(0));
            return r < i && (r = i),
            n < r && (r = n),
            r
        }
        var rg = {
            getLayoutOnAxis: function(t) {
                var e = []
                  , i = t.axis;
                if ("category" === i.type) {
                    for (var n = i.getBandWidth(), a = 0; a < t.count; a++)
                        e.push(it.defaults({
                            bandWidth: n,
                            axisKey: "axis0",
                            stackId: jf + a
                        }, t));
                    var r = Qf(e)
                      , o = [];
                    for (a = 0; a < t.count; a++) {
                        var s = r.axis0[jf + a];
                        s.offsetCenter = s.offset + s.width / 2,
                        o.push(s)
                    }
                    return o
                }
            },
            prepareLayoutBarSeries: $f,
            makeColumnLayout: Jf,
            retrieveColumnLayout: tg,
            layout: function(t, e) {
                var i = $f(t, e)
                  , A = Jf(i)
                  , T = {};
                it.each(i, function(t) {
                    var e = t.getData()
                      , i = t.coordinateSystem
                      , n = i.getBaseAxis()
                      , a = qf(t)
                      , r = A[Kf(n)][a]
                      , o = r.offset
                      , s = r.width
                      , l = i.getOtherAxis(n)
                      , u = t.get("barMinHeight") || 0;
                    T[a] = T[a] || [],
                    e.setLayout({
                        offset: o,
                        size: s
                    });
                    for (var h = e.mapDimension(l.dim), c = e.mapDimension(n.dim), d = Yf(e, h), p = l.isHorizontal(), f = ag(n, l), g = 0, m = e.count(); g < m; g++) {
                        var v = e.get(h, g)
                          , y = e.get(c, g);
                        if (!isNaN(v)) {
                            var x, _, b, w, S, M = 0 <= v ? "p" : "n", I = f;
                            if (d && (T[a][y] || (T[a][y] = {
                                p: f,
                                n: f
                            }),
                            I = T[a][y][M]),
                            p)
                                x = I,
                                _ = (S = i.dataToPoint([v, y]))[1] + o,
                                b = S[0] - f,
                                w = s,
                                Math.abs(b) < u && (b = (b < 0 ? -1 : 1) * u),
                                d && (T[a][y][M] += b);
                            else
                                x = (S = i.dataToPoint([y, v]))[0] + o,
                                _ = I,
                                b = s,
                                w = S[1] - f,
                                Math.abs(w) < u && (w = (w <= 0 ? -1 : 1) * u),
                                d && (T[a][y][M] += w);
                            e.setItemLayout(g, {
                                x: x,
                                y: _,
                                width: b,
                                height: w
                            })
                        }
                    }
                }, this)
            },
            largeLayout: eg
        }
          , og = Zf.prototype
          , sg = Math.ceil
          , lg = Math.floor
          , ug = 36e5
          , hg = 864e5
          , cg = Zf.extend({
            type: "time",
            getLabel: function(t) {
                var e = this._stepLvl
                  , i = new Date(t);
                return fl.formatTime(e[0], i, this.getSetting("useUTC"))
            },
            niceExtent: function(t) {
                var e = this._extent;
                if (e[0] === e[1] && (e[0] -= hg,
                e[1] += hg),
                e[1] === -1 / 0 && e[0] === 1 / 0) {
                    var i = new Date;
                    e[1] = +new Date(i.getFullYear(),i.getMonth(),i.getDate()),
                    e[0] = e[1] - hg
                }
                this.niceTicks(t.splitNumber, t.minInterval, t.maxInterval);
                var n = this._interval;
                t.fixMin || (e[0] = ol.round(lg(e[0] / n) * n)),
                t.fixMax || (e[1] = ol.round(sg(e[1] / n) * n))
            },
            niceTicks: function(t, e, i) {
                t = t || 10;
                var n = this._extent
                  , a = n[1] - n[0]
                  , r = a / t;
                null != e && r < e && (r = e),
                null != i && i < r && (r = i);
                var o = dg.length
                  , s = function(t, e, i, n) {
                    for (; i < n; ) {
                        var a = i + n >>> 1;
                        t[a][1] < e ? i = 1 + a : n = a
                    }
                    return i
                }(dg, r, 0, o)
                  , l = dg[Math.min(s, o - 1)]
                  , u = l[1];
                if ("year" === l[0]) {
                    var h = a / u;
                    u *= ol.nice(h / t, !0)
                }
                var c = this.getSetting("useUTC") ? 0 : 60 * new Date(+n[0] || +n[1]).getTimezoneOffset() * 1e3
                  , d = [Math.round(sg((n[0] - c) / u) * u + c), Math.round(lg((n[1] - c) / u) * u + c)];
                Ff.fixExtent(d, n),
                this._stepLvl = l,
                this._interval = u,
                this._niceExtent = d
            },
            parse: function(t) {
                return +ol.parseDate(t)
            }
        });
        it.each(["contain", "normalize"], function(e) {
            cg.prototype[e] = function(t) {
                return og[e].call(this, this.parse(t))
            }
        });
        var dg = [["hh:mm:ss", 1e3], ["hh:mm:ss", 5e3], ["hh:mm:ss", 1e4], ["hh:mm:ss", 15e3], ["hh:mm:ss", 3e4], ["hh:mm\nMM-dd", 6e4], ["hh:mm\nMM-dd", 3e5], ["hh:mm\nMM-dd", 6e5], ["hh:mm\nMM-dd", 9e5], ["hh:mm\nMM-dd", 18e5], ["hh:mm\nMM-dd", ug], ["hh:mm\nMM-dd", 72e5], ["hh:mm\nMM-dd", 6 * ug], ["hh:mm\nMM-dd", 432e5], ["MM-dd\nyyyy", hg], ["MM-dd\nyyyy", 2 * hg], ["MM-dd\nyyyy", 3 * hg], ["MM-dd\nyyyy", 4 * hg], ["MM-dd\nyyyy", 5 * hg], ["MM-dd\nyyyy", 6 * hg], ["week", 7 * hg], ["MM-dd\nyyyy", 864e6], ["week", 14 * hg], ["week", 21 * hg], ["month", 31 * hg], ["week", 42 * hg], ["month", 62 * hg], ["week", 70 * hg], ["quarter", 95 * hg], ["month", 31 * hg * 4], ["month", 13392e6], ["half-year", 16416e6], ["month", 31 * hg * 8], ["month", 26784e6], ["year", 380 * hg]];
        cg.create = function(t) {
            return new cg({
                useUTC: t.ecModel.get("useUTC")
            })
        }
        ;
        var pg = If.prototype
          , fg = Zf.prototype
          , gg = ol.getPrecisionSafe
          , mg = ol.round
          , vg = Math.floor
          , yg = Math.ceil
          , xg = Math.pow
          , _g = Math.log
          , bg = If.extend({
            type: "log",
            base: 10,
            $constructor: function() {
                If.apply(this, arguments),
                this._originalScale = new Zf
            },
            getTicks: function() {
                var i = this._originalScale
                  , n = this._extent
                  , a = i.getExtent();
                return it.map(fg.getTicks.call(this), function(t) {
                    var e = ol.round(xg(this.base, t));
                    return e = t === n[0] && i.__fixMin ? wg(e, a[0]) : e,
                    e = t === n[1] && i.__fixMax ? wg(e, a[1]) : e
                }, this)
            },
            getLabel: fg.getLabel,
            scale: function(t) {
                return t = pg.scale.call(this, t),
                xg(this.base, t)
            },
            setExtent: function(t, e) {
                var i = this.base;
                t = _g(t) / _g(i),
                e = _g(e) / _g(i),
                fg.setExtent.call(this, t, e)
            },
            getExtent: function() {
                var t = this.base
                  , e = pg.getExtent.call(this);
                e[0] = xg(t, e[0]),
                e[1] = xg(t, e[1]);
                var i = this._originalScale
                  , n = i.getExtent();
                return i.__fixMin && (e[0] = wg(e[0], n[0])),
                i.__fixMax && (e[1] = wg(e[1], n[1])),
                e
            },
            unionExtent: function(t) {
                this._originalScale.unionExtent(t);
                var e = this.base;
                t[0] = _g(t[0]) / _g(e),
                t[1] = _g(t[1]) / _g(e),
                pg.unionExtent.call(this, t)
            },
            unionExtentFromData: function(t, e) {
                this.unionExtent(t.getApproximateExtent(e))
            },
            niceTicks: function(t) {
                t = t || 10;
                var e = this._extent
                  , i = e[1] - e[0];
                if (!(i == 1 / 0 || i <= 0)) {
                    var n = ol.quantity(i);
                    for (t / i * n <= .5 && (n *= 10); !isNaN(n) && Math.abs(n) < 1 && 0 < Math.abs(n); )
                        n *= 10;
                    var a = [ol.round(yg(e[0] / n) * n), ol.round(vg(e[1] / n) * n)];
                    this._interval = n,
                    this._niceExtent = a
                }
            },
            niceExtent: function(t) {
                fg.niceExtent.call(this, t);
                var e = this._originalScale;
                e.__fixMin = t.fixMin,
                e.__fixMax = t.fixMax
            }
        });
        function wg(t, e) {
            return mg(t, gg(e))
        }
        it.each(["contain", "normalize"], function(e) {
            bg.prototype[e] = function(t) {
                return t = _g(t) / _g(this.base),
                pg[e].call(this, t)
            }
        }),
        bg.create = function() {
            return new bg
        }
        ;
        var Sg = rg.prepareLayoutBarSeries
          , Mg = rg.makeColumnLayout
          , Ig = rg.retrieveColumnLayout;
        function Ag(t, e) {
            var i, n, a, r = t.type, o = e.getMin(), s = e.getMax(), l = null != o, u = null != s, h = t.getExtent();
            "ordinal" === r ? i = e.getCategories().length : (n = e.get("boundaryGap"),
            it.isArray(n) || (n = [n || 0, n || 0]),
            "boolean" == typeof n[0] && (n = [0, 0]),
            n[0] = ol.parsePercent(n[0], 1),
            n[1] = ol.parsePercent(n[1], 1),
            a = h[1] - h[0] || Math.abs(h[0])),
            null == o && (o = "ordinal" === r ? i ? 0 : NaN : h[0] - n[0] * a),
            null == s && (s = "ordinal" === r ? i ? i - 1 : NaN : h[1] + n[1] * a),
            "dataMin" === o ? o = h[0] : "function" == typeof o && (o = o({
                min: h[0],
                max: h[1]
            })),
            "dataMax" === s ? s = h[1] : "function" == typeof s && (s = s({
                min: h[0],
                max: h[1]
            })),
            null != o && isFinite(o) || (o = NaN),
            null != s && isFinite(s) || (s = NaN),
            t.setBlank(it.eqNaN(o) || it.eqNaN(s) || "ordinal" === r && !t.getOrdinalMeta().categories.length),
            e.getNeedCrossZero() && (0 < o && 0 < s && !l && (o = 0),
            o < 0 && s < 0 && !u && (s = 0));
            var c = e.ecModel;
            if (c && "time" === r) {
                var d, p = Sg("bar", c);
                if (it.each(p, function(t) {
                    d |= t.getBaseAxis() === e.axis
                }),
                d) {
                    var f = Mg(p)
                      , g = function(t, e, i, n) {
                        var a = i.axis.getExtent()
                          , r = a[1] - a[0]
                          , o = Ig(n, i.axis);
                        if (void 0 === o)
                            return {
                                min: t,
                                max: e
                            };
                        var s = 1 / 0;
                        it.each(o, function(t) {
                            s = Math.min(t.offset, s)
                        });
                        var l = -1 / 0;
                        it.each(o, function(t) {
                            l = Math.max(t.offset + t.width, l)
                        }),
                        s = Math.abs(s),
                        l = Math.abs(l);
                        var u = s + l
                          , h = e - t
                          , c = h / (1 - (s + l) / r) - h;
                        return {
                            min: t -= s / u * c,
                            max: e += l / u * c
                        }
                    }(o, s, e, f);
                    o = g.min,
                    s = g.max
                }
            }
            return [o, s]
        }
        function Tg(i) {
            var e, n = i.getLabelModel().get("formatter"), a = "category" === i.type ? i.scale.getExtent()[0] : null;
            return "string" == typeof n ? (e = n,
            n = function(t) {
                return t = i.scale.getLabel(t),
                e.replace("{value}", null != t ? t : "")
            }
            ) : "function" == typeof n ? function(t, e) {
                return null != a && (e = t - a),
                n(Cg(i, t), e)
            }
            : function(t) {
                return i.scale.getLabel(t)
            }
        }
        function Cg(t, e) {
            return "category" === t.type ? t.scale.getLabel(e) : e
        }
        function Dg(t) {
            var e = t.get("interval");
            return null == e ? "auto" : e
        }
        var Lg = {
            getScaleExtent: Ag,
            niceScaleExtent: function(t, e) {
                var i = Ag(t, e)
                  , n = null != e.getMin()
                  , a = null != e.getMax()
                  , r = e.get("splitNumber");
                "log" === t.type && (t.base = e.get("logBase"));
                var o = t.type;
                t.setExtent(i[0], i[1]),
                t.niceExtent({
                    splitNumber: r,
                    fixMin: n,
                    fixMax: a,
                    minInterval: "interval" === o || "time" === o ? e.get("minInterval") : null,
                    maxInterval: "interval" === o || "time" === o ? e.get("maxInterval") : null
                });
                var s = e.get("interval");
                null != s && t.setInterval && t.setInterval(s)
            },
            createScaleByModel: function(t, e) {
                if (e = e || t.get("type"))
                    switch (e) {
                    case "category":
                        return new Ef(t.getOrdinalMeta ? t.getOrdinalMeta() : t.getCategories(),[1 / 0, -1 / 0]);
                    case "value":
                        return new Zf;
                    default:
                        return (If.getClass(e) || Zf).create(t)
                    }
            },
            ifAxisCrossZero: function(t) {
                var e = t.scale.getExtent()
                  , i = e[0]
                  , n = e[1];
                return !(0 < i && 0 < n || i < 0 && n < 0)
            },
            makeLabelFormatter: Tg,
            getAxisRawValue: Cg,
            estimateLabelUnionRect: function(t) {
                var e = t.model
                  , i = t.scale;
                if (e.get("axisLabel.show") && !i.isBlank()) {
                    var n, a, r = "category" === t.type, o = i.getExtent();
                    a = r ? i.count() : (n = i.getTicks()).length;
                    var s, l, u, h, c, d, p, f, g, m = t.getLabelModel(), v = Tg(t), y = 1;
                    40 < a && (y = Math.ceil(a / 40));
                    for (var x = 0; x < a; x += y) {
                        var _ = v(n ? n[x] : o[0] + x)
                          , b = m.getTextRect(_)
                          , w = (l = b,
                        u = m.get("rotate") || 0,
                        void 0,
                        h = u * Math.PI / 180,
                        c = l.plain(),
                        d = c.width,
                        p = c.height,
                        f = d * Math.cos(h) + p * Math.sin(h),
                        g = d * Math.sin(h) + p * Math.cos(h),
                        new Oe(c.x,c.y,f,g));
                        s ? s.union(w) : s = w
                    }
                    return s
                }
            },
            getOptionCategoryInterval: Dg,
            shouldShowAllLabels: function(t) {
                return "category" === t.type && 0 === Dg(t.getLabelModel())
            }
        }
          , Pg = {
            getMin: function(t) {
                var e = this.option
                  , i = t || null == e.rangeStart ? e.min : e.rangeStart;
                return this.axis && null != i && "dataMin" !== i && "function" != typeof i && !it.eqNaN(i) && (i = this.axis.scale.parse(i)),
                i
            },
            getMax: function(t) {
                var e = this.option
                  , i = t || null == e.rangeEnd ? e.max : e.rangeEnd;
                return this.axis && null != i && "dataMax" !== i && "function" != typeof i && !it.eqNaN(i) && (i = this.axis.scale.parse(i)),
                i
            },
            getNeedCrossZero: function() {
                var t = this.option;
                return null == t.rangeStart && null == t.rangeEnd && !t.scale
            },
            getCoordSysModel: it.noop,
            setRange: function(t, e) {
                this.option.rangeStart = t,
                this.option.rangeEnd = e
            },
            resetRange: function() {
                this.option.rangeStart = this.option.rangeEnd = null
            }
        }
          , kg = Fs.extendShape({
            type: "triangle",
            shape: {
                cx: 0,
                cy: 0,
                width: 0,
                height: 0
            },
            buildPath: function(t, e) {
                var i = e.cx
                  , n = e.cy
                  , a = e.width / 2
                  , r = e.height / 2;
                t.moveTo(i, n - r),
                t.lineTo(i + a, n + r),
                t.lineTo(i - a, n + r),
                t.closePath()
            }
        })
          , Og = Fs.extendShape({
            type: "diamond",
            shape: {
                cx: 0,
                cy: 0,
                width: 0,
                height: 0
            },
            buildPath: function(t, e) {
                var i = e.cx
                  , n = e.cy
                  , a = e.width / 2
                  , r = e.height / 2;
                t.moveTo(i, n - r),
                t.lineTo(i + a, n),
                t.lineTo(i, n + r),
                t.lineTo(i - a, n),
                t.closePath()
            }
        })
          , Rg = Fs.extendShape({
            type: "pin",
            shape: {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            },
            buildPath: function(t, e) {
                var i = e.x
                  , n = e.y
                  , a = e.width / 5 * 3
                  , r = Math.max(a, e.height)
                  , o = a / 2
                  , s = o * o / (r - o)
                  , l = n - r + o + s
                  , u = Math.asin(s / o)
                  , h = Math.cos(u) * o
                  , c = Math.sin(u)
                  , d = Math.cos(u)
                  , p = .6 * o
                  , f = .7 * o;
                t.moveTo(i - h, l + s),
                t.arc(i, l, o, Math.PI - u, 2 * Math.PI + u),
                t.bezierCurveTo(i + h - c * p, l + s + d * p, i, n - f, i, n),
                t.bezierCurveTo(i, n - f, i - h + c * p, l + s + d * p, i - h, l + s),
                t.closePath()
            }
        })
          , Ng = Fs.extendShape({
            type: "arrow",
            shape: {
                x: 0,
                y: 0,
                width: 0,
                height: 0
            },
            buildPath: function(t, e) {
                var i = e.height
                  , n = e.width
                  , a = e.x
                  , r = e.y
                  , o = n / 3 * 2;
                t.moveTo(a, r),
                t.lineTo(a + o, r + i),
                t.lineTo(a, r + i / 4 * 3),
                t.lineTo(a - o, r + i),
                t.lineTo(a, r),
                t.closePath()
            }
        })
          , Eg = {
            line: Fs.Line,
            rect: Fs.Rect,
            roundRect: Fs.Rect,
            square: Fs.Rect,
            circle: Fs.Circle,
            diamond: Og,
            pin: Rg,
            arrow: Ng,
            triangle: kg
        }
          , zg = {
            line: function(t, e, i, n, a) {
                a.x1 = t,
                a.y1 = e + n / 2,
                a.x2 = t + i,
                a.y2 = e + n / 2
            },
            rect: function(t, e, i, n, a) {
                a.x = t,
                a.y = e,
                a.width = i,
                a.height = n
            },
            roundRect: function(t, e, i, n, a) {
                a.x = t,
                a.y = e,
                a.width = i,
                a.height = n,
                a.r = Math.min(i, n) / 4
            },
            square: function(t, e, i, n, a) {
                var r = Math.min(i, n);
                a.x = t,
                a.y = e,
                a.width = r,
                a.height = r
            },
            circle: function(t, e, i, n, a) {
                a.cx = t + i / 2,
                a.cy = e + n / 2,
                a.r = Math.min(i, n) / 2
            },
            diamond: function(t, e, i, n, a) {
                a.cx = t + i / 2,
                a.cy = e + n / 2,
                a.width = i,
                a.height = n
            },
            pin: function(t, e, i, n, a) {
                a.x = t + i / 2,
                a.y = e + n / 2,
                a.width = i,
                a.height = n
            },
            arrow: function(t, e, i, n, a) {
                a.x = t + i / 2,
                a.y = e + n / 2,
                a.width = i,
                a.height = n
            },
            triangle: function(t, e, i, n, a) {
                a.cx = t + i / 2,
                a.cy = e + n / 2,
                a.width = i,
                a.height = n
            }
        }
          , Vg = {};
        it.each(Eg, function(t, e) {
            Vg[e] = new t
        });
        var Bg = Fs.extendShape({
            type: "symbol",
            shape: {
                symbolType: "",
                x: 0,
                y: 0,
                width: 0,
                height: 0
            },
            beforeBrush: function() {
                var t = this.style;
                "pin" === this.shape.symbolType && "inside" === t.textPosition && (t.textPosition = ["50%", "40%"],
                t.textAlign = "center",
                t.textVerticalAlign = "middle")
            },
            buildPath: function(t, e, i) {
                var n = e.symbolType
                  , a = Vg[n];
                "none" !== e.symbolType && (a = a || Vg[n = "rect"],
                zg[n](e.x, e.y, e.width, e.height, a.shape),
                a.buildPath(t, a.shape, i))
            }
        });
        function Gg(t, e) {
            if ("image" !== this.type) {
                var i = this.style
                  , n = this.shape;
                n && "line" === n.symbolType ? i.stroke = t : this.__isEmptyBrush ? (i.stroke = t,
                i.fill = e || "#fff") : (i.fill && (i.fill = t),
                i.stroke && (i.stroke = t)),
                this.dirty(!1)
            }
        }
        var Fg = {
            createSymbol: function(t, e, i, n, a, r, o) {
                var s, l = 0 === t.indexOf("empty");
                return l && (t = t.substr(5, 1).toLowerCase() + t.substr(6)),
                (s = 0 === t.indexOf("image://") ? Fs.makeImage(t.slice(8), new Oe(e,i,n,a), o ? "center" : "cover") : 0 === t.indexOf("path://") ? Fs.makePath(t.slice(7), {}, new Oe(e,i,n,a), o ? "center" : "cover") : new Bg({
                    shape: {
                        symbolType: t,
                        x: e,
                        y: i,
                        width: n,
                        height: a
                    }
                })).__isEmptyBrush = l,
                s.setColor = Gg,
                s.setColor(r),
                s
            }
        }
          , Hg = Il.getLayoutRect
          , Wg = vf.enableDataStack
          , Zg = vf.isDimensionStacked
          , Ug = vf.getStackedDimension;
        var Yg = {
            getLayoutRect: Hg,
            completeDimensions: df,
            createDimensions: pf,
            createSymbol: Fg.createSymbol,
            createList: function(t) {
                return Sf(t.getSource(), t)
            },
            dataStack: {
                isDimensionStacked: Zg,
                enableDataStack: Wg,
                getStackedDimension: Ug
            },
            createScale: function(t, e) {
                var i = e;
                tl.isInstance(e) || (i = new tl(e),
                it.mixin(i, Pg));
                var n = Lg.createScaleByModel(i);
                return n.setExtent(t[0], t[1]),
                Lg.niceScaleExtent(n, i),
                n
            },
            mixinAxisModelCommonMethods: function(t) {
                it.mixin(t, Pg)
            }
        }
          , jg = 1e-8;
        function Xg(t, e) {
            return Math.abs(t - e) < jg
        }
        var qg = {
            contain: function(t, e, i) {
                var n = 0
                  , a = t[0];
                if (!a)
                    return !1;
                for (var r = 1; r < t.length; r++) {
                    var o = t[r];
                    n += dr(a[0], a[1], o[0], o[1], e, i),
                    a = o
                }
                var s = t[0];
                return Xg(a[0], s[0]) && Xg(a[1], s[1]) || (n += dr(a[0], a[1], s[0], s[1], e, i)),
                0 !== n
            }
        };
        function Kg(t, e, i) {
            if (this.name = t,
            this.geometries = e,
            i)
                i = [i[0], i[1]];
            else {
                var n = this.getBoundingRect();
                i = [n.x + n.width / 2, n.y + n.height / 2]
            }
            this.center = i
        }
        Kg.prototype = {
            constructor: Kg,
            properties: null,
            getBoundingRect: function() {
                var t = this._rect;
                if (t)
                    return t;
                for (var e = Number.MAX_VALUE, i = [e, e], n = [-e, -e], a = [], r = [], o = this.geometries, s = 0; s < o.length; s++)
                    if ("polygon" === o[s].type) {
                        var l = o[s].exterior;
                        Ha.fromPoints(l, a, r),
                        R.min(i, i, a),
                        R.max(n, n, r)
                    }
                return 0 === s && (i[0] = i[1] = n[0] = n[1] = 0),
                this._rect = new Oe(i[0],i[1],n[0] - i[0],n[1] - i[1])
            },
            contain: function(t) {
                var e = this.getBoundingRect()
                  , i = this.geometries;
                if (!e.contain(t[0], t[1]))
                    return !1;
                t: for (var n = 0, a = i.length; n < a; n++)
                    if ("polygon" === i[n].type) {
                        var r = i[n].exterior
                          , o = i[n].interiors;
                        if (qg.contain(r, t[0], t[1])) {
                            for (var s = 0; s < (o ? o.length : 0); s++)
                                if (qg.contain(o[s]))
                                    continue t;
                            return !0
                        }
                    }
                return !1
            },
            transformTo: function(t, e, i, n) {
                var a = this.getBoundingRect()
                  , r = a.width / a.height;
                i ? n = n || i / r : i = r * n;
                for (var o = new Oe(t,e,i,n), s = a.calculateTransform(o), l = this.geometries, u = 0; u < l.length; u++)
                    if ("polygon" === l[u].type) {
                        for (var h = l[u].exterior, c = l[u].interiors, d = 0; d < h.length; d++)
                            R.applyTransform(h[d], h[d], s);
                        for (var p = 0; p < (c ? c.length : 0); p++)
                            for (d = 0; d < c[p].length; d++)
                                R.applyTransform(c[p][d], c[p][d], s)
                    }
                (a = this._rect).copy(o),
                this.center = [a.x + a.width / 2, a.y + a.height / 2]
            },
            cloneShallow: function(t) {
                null == t && (t = this.name);
                var e = new Kg(t,this.geometries,this.center);
                return e._rect = this._rect,
                e.transformTo = null,
                e
            }
        };
        var $g = Kg;
        function Jg(t, e, i) {
            for (var n = [], a = e[0], r = e[1], o = 0; o < t.length; o += 2) {
                var s = t.charCodeAt(o) - 64
                  , l = t.charCodeAt(o + 1) - 64;
                s = s >> 1 ^ -(1 & s),
                l = l >> 1 ^ -(1 & l),
                a = s += a,
                r = l += r,
                n.push([s / i, l / i])
            }
            return n
        }
        var Qg = function(t) {
            return function(t) {
                if (!t.UTF8Encoding)
                    return;
                var e = t.UTF8Scale;
                null == e && (e = 1024);
                for (var i = t.features, n = 0; n < i.length; n++)
                    for (var a = i[n].geometry, r = a.coordinates, o = a.encodeOffsets, s = 0; s < r.length; s++) {
                        var l = r[s];
                        if ("Polygon" === a.type)
                            r[s] = Jg(l, o[s], e);
                        else if ("MultiPolygon" === a.type)
                            for (var u = 0; u < l.length; u++) {
                                var h = l[u];
                                l[u] = Jg(h, o[s][u], e)
                            }
                    }
                t.UTF8Encoding = !1
            }(t),
            it.map(it.filter(t.features, function(t) {
                return t.geometry && t.properties && 0 < t.geometry.coordinates.length
            }), function(t) {
                var e = t.properties
                  , i = t.geometry
                  , n = i.coordinates
                  , a = [];
                "Polygon" === i.type && a.push({
                    type: "polygon",
                    exterior: n[0],
                    interiors: n.slice(1)
                }),
                "MultiPolygon" === i.type && it.each(n, function(t) {
                    t[0] && a.push({
                        type: "polygon",
                        exterior: t[0],
                        interiors: t.slice(1)
                    })
                });
                var r = new $g(e.name,a,e.cp);
                return r.properties = e,
                r
            })
        }
          , tm = aa.makeInner
          , em = Lg.makeLabelFormatter
          , im = Lg.getOptionCategoryInterval
          , nm = Lg.shouldShowAllLabels
          , am = tm();
        function rm(t, e) {
            var i, n = om(t, "labels"), a = im(e), r = sm(n, a);
            return r || lm(n, a, {
                labels: it.isFunction(a) ? hm(t, a) : um(t, i = "auto" === a ? function(t) {
                    var e = am(t).autoInterval;
                    return null != e ? e : am(t).autoInterval = t.calculateCategoryInterval()
                }(t) : a),
                labelCategoryInterval: i
            })
        }
        function om(t, e) {
            return am(t)[e] || (am(t)[e] = [])
        }
        function sm(t, e) {
            for (var i = 0; i < t.length; i++)
                if (t[i].key === e)
                    return t[i].value
        }
        function lm(t, e, i) {
            return t.push({
                key: e,
                value: i
            }),
            i
        }
        function um(t, e, i) {
            var n = em(t)
              , a = t.scale
              , r = a.getExtent()
              , o = t.getLabelModel()
              , s = []
              , l = Math.max((e || 0) + 1, 1)
              , u = r[0]
              , h = a.count();
            0 !== u && 1 < l && 2 < h / l && (u = Math.round(Math.ceil(u / l) * l));
            var c = nm(t)
              , d = o.get("showMinLabel") || c
              , p = o.get("showMaxLabel") || c;
            d && u !== r[0] && g(r[0]);
            for (var f = u; f <= r[1]; f += l)
                g(f);
            function g(t) {
                s.push(i ? t : {
                    formattedLabel: n(t),
                    rawLabel: a.getLabel(t),
                    tickValue: t
                })
            }
            return p && f !== r[1] && g(r[1]),
            s
        }
        function hm(t, i, n) {
            var a = t.scale
              , r = em(t)
              , o = [];
            return it.each(a.getTicks(), function(t) {
                var e = a.getLabel(t);
                i(t, e) && o.push(n ? t : {
                    formattedLabel: r(t),
                    rawLabel: e,
                    tickValue: t
                })
            }),
            o
        }
        function cm(t, e, i) {
            this.dim = t,
            this.scale = e,
            this._extent = i || [0, 0],
            this.inverse = !1,
            this.onBand = !1
        }
        var dm = {
            createAxisLabels: function(t) {
                return "category" === t.type ? function(t) {
                    var e = t.getLabelModel()
                      , i = rm(t, e);
                    return !e.get("show") || t.scale.isBlank() ? {
                        labels: [],
                        labelCategoryInterval: i.labelCategoryInterval
                    } : i
                }(t) : function(i) {
                    var t = i.scale.getTicks()
                      , n = em(i);
                    return {
                        labels: it.map(t, function(t, e) {
                            return {
                                formattedLabel: n(t, e),
                                rawLabel: i.scale.getLabel(t),
                                tickValue: t
                            }
                        })
                    }
                }(t)
            },
            createAxisTicks: function(t, e) {
                return "category" === t.type ? function(t, e) {
                    var i, n, a = om(t, "ticks"), r = im(e), o = sm(a, r);
                    if (o)
                        return o;
                    e.get("show") && !t.scale.isBlank() || (i = []);
                    if (it.isFunction(r))
                        i = hm(t, r, !0);
                    else if ("auto" === r) {
                        var s = rm(t, t.getLabelModel());
                        n = s.labelCategoryInterval,
                        i = it.map(s.labels, function(t) {
                            return t.tickValue
                        })
                    } else
                        i = um(t, n = r, !0);
                    return lm(a, r, {
                        ticks: i,
                        tickCategoryInterval: n
                    })
                }(t, e) : {
                    ticks: t.scale.getTicks()
                }
            },
            calculateCategoryInterval: function(t) {
                var e = function(t) {
                    var e = t.getLabelModel();
                    return {
                        axisRotate: t.getRotate ? t.getRotate() : t.isHorizontal && !t.isHorizontal() ? 90 : 0,
                        labelRotate: e.get("rotate") || 0,
                        font: e.getFont()
                    }
                }(t)
                  , i = em(t)
                  , n = (e.axisRotate - e.labelRotate) / 180 * Math.PI
                  , a = t.scale
                  , r = a.getExtent()
                  , o = a.count();
                if (r[1] - r[0] < 1)
                    return 0;
                var s = 1;
                40 < o && (s = Math.max(1, Math.floor(o / 40)));
                for (var l = r[0], u = t.dataToCoord(l + 1) - t.dataToCoord(l), h = Math.abs(u * Math.cos(n)), c = Math.abs(u * Math.sin(n)), d = 0, p = 0; l <= r[1]; l += s) {
                    var f, g, m = Bi.getBoundingRect(i(l), e.font, "center", "top");
                    f = 1.3 * m.width,
                    g = 1.3 * m.height,
                    d = Math.max(d, f, 7),
                    p = Math.max(p, g, 7)
                }
                var v = d / h
                  , y = p / c;
                isNaN(v) && (v = 1 / 0),
                isNaN(y) && (y = 1 / 0);
                var x = Math.max(0, Math.floor(Math.min(v, y)))
                  , _ = am(t.model)
                  , b = _.lastAutoInterval
                  , w = _.lastTickCount;
                return null != b && null != w && Math.abs(b - x) <= 1 && Math.abs(w - o) <= 1 && x < b ? x = b : (_.lastTickCount = o,
                _.lastAutoInterval = x),
                x
            }
        }
          , pm = it.each
          , fm = it.map
          , gm = ol.linearMap
          , mm = ol.getPixelPrecision
          , vm = dm.createAxisTicks
          , ym = dm.createAxisLabels
          , xm = dm.calculateCategoryInterval
          , _m = [0, 1];
        function bm(t, e) {
            var i = (t[1] - t[0]) / e / 2;
            t[0] += i,
            t[1] -= i
        }
        cm.prototype = {
            constructor: cm,
            contain: function(t) {
                var e = this._extent
                  , i = Math.min(e[0], e[1])
                  , n = Math.max(e[0], e[1]);
                return i <= t && t <= n
            },
            containData: function(t) {
                return this.contain(this.dataToCoord(t))
            },
            getExtent: function() {
                return this._extent.slice()
            },
            getPixelPrecision: function(t) {
                return mm(t || this.scale.getExtent(), this._extent)
            },
            setExtent: function(t, e) {
                var i = this._extent;
                i[0] = t,
                i[1] = e
            },
            dataToCoord: function(t, e) {
                var i = this._extent
                  , n = this.scale;
                return t = n.normalize(t),
                this.onBand && "ordinal" === n.type && bm(i = i.slice(), n.count()),
                gm(t, _m, i, e)
            },
            coordToData: function(t, e) {
                var i = this._extent
                  , n = this.scale;
                this.onBand && "ordinal" === n.type && bm(i = i.slice(), n.count());
                var a = gm(t, i, _m, e);
                return this.scale.scale(a)
            },
            pointToData: function(t, e) {},
            getTicksCoords: function(t) {
                var e = (t = t || {}).tickModel || this.getTickModel()
                  , i = vm(this, e)
                  , n = i.ticks
                  , a = fm(n, function(t) {
                    return {
                        coord: this.dataToCoord(t),
                        tickValue: t
                    }
                }, this)
                  , r = e.get("alignWithLabel");
                return function(t, e, i, n, a) {
                    var r = e.length;
                    if (!t.onBand || n || !r)
                        return;
                    var o, s = t.getExtent();
                    if (1 === r)
                        e[0].coord = s[0],
                        o = e[1] = {
                            coord: s[0]
                        };
                    else {
                        var l = e[1].coord - e[0].coord;
                        pm(e, function(t) {
                            t.coord -= l / 2;
                            var e = e || 0;
                            0 < e % 2 && (t.coord -= l / (2 * (e + 1)))
                        }),
                        o = {
                            coord: e[r - 1].coord + l
                        },
                        e.push(o)
                    }
                    var u = s[0] > s[1];
                    h(e[0].coord, s[0]) && (a ? e[0].coord = s[0] : e.shift());
                    a && h(s[0], e[0].coord) && e.unshift({
                        coord: s[0]
                    });
                    h(s[1], o.coord) && (a ? o.coord = s[1] : e.pop());
                    a && h(o.coord, s[1]) && e.push({
                        coord: s[1]
                    });
                    function h(t, e) {
                        return u ? e < t : t < e
                    }
                }(this, a, i.tickCategoryInterval, r, t.clamp),
                a
            },
            getViewLabels: function() {
                return ym(this).labels
            },
            getLabelModel: function() {
                return this.model.getModel("axisLabel")
            },
            getTickModel: function() {
                return this.model.getModel("axisTick")
            },
            getBandWidth: function() {
                var t = this._extent
                  , e = this.scale.getExtent()
                  , i = e[1] - e[0] + (this.onBand ? 1 : 0);
                0 === i && (i = 1);
                var n = Math.abs(t[1] - t[0]);
                return Math.abs(n) / i
            },
            isHorizontal: null,
            getRotate: null,
            calculateCategoryInterval: function() {
                return xm(this)
            }
        };
        var wm = cm
          , Sm = qn
          , Mm = ct
          , Im = R
          , Am = jt
          , Tm = ol
          , Cm = fl
          , Dm = Qc.throttle
          , Lm = Yg
          , Pm = Qg
          , km = Qp
          , Om = tl
          , Rm = wm
          , Nm = et
          , Em = Qg
          , zm = {};
        it.each(["map", "each", "filter", "indexOf", "inherits", "reduce", "filter", "bind", "curry", "isArray", "isString", "isObject", "isFunction", "extend", "defaults", "clone", "merge"], function(t) {
            zm[t] = it[t]
        });
        var Vm = {};
        it.each(["extendShape", "extendPath", "makePath", "makeImage", "mergePath", "resizePath", "createIcon", "setHoverStyle", "setLabelStyle", "setTextStyle", "setText", "getFont", "updateProps", "initProps", "getTransform", "clipPointsByRect", "clipRectByRect", "Group", "Image", "Text", "Circle", "Sector", "Ring", "Polygon", "Polyline", "Rect", "Line", "BezierCurve", "Arc", "IncrementalDisplayable", "CompoundPath", "LinearGradient", "RadialGradient", "BoundingRect"], function(t) {
            Vm[t] = Fs[t]
        });
        var Bm = {
            zrender: Sm,
            matrix: Mm,
            vector: Im,
            color: Am,
            number: Tm,
            format: Cm,
            throttle: Dm,
            helper: Lm,
            parseGeoJSON: Pm,
            List: km,
            Model: Om,
            Axis: Rm,
            env: Nm,
            parseGeoJson: Em,
            util: zm,
            graphic: Vm
        }
          , Gm = i(function(t, e) {
            var o = Qc.throttle
              , a = it.assert
              , f = it.each
              , s = it.isFunction
              , l = it.isObject
              , p = Pl.parseClassType
              , i = {
                PROCESSOR: {
                    FILTER: 1e3,
                    STATISTIC: 5e3
                },
                VISUAL: {
                    LAYOUT: 1e3,
                    GLOBAL: 2e3,
                    CHART: 3e3,
                    COMPONENT: 4e3,
                    BRUSH: 5e3
                }
            }
              , g = "__flagInMainProcess"
              , m = "__optionUpdated"
              , r = /^[a-zA-Z0-9_]+$/;
            function n(n) {
                return function(t, e, i) {
                    t = t && t.toLowerCase(),
                    nt.prototype[n].call(this, t, e, i)
                }
            }
            function u() {
                nt.call(this)
            }
            function h(t, e, i) {
                i = i || {},
                "string" == typeof e && (e = V[e]),
                this.id,
                this.group,
                this._dom = t;
                var n = this._zr = qn.init(t, {
                    renderer: i.renderer || "canvas",
                    devicePixelRatio: i.devicePixelRatio,
                    width: i.width,
                    height: i.height
                });
                this._throttledZrFlush = o(it.bind(n.flush, n), 17),
                (e = it.clone(e)) && _h(e, !0),
                this._theme = e,
                this._chartsViews = [],
                this._chartsMap = {},
                this._componentsViews = [],
                this._componentsMap = {},
                this._coordSysMgr = new ju;
                var a = this._api = function(i) {
                    var t = i._coordSysMgr;
                    return it.extend(new Zu(i), {
                        getCoordinateSystems: it.bind(t.getCoordinateSystems, t),
                        getComponentByElement: function(t) {
                            for (; t; ) {
                                var e = t.__ecComponentInfo;
                                if (null != e)
                                    return i._model.getComponent(e.mainType, e.index);
                                t = t.parent
                            }
                        }
                    })
                }(this);
                function r(t, e) {
                    return t.__prio - e.__prio
                }
                He(z, r),
                He(R, r),
                this._scheduler = new Od(this,a,R,z),
                nt.call(this, this._ecEventProcessor = new P),
                this._messageCenter = new u,
                this._initEvents(),
                this.resize = it.bind(this.resize, this),
                this._pendingActions = [],
                n.animation.on("frame", this._onframe, this),
                function(t, e) {
                    t.on("rendered", function() {
                        e.trigger("rendered"),
                        !t.animation.isFinished() || e[m] || e._scheduler.unfinished || e._pendingActions.length || e.trigger("finished")
                    })
                }(n, this),
                it.setAsPrimitive(this)
            }
            u.prototype.on = n("on"),
            u.prototype.off = n("off"),
            u.prototype.one = n("one"),
            it.mixin(u, nt);
            var c = h.prototype;
            function d(t, e, i) {
                var n, a = this._model, r = this._coordSysMgr.getCoordinateSystems();
                e = aa.parseFinder(a, e);
                for (var o = 0; o < r.length; o++) {
                    var s = r[o];
                    if (s[t] && null != (n = s[t](a, e, i)))
                        return n
                }
            }
            c._onframe = function() {
                if (!this._disposed) {
                    var t = this._scheduler;
                    if (this[m]) {
                        var e = this[m].silent;
                        this[g] = !0,
                        y(this),
                        v.update.call(this),
                        this[g] = !1,
                        this[m] = !1,
                        w.call(this, e),
                        S.call(this, e)
                    } else if (t.unfinished) {
                        var i = 1
                          , n = this._model
                          , a = this._api;
                        t.unfinished = !1;
                        do {
                            var r = +new Date;
                            t.performSeriesTasks(n),
                            t.performDataProcessorTasks(n),
                            _(this, n),
                            t.performVisualTasks(n),
                            T(this, this._model, a, "remain"),
                            i -= +new Date - r
                        } while (0 < i && t.unfinished);
                        t.unfinished || this._zr.flush()
                    }
                }
            }
            ,
            c.getDom = function() {
                return this._dom
            }
            ,
            c.getZr = function() {
                return this._zr
            }
            ,
            c.setOption = function(t, e, i) {
                var n;
                if (l(e) && (i = e.lazyUpdate,
                n = e.silent,
                e = e.notMerge),
                this[g] = !0,
                !this._model || e) {
                    var a = new eh(this._api)
                      , r = this._theme
                      , o = this._model = new Hu(null,null,r,a);
                    o.scheduler = this._scheduler,
                    o.init(null, null, r, a)
                }
                this._model.setOption(t, N),
                i ? (this[m] = {
                    silent: n
                },
                this[g] = !1) : (y(this),
                v.update.call(this),
                this._zr.flush(),
                this[m] = !1,
                this[g] = !1,
                w.call(this, n),
                S.call(this, n))
            }
            ,
            c.setTheme = function() {
                console.error("ECharts#setTheme() is DEPRECATED in ECharts 3.0")
            }
            ,
            c.getModel = function() {
                return this._model
            }
            ,
            c.getOption = function() {
                return this._model && this._model.getOption()
            }
            ,
            c.getWidth = function() {
                return this._zr.getWidth()
            }
            ,
            c.getHeight = function() {
                return this._zr.getHeight()
            }
            ,
            c.getDevicePixelRatio = function() {
                return this._zr.painter.dpr || window.devicePixelRatio || 1
            }
            ,
            c.getRenderedCanvas = function(t) {
                if (et.canvasSupported)
                    return (t = t || {}).pixelRatio = t.pixelRatio || 1,
                    t.backgroundColor = t.backgroundColor || this._model.get("backgroundColor"),
                    this._zr.painter.getRenderedCanvas(t)
            }
            ,
            c.getSvgDataUrl = function() {
                if (et.svgSupported) {
                    var t = this._zr
                      , e = t.storage.getDisplayList();
                    return it.each(e, function(t) {
                        t.stopAnimation(!0)
                    }),
                    t.painter.pathToDataUrl()
                }
            }
            ,
            c.getDataURL = function(t) {
                var e = (t = t || {}).excludeComponents
                  , i = this._model
                  , n = []
                  , a = this;
                f(e, function(t) {
                    i.eachComponent({
                        mainType: t
                    }, function(t) {
                        var e = a._componentsMap[t.__viewId];
                        e.group.ignore || (n.push(e),
                        e.group.ignore = !0)
                    })
                });
                var r = "svg" === this._zr.painter.getType() ? this.getSvgDataUrl() : this.getRenderedCanvas(t).toDataURL("image/" + (t && t.type || "png"));
                return f(n, function(t) {
                    t.group.ignore = !1
                }),
                r
            }
            ,
            c.getConnectedDataURL = function(a) {
                if (et.canvasSupported) {
                    var r = this.group
                      , o = Math.min
                      , s = Math.max;
                    if (F[r]) {
                        var l = 1 / 0
                          , u = 1 / 0
                          , h = -1 / 0
                          , c = -1 / 0
                          , d = []
                          , i = a && a.pixelRatio || 1;
                        it.each(G, function(t, e) {
                            if (t.group === r) {
                                var i = t.getRenderedCanvas(it.clone(a))
                                  , n = t.getDom().getBoundingClientRect();
                                l = o(n.left, l),
                                u = o(n.top, u),
                                h = s(n.right, h),
                                c = s(n.bottom, c),
                                d.push({
                                    dom: i,
                                    left: n.left,
                                    top: n.top
                                })
                            }
                        });
                        var t = (h *= i) - (l *= i)
                          , e = (c *= i) - (u *= i)
                          , n = it.createCanvas();
                        n.width = t,
                        n.height = e;
                        var p = qn.init(n);
                        return f(d, function(t) {
                            var e = new Fs.Image({
                                style: {
                                    x: t.left * i - l,
                                    y: t.top * i - u,
                                    image: t.dom
                                }
                            });
                            p.add(e)
                        }),
                        p.refreshImmediately(),
                        n.toDataURL("image/" + (a && a.type || "png"))
                    }
                    return this.getDataURL(a)
                }
            }
            ,
            c.convertToPixel = it.curry(d, "convertToPixel"),
            c.convertFromPixel = it.curry(d, "convertFromPixel"),
            c.containPixel = function(t, a) {
                var r, e = this._model;
                return t = aa.parseFinder(e, t),
                it.each(t, function(t, n) {
                    0 <= n.indexOf("Models") && it.each(t, function(t) {
                        var e = t.coordinateSystem;
                        if (e && e.containPoint)
                            r |= !!e.containPoint(a);
                        else if ("seriesModels" === n) {
                            var i = this._chartsMap[t.__viewId];
                            i && i.containPoint && (r |= i.containPoint(a, t))
                        }
                    }, this)
                }, this),
                !!r
            }
            ,
            c.getVisual = function(t, e) {
                var i = this._model
                  , n = (t = aa.parseFinder(i, t, {
                    defaultMainType: "series"
                })).seriesModel.getData()
                  , a = t.hasOwnProperty("dataIndexInside") ? t.dataIndexInside : t.hasOwnProperty("dataIndex") ? n.indexOfRawIndex(t.dataIndex) : null;
                return null != a ? n.getItemVisual(a, e) : n.getVisual(e)
            }
            ,
            c.getViewOfComponentModel = function(t) {
                return this._componentsMap[t.__viewId]
            }
            ,
            c.getViewOfSeriesModel = function(t) {
                return this._chartsMap[t.__viewId]
            }
            ;
            var v = {
                prepareAndUpdate: function(t) {
                    y(this),
                    v.update.call(this, t)
                },
                update: function(t) {
                    var e = this._model
                      , i = this._api
                      , n = this._zr
                      , a = this._coordSysMgr
                      , r = this._scheduler;
                    if (e) {
                        r.restoreData(e, t),
                        r.performSeriesTasks(e),
                        a.create(e, i),
                        r.performDataProcessorTasks(e, t),
                        _(this, e),
                        a.update(e, i),
                        I(e),
                        r.performVisualTasks(e, t),
                        A(this, e, i, t);
                        var o = e.get("backgroundColor") || "transparent";
                        if (et.canvasSupported)
                            n.setBackgroundColor(o);
                        else {
                            var s = jt.parse(o);
                            o = jt.stringify(s, "rgb"),
                            0 === s[3] && (o = "transparent")
                        }
                        C(e, i)
                    }
                },
                updateTransform: function(a) {
                    var r = this._model
                      , o = this
                      , s = this._api;
                    if (r) {
                        var l = [];
                        r.eachComponent(function(t, e) {
                            var i = o.getViewOfComponentModel(e);
                            if (i && i.__alive)
                                if (i.updateTransform) {
                                    var n = i.updateTransform(e, r, s, a);
                                    n && n.update && l.push(i)
                                } else
                                    l.push(i)
                        });
                        var n = it.createHashMap();
                        r.eachSeries(function(t) {
                            var e = o._chartsMap[t.__viewId];
                            if (e.updateTransform) {
                                var i = e.updateTransform(t, r, s, a);
                                i && i.update && n.set(t.uid, 1)
                            } else
                                n.set(t.uid, 1)
                        }),
                        I(r),
                        this._scheduler.performVisualTasks(r, a, {
                            setDirty: !0,
                            dirtyMap: n
                        }),
                        T(o, r, s, a, n),
                        C(r, this._api)
                    }
                },
                updateView: function(t) {
                    var e = this._model;
                    e && (Xc.markUpdateMethod(t, "updateView"),
                    I(e),
                    this._scheduler.performVisualTasks(e, t, {
                        setDirty: !0
                    }),
                    A(this, this._model, this._api, t),
                    C(e, this._api))
                },
                updateVisual: function(t) {
                    v.update.call(this, t)
                },
                updateLayout: function(t) {
                    v.update.call(this, t)
                }
            };
            function y(t) {
                var e = t._model
                  , i = t._scheduler;
                i.restorePipelines(e),
                i.prepareStageTasks(),
                M(t, "component", e, i),
                M(t, "chart", e, i),
                i.plan()
            }
            function x(e, i, n, a, t) {
                var r = e._model;
                if (a) {
                    var o = {};
                    o[a + "Id"] = n[a + "Id"],
                    o[a + "Index"] = n[a + "Index"],
                    o[a + "Name"] = n[a + "Name"];
                    var s = {
                        mainType: a,
                        query: o
                    };
                    t && (s.subType = t);
                    var l = n.excludeSeriesId;
                    null != l && (l = it.createHashMap(aa.normalizeToArray(l))),
                    r && r.eachComponent(s, function(t) {
                        l && null != l.get(t.id) || u(e["series" === a ? "_chartsMap" : "_componentsMap"][t.__viewId])
                    }, e)
                } else
                    f(e._componentsViews.concat(e._chartsViews), u);
                function u(t) {
                    t && t.__alive && t[i] && t[i](t.__model, r, e._api, n)
                }
            }
            function _(t, e) {
                var i = t._chartsMap
                  , n = t._scheduler;
                e.eachSeries(function(t) {
                    n.updateStreamModes(t, i[t.__viewId])
                })
            }
            function b(e, t) {
                var i = e.type
                  , n = e.escapeConnect
                  , a = k[i]
                  , r = a.actionInfo
                  , o = (r.update || "update").split(":")
                  , s = o.pop();
                o = null != o[0] && p(o[0]),
                this[g] = !0;
                var l = [e]
                  , u = !1;
                e.batch && (u = !0,
                l = it.map(e.batch, function(t) {
                    return (t = it.defaults(it.extend({}, t), e)).batch = null,
                    t
                }));
                var h, c = [], d = "highlight" === i || "downplay" === i;
                f(l, function(t) {
                    (h = (h = a.action(t, this._model, this._api)) || it.extend({}, t)).type = r.event || h.type,
                    c.push(h),
                    d ? x(this, s, t, "series") : o && x(this, s, t, o.main, o.sub)
                }, this),
                "none" === s || d || o || (this[m] ? (y(this),
                v.update.call(this, e),
                this[m] = !1) : v[s].call(this, e)),
                h = u ? {
                    type: r.event || i,
                    escapeConnect: n,
                    batch: c
                } : c[0],
                this[g] = !1,
                t || this._messageCenter.trigger(h.type, h)
            }
            function w(t) {
                for (var e = this._pendingActions; e.length; ) {
                    var i = e.shift();
                    b.call(this, i, t)
                }
            }
            function S(t) {
                t || this.trigger("updated")
            }
            function M(t, e, a, r) {
                for (var o = "component" === e, s = o ? t._componentsViews : t._chartsViews, l = o ? t._componentsMap : t._chartsMap, u = t._zr, h = t._api, i = 0; i < s.length; i++)
                    s[i].__alive = !1;
                function n(t) {
                    var e = "_ec_" + t.id + "_" + t.type
                      , i = l[e];
                    if (!i) {
                        var n = p(t.type);
                        (i = new (o ? Rc.getClass(n.main, n.sub) : Xc.getClass(n.sub))).init(a, h),
                        l[e] = i,
                        s.push(i),
                        u.add(i.group)
                    }
                    t.__viewId = i.__id = e,
                    i.__alive = !0,
                    i.__model = t,
                    i.group.__ecComponentInfo = {
                        mainType: t.mainType,
                        index: t.componentIndex
                    },
                    o || r.prepareView(i, t, a, h)
                }
                o ? a.eachComponent(function(t, e) {
                    "series" !== t && n(e)
                }) : a.eachSeries(n);
                for (i = 0; i < s.length; ) {
                    var c = s[i];
                    c.__alive ? i++ : (o || c.renderTask.dispose(),
                    u.remove(c.group),
                    c.dispose(a, h),
                    s.splice(i, 1),
                    delete l[c.__id],
                    c.__id = c.group.__ecComponentInfo = null)
                }
            }
            function I(t) {
                t.clearColorPalette(),
                t.eachSeries(function(t) {
                    t.clearColorPalette()
                })
            }
            function A(t, e, i, n) {
                !function(t, i, n, a, e) {
                    f(e || t._componentsViews, function(t) {
                        var e = t.__model;
                        t.render(e, i, n, a),
                        L(e, t)
                    })
                }(t, e, i, n),
                f(t._chartsViews, function(t) {
                    t.__alive = !1
                }),
                T(t, e, i, n),
                f(t._chartsViews, function(t) {
                    t.__alive || t.remove(e, i)
                })
            }
            function T(n, t, e, a, r) {
                var o, s = n._scheduler;
                t.eachSeries(function(t) {
                    var e = n._chartsMap[t.__viewId];
                    e.__alive = !0;
                    var i = e.renderTask;
                    s.updatePayload(i, a),
                    r && r.get(t.uid) && i.dirty(),
                    o |= i.perform(s.getPerformArgs(i)),
                    e.group.silent = !!t.get("silent"),
                    L(t, e),
                    function(t, e) {
                        var i = t.get("blendMode") || null;
                        e.group.traverse(function(t) {
                            t.isGroup || t.style.blend !== i && t.setStyle("blend", i),
                            t.eachPendingDisplayable && t.eachPendingDisplayable(function(t) {
                                t.setStyle("blend", i)
                            })
                        })
                    }(t, e)
                }),
                s.unfinished |= o,
                function(t, e) {
                    var i = t.storage
                      , n = 0;
                    i.traverse(function(t) {
                        t.isGroup || n++
                    }),
                    n > e.get("hoverLayerThreshold") && !et.node && i.traverse(function(t) {
                        t.isGroup || (t.useHoverLayer = !0)
                    })
                }(n._zr, t),
                nd(n._zr.dom, t)
            }
            function C(e, i) {
                f(E, function(t) {
                    t(e, i)
                })
            }
            c.resize = function(t) {
                this._zr.resize(t);
                var e = this._model;
                if (this._loadingFX && this._loadingFX.resize(),
                e) {
                    var i = e.resetOption("media")
                      , n = t && t.silent;
                    this[g] = !0,
                    i && y(this),
                    v.update.call(this),
                    this[g] = !1,
                    w.call(this, n),
                    S.call(this, n)
                }
            }
            ,
            c.showLoading = function(t, e) {
                if (l(t) && (e = t,
                t = ""),
                t = t || "default",
                this.hideLoading(),
                B[t]) {
                    var i = B[t](this._api, e)
                      , n = this._zr;
                    this._loadingFX = i,
                    n.add(i)
                }
            }
            ,
            c.hideLoading = function() {
                this._loadingFX && this._zr.remove(this._loadingFX),
                this._loadingFX = null
            }
            ,
            c.makeActionFromEvent = function(t) {
                var e = it.extend({}, t);
                return e.type = O[t.type],
                e
            }
            ,
            c.dispatchAction = function(t, e) {
                l(e) || (e = {
                    silent: !!e
                }),
                k[t.type] && this._model && (this[g] ? this._pendingActions.push(t) : (b.call(this, t, e.silent),
                e.flush ? this._zr.flush(!0) : !1 !== e.flush && et.browser.weChat && this._throttledZrFlush(),
                w.call(this, e.silent),
                S.call(this, e.silent)))
            }
            ,
            c.appendData = function(t) {
                var e = t.seriesIndex;
                this.getModel().getSeriesByIndex(e).appendData(t),
                this._scheduler.unfinished = !0
            }
            ,
            c.on = n("on"),
            c.off = n("off"),
            c.one = n("one");
            var D = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
            function L(t, e) {
                var i = t.get("z")
                  , n = t.get("zlevel");
                e.group.traverse(function(t) {
                    "group" !== t.type && (null != i && (t.z = i),
                    null != n && (t.zlevel = n))
                })
            }
            function P() {
                this.eventInfo
            }
            c._initEvents = function() {
                f(D, function(u) {
                    function t(t) {
                        var e, i = this.getModel(), n = t.target;
                        if ("globalout" === u)
                            e = {};
                        else if (n && null != n.dataIndex) {
                            var a = n.dataModel || i.getSeriesByIndex(n.seriesIndex);
                            e = a && a.getDataParams(n.dataIndex, n.dataType, n) || {}
                        } else
                            n && n.eventData && (e = it.extend({}, n.eventData));
                        if (e) {
                            var r = e.componentType
                              , o = e.componentIndex;
                            "markLine" !== r && "markPoint" !== r && "markArea" !== r || (r = "series",
                            o = e.seriesIndex);
                            var s = r && null != o && i.getComponent(r, o)
                              , l = s && this["series" === s.mainType ? "_chartsMap" : "_componentsMap"][s.__viewId];
                            e.event = t,
                            e.type = u,
                            this._ecEventProcessor.eventInfo = {
                                targetEl: n,
                                packedEvent: e,
                                model: s,
                                view: l
                            },
                            this.trigger(u, e)
                        }
                    }
                    t.zrEventfulCallAtLast = !0,
                    this._zr.on(u, t, this)
                }, this),
                f(O, function(t, e) {
                    this._messageCenter.on(e, function(t) {
                        this.trigger(e, t)
                    }, this)
                }, this)
            }
            ,
            c.isDisposed = function() {
                return this._disposed
            }
            ,
            c.clear = function() {
                this.setOption({
                    series: []
                }, !0)
            }
            ,
            c.dispose = function() {
                if (!this._disposed) {
                    this._disposed = !0,
                    aa.setAttribute(this.getDom(), Z, "");
                    var e = this._api
                      , i = this._model;
                    f(this._componentsViews, function(t) {
                        t.dispose(i, e)
                    }),
                    f(this._chartsViews, function(t) {
                        t.dispose(i, e)
                    }),
                    this._zr.dispose(),
                    delete G[this.id]
                }
            }
            ,
            it.mixin(h, nt),
            P.prototype = {
                constructor: P,
                normalizeQuery: function(t) {
                    var s = {}
                      , l = {}
                      , u = {};
                    if (it.isString(t)) {
                        var e = p(t);
                        s.mainType = e.main || null,
                        s.subType = e.sub || null
                    } else {
                        var h = ["Index", "Name", "Id"]
                          , c = {
                            name: 1,
                            dataIndex: 1,
                            dataType: 1
                        };
                        it.each(t, function(t, e) {
                            for (var i = !1, n = 0; n < h.length; n++) {
                                var a = h[n]
                                  , r = e.lastIndexOf(a);
                                if (0 < r && r === e.length - a.length) {
                                    var o = e.slice(0, r);
                                    "data" !== o && (s.mainType = o,
                                    s[a.toLowerCase()] = t,
                                    i = !0)
                                }
                            }
                            c.hasOwnProperty(e) && (l[e] = t,
                            i = !0),
                            i || (u[e] = t)
                        })
                    }
                    return {
                        cptQuery: s,
                        dataQuery: l,
                        otherQuery: u
                    }
                },
                filter: function(t, e, i) {
                    var n = this.eventInfo;
                    if (!n)
                        return !0;
                    var a = n.targetEl
                      , r = n.packedEvent
                      , o = n.model
                      , s = n.view;
                    if (!o || !s)
                        return !0;
                    var l = e.cptQuery
                      , u = e.dataQuery;
                    return h(l, o, "mainType") && h(l, o, "subType") && h(l, o, "index", "componentIndex") && h(l, o, "name") && h(l, o, "id") && h(u, r, "name") && h(u, r, "dataIndex") && h(u, r, "dataType") && (!s.filterForExposedEvent || s.filterForExposedEvent(t, e.otherQuery, a, r));
                    function h(t, e, i, n) {
                        return null == t[i] || e[n || i] === t[i]
                    }
                },
                afterTrigger: function() {
                    this.eventInfo = null
                }
            };
            var k = {}
              , O = {}
              , R = []
              , N = []
              , E = []
              , z = []
              , V = {}
              , B = {}
              , G = {}
              , F = {}
              , H = new Date - 0
              , W = new Date - 0
              , Z = "_echarts_instance_";
            function U(t) {
                F[t] = !1
            }
            var Y = U;
            function j(t) {
                return G[aa.getAttribute(t, Z)]
            }
            function X(t, e) {
                V[t] = e
            }
            function q(t) {
                N.push(t)
            }
            function K(t, e) {
                Q(R, t, e, 1e3)
            }
            function $(t, e, i) {
                "function" == typeof e && (i = e,
                e = "");
                var n = l(t) ? t.type : [t, t = {
                    event: e
                }][0];
                t.event = (t.event || n).toLowerCase(),
                e = t.event,
                a(r.test(n) && r.test(e)),
                k[n] || (k[n] = {
                    action: i,
                    actionInfo: t
                }),
                O[e] = n
            }
            function J(t, e) {
                Q(z, t, e, 3e3, "visual")
            }
            function Q(t, e, i, n, a) {
                (s(e) || l(e)) && (i = e,
                e = n);
                var r = Od.wrapStageHandler(i, a);
                return r.__prio = e,
                r.__raw = i,
                t.push(r),
                r
            }
            function tt(t, e) {
                B[t] = e
            }
            J(2e3, td),
            q(_h),
            K(5e3, Mh),
            tt("default", rd),
            $({
                type: "highlight",
                event: "highlight",
                update: "highlight"
            }, it.noop),
            $({
                type: "downplay",
                event: "downplay",
                update: "downplay"
            }, it.noop),
            X("light", Nd),
            X("dark", Bd);
            e.version = "4.2.1",
            e.dependencies = {
                zrender: "4.0.6"
            },
            e.PRIORITY = i,
            e.init = function(t, e, i) {
                var n = j(t);
                if (n)
                    return n;
                var a = new h(t,e,i);
                return a.id = "ec_" + H++,
                G[a.id] = a,
                aa.setAttribute(t, Z, a.id),
                function(n) {
                    var a = "__connectUpdateStatus";
                    function r(t, e) {
                        for (var i = 0; i < t.length; i++) {
                            t[i][a] = e
                        }
                    }
                    f(O, function(t, e) {
                        n._messageCenter.on(e, function(t) {
                            if (F[n.group] && 0 !== n[a]) {
                                if (t && t.escapeConnect)
                                    return;
                                var e = n.makeActionFromEvent(t)
                                  , i = [];
                                f(G, function(t) {
                                    t !== n && t.group === n.group && i.push(t)
                                }),
                                r(i, 0),
                                f(i, function(t) {
                                    1 !== t[a] && t.dispatchAction(e)
                                }),
                                r(i, 2)
                            }
                        })
                    })
                }(a),
                a
            }
            ,
            e.connect = function(e) {
                if (it.isArray(e)) {
                    var t = e;
                    e = null,
                    f(t, function(t) {
                        null != t.group && (e = t.group)
                    }),
                    e = e || "g_" + W++,
                    f(t, function(t) {
                        t.group = e
                    })
                }
                return F[e] = !0,
                e
            }
            ,
            e.disConnect = U,
            e.disconnect = Y,
            e.dispose = function(t) {
                "string" == typeof t ? t = G[t] : t instanceof h || (t = j(t)),
                t instanceof h && !t.isDisposed() && t.dispose()
            }
            ,
            e.getInstanceByDom = j,
            e.getInstanceById = function(t) {
                return G[t]
            }
            ,
            e.registerTheme = X,
            e.registerPreprocessor = q,
            e.registerProcessor = K,
            e.registerPostUpdate = function(t) {
                E.push(t)
            }
            ,
            e.registerAction = $,
            e.registerCoordinateSystem = function(t, e) {
                ju.register(t, e)
            }
            ,
            e.getCoordinateSystemDimensions = function(t) {
                var e = ju.get(t);
                if (e)
                    return e.getDimensionsInfo ? e.getDimensionsInfo() : e.dimensions.slice()
            }
            ,
            e.registerLayout = function(t, e) {
                Q(z, t, e, 1e3, "layout")
            }
            ,
            e.registerVisual = J,
            e.registerLoading = tt,
            e.extendComponentModel = function(t) {
                return Pl.extend(t)
            }
            ,
            e.extendComponentView = function(t) {
                return Rc.extend(t)
            }
            ,
            e.extendSeriesModel = function(t) {
                return kc.extend(t)
            }
            ,
            e.extendChartView = function(t) {
                return Xc.extend(t)
            }
            ,
            e.setCanvasCreator = function(t) {
                it.$override("createCanvas", t)
            }
            ,
            e.registerMap = function(t, e, i) {
                yp.registerMap(t, e, i)
            }
            ,
            e.getMap = function(t) {
                var e = yp.retrieveMap(t);
                return e && e[0] && {
                    geoJson: e[0].geoJSON,
                    specialAreas: e[0].specialAreas
                }
            }
            ,
            e.dataTool = {},
            function() {
                for (var t in Bm)
                    Bm.hasOwnProperty(t) && (e[t] = Bm[t])
            }()
        })
          , Fm = (Gm.version,
        Gm.dependencies,
        Gm.PRIORITY,
        Gm.init,
        Gm.connect,
        Gm.disConnect,
        Gm.disconnect,
        Gm.dispose,
        Gm.getInstanceByDom,
        Gm.getInstanceById,
        Gm.registerTheme,
        Gm.registerPreprocessor,
        Gm.registerProcessor,
        Gm.registerPostUpdate,
        Gm.registerAction,
        Gm.registerCoordinateSystem,
        Gm.getCoordinateSystemDimensions,
        Gm.registerLayout,
        Gm.registerVisual,
        Gm.registerLoading,
        Gm.extendComponentModel,
        Gm.extendComponentView,
        Gm.extendSeriesModel,
        Gm.extendChartView,
        Gm.setCanvasCreator,
        Gm.registerMap,
        Gm.getMap,
        Gm.dataTool,
        kc.extend({
            type: "series.line",
            dependencies: ["grid", "polar"],
            getInitialData: function(t, e) {
                return Sf(this.getSource(), this)
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "cartesian2d",
                legendHoverLink: !0,
                hoverAnimation: !0,
                clipOverflow: !0,
                label: {
                    position: "top"
                },
                lineStyle: {
                    width: 2,
                    type: "solid"
                },
                step: !1,
                smooth: !1,
                smoothMonotone: null,
                symbol: "emptyCircle",
                symbolSize: 4,
                symbolRotate: null,
                showSymbol: !0,
                showAllSymbol: "auto",
                connectNulls: !1,
                sampling: "none",
                animationEasing: "linear",
                progressive: 0,
                hoverLayerThreshold: 1 / 0
            }
        }),
        Uh.retrieveRawValue);
        var Hm = {
            getDefaultLabel: function(t, e) {
                var i = t.mapDimension("defaultedLabel", !0)
                  , n = i.length;
                if (1 === n)
                    return Fm(t, e, i[0]);
                if (n) {
                    for (var a = [], r = 0; r < i.length; r++) {
                        var o = Fm(t, e, i[r]);
                        a.push(o)
                    }
                    return a.join(" ")
                }
            }
        }
          , Wm = Fg.createSymbol
          , Zm = ol.parsePercent
          , Um = Hm.getDefaultLabel;
        function Ym(t, e, i) {
            Fs.Group.call(this),
            this.updateData(t, e, i)
        }
        var jm = Ym.prototype
          , Xm = Ym.getSymbolSize = function(t, e) {
            var i = t.getItemVisual(e, "symbolSize");
            return i instanceof Array ? i.slice() : [+i, +i]
        }
        ;
        function qm(t) {
            return [t[0] / 2, t[1] / 2]
        }
        function Km(t, e) {
            this.parent.drift(t, e)
        }
        jm._createSymbol = function(t, e, i, n, a) {
            this.removeAll();
            var r = e.getItemVisual(i, "color")
              , o = Wm(t, -1, -1, 2, 2, r, a);
            o.attr({
                z2: 100,
                culling: !0,
                scale: qm(n)
            }),
            o.drift = Km,
            this._symbolType = t,
            this.add(o)
        }
        ,
        jm.stopSymbolAnimation = function(t) {
            this.childAt(0).stopAnimation(t)
        }
        ,
        jm.getSymbolPath = function() {
            return this.childAt(0)
        }
        ,
        jm.getScale = function() {
            return this.childAt(0).scale
        }
        ,
        jm.highlight = function() {
            this.childAt(0).trigger("emphasis")
        }
        ,
        jm.downplay = function() {
            this.childAt(0).trigger("normal")
        }
        ,
        jm.setZ = function(t, e) {
            var i = this.childAt(0);
            i.zlevel = t,
            i.z = e
        }
        ,
        jm.setDraggable = function(t) {
            var e = this.childAt(0);
            e.draggable = t,
            e.cursor = t ? "move" : "pointer"
        }
        ,
        jm.updateData = function(t, e, i) {
            this.silent = !1;
            var n = t.getItemVisual(e, "symbol") || "circle"
              , a = t.hostModel
              , r = Xm(t, e)
              , o = n !== this._symbolType;
            if (o) {
                var s = t.getItemVisual(e, "symbolKeepAspect");
                this._createSymbol(n, t, e, r, s)
            } else {
                (l = this.childAt(0)).silent = !1,
                Fs.updateProps(l, {
                    scale: qm(r)
                }, a, e)
            }
            if (this._updateCommon(t, e, r, i),
            o) {
                var l = this.childAt(0)
                  , u = i && i.fadeIn
                  , h = {
                    scale: l.scale.slice()
                };
                u && (h.style = {
                    opacity: l.style.opacity
                }),
                l.scale = [0, 0],
                u && (l.style.opacity = 0),
                Fs.initProps(l, h, a, e)
            }
            this._seriesModel = a
        }
        ;
        var $m = ["itemStyle"]
          , Jm = ["emphasis", "itemStyle"]
          , Qm = ["label"]
          , tv = ["emphasis", "label"];
        function ev() {
            Fs.isInEmphasis(this) || nv.call(this)
        }
        function iv() {
            Fs.isInEmphasis(this) || av.call(this)
        }
        function nv() {
            if (!this.incremental && !this.useHoverLayer) {
                var t = this.__symbolOriginalScale
                  , e = t[1] / t[0];
                this.animateTo({
                    scale: [Math.max(1.1 * t[0], t[0] + 3), Math.max(1.1 * t[1], t[1] + 3 * e)]
                }, 400, "elasticOut")
            }
        }
        function av() {
            this.incremental || this.useHoverLayer || this.animateTo({
                scale: this.__symbolOriginalScale
            }, 400, "elasticOut")
        }
        jm._updateCommon = function(i, t, e, n) {
            var a = this.childAt(0)
              , r = i.hostModel
              , o = i.getItemVisual(t, "color");
            "image" !== a.type && a.useStyle({
                strokeNoScale: !0
            });
            var s = n && n.itemStyle
              , l = n && n.hoverItemStyle
              , u = n && n.symbolRotate
              , h = n && n.symbolOffset
              , c = n && n.labelModel
              , d = n && n.hoverLabelModel
              , p = n && n.hoverAnimation
              , f = n && n.cursorStyle;
            if (!n || i.hasItemOption) {
                var g = n && n.itemModel ? n.itemModel : i.getItemModel(t);
                s = g.getModel($m).getItemStyle(["color"]),
                l = g.getModel(Jm).getItemStyle(),
                u = g.getShallow("symbolRotate"),
                h = g.getShallow("symbolOffset"),
                c = g.getModel(Qm),
                d = g.getModel(tv),
                p = g.getShallow("hoverAnimation"),
                f = g.getShallow("cursor")
            } else
                l = it.extend({}, l);
            var m = a.style;
            a.attr("rotation", (u || 0) * Math.PI / 180 || 0),
            h && a.attr("position", [Zm(h[0], e[0]), Zm(h[1], e[1])]),
            f && a.attr("cursor", f),
            a.setColor(o, n && n.symbolInnerColor),
            a.setStyle(s);
            var v = i.getItemVisual(t, "opacity");
            null != v && (m.opacity = v);
            var y = i.getItemVisual(t, "liftZ")
              , x = a.__z2Origin;
            null != y ? null == x && (a.__z2Origin = a.z2,
            a.z2 += y) : null != x && (a.z2 = x,
            a.__z2Origin = null);
            var _ = n && n.useNameLabel;
            Fs.setLabelStyle(m, l, c, d, {
                labelFetcher: r,
                labelDataIndex: t,
                defaultText: function(t, e) {
                    return _ ? i.getName(t) : Um(i, t)
                },
                isRectText: !0,
                autoColor: o
            }),
            a.off("mouseover").off("mouseout").off("emphasis").off("normal"),
            a.hoverStyle = l,
            Fs.setHoverStyle(a),
            a.__symbolOriginalScale = qm(e),
            p && r.isAnimationEnabled() && a.on("mouseover", ev).on("mouseout", iv).on("emphasis", nv).on("normal", av)
        }
        ,
        jm.fadeOut = function(t, e) {
            var i = this.childAt(0);
            this.silent = i.silent = !0,
            e && e.keepLabel || (i.style.text = null),
            Fs.updateProps(i, {
                style: {
                    opacity: 0
                },
                scale: [0, 0]
            }, this._seriesModel, this.dataIndex, t)
        }
        ,
        it.inherits(Ym, Fs.Group);
        var rv = Ym
          , ov = it.isObject;
        function sv(t) {
            this.group = new Fs.Group,
            this._symbolCtor = t || rv
        }
        var lv = sv.prototype;
        function uv(t, e, i, n) {
            return e && !isNaN(e[0]) && !isNaN(e[1]) && !(n.isIgnore && n.isIgnore(i)) && !(n.clipShape && !n.clipShape.contain(e[0], e[1])) && "none" !== t.getItemVisual(i, "symbol")
        }
        function hv(t) {
            return null == t || ov(t) || (t = {
                isIgnore: t
            }),
            t || {}
        }
        function cv(t) {
            var e = t.hostModel;
            return {
                itemStyle: e.getModel("itemStyle").getItemStyle(["color"]),
                hoverItemStyle: e.getModel("emphasis.itemStyle").getItemStyle(),
                symbolRotate: e.get("symbolRotate"),
                symbolOffset: e.get("symbolOffset"),
                hoverAnimation: e.get("hoverAnimation"),
                labelModel: e.getModel("label"),
                hoverLabelModel: e.getModel("emphasis.label"),
                cursorStyle: e.get("cursor")
            }
        }
        lv.updateData = function(a, r) {
            r = hv(r);
            var o = this.group
              , s = a.hostModel
              , l = this._data
              , u = this._symbolCtor
              , h = cv(a);
            l || o.removeAll(),
            a.diff(l).add(function(t) {
                var e = a.getItemLayout(t);
                if (uv(a, e, t, r)) {
                    var i = new u(a,t,h);
                    i.attr("position", e),
                    a.setItemGraphicEl(t, i),
                    o.add(i)
                }
            }).update(function(t, e) {
                var i = l.getItemGraphicEl(e)
                  , n = a.getItemLayout(t);
                uv(a, n, t, r) ? (i ? (i.updateData(a, t, h),
                Fs.updateProps(i, {
                    position: n
                }, s)) : (i = new u(a,t)).attr("position", n),
                o.add(i),
                a.setItemGraphicEl(t, i)) : o.remove(i)
            }).remove(function(t) {
                var e = l.getItemGraphicEl(t);
                e && e.fadeOut(function() {
                    o.remove(e)
                })
            }).execute(),
            this._data = a
        }
        ,
        lv.isPersistent = function() {
            return !0
        }
        ,
        lv.updateLayout = function() {
            var n = this._data;
            n && n.eachItemGraphicEl(function(t, e) {
                var i = n.getItemLayout(e);
                t.attr("position", i)
            })
        }
        ,
        lv.incrementalPrepareUpdate = function(t) {
            this._seriesScope = cv(t),
            this._data = null,
            this.group.removeAll()
        }
        ,
        lv.incrementalUpdate = function(t, e, i) {
            function n(t) {
                t.isGroup || (t.incremental = t.useHoverLayer = !0)
            }
            i = hv(i);
            for (var a = t.start; a < t.end; a++) {
                var r = e.getItemLayout(a);
                if (uv(e, r, a, i)) {
                    var o = new this._symbolCtor(e,a,this._seriesScope);
                    o.traverse(n),
                    o.attr("position", r),
                    this.group.add(o),
                    e.setItemGraphicEl(a, o)
                }
            }
        }
        ,
        lv.remove = function(t) {
            var e = this.group
              , i = this._data;
            i && t ? i.eachItemGraphicEl(function(t) {
                t.fadeOut(function() {
                    e.remove(t)
                })
            }) : e.removeAll()
        }
        ;
        var dv = sv
          , pv = vf.isDimensionStacked
          , fv = it.map;
        var gv = {
            prepareDataCoordInfo: function(t, e, i) {
                var n, a = t.getBaseAxis(), r = t.getOtherAxis(a), o = function(t, e) {
                    var i = 0
                      , n = t.scale.getExtent();
                    "start" === e ? i = n[0] : "end" === e ? i = n[1] : 0 < n[0] ? i = n[0] : n[1] < 0 && (i = n[1]);
                    return i
                }(r, i), s = a.dim, l = r.dim, u = e.mapDimension(l), h = e.mapDimension(s), c = "x" === l || "radius" === l ? 1 : 0, d = fv(t.dimensions, function(t) {
                    return e.mapDimension(t)
                }), p = e.getCalculationInfo("stackResultDimension");
                return (n |= pv(e, d[0])) && (d[0] = p),
                (n |= pv(e, d[1])) && (d[1] = p),
                {
                    dataDimsForPoint: d,
                    valueStart: o,
                    valueAxisDim: l,
                    baseAxisDim: s,
                    stacked: !!n,
                    valueDim: u,
                    baseDim: h,
                    baseDataOffset: c,
                    stackedOverDimension: e.getCalculationInfo("stackedOverDimension")
                }
            },
            getStackedOnPoint: function(t, e, i, n) {
                var a = NaN;
                t.stacked && (a = i.get(i.getCalculationInfo("stackedOverDimension"), n)),
                isNaN(a) && (a = t.valueStart);
                var r = t.baseDataOffset
                  , o = [];
                return o[r] = i.get(t.baseDim, n),
                o[1 - r] = a,
                e.dataToPoint(o)
            }
        }
          , mv = gv.prepareDataCoordInfo
          , vv = gv.getStackedOnPoint;
        var yv = function(t, e, i, n, a, r, o, s) {
            for (var l = function(t, e) {
                var i = [];
                return e.diff(t).add(function(t) {
                    i.push({
                        cmd: "+",
                        idx: t
                    })
                }).update(function(t, e) {
                    i.push({
                        cmd: "=",
                        idx: e,
                        idx1: t
                    })
                }).remove(function(t) {
                    i.push({
                        cmd: "-",
                        idx: t
                    })
                }).execute(),
                i
            }(t, e), u = [], h = [], c = [], d = [], p = [], f = [], g = [], m = mv(a, e, o), v = mv(r, t, s), y = 0; y < l.length; y++) {
                var x = l[y]
                  , _ = !0;
                switch (x.cmd) {
                case "=":
                    var b = t.getItemLayout(x.idx)
                      , w = e.getItemLayout(x.idx1);
                    (isNaN(b[0]) || isNaN(b[1])) && (b = w.slice()),
                    u.push(b),
                    h.push(w),
                    c.push(i[x.idx]),
                    d.push(n[x.idx1]),
                    g.push(e.getRawIndex(x.idx1));
                    break;
                case "+":
                    var S = x.idx;
                    u.push(a.dataToPoint([e.get(m.dataDimsForPoint[0], S), e.get(m.dataDimsForPoint[1], S)])),
                    h.push(e.getItemLayout(S).slice()),
                    c.push(vv(m, a, e, S)),
                    d.push(n[S]),
                    g.push(e.getRawIndex(S));
                    break;
                case "-":
                    S = x.idx;
                    var M = t.getRawIndex(S);
                    M !== S ? (u.push(t.getItemLayout(S)),
                    h.push(r.dataToPoint([t.get(v.dataDimsForPoint[0], S), t.get(v.dataDimsForPoint[1], S)])),
                    c.push(i[S]),
                    d.push(vv(v, r, t, S)),
                    g.push(M)) : _ = !1
                }
                _ && (p.push(x),
                f.push(f.length))
            }
            f.sort(function(t, e) {
                return g[t] - g[e]
            });
            var I = []
              , A = []
              , T = []
              , C = []
              , D = [];
            for (y = 0; y < f.length; y++) {
                S = f[y];
                I[y] = u[S],
                A[y] = h[S],
                T[y] = c[S],
                C[y] = d[S],
                D[y] = p[S]
            }
            return {
                current: I,
                next: A,
                stackedOnCurrent: T,
                stackedOnNext: C,
                status: D
            }
        }
          , xv = R.min
          , _v = R.max
          , bv = R.scaleAndAdd
          , wv = R.copy
          , Sv = []
          , Mv = []
          , Iv = [];
        function Av(t) {
            return isNaN(t[0]) || isNaN(t[1])
        }
        function Tv(t, e, i, n, a, r, o, s, l, u) {
            return "none" !== u && u ? function(t, e, i, n, a, r, o, s, l, u, h) {
                for (var c = 0, d = i, p = 0; p < n; p++) {
                    var f = e[d];
                    if (a <= d || d < 0)
                        break;
                    if (Av(f)) {
                        if (h) {
                            d += r;
                            continue
                        }
                        break
                    }
                    if (d === i)
                        t[0 < r ? "moveTo" : "lineTo"](f[0], f[1]);
                    else if (0 < l) {
                        var g = e[c]
                          , m = "y" === u ? 1 : 0
                          , v = (f[m] - g[m]) * l;
                        wv(Mv, g),
                        Mv[m] = g[m] + v,
                        wv(Iv, f),
                        Iv[m] = f[m] - v,
                        t.bezierCurveTo(Mv[0], Mv[1], Iv[0], Iv[1], f[0], f[1])
                    } else
                        t.lineTo(f[0], f[1]);
                    c = d,
                    d += r
                }
                return p
            }
            .apply(this, arguments) : function(t, e, i, n, a, r, o, s, l, u, h) {
                for (var c = 0, d = i, p = 0; p < n; p++) {
                    var f = e[d];
                    if (a <= d || d < 0)
                        break;
                    if (Av(f)) {
                        if (h) {
                            d += r;
                            continue
                        }
                        break
                    }
                    if (d === i)
                        t[0 < r ? "moveTo" : "lineTo"](f[0], f[1]),
                        wv(Mv, f);
                    else if (0 < l) {
                        var g = d + r
                          , m = e[g];
                        if (h)
                            for (; m && Av(e[g]); )
                                m = e[g += r];
                        var v = .5
                          , y = e[c];
                        if (!(m = e[g]) || Av(m))
                            wv(Iv, f);
                        else {
                            var x, _;
                            if (Av(m) && !h && (m = f),
                            R.sub(Sv, m, y),
                            "x" === u || "y" === u) {
                                var b = "x" === u ? 0 : 1;
                                x = Math.abs(f[b] - y[b]),
                                _ = Math.abs(f[b] - m[b])
                            } else
                                x = R.dist(f, y),
                                _ = R.dist(f, m);
                            bv(Iv, f, Sv, -l * (1 - (v = _ / (_ + x))))
                        }
                        xv(Mv, Mv, s),
                        _v(Mv, Mv, o),
                        xv(Iv, Iv, s),
                        _v(Iv, Iv, o),
                        t.bezierCurveTo(Mv[0], Mv[1], Iv[0], Iv[1], f[0], f[1]),
                        bv(Mv, f, Sv, l * v)
                    } else
                        t.lineTo(f[0], f[1]);
                    c = d,
                    d += r
                }
                return p
            }
            .apply(this, arguments)
        }
        function Cv(t, e) {
            var i = [1 / 0, 1 / 0]
              , n = [-1 / 0, -1 / 0];
            if (e)
                for (var a = 0; a < t.length; a++) {
                    var r = t[a];
                    r[0] < i[0] && (i[0] = r[0]),
                    r[1] < i[1] && (i[1] = r[1]),
                    r[0] > n[0] && (n[0] = r[0]),
                    r[1] > n[1] && (n[1] = r[1])
                }
            return {
                min: e ? i : n,
                max: e ? n : i
            }
        }
        var Dv = {
            Polyline: Cr.extend({
                type: "ec-polyline",
                shape: {
                    points: [],
                    smooth: 0,
                    smoothConstraint: !0,
                    smoothMonotone: null,
                    connectNulls: !1
                },
                style: {
                    fill: null,
                    stroke: "#000"
                },
                brush: Jr(Cr.prototype.brush),
                buildPath: function(t, e) {
                    var i = e.points
                      , n = 0
                      , a = i.length
                      , r = Cv(i, e.smoothConstraint);
                    if (e.connectNulls) {
                        for (; 0 < a && Av(i[a - 1]); a--)
                            ;
                        for (; n < a && Av(i[n]); n++)
                            ;
                    }
                    for (; n < a; )
                        n += Tv(t, i, n, a, a, 1, r.min, r.max, e.smooth, e.smoothMonotone, e.connectNulls) + 1
                }
            }),
            Polygon: Cr.extend({
                type: "ec-polygon",
                shape: {
                    points: [],
                    stackedOnPoints: [],
                    smooth: 0,
                    stackedOnSmooth: 0,
                    smoothConstraint: !0,
                    smoothMonotone: null,
                    connectNulls: !1
                },
                brush: Jr(Cr.prototype.brush),
                buildPath: function(t, e) {
                    var i = e.points
                      , n = e.stackedOnPoints
                      , a = 0
                      , r = i.length
                      , o = e.smoothMonotone
                      , s = Cv(i, e.smoothConstraint)
                      , l = Cv(n, e.smoothConstraint);
                    if (e.connectNulls) {
                        for (; 0 < r && Av(i[r - 1]); r--)
                            ;
                        for (; a < r && Av(i[a]); a++)
                            ;
                    }
                    for (; a < r; ) {
                        var u = Tv(t, i, a, r, r, 1, s.min, s.max, e.smooth, o, e.connectNulls);
                        Tv(t, n, a + u - 1, u, r, -1, l.min, l.max, e.stackedOnSmooth, o, e.connectNulls),
                        a += u + 1,
                        t.closePath()
                    }
                }
            })
        }
          , Lv = Dv.Polyline
          , Pv = Dv.Polygon
          , kv = ol.round
          , Ov = gv.prepareDataCoordInfo
          , Rv = gv.getStackedOnPoint;
        function Nv(t, e) {
            if (t.length === e.length) {
                for (var i = 0; i < t.length; i++) {
                    var n = t[i]
                      , a = e[i];
                    if (n[0] !== a[0] || n[1] !== a[1])
                        return
                }
                return !0
            }
        }
        function Ev(t) {
            return "number" == typeof t ? t : t ? .5 : 0
        }
        function zv(t) {
            var e = t.getGlobalExtent();
            if (t.onBand) {
                var i = t.getBandWidth() / 2 - 1
                  , n = e[1] > e[0] ? 1 : -1;
                e[0] += n * i,
                e[1] -= n * i
            }
            return e
        }
        function Vv(t, e, i, n) {
            return "polar" === t.type ? function(t, e, i, n) {
                var a = t.getAngleAxis()
                  , r = t.getRadiusAxis().getExtent().slice();
                r[0] > r[1] && r.reverse();
                var o = a.getExtent()
                  , s = Math.PI / 180;
                i && (r[0] -= .5,
                r[1] += .5);
                var l = new Fs.Sector({
                    shape: {
                        cx: kv(t.cx, 1),
                        cy: kv(t.cy, 1),
                        r0: kv(r[0], 1),
                        r: kv(r[1], 1),
                        startAngle: -o[0] * s,
                        endAngle: -o[1] * s,
                        clockwise: a.inverse
                    }
                });
                return e && (l.shape.endAngle = -o[0] * s,
                Fs.initProps(l, {
                    shape: {
                        endAngle: -o[1] * s
                    }
                }, n)),
                l
            }(t, e, i, n) : function(t, e, i, n) {
                var a = zv(t.getAxis("x"))
                  , r = zv(t.getAxis("y"))
                  , o = t.getBaseAxis().isHorizontal()
                  , s = Math.min(a[0], a[1])
                  , l = Math.min(r[0], r[1])
                  , u = Math.max(a[0], a[1]) - s
                  , h = Math.max(r[0], r[1]) - l;
                if (i)
                    s -= .5,
                    u += .5,
                    l -= .5,
                    h += .5;
                else {
                    var c = n.get("lineStyle.width") || 2
                      , d = n.get("clipOverflow") ? c / 2 : Math.max(u, h);
                    o ? (l -= d,
                    h += 2 * d) : (s -= d,
                    u += 2 * d)
                }
                var p = new Fs.Rect({
                    shape: {
                        x: s,
                        y: l,
                        width: u,
                        height: h
                    }
                });
                return e && (p.shape[o ? "width" : "height"] = 0,
                Fs.initProps(p, {
                    shape: {
                        width: u,
                        height: h
                    }
                }, n)),
                p
            }(t, e, i, n)
        }
        function Bv(t, e, i) {
            for (var n = e.getBaseAxis(), a = "x" === n.dim || "radius" === n.dim ? 0 : 1, r = [], o = 0; o < t.length - 1; o++) {
                var s = t[o + 1]
                  , l = t[o];
                r.push(l);
                var u = [];
                switch (i) {
                case "end":
                    u[a] = s[a],
                    u[1 - a] = l[1 - a],
                    r.push(u);
                    break;
                case "middle":
                    var h = (l[a] + s[a]) / 2
                      , c = [];
                    u[a] = c[a] = h,
                    u[1 - a] = l[1 - a],
                    c[1 - a] = s[1 - a],
                    r.push(u),
                    r.push(c);
                    break;
                default:
                    u[a] = l[a],
                    u[1 - a] = s[1 - a],
                    r.push(u)
                }
            }
            return t[o] && r.push(t[o]),
            r
        }
        function Gv(t, e, i) {
            var n = t.get("showAllSymbol")
              , a = "auto" === n;
            if (!n || a) {
                var r = i.getAxesByScale("ordinal")[0];
                if (r && (!a || !function(t, e) {
                    var i = t.getExtent()
                      , n = Math.abs(i[1] - i[0]) / t.scale.count();
                    isNaN(n) && (n = 0);
                    for (var a = e.count(), r = Math.max(1, Math.round(a / 5)), o = 0; o < a; o += r)
                        if (1.5 * rv.getSymbolSize(e, o)[t.isHorizontal() ? 1 : 0] > n)
                            return !1;
                    return !0
                }(r, e))) {
                    var o = e.mapDimension(r.dim)
                      , s = {};
                    return it.each(r.getViewLabels(), function(t) {
                        s[t.tickValue] = 1
                    }),
                    function(t) {
                        return !s.hasOwnProperty(e.get(o, t))
                    }
                }
            }
        }
        Xc.extend({
            type: "line",
            init: function() {
                var t = new Fs.Group
                  , e = new dv;
                this.group.add(e.group),
                this._symbolDraw = e,
                this._lineGroup = t
            },
            render: function(t, e, i) {
                var n = t.coordinateSystem
                  , a = this.group
                  , r = t.getData()
                  , o = t.getModel("lineStyle")
                  , s = t.getModel("areaStyle")
                  , l = r.mapArray(r.getItemLayout)
                  , u = "polar" === n.type
                  , h = this._coordSys
                  , c = this._symbolDraw
                  , d = this._polyline
                  , p = this._polygon
                  , f = this._lineGroup
                  , g = t.get("animation")
                  , m = !s.isEmpty()
                  , v = s.get("origin")
                  , y = function(t, e, i) {
                    if (!i.valueDim)
                        return [];
                    for (var n = [], a = 0, r = e.count(); a < r; a++)
                        n.push(Rv(i, t, e, a));
                    return n
                }(n, r, Ov(n, r, v))
                  , x = t.get("showSymbol")
                  , _ = x && !u && Gv(t, r, n)
                  , b = this._data;
                b && b.eachItemGraphicEl(function(t, e) {
                    t.__temp && (a.remove(t),
                    b.setItemGraphicEl(e, null))
                }),
                x || c.remove(),
                a.add(f);
                var w = !u && t.get("step");
                d && h.type === n.type && w === this._step ? (m && !p ? p = this._newPolygon(l, y, n, g) : p && !m && (f.remove(p),
                p = this._polygon = null),
                f.setClipPath(Vv(n, !1, !1, t)),
                x && c.updateData(r, {
                    isIgnore: _,
                    clipShape: Vv(n, !1, !0, t)
                }),
                r.eachItemGraphicEl(function(t) {
                    t.stopAnimation(!0)
                }),
                Nv(this._stackedOnPoints, y) && Nv(this._points, l) || (g ? this._updateAnimation(r, y, n, i, w, v) : (w && (l = Bv(l, n, w),
                y = Bv(y, n, w)),
                d.setShape({
                    points: l
                }),
                p && p.setShape({
                    points: l,
                    stackedOnPoints: y
                })))) : (x && c.updateData(r, {
                    isIgnore: _,
                    clipShape: Vv(n, !1, !0, t)
                }),
                w && (l = Bv(l, n, w),
                y = Bv(y, n, w)),
                d = this._newPolyline(l, n, g),
                m && (p = this._newPolygon(l, y, n, g)),
                f.setClipPath(Vv(n, !0, !1, t)));
                var S = function(t, e) {
                    var i = t.getVisual("visualMeta");
                    if (i && i.length && t.count() && "cartesian2d" === e.type) {
                        for (var n, a, r = i.length - 1; 0 <= r; r--) {
                            var o = i[r].dimension
                              , s = t.dimensions[o]
                              , l = t.getDimensionInfo(s);
                            if ("x" === (n = l && l.coordDim) || "y" === n) {
                                a = i[r];
                                break
                            }
                        }
                        if (a) {
                            var u = e.getAxis(n)
                              , h = it.map(a.stops, function(t) {
                                return {
                                    coord: u.toGlobalCoord(u.dataToCoord(t.value)),
                                    color: t.color
                                }
                            })
                              , c = h.length
                              , d = a.outerColors.slice();
                            c && h[0].coord > h[c - 1].coord && (h.reverse(),
                            d.reverse());
                            var p = h[0].coord - 10
                              , f = h[c - 1].coord + 10
                              , g = f - p;
                            if (g < .001)
                                return "transparent";
                            it.each(h, function(t) {
                                t.offset = (t.coord - p) / g
                            }),
                            h.push({
                                offset: c ? h[c - 1].offset : .5,
                                color: d[1] || "transparent"
                            }),
                            h.unshift({
                                offset: c ? h[0].offset : .5,
                                color: d[0] || "transparent"
                            });
                            var m = new Fs.LinearGradient(0,0,0,0,h,!0);
                            return m[n] = p,
                            m[n + "2"] = f,
                            m
                        }
                    }
                }(r, n) || r.getVisual("color");
                d.useStyle(it.defaults(o.getLineStyle(), {
                    fill: "none",
                    stroke: S,
                    lineJoin: "bevel"
                }));
                var M = t.get("smooth");
                if (M = Ev(t.get("smooth")),
                d.setShape({
                    smooth: M,
                    smoothMonotone: t.get("smoothMonotone"),
                    connectNulls: t.get("connectNulls")
                }),
                p) {
                    var I = r.getCalculationInfo("stackedOnSeries")
                      , A = 0;
                    p.useStyle(it.defaults(s.getAreaStyle(), {
                        fill: S,
                        opacity: .7,
                        lineJoin: "bevel"
                    })),
                    I && (A = Ev(I.get("smooth"))),
                    p.setShape({
                        smooth: M,
                        stackedOnSmooth: A,
                        smoothMonotone: t.get("smoothMonotone"),
                        connectNulls: t.get("connectNulls")
                    })
                }
                this._data = r,
                this._coordSys = n,
                this._stackedOnPoints = y,
                this._points = l,
                this._step = w,
                this._valueOrigin = v
            },
            dispose: function() {},
            highlight: function(t, e, i, n) {
                var a = t.getData()
                  , r = aa.queryDataIndex(a, n);
                if (!(r instanceof Array) && null != r && 0 <= r) {
                    var o = a.getItemGraphicEl(r);
                    if (!o) {
                        var s = a.getItemLayout(r);
                        if (!s)
                            return;
                        (o = new rv(a,r)).position = s,
                        o.setZ(t.get("zlevel"), t.get("z")),
                        o.ignore = isNaN(s[0]) || isNaN(s[1]),
                        o.__temp = !0,
                        a.setItemGraphicEl(r, o),
                        o.stopSymbolAnimation(!0),
                        this.group.add(o)
                    }
                    o.highlight()
                } else
                    Xc.prototype.highlight.call(this, t, e, i, n)
            },
            downplay: function(t, e, i, n) {
                var a = t.getData()
                  , r = aa.queryDataIndex(a, n);
                if (null != r && 0 <= r) {
                    var o = a.getItemGraphicEl(r);
                    o && (o.__temp ? (a.setItemGraphicEl(r, null),
                    this.group.remove(o)) : o.downplay())
                } else
                    Xc.prototype.downplay.call(this, t, e, i, n)
            },
            _newPolyline: function(t) {
                var e = this._polyline;
                return e && this._lineGroup.remove(e),
                e = new Lv({
                    shape: {
                        points: t
                    },
                    silent: !0,
                    z2: 10
                }),
                this._lineGroup.add(e),
                this._polyline = e
            },
            _newPolygon: function(t, e) {
                var i = this._polygon;
                return i && this._lineGroup.remove(i),
                i = new Pv({
                    shape: {
                        points: t,
                        stackedOnPoints: e
                    },
                    silent: !0
                }),
                this._lineGroup.add(i),
                this._polygon = i
            },
            _updateAnimation: function(t, e, i, n, a, r) {
                var o = this._polyline
                  , s = this._polygon
                  , l = t.hostModel
                  , u = yv(this._data, t, this._stackedOnPoints, e, this._coordSys, i, this._valueOrigin, r)
                  , h = u.current
                  , c = u.stackedOnCurrent
                  , d = u.next
                  , p = u.stackedOnNext;
                a && (h = Bv(u.current, i, a),
                c = Bv(u.stackedOnCurrent, i, a),
                d = Bv(u.next, i, a),
                p = Bv(u.stackedOnNext, i, a)),
                o.shape.__points = u.current,
                o.shape.points = h,
                Fs.updateProps(o, {
                    shape: {
                        points: d
                    }
                }, l),
                s && (s.setShape({
                    points: h,
                    stackedOnPoints: c
                }),
                Fs.updateProps(s, {
                    shape: {
                        points: d,
                        stackedOnPoints: p
                    }
                }, l));
                for (var f = [], g = u.status, m = 0; m < g.length; m++) {
                    if ("=" === g[m].cmd) {
                        var v = t.getItemGraphicEl(g[m].idx1);
                        v && f.push({
                            el: v,
                            ptIdx: m
                        })
                    }
                }
                o.animators && o.animators.length && o.animators[0].during(function() {
                    for (var t = 0; t < f.length; t++) {
                        f[t].el.attr("position", o.shape.__points[f[t].ptIdx])
                    }
                })
            },
            remove: function(t) {
                var i = this.group
                  , n = this._data;
                this._lineGroup.removeAll(),
                this._symbolDraw.remove(!0),
                n && n.eachItemGraphicEl(function(t, e) {
                    t.__temp && (i.remove(t),
                    n.setItemGraphicEl(e, null))
                }),
                this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null
            }
        });
        var Fv = function(t, o, s) {
            return {
                seriesType: t,
                performRawSeries: !0,
                reset: function(l, t, e) {
                    var i = l.getData()
                      , n = l.get("symbol") || o
                      , u = l.get("symbolSize")
                      , a = l.get("symbolKeepAspect");
                    if (i.setVisual({
                        legendSymbol: s || n,
                        symbol: n,
                        symbolSize: u,
                        symbolKeepAspect: a
                    }),
                    !t.isSeriesFiltered(l)) {
                        var r = "function" == typeof u;
                        return {
                            dataEach: i.hasItemOption || r ? function(t, e) {
                                if ("function" == typeof u) {
                                    var i = l.getRawValue(e)
                                      , n = l.getDataParams(e);
                                    t.setItemVisual(e, "symbolSize", u(i, n))
                                }
                                if (t.hasItemOption) {
                                    var a = t.getItemModel(e)
                                      , r = a.getShallow("symbol", !0)
                                      , o = a.getShallow("symbolSize", !0)
                                      , s = a.getShallow("symbolKeepAspect", !0);
                                    null != r && t.setItemVisual(e, "symbol", r),
                                    null != o && t.setItemVisual(e, "symbolSize", o),
                                    null != s && t.setItemVisual(e, "symbolKeepAspect", s)
                                }
                            }
                            : null
                        }
                    }
                }
            }
        }
          , Hv = it.map
          , Wv = vf.isDimensionStacked;
        function Zv(t, e) {
            return Math.round(t.length / 2)
        }
        var Uv = function(t) {
            return {
                seriesType: t,
                plan: Ec(),
                reset: function(t) {
                    var e = t.getData()
                      , c = t.coordinateSystem
                      , d = t.pipelineContext.large;
                    if (c) {
                        var p = Hv(c.dimensions, function(t) {
                            return e.mapDimension(t)
                        }).slice(0, 2)
                          , f = p.length
                          , i = e.getCalculationInfo("stackResultDimension");
                        return Wv(e, p[0]) && (p[0] = i),
                        Wv(e, p[1]) && (p[1] = i),
                        f && {
                            progress: function(t, e) {
                                for (var i = t.end - t.start, n = d && new Float32Array(i * f), a = t.start, r = 0, o = [], s = []; a < t.end; a++) {
                                    var l;
                                    if (1 === f) {
                                        var u = e.get(p[0], a);
                                        l = !isNaN(u) && c.dataToPoint(u, null, s)
                                    } else {
                                        u = o[0] = e.get(p[0], a);
                                        var h = o[1] = e.get(p[1], a);
                                        l = !isNaN(u) && !isNaN(h) && c.dataToPoint(o, null, s)
                                    }
                                    d ? (n[r++] = l ? l[0] : NaN,
                                    n[r++] = l ? l[1] : NaN) : e.setItemLayout(a, l && l.slice() || [NaN, NaN])
                                }
                                d && e.setLayout("symbolPoints", n)
                            }
                        }
                    }
                }
            }
        }
          , Yv = {
            average: function(t) {
                for (var e = 0, i = 0, n = 0; n < t.length; n++)
                    isNaN(t[n]) || (e += t[n],
                    i++);
                return 0 === i ? NaN : e / i
            },
            sum: function(t) {
                for (var e = 0, i = 0; i < t.length; i++)
                    e += t[i] || 0;
                return e
            },
            max: function(t) {
                for (var e = -1 / 0, i = 0; i < t.length; i++)
                    t[i] > e && (e = t[i]);
                return isFinite(e) ? e : NaN
            },
            min: function(t) {
                for (var e = 1 / 0, i = 0; i < t.length; i++)
                    t[i] < e && (e = t[i]);
                return isFinite(e) ? e : NaN
            },
            nearest: function(t) {
                return t[0]
            }
        };
        var jv = function(t) {
            return {
                seriesType: t,
                modifyOutputEnd: !0,
                reset: function(t, e, i) {
                    var n = t.getData()
                      , a = t.get("sampling")
                      , r = t.coordinateSystem;
                    if ("cartesian2d" === r.type && a) {
                        var o, s = r.getBaseAxis(), l = r.getOtherAxis(s), u = s.getExtent(), h = u[1] - u[0], c = Math.round(n.count() / h);
                        if (1 < c)
                            "string" == typeof a ? o = Yv[a] : "function" == typeof a && (o = a),
                            o && t.setData(n.downSample(n.mapDimension(l.dim), 1 / c, o, Zv))
                    }
                }
            }
        };
        function Xv(t) {
            return this._axes[t]
        }
        function qv(t) {
            this._axes = {},
            this._dimList = [],
            this.name = t || ""
        }
        qv.prototype = {
            constructor: qv,
            type: "cartesian",
            getAxis: function(t) {
                return this._axes[t]
            },
            getAxes: function() {
                return it.map(this._dimList, Xv, this)
            },
            getAxesByScale: function(e) {
                return e = e.toLowerCase(),
                it.filter(this.getAxes(), function(t) {
                    return t.scale.type === e
                })
            },
            addAxis: function(t) {
                var e = t.dim;
                this._axes[e] = t,
                this._dimList.push(e)
            },
            dataToCoord: function(t) {
                return this._dataCoordConvert(t, "dataToCoord")
            },
            coordToData: function(t) {
                return this._dataCoordConvert(t, "coordToData")
            },
            _dataCoordConvert: function(t, e) {
                for (var i = this._dimList, n = t instanceof Array ? [] : {}, a = 0; a < i.length; a++) {
                    var r = i[a]
                      , o = this._axes[r];
                    n[r] = o[e](t[r])
                }
                return n
            }
        };
        var Kv = qv;
        function $v(t) {
            Kv.call(this, t)
        }
        $v.prototype = {
            constructor: $v,
            type: "cartesian2d",
            dimensions: ["x", "y"],
            getBaseAxis: function() {
                return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x")
            },
            containPoint: function(t) {
                var e = this.getAxis("x")
                  , i = this.getAxis("y");
                return e.contain(e.toLocalCoord(t[0])) && i.contain(i.toLocalCoord(t[1]))
            },
            containData: function(t) {
                return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1])
            },
            dataToPoint: function(t, e, i) {
                var n = this.getAxis("x")
                  , a = this.getAxis("y");
                return (i = i || [])[0] = n.toGlobalCoord(n.dataToCoord(t[0])),
                i[1] = a.toGlobalCoord(a.dataToCoord(t[1])),
                i
            },
            clampData: function(t, e) {
                var i = this.getAxis("x").scale
                  , n = this.getAxis("y").scale
                  , a = i.getExtent()
                  , r = n.getExtent()
                  , o = i.parse(t[0])
                  , s = n.parse(t[1]);
                return (e = e || [])[0] = Math.min(Math.max(Math.min(a[0], a[1]), o), Math.max(a[0], a[1])),
                e[1] = Math.min(Math.max(Math.min(r[0], r[1]), s), Math.max(r[0], r[1])),
                e
            },
            pointToData: function(t, e) {
                var i = this.getAxis("x")
                  , n = this.getAxis("y");
                return (e = e || [])[0] = i.coordToData(i.toLocalCoord(t[0])),
                e[1] = n.coordToData(n.toLocalCoord(t[1])),
                e
            },
            getOtherAxis: function(t) {
                return this.getAxis("x" === t.dim ? "y" : "x")
            }
        },
        it.inherits($v, Kv);
        function Jv(t, e, i, n, a) {
            wm.call(this, t, e, i),
            this.type = n || "value",
            this.position = a || "bottom"
        }
        var Qv = $v;
        Jv.prototype = {
            constructor: Jv,
            index: 0,
            getAxesOnZeroOf: null,
            model: null,
            isHorizontal: function() {
                var t = this.position;
                return "top" === t || "bottom" === t
            },
            getGlobalExtent: function(t) {
                var e = this.getExtent();
                return e[0] = this.toGlobalCoord(e[0]),
                e[1] = this.toGlobalCoord(e[1]),
                t && e[0] > e[1] && e.reverse(),
                e
            },
            getOtherAxis: function() {
                this.grid.getOtherAxis()
            },
            pointToData: function(t, e) {
                return this.coordToData(this.toLocalCoord(t["x" === this.dim ? 0 : 1]), e)
            },
            toLocalCoord: null,
            toGlobalCoord: null
        },
        it.inherits(Jv, wm);
        var ty = Jv
          , ey = {
            show: !0,
            zlevel: 0,
            z: 0,
            inverse: !1,
            name: "",
            nameLocation: "end",
            nameRotate: null,
            nameTruncate: {
                maxWidth: null,
                ellipsis: "...",
                placeholder: "."
            },
            nameTextStyle: {},
            nameGap: 15,
            silent: !1,
            triggerEvent: !1,
            tooltip: {
                show: !1
            },
            axisPointer: {},
            axisLine: {
                show: !0,
                onZero: !0,
                onZeroAxisIndex: null,
                lineStyle: {
                    color: "#333",
                    width: 1,
                    type: "solid"
                },
                symbol: ["none", "none"],
                symbolSize: [10, 15]
            },
            axisTick: {
                show: !0,
                inside: !1,
                length: 5,
                lineStyle: {
                    width: 1
                }
            },
            axisLabel: {
                show: !0,
                inside: !1,
                rotate: 0,
                showMinLabel: null,
                showMaxLabel: null,
                margin: 8,
                fontSize: 12
            },
            splitLine: {
                show: !0,
                lineStyle: {
                    color: ["#ccc"],
                    width: 1,
                    type: "solid"
                }
            },
            splitArea: {
                show: !1,
                areaStyle: {
                    color: ["rgba(250,250,250,0.3)", "rgba(200,200,200,0.3)"]
                }
            }
        }
          , iy = {};
        iy.categoryAxis = it.merge({
            boundaryGap: !0,
            deduplication: null,
            splitLine: {
                show: !1
            },
            axisTick: {
                alignWithLabel: !1,
                interval: "auto"
            },
            axisLabel: {
                interval: "auto"
            }
        }, ey),
        iy.valueAxis = it.merge({
            boundaryGap: [0, 0],
            splitNumber: 5
        }, ey),
        iy.timeAxis = it.defaults({
            scale: !0,
            min: "dataMin",
            max: "dataMax"
        }, iy.valueAxis),
        iy.logAxis = it.defaults({
            scale: !0,
            logBase: 10
        }, iy.valueAxis);
        var ny = iy
          , ay = Il.getLayoutParams
          , ry = Il.mergeLayoutParam
          , oy = ["value", "category", "time", "log"];
        var sy = function(o, t, s, e) {
            it.each(oy, function(r) {
                t.extend({
                    type: o + "Axis." + r,
                    mergeDefaultAndTheme: function(t, e) {
                        var i = this.layoutMode
                          , n = i ? ay(t) : {}
                          , a = e.getTheme();
                        it.merge(t, a.get(r + "Axis")),
                        it.merge(t, this.getDefaultOption()),
                        t.type = s(o, t),
                        i && ry(t, n, i)
                    },
                    optionUpdated: function() {
                        "category" === this.option.type && (this.__ordinalMeta = Of.createByAxisModel(this))
                    },
                    getCategories: function(t) {
                        var e = this.option;
                        if ("category" === e.type)
                            return t ? e.data : this.__ordinalMeta.categories
                    },
                    getOrdinalMeta: function() {
                        return this.__ordinalMeta
                    },
                    defaultOption: it.mergeAll([{}, ny[r + "Axis"], e], !0)
                })
            }),
            Pl.registerSubTypeDefaulter(o + "Axis", it.curry(s, o))
        }
          , ly = Pl.extend({
            type: "cartesian2dAxis",
            axis: null,
            init: function() {
                ly.superApply(this, "init", arguments),
                this.resetRange()
            },
            mergeOption: function() {
                ly.superApply(this, "mergeOption", arguments),
                this.resetRange()
            },
            restoreData: function() {
                ly.superApply(this, "restoreData", arguments),
                this.resetRange()
            },
            getCoordSysModel: function() {
                return this.ecModel.queryComponents({
                    mainType: "grid",
                    index: this.option.gridIndex,
                    id: this.option.gridId
                })[0]
            }
        });
        function uy(t, e) {
            return e.type || (e.data ? "category" : "value")
        }
        it.merge(ly.prototype, Pg);
        var hy = {
            offset: 0
        };
        sy("x", ly, uy, hy),
        sy("y", ly, uy, hy);
        Pl.extend({
            type: "grid",
            dependencies: ["xAxis", "yAxis"],
            layoutMode: "box",
            coordinateSystem: null,
            defaultOption: {
                show: !1,
                zlevel: 0,
                z: 0,
                left: "10%",
                top: 60,
                right: "10%",
                bottom: 60,
                containLabel: !1,
                backgroundColor: "rgba(0,0,0,0)",
                borderWidth: 1,
                borderColor: "#ccc"
            }
        });
        var cy = it.isObject
          , dy = it.each
          , py = it.map
          , fy = it.indexOf
          , gy = Il.getLayoutRect
          , my = Lg.createScaleByModel
          , vy = Lg.ifAxisCrossZero
          , yy = Lg.niceScaleExtent
          , xy = Lg.estimateLabelUnionRect
          , _y = vf.getStackedDimension;
        function by(t, e) {
            return t.getCoordSysModel() === e
        }
        function wy(t, e, i) {
            this._coordsMap = {},
            this._coordsList = [],
            this._axesMap = {},
            this._axesList = [],
            this._initCartesian(t, e, i),
            this.model = t
        }
        var Sy = wy.prototype;
        function My(t, e, i, n) {
            i.getAxesOnZeroOf = function() {
                return a ? [a] : []
            }
            ;
            var a, r = t[e], o = i.model, s = o.get("axisLine.onZero"), l = o.get("axisLine.onZeroAxisIndex");
            if (s) {
                if (null != l)
                    Iy(r[l]) && (a = r[l]);
                else
                    for (var u in r)
                        if (r.hasOwnProperty(u) && Iy(r[u]) && !n[h(r[u])]) {
                            a = r[u];
                            break
                        }
                a && (n[h(a)] = !0)
            }
            function h(t) {
                return t.dim + "_" + t.index
            }
        }
        function Iy(t) {
            return t && "category" !== t.type && "time" !== t.type && vy(t)
        }
        Sy.type = "grid",
        Sy.axisPointerEnabled = !0,
        Sy.getRect = function() {
            return this._rect
        }
        ,
        Sy.update = function(t, e) {
            var i = this._axesMap;
            this._updateScale(t, this.model),
            dy(i.x, function(t) {
                yy(t.scale, t.model)
            }),
            dy(i.y, function(t) {
                yy(t.scale, t.model)
            });
            var n = {};
            dy(i.x, function(t) {
                My(i, "y", t, n)
            }),
            dy(i.y, function(t) {
                My(i, "x", t, n)
            }),
            this.resize(this.model, e)
        }
        ,
        Sy.resize = function(t, e, i) {
            var a = gy(t.getBoxLayoutParams(), {
                width: e.getWidth(),
                height: e.getHeight()
            });
            this._rect = a;
            var n = this._axesList;
            function r() {
                dy(n, function(t) {
                    var e = t.isHorizontal()
                      , i = e ? [0, a.width] : [0, a.height]
                      , n = t.inverse ? 1 : 0;
                    t.setExtent(i[n], i[1 - n]),
                    function(t, e) {
                        var i = t.getExtent()
                          , n = i[0] + i[1];
                        t.toGlobalCoord = "x" === t.dim ? function(t) {
                            return t + e
                        }
                        : function(t) {
                            return n - t + e
                        }
                        ,
                        t.toLocalCoord = "x" === t.dim ? function(t) {
                            return t - e
                        }
                        : function(t) {
                            return n - t + e
                        }
                    }(t, e ? a.x : a.y)
                })
            }
            r(),
            !i && t.get("containLabel") && (dy(n, function(t) {
                if (!t.model.get("axisLabel.inside")) {
                    var e = xy(t);
                    if (e) {
                        var i = t.isHorizontal() ? "height" : "width"
                          , n = t.model.get("axisLabel.margin");
                        a[i] -= e[i] + n,
                        "top" === t.position ? a.y += e.height + n : "left" === t.position && (a.x += e.width + n)
                    }
                }
            }),
            r())
        }
        ,
        Sy.getAxis = function(t, e) {
            var i = this._axesMap[t];
            if (null != i) {
                if (null == e)
                    for (var n in i)
                        if (i.hasOwnProperty(n))
                            return i[n];
                return i[e]
            }
        }
        ,
        Sy.getAxes = function() {
            return this._axesList.slice()
        }
        ,
        Sy.getCartesian = function(t, e) {
            if (null != t && null != e) {
                var i = "x" + t + "y" + e;
                return this._coordsMap[i]
            }
            cy(t) && (e = t.yAxisIndex,
            t = t.xAxisIndex);
            for (var n = 0, a = this._coordsList; n < a.length; n++)
                if (a[n].getAxis("x").index === t || a[n].getAxis("y").index === e)
                    return a[n]
        }
        ,
        Sy.getCartesians = function() {
            return this._coordsList.slice()
        }
        ,
        Sy.convertToPixel = function(t, e, i) {
            var n = this._findConvertTarget(t, e);
            return n.cartesian ? n.cartesian.dataToPoint(i) : n.axis ? n.axis.toGlobalCoord(n.axis.dataToCoord(i)) : null
        }
        ,
        Sy.convertFromPixel = function(t, e, i) {
            var n = this._findConvertTarget(t, e);
            return n.cartesian ? n.cartesian.pointToData(i) : n.axis ? n.axis.coordToData(n.axis.toLocalCoord(i)) : null
        }
        ,
        Sy._findConvertTarget = function(t, e) {
            var i, n, a = e.seriesModel, r = e.xAxisModel || a && a.getReferringComponents("xAxis")[0], o = e.yAxisModel || a && a.getReferringComponents("yAxis")[0], s = e.gridModel, l = this._coordsList;
            if (a)
                i = a.coordinateSystem,
                fy(l, i) < 0 && (i = null);
            else if (r && o)
                i = this.getCartesian(r.componentIndex, o.componentIndex);
            else if (r)
                n = this.getAxis("x", r.componentIndex);
            else if (o)
                n = this.getAxis("y", o.componentIndex);
            else if (s) {
                s.coordinateSystem === this && (i = this._coordsList[0])
            }
            return {
                cartesian: i,
                axis: n
            }
        }
        ,
        Sy.containPoint = function(t) {
            var e = this._coordsList[0];
            if (e)
                return e.containPoint(t)
        }
        ,
        Sy._initCartesian = function(o, t, e) {
            var s = {
                left: !1,
                right: !1,
                top: !1,
                bottom: !1
            }
              , l = {
                x: {},
                y: {}
            }
              , u = {
                x: 0,
                y: 0
            };
            if (t.eachComponent("xAxis", i("x"), this),
            t.eachComponent("yAxis", i("y"), this),
            !u.x || !u.y)
                return this._axesMap = {},
                void (this._axesList = []);
            function i(r) {
                return function(t, e) {
                    if (by(t, o)) {
                        var i = t.get("position");
                        "x" === r ? "top" !== i && "bottom" !== i && s[i = "bottom"] && (i = "top" === i ? "bottom" : "top") : "left" !== i && "right" !== i && s[i = "left"] && (i = "left" === i ? "right" : "left"),
                        s[i] = !0;
                        var n = new ty(r,my(t),[0, 0],t.get("type"),i)
                          , a = "category" === n.type;
                        n.onBand = a && t.get("boundaryGap"),
                        n.inverse = t.get("inverse"),
                        (t.axis = n).model = t,
                        n.grid = this,
                        n.index = e,
                        this._axesList.push(n),
                        l[r][e] = n,
                        u[r]++
                    }
                }
            }
            this._axesMap = l,
            dy(l.x, function(a, r) {
                dy(l.y, function(t, e) {
                    var i = "x" + r + "y" + e
                      , n = new Qv(i);
                    n.grid = this,
                    n.model = o,
                    this._coordsMap[i] = n,
                    this._coordsList.push(n),
                    n.addAxis(a),
                    n.addAxis(t)
                }, this)
            }, this)
        }
        ,
        Sy._updateScale = function(t, l) {
            function u(e, i) {
                dy(e.mapDimension(i.dim, !0), function(t) {
                    i.scale.unionExtentFromData(e, _y(e, t))
                })
            }
            dy(this._axesList, function(t) {
                t.scale.setExtent(1 / 0, -1 / 0)
            }),
            t.eachSeries(function(t) {
                if (Cy(t)) {
                    var e = Ty(t)
                      , i = e[0]
                      , n = e[1];
                    if (!by(i, l) || !by(n, l))
                        return;
                    var a = this.getCartesian(i.componentIndex, n.componentIndex)
                      , r = t.getData()
                      , o = a.getAxis("x")
                      , s = a.getAxis("y");
                    "list" === r.type && (u(r, o),
                    u(r, s))
                }
            }, this)
        }
        ,
        Sy.getTooltipAxes = function(n) {
            var a = []
              , r = [];
            return dy(this.getCartesians(), function(t) {
                var e = null != n && "auto" !== n ? t.getAxis(n) : t.getBaseAxis()
                  , i = t.getOtherAxis(e);
                fy(a, e) < 0 && a.push(e),
                fy(r, i) < 0 && r.push(i)
            }),
            {
                baseAxes: a,
                otherAxes: r
            }
        }
        ;
        var Ay = ["xAxis", "yAxis"];
        function Ty(e) {
            return py(Ay, function(t) {
                return e.getReferringComponents(t)[0]
            })
        }
        function Cy(t) {
            return "cartesian2d" === t.get("coordinateSystem")
        }
        wy.create = function(n, a) {
            var r = [];
            return n.eachComponent("grid", function(t, e) {
                var i = new wy(t,n,a);
                i.name = "grid_" + e,
                i.resize(t, a, !0),
                t.coordinateSystem = i,
                r.push(i)
            }),
            n.eachSeries(function(t) {
                if (Cy(t)) {
                    var e = Ty(t)
                      , i = e[0]
                      , n = e[1]
                      , a = i.getCoordSysModel().coordinateSystem;
                    t.coordinateSystem = a.getCartesian(i.componentIndex, n.componentIndex)
                }
            }),
            r
        }
        ,
        wy.dimensions = wy.prototype.dimensions = Qv.prototype.dimensions,
        ju.register("cartesian2d", wy);
        var Dy = it.retrieve
          , Ly = it.defaults
          , Py = it.extend
          , ky = it.each
          , Oy = ol.isRadianAroundZero
          , Ry = ol.remRadian
          , Ny = Fg.createSymbol
          , Ey = R.applyTransform
          , zy = Lg.shouldShowAllLabels
          , Vy = Math.PI;
        function By(t) {
            var e = {
                componentType: t.mainType,
                componentIndex: t.componentIndex
            };
            return e[t.mainType + "Index"] = t.componentIndex,
            e
        }
        function Gy(t, e) {
            this.opt = e,
            this.axisModel = t,
            Ly(e, {
                labelOffset: 0,
                nameDirection: 1,
                tickDirection: 1,
                labelDirection: 1,
                silent: !0
            }),
            this.group = new Fs.Group;
            var i = new Fs.Group({
                position: e.position.slice(),
                rotation: e.rotation
            });
            i.updateTransform(),
            this._transform = i.transform,
            this._dumbGroup = i
        }
        Gy.prototype = {
            constructor: Gy,
            hasBuilder: function(t) {
                return !!Fy[t]
            },
            add: function(t) {
                Fy[t].call(this)
            },
            getGroup: function() {
                return this.group
            }
        };
        var Fy = {
            axisLine: function() {
                var r = this.opt
                  , t = this.axisModel;
                if (t.get("axisLine.show")) {
                    var e = this.axisModel.axis.getExtent()
                      , i = this._transform
                      , o = [e[0], 0]
                      , n = [e[1], 0];
                    i && (Ey(o, o, i),
                    Ey(n, n, i));
                    var s = Py({
                        lineCap: "round"
                    }, t.getModel("axisLine.lineStyle").getLineStyle());
                    this.group.add(new Fs.Line(Fs.subPixelOptimizeLine({
                        anid: "line",
                        shape: {
                            x1: o[0],
                            y1: o[1],
                            x2: n[0],
                            y2: n[1]
                        },
                        style: s,
                        strokeContainThreshold: r.strokeContainThreshold || 5,
                        silent: !0,
                        z2: 1
                    })));
                    var l = t.get("axisLine.symbol")
                      , a = t.get("axisLine.symbolSize")
                      , u = t.get("axisLine.symbolOffset") || 0;
                    if ("number" == typeof u && (u = [u, u]),
                    null != l) {
                        "string" == typeof l && (l = [l, l]),
                        "string" != typeof a && "number" != typeof a || (a = [a, a]);
                        var h = a[0]
                          , c = a[1];
                        ky([{
                            rotate: r.rotation + Math.PI / 2,
                            offset: u[0],
                            r: 0
                        }, {
                            rotate: r.rotation - Math.PI / 2,
                            offset: u[1],
                            r: Math.sqrt((o[0] - n[0]) * (o[0] - n[0]) + (o[1] - n[1]) * (o[1] - n[1]))
                        }], function(t, e) {
                            if ("none" !== l[e] && null != l[e]) {
                                var i = Ny(l[e], -h / 2, -c / 2, h, c, s.stroke, !0)
                                  , n = t.r + t.offset
                                  , a = [o[0] + n * Math.cos(r.rotation), o[1] - n * Math.sin(r.rotation)];
                                i.attr({
                                    rotation: t.rotate,
                                    position: a,
                                    silent: !0,
                                    z2: 11
                                }),
                                this.group.add(i)
                            }
                        }, this)
                    }
                }
            },
            axisTickLabel: function() {
                var t = this.axisModel
                  , e = this.opt
                  , i = function(t, e, i) {
                    var n = e.axis;
                    if (!e.get("axisTick.show") || n.scale.isBlank())
                        return;
                    for (var a = e.getModel("axisTick"), r = a.getModel("lineStyle"), o = a.get("length"), s = n.getTicksCoords(), l = [], u = [], h = t._transform, c = [], d = 0; d < s.length; d++) {
                        var p = s[d].coord;
                        l[0] = p,
                        l[1] = 0,
                        u[0] = p,
                        u[1] = i.tickDirection * o,
                        h && (Ey(l, l, h),
                        Ey(u, u, h));
                        var f = new Fs.Line(Fs.subPixelOptimizeLine({
                            anid: "tick_" + s[d].tickValue,
                            shape: {
                                x1: l[0],
                                y1: l[1],
                                x2: u[0],
                                y2: u[1]
                            },
                            style: Ly(r.getLineStyle(), {
                                stroke: e.get("axisLine.lineStyle.color")
                            }),
                            z2: 2,
                            silent: !0
                        }));
                        t.group.add(f),
                        c.push(f)
                    }
                    return c
                }(this, t, e);
                !function(t, e, i) {
                    if (zy(t.axis))
                        return;
                    var n = t.get("axisLabel.showMinLabel")
                      , a = t.get("axisLabel.showMaxLabel");
                    i = i || [];
                    var r = (e = e || [])[0]
                      , o = e[1]
                      , s = e[e.length - 1]
                      , l = e[e.length - 2]
                      , u = i[0]
                      , h = i[1]
                      , c = i[i.length - 1]
                      , d = i[i.length - 2];
                    !1 === n ? (Zy(r),
                    Zy(u)) : Uy(r, o) && (n ? (Zy(o),
                    Zy(h)) : (Zy(r),
                    Zy(u)));
                    !1 === a ? (Zy(s),
                    Zy(c)) : Uy(l, s) && (a ? (Zy(l),
                    Zy(d)) : (Zy(s),
                    Zy(c)))
                }(t, function(u, h, c) {
                    var d = h.axis;
                    if (!Dy(c.axisLabelShow, h.get("axisLabel.show")) || d.scale.isBlank())
                        return;
                    var p = h.getModel("axisLabel")
                      , f = p.get("margin")
                      , t = d.getViewLabels()
                      , e = (Dy(c.labelRotate, p.get("rotate")) || 0) * Vy / 180
                      , g = Hy(c.rotation, e, c.labelDirection)
                      , m = h.getCategories(!0)
                      , v = []
                      , y = Wy(h)
                      , x = h.get("triggerEvent");
                    return ky(t, function(t, e) {
                        var i = t.tickValue
                          , n = t.formattedLabel
                          , a = t.rawLabel
                          , r = p;
                        m && m[i] && m[i].textStyle && (r = new tl(m[i].textStyle,p,h.ecModel));
                        var o = r.getTextColor() || h.get("axisLine.lineStyle.color")
                          , s = [d.dataToCoord(i), c.labelOffset + c.labelDirection * f]
                          , l = new Fs.Text({
                            anid: "label_" + i,
                            position: s,
                            rotation: g.rotation,
                            silent: y,
                            z2: 10
                        });
                        Fs.setTextStyle(l.style, r, {
                            text: n,
                            textAlign: r.getShallow("align", !0) || g.textAlign,
                            textVerticalAlign: r.getShallow("verticalAlign", !0) || r.getShallow("baseline", !0) || g.textVerticalAlign,
                            textFill: "function" == typeof o ? o("category" === d.type ? a : "value" === d.type ? i + "" : i, e) : o
                        }),
                        x && (l.eventData = By(h),
                        l.eventData.targetType = "axisLabel",
                        l.eventData.value = a),
                        u._dumbGroup.add(l),
                        l.updateTransform(),
                        v.push(l),
                        u.group.add(l),
                        l.decomposeTransform()
                    }),
                    v
                }(this, t, e), i)
            },
            axisName: function() {
                var t = this.opt
                  , e = this.axisModel
                  , i = Dy(t.axisName, e.get("name"));
                if (i) {
                    var n, a, r = e.get("nameLocation"), o = t.nameDirection, s = e.getModel("nameTextStyle"), l = e.get("nameGap") || 0, u = this.axisModel.axis.getExtent(), h = u[0] > u[1] ? -1 : 1, c = ["start" === r ? u[0] - h * l : "end" === r ? u[1] + h * l : (u[0] + u[1]) / 2, Yy(r) ? t.labelOffset + o * l : 0], d = e.get("nameRotate");
                    null != d && (d = d * Vy / 180),
                    Yy(r) ? n = Hy(t.rotation, null != d ? d : t.rotation, o) : (n = function(t, e, i, n) {
                        var a, r, o = Ry(i - t.rotation), s = n[0] > n[1], l = "start" === e && !s || "start" !== e && s;
                        a = Oy(o - Vy / 2) ? (r = l ? "bottom" : "top",
                        "center") : Oy(o - 1.5 * Vy) ? (r = l ? "top" : "bottom",
                        "center") : (r = "middle",
                        o < 1.5 * Vy && Vy / 2 < o ? l ? "left" : "right" : l ? "right" : "left");
                        return {
                            rotation: o,
                            textAlign: a,
                            textVerticalAlign: r
                        }
                    }(t, r, d || 0, u),
                    null != (a = t.axisNameAvailableWidth) && (a = Math.abs(a / Math.sin(n.rotation)),
                    isFinite(a) || (a = null)));
                    var p = s.getFont()
                      , f = e.get("nameTruncate", !0) || {}
                      , g = f.ellipsis
                      , m = Dy(t.nameTruncateMaxWidth, f.maxWidth, a)
                      , v = null != g && null != m ? fl.truncateText(i, m, p, g, {
                        minChar: 2,
                        placeholder: f.placeholder
                    }) : i
                      , y = e.get("tooltip", !0)
                      , x = e.mainType
                      , _ = {
                        componentType: x,
                        name: i,
                        $vars: ["name"]
                    };
                    _[x + "Index"] = e.componentIndex;
                    var b = new Fs.Text({
                        anid: "name",
                        __fullText: i,
                        __truncatedText: v,
                        position: c,
                        rotation: n.rotation,
                        silent: Wy(e),
                        z2: 1,
                        tooltip: y && y.show ? Py({
                            content: i,
                            formatter: function() {
                                return i
                            },
                            formatterParams: _
                        }, y) : null
                    });
                    Fs.setTextStyle(b.style, s, {
                        text: v,
                        textFont: p,
                        textFill: s.getTextColor() || e.get("axisLine.lineStyle.color"),
                        textAlign: n.textAlign,
                        textVerticalAlign: n.textVerticalAlign
                    }),
                    e.get("triggerEvent") && (b.eventData = By(e),
                    b.eventData.targetType = "axisName",
                    b.eventData.name = i),
                    this._dumbGroup.add(b),
                    b.updateTransform(),
                    this.group.add(b),
                    b.decomposeTransform()
                }
            }
        }
          , Hy = Gy.innerTextLayout = function(t, e, i) {
            var n, a = Ry(e - t);
            return {
                rotation: a,
                textAlign: Oy(a) ? (n = 0 < i ? "top" : "bottom",
                "center") : Oy(a - Vy) ? (n = 0 < i ? "bottom" : "top",
                "center") : (n = "middle",
                0 < a && a < Vy ? 0 < i ? "right" : "left" : 0 < i ? "left" : "right"),
                textVerticalAlign: n
            }
        }
        ;
        function Wy(t) {
            var e = t.get("tooltip");
            return t.get("silent") || !(t.get("triggerEvent") || e && e.show)
        }
        function Zy(t) {
            t && (t.ignore = !0)
        }
        function Uy(t, e) {
            var i = t && t.getBoundingRect().clone()
              , n = e && e.getBoundingRect().clone();
            if (i && n) {
                var a = ct.identity([]);
                return ct.rotate(a, a, -t.rotation),
                i.applyTransform(ct.mul([], a, t.getLocalTransform())),
                n.applyTransform(ct.mul([], a, e.getLocalTransform())),
                i.intersect(n)
            }
        }
        function Yy(t) {
            return "middle" === t || "center" === t
        }
        var jy = Gy
          , Xy = it.each
          , qy = it.curry;
        function Ky(t, e) {
            return "all" === t || it.isArray(t) && 0 <= it.indexOf(t, e) || t === e
        }
        function $y(t) {
            var e = (t.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
            return e && e.axesInfo[Qy(t)]
        }
        function Jy(t) {
            return !!t.get("handle.show")
        }
        function Qy(t) {
            return t.type + "||" + t.id
        }
        var tx = {
            collect: function(t, e) {
                var i = {
                    axesInfo: {},
                    seriesInvolved: !1,
                    coordSysAxesInfo: {},
                    coordSysMap: {}
                };
                return function(f, g, t) {
                    var r = g.getComponent("tooltip")
                      , m = g.getComponent("axisPointer")
                      , v = m.get("link", !0) || []
                      , y = [];
                    Xy(t.getCoordinateSystems(), function(c) {
                        if (c.axisPointerEnabled) {
                            var t = Qy(c.model)
                              , d = f.coordSysAxesInfo[t] = {}
                              , p = (f.coordSysMap[t] = c).model.getModel("tooltip", r);
                            if (Xy(c.getAxes(), qy(a, !1, null)),
                            c.getTooltipAxes && r && p.get("show")) {
                                var e = "axis" === p.get("trigger")
                                  , i = "cross" === p.get("axisPointer.type")
                                  , n = c.getTooltipAxes(p.get("axisPointer.axis"));
                                (e || i) && Xy(n.baseAxes, qy(a, !i || "cross", e)),
                                i && Xy(n.otherAxes, qy(a, "cross", !1))
                            }
                        }
                        function a(t, e, i) {
                            var n = i.model.getModel("axisPointer", m)
                              , a = n.get("show");
                            if (a && ("auto" !== a || t || Jy(n))) {
                                null == e && (e = n.get("triggerTooltip"));
                                var r = (n = t ? function(t, e, i, n, a, r) {
                                    var o = e.getModel("axisPointer")
                                      , s = {};
                                    Xy(["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], function(t) {
                                        s[t] = it.clone(o.get(t))
                                    }),
                                    s.snap = "category" !== t.type && !!r,
                                    "cross" === o.get("type") && (s.type = "line");
                                    var l = s.label || (s.label = {});
                                    if (null == l.show && (l.show = !1),
                                    "cross" === a) {
                                        var u = o.get("label.show");
                                        if (l.show = null == u || u,
                                        !r) {
                                            var h = s.lineStyle = o.get("crossStyle");
                                            h && it.defaults(l, h.textStyle)
                                        }
                                    }
                                    return t.model.getModel("axisPointer", new tl(s,i,n))
                                }(i, p, m, g, t, e) : n).get("snap")
                                  , o = Qy(i.model)
                                  , s = e || r || "category" === i.type
                                  , l = f.axesInfo[o] = {
                                    key: o,
                                    axis: i,
                                    coordSys: c,
                                    axisPointerModel: n,
                                    triggerTooltip: e,
                                    involveSeries: s,
                                    snap: r,
                                    useHandle: Jy(n),
                                    seriesModels: []
                                };
                                d[o] = l,
                                f.seriesInvolved |= s;
                                var u = function(t, e) {
                                    for (var i = e.model, n = e.dim, a = 0; a < t.length; a++) {
                                        var r = t[a] || {};
                                        if (Ky(r[n + "AxisId"], i.id) || Ky(r[n + "AxisIndex"], i.componentIndex) || Ky(r[n + "AxisName"], i.name))
                                            return a
                                    }
                                }(v, i);
                                if (null != u) {
                                    var h = y[u] || (y[u] = {
                                        axesInfo: {}
                                    });
                                    h.axesInfo[o] = l,
                                    h.mapper = v[u].mapper,
                                    l.linkGroup = h
                                }
                            }
                        }
                    })
                }(i, t, e),
                i.seriesInvolved && function(a, t) {
                    t.eachSeries(function(i) {
                        var n = i.coordinateSystem
                          , t = i.get("tooltip.trigger", !0)
                          , e = i.get("tooltip.show", !0);
                        n && "none" !== t && !1 !== t && "item" !== t && !1 !== e && !1 !== i.get("axisPointer.show", !0) && Xy(a.coordSysAxesInfo[Qy(n.model)], function(t) {
                            var e = t.axis;
                            n.getAxis(e.dim) === e && (t.seriesModels.push(i),
                            null == t.seriesDataCount && (t.seriesDataCount = 0),
                            t.seriesDataCount += i.getData().count())
                        })
                    }, this)
                }(i, t),
                i
            },
            fixValue: function(t) {
                var e = $y(t);
                if (e) {
                    var i = e.axisPointerModel
                      , n = e.axis.scale
                      , a = i.option
                      , r = i.get("status")
                      , o = i.get("value");
                    null != o && (o = n.parse(o));
                    var s = Jy(i);
                    null == r && (a.status = s ? "show" : "hide");
                    var l = n.getExtent().slice();
                    l[0] > l[1] && l.reverse(),
                    (null == o || o > l[1]) && (o = l[1]),
                    o < l[0] && (o = l[0]),
                    a.value = o,
                    s && (a.status = e.axis.scale.isBlank() ? "hide" : "show")
                }
            },
            getAxisInfo: $y,
            getAxisPointerModel: function(t) {
                var e = $y(t);
                return e && e.axisPointerModel
            },
            makeKey: Qy
        }
          , ex = Gm.extendComponentView({
            type: "axis",
            _axisPointer: null,
            axisPointerClass: null,
            render: function(t, e, i, n) {
                this.axisPointerClass && tx.fixValue(t),
                ex.superApply(this, "render", arguments),
                ix(this, t, e, i, n, !0)
            },
            updateAxisPointer: function(t, e, i, n, a) {
                ix(this, t, e, i, n, !1)
            },
            remove: function(t, e) {
                var i = this._axisPointer;
                i && i.remove(e),
                ex.superApply(this, "remove", arguments)
            },
            dispose: function(t, e) {
                nx(this, e),
                ex.superApply(this, "dispose", arguments)
            }
        });
        function ix(t, e, i, n, a, r) {
            var o = ex.getAxisPointerClass(t.axisPointerClass);
            if (o) {
                var s = tx.getAxisPointerModel(e);
                s ? (t._axisPointer || (t._axisPointer = new o)).render(e, s, n, r) : nx(t, n)
            }
        }
        function nx(t, e, i) {
            var n = t._axisPointer;
            n && n.dispose(e, i),
            t._axisPointer = null
        }
        var ax = [];
        ex.registerAxisPointerClass = function(t, e) {
            ax[t] = e
        }
        ,
        ex.getAxisPointerClass = function(t) {
            return t && ax[t]
        }
        ;
        var rx = ex;
        var ox = {
            layout: function(t, e, i) {
                i = i || {};
                var n = t.coordinateSystem
                  , a = e.axis
                  , r = {}
                  , o = a.getAxesOnZeroOf()[0]
                  , s = a.position
                  , l = o ? "onZero" : s
                  , u = a.dim
                  , h = n.getRect()
                  , c = [h.x, h.x + h.width, h.y, h.y + h.height]
                  , d = {
                    left: 0,
                    right: 1,
                    top: 0,
                    bottom: 1,
                    onZero: 2
                }
                  , p = e.get("offset") || 0
                  , f = "x" === u ? [c[2] - p, c[3] + p] : [c[0] - p, c[1] + p];
                if (o) {
                    var g = o.toGlobalCoord(o.dataToCoord(0));
                    f[d.onZero] = Math.max(Math.min(g, f[1]), f[0])
                }
                r.position = ["y" === u ? f[d[l]] : c[0], "x" === u ? f[d[l]] : c[3]],
                r.rotation = Math.PI / 2 * ("x" === u ? 0 : 1),
                r.labelDirection = r.tickDirection = r.nameDirection = {
                    top: -1,
                    bottom: 1,
                    left: -1,
                    right: 1
                }[s],
                r.labelOffset = o ? f[d[s]] - f[d.onZero] : 0,
                e.get("axisTick.inside") && (r.tickDirection = -r.tickDirection),
                it.retrieve(i.labelInside, e.get("axisLabel.inside")) && (r.labelDirection = -r.labelDirection);
                var m = e.get("axisLabel.rotate");
                return r.labelRotate = "top" === l ? -m : m,
                r.z2 = 1,
                r
            }
        }
          , sx = ["axisLine", "axisTickLabel", "axisName"]
          , lx = ["splitArea", "splitLine"]
          , ux = rx.extend({
            type: "cartesianAxis",
            axisPointerClass: "CartesianAxisPointer",
            render: function(e, t, i, n) {
                this.group.removeAll();
                var a = this._axisGroup;
                if (this._axisGroup = new Fs.Group,
                this.group.add(this._axisGroup),
                e.get("show")) {
                    var r = e.getCoordSysModel()
                      , o = ox.layout(r, e)
                      , s = new jy(e,o);
                    it.each(sx, s.add, s),
                    this._axisGroup.add(s.getGroup()),
                    it.each(lx, function(t) {
                        e.get(t + ".show") && this["_" + t](e, r)
                    }, this),
                    Fs.groupTransition(a, this._axisGroup, e),
                    ux.superCall(this, "render", e, t, i, n)
                }
            },
            remove: function() {
                this._splitAreaColors = null
            },
            _splitLine: function(t, e) {
                var i = t.axis;
                if (!i.scale.isBlank()) {
                    var n = t.getModel("splitLine")
                      , a = n.getModel("lineStyle")
                      , r = a.get("color");
                    r = it.isArray(r) ? r : [r];
                    for (var o = e.coordinateSystem.getRect(), s = i.isHorizontal(), l = 0, u = i.getTicksCoords({
                        tickModel: n
                    }), h = [], c = [], d = a.getLineStyle(), p = 0; p < u.length; p++) {
                        var f = i.toGlobalCoord(u[p].coord);
                        s ? (h[0] = f,
                        h[1] = o.y,
                        c[0] = f,
                        c[1] = o.y + o.height) : (h[0] = o.x,
                        h[1] = f,
                        c[0] = o.x + o.width,
                        c[1] = f);
                        var g = l++ % r.length
                          , m = u[p].tickValue;
                        this._axisGroup.add(new Fs.Line(Fs.subPixelOptimizeLine({
                            anid: null != m ? "line_" + u[p].tickValue : null,
                            shape: {
                                x1: h[0],
                                y1: h[1],
                                x2: c[0],
                                y2: c[1]
                            },
                            style: it.defaults({
                                stroke: r[g]
                            }, d),
                            silent: !0
                        })))
                    }
                }
            },
            _splitArea: function(t, e) {
                var i = t.axis;
                if (!i.scale.isBlank()) {
                    var n = t.getModel("splitArea")
                      , a = n.getModel("areaStyle")
                      , r = a.get("color")
                      , o = e.coordinateSystem.getRect()
                      , s = i.getTicksCoords({
                        tickModel: n,
                        clamp: !0
                    });
                    if (s.length) {
                        var l = r.length
                          , u = this._splitAreaColors
                          , h = it.createHashMap()
                          , c = 0;
                        if (u)
                            for (var d = 0; d < s.length; d++) {
                                var p = u.get(s[d].tickValue);
                                if (null != p) {
                                    c = (p + (l - 1) * d) % l;
                                    break
                                }
                            }
                        var f = i.toGlobalCoord(s[0].coord)
                          , g = a.getAreaStyle();
                        r = it.isArray(r) ? r : [r];
                        for (d = 1; d < s.length; d++) {
                            var m, v, y, x, _ = i.toGlobalCoord(s[d].coord);
                            f = i.isHorizontal() ? (m = f,
                            v = o.y,
                            y = _ - m,
                            x = o.height,
                            m + y) : (m = o.x,
                            v = f,
                            y = o.width,
                            v + (x = _ - v));
                            var b = s[d - 1].tickValue;
                            null != b && h.set(b, c),
                            this._axisGroup.add(new Fs.Rect({
                                anid: null != b ? "area_" + b : null,
                                shape: {
                                    x: m,
                                    y: v,
                                    width: y,
                                    height: x
                                },
                                style: it.defaults({
                                    fill: r[c]
                                }, g),
                                silent: !0
                            })),
                            c = (c + 1) % l
                        }
                        this._splitAreaColors = h
                    }
                }
            }
        });
        ux.extend({
            type: "xAxis"
        }),
        ux.extend({
            type: "yAxis"
        }),
        Gm.extendComponentView({
            type: "grid",
            render: function(t, e) {
                this.group.removeAll(),
                t.get("show") && this.group.add(new Fs.Rect({
                    shape: t.coordinateSystem.getRect(),
                    style: it.defaults({
                        fill: t.get("backgroundColor")
                    }, t.getItemStyle()),
                    silent: !0,
                    z2: -1
                }))
            }
        }),
        Gm.registerPreprocessor(function(t) {
            t.xAxis && t.yAxis && !t.grid && (t.grid = {})
        }),
        Gm.registerVisual(Fv("line", "circle", "line")),
        Gm.registerLayout(Uv("line")),
        Gm.registerProcessor(Gm.PRIORITY.PROCESSOR.STATISTIC, jv("line"));
        var hx = kc.extend({
            type: "series.__base_bar__",
            getInitialData: function(t, e) {
                return Sf(this.getSource(), this)
            },
            getMarkerPosition: function(t) {
                var e = this.coordinateSystem;
                if (e) {
                    var i = e.dataToPoint(e.clampData(t))
                      , n = this.getData()
                      , a = n.getLayout("offset")
                      , r = n.getLayout("size");
                    return i[e.getBaseAxis().isHorizontal() ? 0 : 1] += a + r / 2,
                    i
                }
                return [NaN, NaN]
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "cartesian2d",
                legendHoverLink: !0,
                barMinHeight: 0,
                barMinAngle: 0,
                large: !1,
                largeThreshold: 400,
                progressive: 3e3,
                progressiveChunkMode: "mod",
                itemStyle: {},
                emphasis: {}
            }
        })
          , cx = (hx.extend({
            type: "series.bar",
            dependencies: ["grid", "polar"],
            brushSelector: "rect",
            getProgressive: function() {
                return !!this.get("large") && this.get("progressive")
            },
            getProgressiveThreshold: function() {
                var t = this.get("progressiveThreshold")
                  , e = this.get("largeThreshold");
                return t < e && (t = e),
                t
            }
        }),
        Hm.getDefaultLabel);
        function dx(t, e) {
            "outside" === t.textPosition && (t.textPosition = e)
        }
        var px = {
            setLabel: function(t, e, i, n, a, r, o) {
                var s = i.getModel("label")
                  , l = i.getModel("emphasis.label");
                Fs.setLabelStyle(t, e, s, l, {
                    labelFetcher: a,
                    labelDataIndex: r,
                    defaultText: cx(a.getData(), r),
                    isRectText: !0,
                    autoColor: n
                }),
                dx(t),
                dx(e)
            }
        }
          , fx = da([["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["stroke", "barBorderColor"], ["lineWidth", "barBorderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]])
          , gx = {
            getBarItemStyle: function(t) {
                var e = fx(this, t);
                if (this.getBorderLineDash) {
                    var i = this.getBorderLineDash();
                    i && (e.lineDash = i)
                }
                return e
            }
        }
          , mx = px.setLabel
          , vx = ["itemStyle", "barBorderWidth"];
        it.extend(tl.prototype, gx);
        Gm.extendChartView({
            type: "bar",
            render: function(t, e, i) {
                this._updateDrawMode(t);
                var n = t.get("coordinateSystem");
                return "cartesian2d" !== n && "polar" !== n || (this._isLargeDraw ? this._renderLarge(t, e, i) : this._renderNormal(t, e, i)),
                this.group
            },
            incrementalPrepareRender: function(t, e, i) {
                this._clear(),
                this._updateDrawMode(t)
            },
            incrementalRender: function(t, e, i, n) {
                this._incrementalRenderLarge(t, e)
            },
            _updateDrawMode: function(t) {
                var e = t.pipelineContext.large;
                (null == this._isLargeDraw || e ^ this._isLargeDraw) && (this._isLargeDraw = e,
                this._clear())
            },
            _renderNormal: function(r, t, e) {
                var o, s = this.group, l = r.getData(), u = this._data, h = r.coordinateSystem, i = h.getBaseAxis();
                "cartesian2d" === h.type ? o = i.isHorizontal() : "polar" === h.type && (o = "angle" === i.dim);
                var c = r.isAnimationEnabled() ? r : null;
                l.diff(u).add(function(t) {
                    if (l.hasValue(t)) {
                        var e = l.getItemModel(t)
                          , i = bx[h.type](l, t, e)
                          , n = yx[h.type](l, t, e, i, o, c);
                        l.setItemGraphicEl(t, n),
                        s.add(n),
                        Sx(n, l, t, e, i, r, o, "polar" === h.type)
                    }
                }).update(function(t, e) {
                    var i = u.getItemGraphicEl(e);
                    if (l.hasValue(t)) {
                        var n = l.getItemModel(t)
                          , a = bx[h.type](l, t, n);
                        i ? Fs.updateProps(i, {
                            shape: a
                        }, c, t) : i = yx[h.type](l, t, n, a, o, c, !0),
                        l.setItemGraphicEl(t, i),
                        s.add(i),
                        Sx(i, l, t, n, a, r, o, "polar" === h.type)
                    } else
                        s.remove(i)
                }).remove(function(t) {
                    var e = u.getItemGraphicEl(t);
                    "cartesian2d" === h.type ? e && xx(t, c, e) : e && _x(t, c, e)
                }).execute(),
                this._data = l
            },
            _renderLarge: function(t, e, i) {
                this._clear(),
                Ix(t, this.group)
            },
            _incrementalRenderLarge: function(t, e) {
                Ix(e, this.group, !0)
            },
            dispose: it.noop,
            remove: function(t) {
                this._clear(t)
            },
            _clear: function(e) {
                var t = this.group
                  , i = this._data;
                e && e.get("animation") && i && !this._isLargeDraw ? i.eachItemGraphicEl(function(t) {
                    "sector" === t.type ? _x(t.dataIndex, e, t) : xx(t.dataIndex, e, t)
                }) : t.removeAll(),
                this._data = null
            }
        });
        var yx = {
            cartesian2d: function(t, e, i, n, a, r, o) {
                var s = new Fs.Rect({
                    shape: it.extend({}, n)
                });
                if (r) {
                    var l = a ? "height" : "width"
                      , u = {};
                    s.shape[l] = 0,
                    u[l] = n[l],
                    Fs[o ? "updateProps" : "initProps"](s, {
                        shape: u
                    }, r, e)
                }
                return s
            },
            polar: function(t, e, i, n, a, r, o) {
                var s = n.startAngle < n.endAngle
                  , l = new Fs.Sector({
                    shape: it.defaults({
                        clockwise: s
                    }, n)
                });
                if (r) {
                    var u = a ? "r" : "endAngle"
                      , h = {};
                    l.shape[u] = a ? 0 : n.startAngle,
                    h[u] = n[u],
                    Fs[o ? "updateProps" : "initProps"](l, {
                        shape: h
                    }, r, e)
                }
                return l
            }
        };
        function xx(t, e, i) {
            i.style.text = null,
            Fs.updateProps(i, {
                shape: {
                    width: 0
                }
            }, e, t, function() {
                i.parent && i.parent.remove(i)
            })
        }
        function _x(t, e, i) {
            i.style.text = null,
            Fs.updateProps(i, {
                shape: {
                    r: i.shape.r0
                }
            }, e, t, function() {
                i.parent && i.parent.remove(i)
            })
        }
        var bx = {
            cartesian2d: function(t, e, i) {
                var n = t.getItemLayout(e)
                  , a = function(t, e) {
                    var i = t.get(vx) || 0;
                    return Math.min(i, Math.abs(e.width), Math.abs(e.height))
                }(i, n)
                  , r = 0 < n.width ? 1 : -1
                  , o = 0 < n.height ? 1 : -1;
                return {
                    x: n.x + r * a / 2,
                    y: n.y + o * a / 2,
                    width: n.width - r * a,
                    height: n.height - o * a
                }
            },
            polar: function(t, e, i) {
                var n = t.getItemLayout(e);
                return {
                    cx: n.cx,
                    cy: n.cy,
                    r0: n.r0,
                    r: n.r,
                    startAngle: n.startAngle,
                    endAngle: n.endAngle
                }
            }
        };
        function Sx(t, e, i, n, a, r, o, s) {
            var l = e.getItemVisual(i, "color")
              , u = e.getItemVisual(i, "opacity")
              , h = n.getModel("itemStyle")
              , c = n.getModel("emphasis.itemStyle").getBarItemStyle();
            s || t.setShape("r", h.get("barBorderRadius") || 0),
            t.useStyle(it.defaults({
                fill: l,
                opacity: u
            }, h.getBarItemStyle()));
            var d = n.getShallow("cursor");
            d && t.attr("cursor", d);
            var p = o ? 0 < a.height ? "bottom" : "top" : 0 < a.width ? "left" : "right";
            s || mx(t.style, c, n, l, r, i, p),
            Fs.setHoverStyle(t, c)
        }
        var Mx = Cr.extend({
            type: "largeBar",
            shape: {
                points: []
            },
            buildPath: function(t, e) {
                for (var i = e.points, n = this.__startPoint, a = this.__valueIdx, r = 0; r < i.length; r += 2)
                    n[this.__valueIdx] = i[r + a],
                    t.moveTo(n[0], n[1]),
                    t.lineTo(i[r], i[r + 1])
            }
        });
        function Ix(t, e, i) {
            var n = t.getData()
              , a = []
              , r = n.getLayout("valueAxisHorizontal") ? 1 : 0;
            a[1 - r] = n.getLayout("valueAxisStart");
            var o = new Mx({
                shape: {
                    points: n.getLayout("largePoints")
                },
                incremental: !!i,
                __startPoint: a,
                __valueIdx: r
            });
            e.add(o),
            function(t, e, i) {
                var n = i.getVisual("borderColor") || i.getVisual("color")
                  , a = e.getModel("itemStyle").getItemStyle(["color", "borderColor"]);
                t.useStyle(a),
                t.style.fill = null,
                t.style.stroke = n,
                t.style.lineWidth = i.getLayout("barWidth")
            }(o, t, n)
        }
        var Ax = rg.layout
          , Tx = rg.largeLayout;
        Gm.registerLayout(it.curry(Ax, "bar")),
        Gm.registerLayout(Tx),
        Gm.registerVisual({
            seriesType: "bar",
            reset: function(t) {
                t.getData().setVisual("legendSymbol", "roundRect")
            }
        });
        var Cx = it.extend
          , Dx = it.isArray;
        var Lx = function(t, e, i) {
            e = Dx(e) && {
                coordDimensions: e
            } || Cx({}, e);
            var n = t.getSource()
              , a = pf(n, e)
              , r = new Qp(a,t);
            return r.initData(n, i),
            r
        }
          , Px = {
            updateSelectedMap: function(t) {
                this._targetList = it.isArray(t) ? t.slice() : [],
                this._selectTargetMap = it.reduce(t || [], function(t, e) {
                    return t.set(e.name, e),
                    t
                }, it.createHashMap())
            },
            select: function(t, e) {
                var i = null != e ? this._targetList[e] : this._selectTargetMap.get(t);
                "single" === this.get("selectedMode") && this._selectTargetMap.each(function(t) {
                    t.selected = !1
                }),
                i && (i.selected = !0)
            },
            unSelect: function(t, e) {
                var i = null != e ? this._targetList[e] : this._selectTargetMap.get(t);
                i && (i.selected = !1)
            },
            toggleSelected: function(t, e) {
                var i = null != e ? this._targetList[e] : this._selectTargetMap.get(t);
                if (null != i)
                    return this[i.selected ? "unSelect" : "select"](t, e),
                    i.selected
            },
            isSelected: function(t, e) {
                var i = null != e ? this._targetList[e] : this._selectTargetMap.get(t);
                return i && i.selected
            }
        }
          , kx = ol.getPercentWithPrecision
          , Ox = Uh.retrieveRawAttr
          , Rx = Gm.extendSeriesModel({
            type: "series.pie",
            init: function(t) {
                Rx.superApply(this, "init", arguments),
                this.legendDataProvider = function() {
                    return this.getRawData()
                }
                ,
                this.updateSelectedMap(this._createSelectableList()),
                this._defaultLabelLine(t)
            },
            mergeOption: function(t) {
                Rx.superCall(this, "mergeOption", t),
                this.updateSelectedMap(this._createSelectableList())
            },
            getInitialData: function(t, e) {
                return Lx(this, ["value"])
            },
            _createSelectableList: function() {
                for (var t = this.getRawData(), e = t.mapDimension("value"), i = [], n = 0, a = t.count(); n < a; n++)
                    i.push({
                        name: t.getName(n),
                        value: t.get(e, n),
                        selected: Ox(t, n, "selected")
                    });
                return i
            },
            getDataParams: function(t) {
                var e = this.getData()
                  , i = Rx.superCall(this, "getDataParams", t)
                  , n = [];
                return e.each(e.mapDimension("value"), function(t) {
                    n.push(t)
                }),
                i.percent = kx(n, t, e.hostModel.get("percentPrecision")),
                i.$vars.push("percent"),
                i
            },
            _defaultLabelLine: function(t) {
                aa.defaultEmphasis(t, "labelLine", ["show"]);
                var e = t.labelLine
                  , i = t.emphasis.labelLine;
                e.show = e.show && t.label.show,
                i.show = i.show && t.emphasis.label.show
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                legendHoverLink: !0,
                hoverAnimation: !0,
                center: ["50%", "50%"],
                radius: [0, "75%"],
                clockwise: !0,
                startAngle: 90,
                minAngle: 0,
                selectedOffset: 10,
                hoverOffset: 10,
                avoidLabelOverlap: !0,
                percentPrecision: 2,
                stillShowZeroSum: !0,
                label: {
                    rotate: !1,
                    show: !0,
                    position: "outer"
                },
                labelLine: {
                    show: !0,
                    length: 15,
                    length2: 15,
                    smooth: !1,
                    lineStyle: {
                        width: 1,
                        type: "solid"
                    }
                },
                itemStyle: {
                    borderWidth: 1
                },
                animationType: "expansion",
                animationEasing: "cubicOut"
            }
        });
        function Nx(t, e, i, n) {
            var a = e.getData()
              , r = this.dataIndex
              , o = a.getName(r)
              , s = e.get("selectedOffset");
            n.dispatchAction({
                type: "pieToggleSelect",
                from: t,
                name: o,
                seriesId: e.id
            }),
            a.each(function(t) {
                Ex(a.getItemGraphicEl(t), a.getItemLayout(t), e.isSelected(a.getName(t)), s, i)
            })
        }
        function Ex(t, e, i, n, a) {
            var r = (e.startAngle + e.endAngle) / 2
              , o = i ? n : 0
              , s = [Math.cos(r) * o, Math.sin(r) * o];
            a ? t.animate().when(200, {
                position: s
            }).start("bounceOut") : t.attr("position", s)
        }
        function zx(t, e) {
            Fs.Group.call(this);
            var i = new Fs.Sector({
                z2: 2
            })
              , n = new Fs.Polyline
              , a = new Fs.Text;
            function r() {
                n.ignore = n.hoverIgnore,
                a.ignore = a.hoverIgnore
            }
            function o() {
                n.ignore = n.normalIgnore,
                a.ignore = a.normalIgnore
            }
            this.add(i),
            this.add(n),
            this.add(a),
            this.updateData(t, e, !0),
            this.on("emphasis", r).on("normal", o).on("mouseover", r).on("mouseout", o)
        }
        it.mixin(Rx, Px);
        var Vx = zx.prototype;
        Vx.updateData = function(t, e, i) {
            var n = this.childAt(0)
              , a = t.hostModel
              , r = t.getItemModel(e)
              , o = t.getItemLayout(e)
              , s = it.extend({}, o);
            (s.label = null,
            i) ? (n.setShape(s),
            "scale" === a.getShallow("animationType") ? (n.shape.r = o.r0,
            Fs.initProps(n, {
                shape: {
                    r: o.r
                }
            }, a, e)) : (n.shape.endAngle = o.startAngle,
            Fs.updateProps(n, {
                shape: {
                    endAngle: o.endAngle
                }
            }, a, e))) : Fs.updateProps(n, {
                shape: s
            }, a, e);
            var l = t.getItemVisual(e, "color");
            n.useStyle(it.defaults({
                lineJoin: "bevel",
                fill: l
            }, r.getModel("itemStyle").getItemStyle())),
            n.hoverStyle = r.getModel("emphasis.itemStyle").getItemStyle();
            var u = r.getShallow("cursor");
            function h() {
                n.stopAnimation(!0),
                n.animateTo({
                    shape: {
                        r: o.r + a.get("hoverOffset")
                    }
                }, 300, "elasticOut")
            }
            function c() {
                n.stopAnimation(!0),
                n.animateTo({
                    shape: {
                        r: o.r
                    }
                }, 300, "elasticOut")
            }
            u && n.attr("cursor", u),
            Ex(this, t.getItemLayout(e), a.isSelected(null, e), a.get("selectedOffset"), a.get("animation")),
            n.off("mouseover").off("mouseout").off("emphasis").off("normal"),
            r.get("hoverAnimation") && a.isAnimationEnabled() && n.on("mouseover", h).on("mouseout", c).on("emphasis", h).on("normal", c),
            this._updateLabel(t, e),
            Fs.setHoverStyle(this)
        }
        ,
        Vx._updateLabel = function(t, e) {
            var i = this.childAt(1)
              , n = this.childAt(2)
              , a = t.hostModel
              , r = t.getItemModel(e)
              , o = t.getItemLayout(e).label
              , s = t.getItemVisual(e, "color");
            Fs.updateProps(i, {
                shape: {
                    points: o.linePoints || [[o.x, o.y], [o.x, o.y], [o.x, o.y]]
                }
            }, a, e),
            Fs.updateProps(n, {
                style: {
                    x: o.x,
                    y: o.y
                }
            }, a, e),
            n.attr({
                rotation: o.rotation,
                origin: [o.x, o.y],
                z2: 10
            });
            var l = r.getModel("label")
              , u = r.getModel("emphasis.label")
              , h = r.getModel("labelLine")
              , c = r.getModel("emphasis.labelLine");
            s = t.getItemVisual(e, "color");
            Fs.setLabelStyle(n.style, n.hoverStyle = {}, l, u, {
                labelFetcher: t.hostModel,
                labelDataIndex: e,
                defaultText: t.getName(e),
                autoColor: s,
                useInsideStyle: !!o.inside
            }, {
                textAlign: o.textAlign,
                textVerticalAlign: o.verticalAlign,
                opacity: t.getItemVisual(e, "opacity")
            }),
            n.ignore = n.normalIgnore = !l.get("show"),
            n.hoverIgnore = !u.get("show"),
            i.ignore = i.normalIgnore = !h.get("show"),
            i.hoverIgnore = !c.get("show"),
            i.setStyle({
                stroke: s,
                opacity: t.getItemVisual(e, "opacity")
            }),
            i.setStyle(h.getModel("lineStyle").getLineStyle()),
            i.hoverStyle = c.getModel("lineStyle").getLineStyle();
            var d = h.get("smooth");
            d && !0 === d && (d = .4),
            i.setShape({
                smooth: d
            })
        }
        ,
        it.inherits(zx, Fs.Group);
        Xc.extend({
            type: "pie",
            init: function() {
                var t = new Fs.Group;
                this._sectorGroup = t
            },
            render: function(t, e, i, n) {
                if (!n || n.from !== this.uid) {
                    var a = t.getData()
                      , r = this._data
                      , o = this.group
                      , s = e.get("animation")
                      , l = !r
                      , u = t.get("animationType")
                      , h = it.curry(Nx, this.uid, t, s, i)
                      , c = t.get("selectedMode");
                    if (a.diff(r).add(function(t) {
                        var e = new zx(a,t);
                        l && "scale" !== u && e.eachChild(function(t) {
                            t.stopAnimation(!0)
                        }),
                        c && e.on("click", h),
                        a.setItemGraphicEl(t, e),
                        o.add(e)
                    }).update(function(t, e) {
                        var i = r.getItemGraphicEl(e);
                        i.updateData(a, t),
                        i.off("click"),
                        c && i.on("click", h),
                        o.add(i),
                        a.setItemGraphicEl(t, i)
                    }).remove(function(t) {
                        var e = r.getItemGraphicEl(t);
                        o.remove(e)
                    }).execute(),
                    s && l && 0 < a.count() && "scale" !== u) {
                        var d = a.getItemLayout(0)
                          , p = Math.max(i.getWidth(), i.getHeight()) / 2
                          , f = it.bind(o.removeClipPath, o);
                        o.setClipPath(this._createClipPath(d.cx, d.cy, p, d.startAngle, d.clockwise, f, t))
                    } else
                        o.removeClipPath();
                    this._data = a
                }
            },
            dispose: function() {},
            _createClipPath: function(t, e, i, n, a, r, o) {
                var s = new Fs.Sector({
                    shape: {
                        cx: t,
                        cy: e,
                        r0: 0,
                        r: i,
                        startAngle: n,
                        endAngle: n,
                        clockwise: a
                    }
                });
                return Fs.initProps(s, {
                    shape: {
                        endAngle: n + (a ? 1 : -1) * Math.PI * 2
                    }
                }, o, r),
                s
            },
            containPoint: function(t, e) {
                var i = e.getData().getItemLayout(0);
                if (i) {
                    var n = t[0] - i.cx
                      , a = t[1] - i.cy
                      , r = Math.sqrt(n * n + a * a);
                    return r <= i.r && r >= i.r0
                }
            }
        });
        var Bx = function(i, t) {
            it.each(t, function(r) {
                r.update = "updateView",
                Gm.registerAction(r, function(t, e) {
                    var a = {};
                    return e.eachComponent({
                        mainType: "series",
                        subType: i,
                        query: t
                    }, function(i) {
                        i[r.method] && i[r.method](t.name, t.dataIndex);
                        var n = i.getData();
                        n.each(function(t) {
                            var e = n.getName(t);
                            a[e] = i.isSelected(e) || !1
                        })
                    }),
                    {
                        name: t.name,
                        selected: a
                    }
                })
            })
        }
          , Gx = it.createHashMap;
        var Fx = function(n) {
            return {
                getTargetSeries: function(t) {
                    var e = {}
                      , i = Gx();
                    return t.eachSeriesByType(n, function(t) {
                        t.__paletteScope = e,
                        i.set(t.uid, t)
                    }),
                    i
                },
                reset: function(a, t) {
                    var r = a.getRawData()
                      , o = {}
                      , s = a.getData();
                    s.each(function(t) {
                        var e = s.getRawIndex(t);
                        o[e] = t
                    }),
                    r.each(function(t) {
                        var e = o[t]
                          , i = null != e && s.getItemVisual(e, "color", !0);
                        if (i)
                            r.setItemVisual(t, "color", i);
                        else {
                            var n = r.getItemModel(t).get("itemStyle.color") || a.getColorFromPalette(r.getName(t) || t + "", a.__paletteScope, r.count());
                            r.setItemVisual(t, "color", n),
                            null != e && s.setItemVisual(e, "color", n)
                        }
                    })
                }
            }
        };
        function Hx(a, t, e, i, n, r, o) {
            function s(t, e, i) {
                for (var n = t; n < e; n++)
                    if (a[n].y += i,
                    t < n && n + 1 < e && a[n + 1].y > a[n].y + a[n].height)
                        return void l(n, i / 2);
                l(e - 1, i / 2)
            }
            function l(t, e) {
                for (var i = t; 0 <= i && (a[i].y -= e,
                !(0 < i && a[i].y > a[i - 1].y + a[i - 1].height)); i--)
                    ;
            }
            function u(t, e, i, n, a, r) {
                for (var o = e ? Number.MAX_VALUE : 0, s = 0, l = t.length; s < l; s++) {
                    var u = Math.abs(t[s].y - n)
                      , h = t[s].len
                      , c = t[s].len2
                      , d = u < a + h ? Math.sqrt((a + h + c) * (a + h + c) - u * u) : Math.abs(t[s].x - i);
                    e && o <= d && (d = o - 10),
                    !e && d <= o && (d = o + 10),
                    t[s].x = i + d * r,
                    o = d
                }
            }
            a.sort(function(t, e) {
                return t.y - e.y
            });
            for (var h, c = 0, d = a.length, p = [], f = [], g = 0; g < d; g++)
                (h = a[g].y - c) < 0 && s(g, d, -h),
                c = a[g].y + a[g].height;
            o - c < 0 && l(d - 1, c - o);
            for (g = 0; g < d; g++)
                a[g].y >= e ? f.push(a[g]) : p.push(a[g]);
            u(p, !1, t, e, i, n),
            u(f, !0, t, e, i, n)
        }
        function Wx(t) {
            return "center" === t.position
        }
        var Zx = function(I, A, t, e) {
            var T, C, D = I.getData(), L = [], P = !1;
            D.each(function(t) {
                var e, i, n, a, r = D.getItemLayout(t), o = D.getItemModel(t), s = o.getModel("label"), l = s.get("position") || o.get("emphasis.label.position"), u = o.getModel("labelLine"), h = u.get("length"), c = u.get("length2"), d = (r.startAngle + r.endAngle) / 2, p = Math.cos(d), f = Math.sin(d);
                T = r.cx,
                C = r.cy;
                var g = "inside" === l || "inner" === l;
                if ("center" === l)
                    e = r.cx,
                    i = r.cy,
                    a = "center";
                else {
                    var m = (g ? (r.r + r.r0) / 2 * p : r.r * p) + T
                      , v = (g ? (r.r + r.r0) / 2 * f : r.r * f) + C;
                    if (e = m + 3 * p,
                    i = v + 3 * f,
                    !g) {
                        var y = m + p * (h + A - r.r)
                          , x = v + f * (h + A - r.r)
                          , _ = y + (p < 0 ? -1 : 1) * c;
                        e = _ + (p < 0 ? -5 : 5),
                        n = [[m, v], [y, x], [_, i = x]]
                    }
                    a = g ? "center" : 0 < p ? "left" : "right"
                }
                var b = s.getFont()
                  , w = s.get("rotate") ? p < 0 ? -d + Math.PI : -d : 0
                  , S = I.getFormattedLabel(t, "normal") || D.getName(t)
                  , M = Bi.getBoundingRect(S, b, a, "top");
                P = !!w,
                r.label = {
                    x: e,
                    y: i,
                    position: l,
                    height: M.height,
                    len: h,
                    len2: c,
                    linePoints: n,
                    textAlign: a,
                    verticalAlign: "middle",
                    rotation: w,
                    inside: g
                },
                g || L.push(r.label)
            }),
            !P && I.get("avoidLabelOverlap") && function(t, e, i, n, a, r) {
                for (var o = [], s = [], l = 0; l < t.length; l++)
                    Wx(t[l]) || (t[l].x < e ? o.push(t[l]) : s.push(t[l]));
                for (Hx(s, e, i, n, 1, 0, r),
                Hx(o, e, i, n, -1, 0, r),
                l = 0; l < t.length; l++)
                    if (!Wx(t[l])) {
                        var u = t[l].linePoints;
                        if (u) {
                            var h = u[1][0] - u[2][0];
                            t[l].x < e ? u[2][0] = t[l].x + 3 : u[2][0] = t[l].x - 3,
                            u[1][1] = u[2][1] = t[l].y,
                            u[1][0] = u[2][0] + h
                        }
                    }
            }(L, T, C, A, 0, e)
        }
          , Ux = ol.parsePercent
          , Yx = ol.linearMap
          , jx = 2 * Math.PI
          , Xx = Math.PI / 180;
        function qx(t, e, A, i) {
            e.eachSeriesByType(t, function(t) {
                var a = t.getData()
                  , e = a.mapDimension("value")
                  , i = t.get("center")
                  , n = t.get("radius");
                it.isArray(n) || (n = [0, n]),
                it.isArray(i) || (i = [i, i]);
                var r = A.getWidth()
                  , o = A.getHeight()
                  , s = Math.min(r, o)
                  , l = Ux(i[0], r)
                  , u = Ux(i[1], o)
                  , h = Ux(n[0], s / 2)
                  , c = Ux(n[1], s / 2)
                  , d = -t.get("startAngle") * Xx
                  , p = t.get("minAngle") * Xx
                  , f = 0;
                a.each(e, function(t) {
                    isNaN(t) || f++
                });
                var g = a.getSum(e)
                  , m = Math.PI / (g || f) * 2
                  , v = t.get("clockwise")
                  , y = t.get("roseType")
                  , x = t.get("stillShowZeroSum")
                  , _ = a.getDataExtent(e);
                _[0] = 0;
                var b = jx
                  , w = 0
                  , S = d
                  , M = v ? 1 : -1;
                if (a.each(e, function(t, e) {
                    var i;
                    if (isNaN(t))
                        a.setItemLayout(e, {
                            angle: NaN,
                            startAngle: NaN,
                            endAngle: NaN,
                            clockwise: v,
                            cx: l,
                            cy: u,
                            r0: h,
                            r: y ? NaN : c
                        });
                    else {
                        (i = "area" !== y ? 0 === g && x ? m : t * m : jx / f) < p ? b -= i = p : w += t;
                        var n = S + M * i;
                        a.setItemLayout(e, {
                            angle: i,
                            startAngle: S,
                            endAngle: n,
                            clockwise: v,
                            cx: l,
                            cy: u,
                            r0: h,
                            r: y ? Yx(t, _, [h, c]) : c
                        }),
                        S = n
                    }
                }),
                b < jx && f)
                    if (b <= .001) {
                        var I = jx / f;
                        a.each(e, function(t, e) {
                            if (!isNaN(t)) {
                                var i = a.getItemLayout(e);
                                i.angle = I,
                                i.startAngle = d + M * e * I,
                                i.endAngle = d + M * (e + 1) * I
                            }
                        })
                    } else
                        m = b / w,
                        S = d,
                        a.each(e, function(t, e) {
                            if (!isNaN(t)) {
                                var i = a.getItemLayout(e)
                                  , n = i.angle === p ? p : t * m;
                                i.startAngle = S,
                                i.endAngle = S + M * n,
                                S += M * n
                            }
                        });
                Zx(t, c, r, o)
            })
        }
        var Kx = function(t) {
            return {
                seriesType: t,
                reset: function(t, e) {
                    var n = e.findComponents({
                        mainType: "legend"
                    });
                    if (n && n.length) {
                        var a = t.getData();
                        a.filterSelf(function(t) {
                            for (var e = a.getName(t), i = 0; i < n.length; i++)
                                if (!n[i].isSelected(e))
                                    return !1;
                            return !0
                        })
                    }
                }
            }
        };
        Bx("pie", [{
            type: "pieToggleSelect",
            event: "pieselectchanged",
            method: "toggleSelected"
        }, {
            type: "pieSelect",
            event: "pieselected",
            method: "select"
        }, {
            type: "pieUnSelect",
            event: "pieunselected",
            method: "unSelect"
        }]),
        Gm.registerVisual(Fx("pie")),
        Gm.registerLayout(it.curry(qx, "pie")),
        Gm.registerProcessor(Kx("pie"));
        kc.extend({
            type: "series.scatter",
            dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"],
            getInitialData: function(t, e) {
                return Sf(this.getSource(), this)
            },
            brushSelector: "point",
            getProgressive: function() {
                var t = this.option.progressive;
                return null == t ? this.option.large ? 5e3 : this.get("progressive") : t
            },
            getProgressiveThreshold: function() {
                var t = this.option.progressiveThreshold;
                return null == t ? this.option.large ? 1e4 : this.get("progressiveThreshold") : t
            },
            defaultOption: {
                coordinateSystem: "cartesian2d",
                zlevel: 0,
                z: 2,
                legendHoverLink: !0,
                hoverAnimation: !0,
                symbolSize: 10,
                large: !1,
                largeThreshold: 2e3,
                itemStyle: {
                    opacity: .8
                }
            }
        });
        var $x = Fg.createSymbol
          , Jx = Fs.extendShape({
            shape: {
                points: null
            },
            symbolProxy: null,
            buildPath: function(t, e) {
                var i = e.points
                  , n = e.size
                  , a = this.symbolProxy
                  , r = a.shape;
                if (!((t.getContext ? t.getContext() : t) && n[0] < 4))
                    for (var o = 0; o < i.length; ) {
                        var s = i[o++]
                          , l = i[o++];
                        isNaN(s) || isNaN(l) || (r.x = s - n[0] / 2,
                        r.y = l - n[1] / 2,
                        r.width = n[0],
                        r.height = n[1],
                        a.buildPath(t, r, !0))
                    }
            },
            afterBrush: function(t) {
                var e = this.shape
                  , i = e.points
                  , n = e.size;
                if (n[0] < 4) {
                    this.setTransform(t);
                    for (var a = 0; a < i.length; ) {
                        var r = i[a++]
                          , o = i[a++];
                        isNaN(r) || isNaN(o) || t.fillRect(r - n[0] / 2, o - n[1] / 2, n[0], n[1])
                    }
                    this.restoreTransform(t)
                }
            },
            findDataIndex: function(t, e) {
                for (var i = this.shape, n = i.points, a = i.size, r = Math.max(a[0], 4), o = Math.max(a[1], 4), s = n.length / 2 - 1; 0 <= s; s--) {
                    var l = 2 * s
                      , u = n[l] - r / 2
                      , h = n[1 + l] - o / 2;
                    if (u <= t && h <= e && t <= u + r && e <= h + o)
                        return s
                }
                return -1
            }
        });
        function Qx() {
            this.group = new Fs.Group
        }
        var t_ = Qx.prototype;
        t_.isPersistent = function() {
            return !this._incremental
        }
        ,
        t_.updateData = function(t) {
            this.group.removeAll();
            var e = new Jx({
                rectHover: !0,
                cursor: "default"
            });
            e.setShape({
                points: t.getLayout("symbolPoints")
            }),
            this._setCommon(e, t),
            this.group.add(e),
            this._incremental = null
        }
        ,
        t_.updateLayout = function(t) {
            if (!this._incremental) {
                var n = t.getLayout("symbolPoints");
                this.group.eachChild(function(t) {
                    if (null != t.startIndex) {
                        var e = 2 * (t.endIndex - t.startIndex)
                          , i = 4 * t.startIndex * 2;
                        n = new Float32Array(n.buffer,i,e)
                    }
                    t.setShape("points", n)
                })
            }
        }
        ,
        t_.incrementalPrepareUpdate = function(t) {
            this.group.removeAll(),
            this._clearIncremental(),
            2e6 < t.count() ? (this._incremental || (this._incremental = new Uo({
                silent: !0
            })),
            this.group.add(this._incremental)) : this._incremental = null
        }
        ,
        t_.incrementalUpdate = function(t, e) {
            var i;
            this._incremental ? (i = new Jx,
            this._incremental.addDisplayable(i, !0)) : ((i = new Jx({
                rectHover: !0,
                cursor: "default",
                startIndex: t.start,
                endIndex: t.end
            })).incremental = !0,
            this.group.add(i)),
            i.setShape({
                points: e.getLayout("symbolPoints")
            }),
            this._setCommon(i, e, !!this._incremental)
        }
        ,
        t_._setCommon = function(i, t, e) {
            var n = t.hostModel
              , a = t.getVisual("symbolSize");
            i.setShape("size", a instanceof Array ? a : [a, a]),
            i.symbolProxy = $x(t.getVisual("symbol"), 0, 0, 0, 0),
            i.setColor = i.symbolProxy.setColor;
            var r = i.shape.size[0] < 4;
            i.useStyle(n.getModel("itemStyle").getItemStyle(r ? ["color", "shadowBlur", "shadowColor"] : ["color"]));
            var o = t.getVisual("color");
            o && i.setColor(o),
            e || (i.seriesIndex = n.seriesIndex,
            i.on("mousemove", function(t) {
                i.dataIndex = null;
                var e = i.findDataIndex(t.offsetX, t.offsetY);
                0 <= e && (i.dataIndex = e + (i.startIndex || 0))
            }))
        }
        ,
        t_.remove = function() {
            this._clearIncremental(),
            this._incremental = null,
            this.group.removeAll()
        }
        ,
        t_._clearIncremental = function() {
            var t = this._incremental;
            t && t.clearDisplaybles()
        }
        ;
        var e_ = Qx;
        function i_(t, e, i) {
            wm.call(this, t, e, i),
            this.type = "value",
            this.angle = 0,
            this.name = "",
            this.model
        }
        Gm.extendChartView({
            type: "scatter",
            render: function(t, e, i) {
                var n = t.getData();
                this._updateSymbolDraw(n, t).updateData(n),
                this._finished = !0
            },
            incrementalPrepareRender: function(t, e, i) {
                var n = t.getData();
                this._updateSymbolDraw(n, t).incrementalPrepareUpdate(n),
                this._finished = !1
            },
            incrementalRender: function(t, e, i) {
                this._symbolDraw.incrementalUpdate(t, e.getData()),
                this._finished = t.end === e.getData().count()
            },
            updateTransform: function(t, e, i) {
                var n = t.getData();
                if (this.group.dirty(),
                !this._finished || 1e4 < n.count() || !this._symbolDraw.isPersistent())
                    return {
                        update: !0
                    };
                var a = Uv().reset(t);
                a.progress && a.progress({
                    start: 0,
                    end: n.count()
                }, n),
                this._symbolDraw.updateLayout(n)
            },
            _updateSymbolDraw: function(t, e) {
                var i = this._symbolDraw
                  , n = e.pipelineContext.large;
                return i && n === this._isLargeDraw || (i && i.remove(),
                i = this._symbolDraw = n ? new e_ : new dv,
                this._isLargeDraw = n,
                this.group.removeAll()),
                this.group.add(i.group),
                i
            },
            remove: function(t, e) {
                this._symbolDraw && this._symbolDraw.remove(!0),
                this._symbolDraw = null
            },
            dispose: function() {}
        }),
        Gm.registerVisual(Fv("scatter", "circle")),
        Gm.registerLayout(Uv("scatter")),
        it.inherits(i_, wm);
        var n_ = i_
          , a_ = Lg.getScaleExtent
          , r_ = Lg.niceScaleExtent;
        function o_(t, e, i) {
            this._model = t,
            this.dimensions = [],
            this._indicatorAxes = it.map(t.getIndicatorModels(), function(t, e) {
                var i = "indicator_" + e
                  , n = new n_(i,new Zf);
                return n.name = t.get("name"),
                (n.model = t).axis = n,
                this.dimensions.push(i),
                n
            }, this),
            this.resize(t, i),
            this.cx,
            this.cy,
            this.r,
            this.r0,
            this.startAngle
        }
        o_.prototype.getIndicatorAxes = function() {
            return this._indicatorAxes
        }
        ,
        o_.prototype.dataToPoint = function(t, e) {
            var i = this._indicatorAxes[e];
            return this.coordToPoint(i.dataToCoord(t), e)
        }
        ,
        o_.prototype.coordToPoint = function(t, e) {
            var i = this._indicatorAxes[e].angle;
            return [this.cx + t * Math.cos(i), this.cy - t * Math.sin(i)]
        }
        ,
        o_.prototype.pointToData = function(t) {
            var e = t[0] - this.cx
              , i = t[1] - this.cy
              , n = Math.sqrt(e * e + i * i);
            e /= n,
            i /= n;
            for (var a, r = Math.atan2(-i, e), o = 1 / 0, s = -1, l = 0; l < this._indicatorAxes.length; l++) {
                var u = this._indicatorAxes[l]
                  , h = Math.abs(r - u.angle);
                h < o && (a = u,
                s = l,
                o = h)
            }
            return [s, +(a && a.coodToData(n))]
        }
        ,
        o_.prototype.resize = function(t, e) {
            var i = t.get("center")
              , n = e.getWidth()
              , a = e.getHeight()
              , r = Math.min(n, a) / 2;
            this.cx = ol.parsePercent(i[0], n),
            this.cy = ol.parsePercent(i[1], a),
            this.startAngle = t.get("startAngle") * Math.PI / 180;
            var o = t.get("radius");
            "string" != typeof o && "number" != typeof o || (o = [0, o]),
            this.r0 = ol.parsePercent(o[0], r),
            this.r = ol.parsePercent(o[1], r),
            it.each(this._indicatorAxes, function(t, e) {
                t.setExtent(this.r0, this.r);
                var i = this.startAngle + e * Math.PI * 2 / this._indicatorAxes.length;
                i = Math.atan2(Math.sin(i), Math.cos(i)),
                t.angle = i
            }, this)
        }
        ,
        o_.prototype.update = function(n, t) {
            var a = this._indicatorAxes
              , r = this._model;
            it.each(a, function(t) {
                t.scale.setExtent(1 / 0, -1 / 0)
            }),
            n.eachSeriesByType("radar", function(t, e) {
                if ("radar" === t.get("coordinateSystem") && n.getComponent("radar", t.get("radarIndex")) === r) {
                    var i = t.getData();
                    it.each(a, function(t) {
                        t.scale.unionExtentFromData(i, i.mapDimension(t.dim))
                    })
                }
            }, this);
            var p = r.get("splitNumber");
            function f(t) {
                var e = Math.pow(10, Math.floor(Math.log(t) / Math.LN10))
                  , i = t / e;
                return 2 === i ? i = 5 : i *= 2,
                i * e
            }
            it.each(a, function(t, e) {
                var i = a_(t.scale, t.model);
                r_(t.scale, t.model);
                var n = t.model
                  , a = t.scale
                  , r = n.getMin()
                  , o = n.getMax()
                  , s = a.getInterval();
                if (null != r && null != o)
                    a.setExtent(+r, +o),
                    a.setInterval((o - r) / p);
                else if (null != r)
                    for (var l; l = r + s * p,
                    a.setExtent(+r, l),
                    a.setInterval(s),
                    s = f(s),
                    l < i[1] && isFinite(l) && isFinite(i[1]); )
                        ;
                else if (null != o)
                    for (var u; u = o - s * p,
                    a.setExtent(u, +o),
                    a.setInterval(s),
                    s = f(s),
                    u > i[0] && isFinite(u) && isFinite(i[0]); )
                        ;
                else {
                    var h = a.getTicks().length - 1;
                    p < h && (s = f(s));
                    var c = Math.round((i[0] + i[1]) / 2 / s) * s
                      , d = Math.round(p / 2);
                    a.setExtent(ol.round(c - d * s), ol.round(c + (p - d) * s)),
                    a.setInterval(s)
                }
            })
        }
        ,
        o_.dimensions = [],
        o_.create = function(i, n) {
            var a = [];
            return i.eachComponent("radar", function(t) {
                var e = new o_(t,i,n);
                a.push(e),
                t.coordinateSystem = e
            }),
            i.eachSeriesByType("radar", function(t) {
                "radar" === t.get("coordinateSystem") && (t.coordinateSystem = a[t.get("radarIndex") || 0])
            }),
            a
        }
        ,
        ju.register("radar", o_);
        var s_ = ny.valueAxis;
        function l_(t, e) {
            return it.defaults({
                show: e
            }, t)
        }
        Gm.extendComponentModel({
            type: "radar",
            optionUpdated: function() {
                var a = this.get("boundaryGap")
                  , r = this.get("splitNumber")
                  , o = this.get("scale")
                  , s = this.get("axisLine")
                  , l = this.get("axisTick")
                  , u = this.get("axisLabel")
                  , h = this.get("name")
                  , c = this.get("name.show")
                  , d = this.get("name.formatter")
                  , p = this.get("nameGap")
                  , f = this.get("triggerEvent")
                  , t = it.map(this.get("indicator") || [], function(t) {
                    null != t.max && 0 < t.max && !t.min ? t.min = 0 : null != t.min && t.min < 0 && !t.max && (t.max = 0);
                    var e = h;
                    if (null != t.color && (e = it.defaults({
                        color: t.color
                    }, h)),
                    t = it.merge(it.clone(t), {
                        boundaryGap: a,
                        splitNumber: r,
                        scale: o,
                        axisLine: s,
                        axisTick: l,
                        axisLabel: u,
                        name: t.text,
                        nameLocation: "end",
                        nameGap: p,
                        nameTextStyle: e,
                        triggerEvent: f
                    }, !1),
                    c || (t.name = ""),
                    "string" == typeof d) {
                        var i = t.name;
                        t.name = d.replace("{value}", null != i ? i : "")
                    } else
                        "function" == typeof d && (t.name = d(t.name, t));
                    var n = it.extend(new tl(t,null,this.ecModel), Pg);
                    return n.mainType = "radar",
                    n.componentIndex = this.componentIndex,
                    n
                }, this);
                this.getIndicatorModels = function() {
                    return t
                }
            },
            defaultOption: {
                zlevel: 0,
                z: 0,
                center: ["50%", "50%"],
                radius: "75%",
                startAngle: 90,
                name: {
                    show: !0
                },
                boundaryGap: [0, 0],
                splitNumber: 5,
                nameGap: 15,
                scale: !1,
                shape: "polygon",
                axisLine: it.merge({
                    lineStyle: {
                        color: "#bbb"
                    }
                }, s_.axisLine),
                axisLabel: l_(s_.axisLabel, !1),
                axisTick: l_(s_.axisTick, !1),
                splitLine: l_(s_.splitLine, !0),
                splitArea: l_(s_.splitArea, !0),
                indicator: []
            }
        });
        var u_ = ["axisLine", "axisTickLabel", "axisName"]
          , h_ = (Gm.extendComponentView({
            type: "radar",
            render: function(t, e, i) {
                this.group.removeAll(),
                this._buildAxes(t),
                this._buildSplitLineAndArea(t)
            },
            _buildAxes: function(t) {
                var e = t.coordinateSystem
                  , i = e.getIndicatorAxes()
                  , n = it.map(i, function(t) {
                    return new jy(t.model,{
                        position: [e.cx, e.cy],
                        rotation: t.angle,
                        labelDirection: -1,
                        tickDirection: -1,
                        nameDirection: 1
                    })
                });
                it.each(n, function(t) {
                    it.each(u_, t.add, t),
                    this.group.add(t.getGroup())
                }, this)
            },
            _buildSplitLineAndArea: function(t) {
                var n = t.coordinateSystem
                  , e = n.getIndicatorAxes();
                if (e.length) {
                    var i = t.get("shape")
                      , a = t.getModel("splitLine")
                      , r = t.getModel("splitArea")
                      , o = a.getModel("lineStyle")
                      , s = r.getModel("areaStyle")
                      , l = a.get("show")
                      , u = r.get("show")
                      , h = o.get("color")
                      , c = s.get("color");
                    h = it.isArray(h) ? h : [h],
                    c = it.isArray(c) ? c : [c];
                    var d = []
                      , p = [];
                    if ("circle" === i)
                        for (var f = e[0].getTicksCoords(), g = n.cx, m = n.cy, v = 0; v < f.length; v++) {
                            if (l)
                                d[I(d, h, v)].push(new Fs.Circle({
                                    shape: {
                                        cx: g,
                                        cy: m,
                                        r: f[v].coord
                                    }
                                }));
                            if (u && v < f.length - 1)
                                p[I(p, c, v)].push(new Fs.Ring({
                                    shape: {
                                        cx: g,
                                        cy: m,
                                        r0: f[v].coord,
                                        r: f[v + 1].coord
                                    }
                                }))
                        }
                    else {
                        var y, x = it.map(e, function(t, e) {
                            var i = t.getTicksCoords();
                            return y = null == y ? i.length - 1 : Math.min(i.length - 1, y),
                            it.map(i, function(t) {
                                return n.coordToPoint(t.coord, e)
                            })
                        }), _ = [];
                        for (v = 0; v <= y; v++) {
                            for (var b = [], w = 0; w < e.length; w++)
                                b.push(x[w][v]);
                            if (b[0] && b.push(b[0].slice()),
                            l)
                                d[I(d, h, v)].push(new Fs.Polyline({
                                    shape: {
                                        points: b
                                    }
                                }));
                            if (u && _)
                                p[I(p, c, v - 1)].push(new Fs.Polygon({
                                    shape: {
                                        points: b.concat(_)
                                    }
                                }));
                            _ = b.slice().reverse()
                        }
                    }
                    var S = o.getLineStyle()
                      , M = s.getAreaStyle();
                    it.each(p, function(t, e) {
                        this.group.add(Fs.mergePath(t, {
                            style: it.defaults({
                                stroke: "none",
                                fill: c[e % c.length]
                            }, M),
                            silent: !0
                        }))
                    }, this),
                    it.each(d, function(t, e) {
                        this.group.add(Fs.mergePath(t, {
                            style: it.defaults({
                                fill: "none",
                                stroke: h[e % h.length]
                            }, S),
                            silent: !0
                        }))
                    }, this)
                }
                function I(t, e, i) {
                    var n = i % e.length;
                    return t[n] = t[n] || [],
                    n
                }
            }
        }),
        fl.encodeHTML)
          , c_ = kc.extend({
            type: "series.radar",
            dependencies: ["radar"],
            init: function(t) {
                c_.superApply(this, "init", arguments),
                this.legendDataProvider = function() {
                    return this.getRawData()
                }
            },
            getInitialData: function(t, e) {
                return Lx(this, {
                    generateCoord: "indicator_",
                    generateCoordCount: 1 / 0
                })
            },
            formatTooltip: function(n) {
                var a = this.getData()
                  , t = this.coordinateSystem.getIndicatorAxes()
                  , e = this.getData().getName(n);
                return h_("" === e ? this.name : e) + "<br/>" + it.map(t, function(t, e) {
                    var i = a.get(a.mapDimension(t.dim), n);
                    return h_(t.name + " : " + i)
                }).join("<br />")
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "radar",
                legendHoverLink: !0,
                radarIndex: 0,
                lineStyle: {
                    width: 2,
                    type: "solid"
                },
                label: {
                    position: "top"
                },
                symbol: "emptyCircle",
                symbolSize: 4
            }
        });
        Gm.extendChartView({
            type: "radar",
            render: function(l, t, e) {
                var i = l.coordinateSystem
                  , v = this.group
                  , y = l.getData()
                  , s = this._data;
                function u(t, e) {
                    var i = t.getItemVisual(e, "symbol") || "circle"
                      , n = t.getItemVisual(e, "color");
                    if ("none" !== i) {
                        var a = function(t) {
                            return it.isArray(t) || (t = [+t, +t]),
                            t
                        }(t.getItemVisual(e, "symbolSize"))
                          , r = Fg.createSymbol(i, -1, -1, 2, 2, n);
                        return r.attr({
                            style: {
                                strokeNoScale: !0
                            },
                            z2: 100,
                            scale: [a[0] / 2, a[1] / 2]
                        }),
                        r
                    }
                }
                function h(t, e, i, n, a, r) {
                    i.removeAll();
                    for (var o = 0; o < e.length - 1; o++) {
                        var s = u(n, a);
                        s && (t[s.__dimIdx = o] ? (s.attr("position", t[o]),
                        Fs[r ? "initProps" : "updateProps"](s, {
                            position: e[o]
                        }, l, a)) : s.attr("position", e[o]),
                        i.add(s))
                    }
                }
                function c(t) {
                    return it.map(t, function(t) {
                        return [i.cx, i.cy]
                    })
                }
                y.diff(s).add(function(t) {
                    var e = y.getItemLayout(t);
                    if (e) {
                        var i = new Fs.Polygon
                          , n = new Fs.Polyline
                          , a = {
                            shape: {
                                points: e
                            }
                        };
                        i.shape.points = c(e),
                        n.shape.points = c(e),
                        Fs.initProps(i, a, l, t),
                        Fs.initProps(n, a, l, t);
                        var r = new Fs.Group
                          , o = new Fs.Group;
                        r.add(n),
                        r.add(i),
                        r.add(o),
                        h(n.shape.points, e, o, y, t, !0),
                        y.setItemGraphicEl(t, r)
                    }
                }).update(function(t, e) {
                    var i = s.getItemGraphicEl(e)
                      , n = i.childAt(0)
                      , a = i.childAt(1)
                      , r = i.childAt(2)
                      , o = {
                        shape: {
                            points: y.getItemLayout(t)
                        }
                    };
                    o.shape.points && (h(n.shape.points, o.shape.points, r, y, t, !1),
                    Fs.updateProps(n, o, l),
                    Fs.updateProps(a, o, l),
                    y.setItemGraphicEl(t, i))
                }).remove(function(t) {
                    v.remove(s.getItemGraphicEl(t))
                }).execute(),
                y.eachItemGraphicEl(function(t, e) {
                    var i = y.getItemModel(e)
                      , n = t.childAt(0)
                      , a = t.childAt(1)
                      , r = t.childAt(2)
                      , o = y.getItemVisual(e, "color");
                    v.add(t),
                    n.useStyle(it.defaults(i.getModel("lineStyle").getLineStyle(), {
                        fill: "none",
                        stroke: o
                    })),
                    n.hoverStyle = i.getModel("emphasis.lineStyle").getLineStyle();
                    var s = i.getModel("areaStyle")
                      , l = i.getModel("emphasis.areaStyle")
                      , u = s.isEmpty() && s.parentModel.isEmpty()
                      , h = l.isEmpty() && l.parentModel.isEmpty();
                    h = h && u,
                    a.ignore = u,
                    a.useStyle(it.defaults(s.getAreaStyle(), {
                        fill: o,
                        opacity: .7
                    })),
                    a.hoverStyle = l.getAreaStyle();
                    var c = i.getModel("itemStyle").getItemStyle(["color"])
                      , d = i.getModel("emphasis.itemStyle").getItemStyle()
                      , p = i.getModel("label")
                      , f = i.getModel("emphasis.label");
                    function g() {
                        a.attr("ignore", h)
                    }
                    function m() {
                        a.attr("ignore", u)
                    }
                    r.eachChild(function(t) {
                        t.setStyle(c),
                        t.hoverStyle = it.clone(d),
                        Fs.setLabelStyle(t.style, t.hoverStyle, p, f, {
                            labelFetcher: y.hostModel,
                            labelDataIndex: e,
                            labelDimIndex: t.__dimIdx,
                            defaultText: y.get(y.dimensions[t.__dimIdx], e),
                            autoColor: o,
                            isRectText: !0
                        })
                    }),
                    t.off("mouseover").off("mouseout").off("normal").off("emphasis"),
                    t.on("emphasis", g).on("mouseover", g).on("normal", m).on("mouseout", m),
                    Fs.setHoverStyle(t)
                }),
                this._data = y
            },
            remove: function() {
                this.group.removeAll(),
                this._data = null
            },
            dispose: function() {}
        });
        function d_(t) {
            t.eachSeriesByType("radar", function(t) {
                var e = t.getData()
                  , i = []
                  , n = t.coordinateSystem;
                if (n) {
                    for (var a = n.getIndicatorAxes(), r = 0; r < a.length; r++)
                        e.each(e.mapDimension(a[r].dim), o);
                    e.each(function(t) {
                        i[t][0] && i[t].push(i[t][0].slice()),
                        e.setItemLayout(t, i[t])
                    })
                }
                function o(t, e) {
                    i[e] = i[e] || [],
                    i[e][r] = n.dataToPoint(t, r)
                }
            })
        }
        function p_(i) {
            var t = i.polar;
            if (t) {
                it.isArray(t) || (t = [t]);
                var n = [];
                it.each(t, function(t, e) {
                    t.indicator ? (t.type && !t.shape && (t.shape = t.type),
                    i.radar = i.radar || [],
                    it.isArray(i.radar) || (i.radar = [i.radar]),
                    i.radar.push(t)) : n.push(t)
                }),
                i.polar = n
            }
            it.each(i.series, function(t) {
                t && "radar" === t.type && t.polarIndex && (t.radarIndex = t.polarIndex)
            })
        }
        Gm.registerVisual(Fx("radar")),
        Gm.registerVisual(Fv("radar", "circle")),
        Gm.registerLayout(d_),
        Gm.registerProcessor(Kx("radar")),
        Gm.registerPreprocessor(p_);
        for (var f_ = [126, 25], g_ = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, .7], [52, .7], [56, 7.7], [59, .7], [64, .7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]], m_ = 0; m_ < g_.length; m_++)
            for (var v_ = 0; v_ < g_[m_].length; v_++)
                g_[m_][v_][0] /= 10.5,
                g_[m_][v_][1] /= -14,
                g_[m_][v_][0] += f_[0],
                g_[m_][v_][1] += f_[1];
        var y_ = function(t, e) {
            "china" === t && e.push(new $g("",it.map(g_, function(t) {
                return {
                    type: "polygon",
                    exterior: t
                }
            }),f_))
        }
          , x_ = {
            "": [32, 80],
            "": [0, -10],
            "": [10, 5],
            "": [-10, 10],
            "": [5, 5]
        };
        var __ = function(t, e) {
            if ("china" === t) {
                var i = x_[e.name];
                if (i) {
                    var n = e.center;
                    n[0] += i[0] / 10.5,
                    n[1] += -i[1] / 14
                }
            }
        }
          , b_ = {
            Russia: [100, 60],
            "United States": [-99, 38],
            "United States of America": [-99, 38]
        };
        var w_ = function(t, e) {
            if ("world" === t) {
                var i = b_[e.name];
                if (i) {
                    var n = e.center;
                    n[0] = i[0],
                    n[1] = i[1]
                }
            }
        }
          , S_ = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
        var M_ = function(t, e) {
            "china" === t && "" === e.name && e.geometries.push({
                type: "polygon",
                exterior: S_[0]
            })
        }
          , I_ = it.each
          , A_ = (0,
        aa.makeInner)();
        var T_ = {
            load: function(n, t) {
                var e = A_(t).parsed;
                if (e)
                    return e;
                var i, a = t.specialAreas || {}, r = t.geoJSON;
                try {
                    i = r ? Qg(r) : []
                } catch (t) {
                    throw new Error("Invalid geoJson format\n" + t.message)
                }
                return I_(i, function(t) {
                    var e = t.name;
                    __(n, t),
                    w_(n, t),
                    M_(n, t);
                    var i = a[e];
                    i && t.transformTo(i.left, i.top, i.width, i.height)
                }),
                y_(n, i),
                A_(t).parsed = {
                    regions: i,
                    boundingRect: function(t) {
                        for (var e, i = 0; i < t.length; i++) {
                            var n = t[i].getBoundingRect();
                            (e = e || n.clone()).union(n)
                        }
                        return e
                    }(i)
                }
            }
        }
          , C_ = up.parseSVG
          , D_ = up.makeViewBoxTransform
          , L_ = it.assert
          , P_ = it.createHashMap
          , k_ = (0,
        aa.makeInner)();
        function O_(t, e) {
            var i, n, a = t.svgXML;
            try {
                n = (i = a && C_(a, {
                    ignoreViewBox: !0,
                    ignoreRootClip: !0
                }) || {}).root,
                L_(null != n)
            } catch (t) {
                throw new Error("Invalid svg format\n" + t.message)
            }
            var r = i.width
              , o = i.height
              , s = i.viewBoxRect;
            if (e || (e = null == r || null == o ? n.getBoundingRect() : new Oe(0,0,0,0),
            null != r && (e.width = r),
            null != o && (e.height = o)),
            s) {
                var l = D_(s, e.width, e.height)
                  , u = n;
                (n = new Re).add(u),
                u.scale = l.scale,
                u.position = l.position
            }
            return n.setClipPath(new bo({
                shape: e.plain()
            })),
            {
                root: n,
                boundingRect: e
            }
        }
        var R_ = {
            load: function(t, e) {
                var i = k_(e).originRoot;
                if (i)
                    return {
                        root: i,
                        boundingRect: k_(e).boundingRect
                    };
                var n = O_(e);
                return k_(e).originRoot = n.root,
                k_(e).boundingRect = n.boundingRect,
                n
            },
            makeGraphic: function(t, e, i) {
                var n = k_(e)
                  , a = n.rootMap || (n.rootMap = P_())
                  , r = a.get(i);
                if (r)
                    return r;
                var o = n.originRoot
                  , s = n.boundingRect;
                return r = n.originRootHostKey ? O_(e, s).root : (n.originRootHostKey = i,
                o),
                a.set(i, r)
            },
            removeGraphic: function(t, e, i) {
                var n = k_(e)
                  , a = n.rootMap;
                a && a.removeKey(i),
                i === n.originRootHostKey && (n.originRootHostKey = null)
            }
        }
          , N_ = it.each
          , E_ = it.createHashMap
          , z_ = {
            geoJSON: T_,
            svg: R_
        };
        function V_(r) {
            return function(i, n) {
                var t = B_(i)
                  , a = [];
                return N_(t, function(t) {
                    var e = z_[t.type][r];
                    e && a.push(e(i, t, n))
                }),
                a
            }
        }
        function B_(t) {
            return yp.retrieveMap(t) || []
        }
        var G_ = {
            load: function(n, a) {
                var r, o = [], s = E_(), l = E_(), t = B_(n);
                return N_(t, function(t) {
                    var e = z_[t.type].load(n, t);
                    N_(e.regions, function(t) {
                        var e = t.name;
                        a && a.hasOwnProperty(e) && (t = t.cloneShallow(e = a[e])),
                        o.push(t),
                        s.set(e, t),
                        l.set(e, t.center)
                    });
                    var i = e.boundingRect;
                    i && (r ? r.union(i) : r = i.clone())
                }),
                {
                    regions: o,
                    regionsMap: s,
                    nameCoordMap: l,
                    boundingRect: r || new Oe(0,0,0,0)
                }
            },
            makeGraphic: V_("makeGraphic"),
            removeGraphic: V_("removeGraphic")
        }
          , F_ = fl.encodeHTML
          , H_ = fl.addCommas
          , W_ = Uh.retrieveRawAttr
          , Z_ = kc.extend({
            type: "series.map",
            dependencies: ["geo"],
            layoutMode: "box",
            needsDrawMap: !1,
            seriesGroup: [],
            getInitialData: function(t) {
                for (var e = Lx(this, ["value"]), i = e.mapDimension("value"), n = it.createHashMap(), a = [], r = [], o = 0, s = e.count(); o < s; o++) {
                    var l = e.getName(o);
                    n.set(l, !0),
                    a.push({
                        name: l,
                        value: e.get(i, o),
                        selected: W_(e, o, "selected")
                    })
                }
                var u = G_.load(this.getMapType(), this.option.nameMap);
                return it.each(u.regions, function(t) {
                    var e = t.name;
                    n.get(e) || (a.push({
                        name: e
                    }),
                    r.push(e))
                }),
                this.updateSelectedMap(a),
                e.appendValues([], r),
                e
            },
            getHostGeoModel: function() {
                var t = this.option.geoIndex;
                return null != t ? this.dependentModels.geo[t] : null
            },
            getMapType: function() {
                return (this.getHostGeoModel() || this).option.map
            },
            getRawValue: function(t) {
                var e = this.getData();
                return e.get(e.mapDimension("value"), t)
            },
            getRegionModel: function(t) {
                var e = this.getData();
                return e.getItemModel(e.indexOfName(t))
            },
            formatTooltip: function(t) {
                for (var e = this.getData(), i = H_(this.getRawValue(t)), n = e.getName(t), a = this.seriesGroup, r = [], o = 0; o < a.length; o++) {
                    var s = a[o].originalData.indexOfName(n)
                      , l = e.mapDimension("value");
                    isNaN(a[o].originalData.get(l, s)) || r.push(F_(a[o].name))
                }
                return r.join(", ") + "<br />" + F_(n + " : " + i)
            },
            getTooltipPosition: function(t) {
                if (null != t) {
                    var e = this.getData().getName(t)
                      , i = this.coordinateSystem
                      , n = i.getRegion(e);
                    return n && i.dataToPoint(n.center)
                }
            },
            setZoom: function(t) {
                this.option.zoom = t
            },
            setCenter: function(t) {
                this.option.center = t
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "geo",
                map: "",
                left: "center",
                top: "center",
                aspectScale: .75,
                showLegendSymbol: !0,
                dataRangeHoverLink: !0,
                boundingCoords: null,
                center: null,
                zoom: 1,
                scaleLimit: null,
                label: {
                    show: !1,
                    color: "#000"
                },
                itemStyle: {
                    borderWidth: .5,
                    borderColor: "#444",
                    areaColor: "#eee"
                },
                emphasis: {
                    label: {
                        show: !0,
                        color: "rgb(100,0,0)"
                    },
                    itemStyle: {
                        areaColor: "rgba(255,215,0,0.8)"
                    }
                }
            }
        });
        it.mixin(Z_, Px);
        var U_ = "\0_ec_interaction_mutex";
        function Y_(t) {
            return t[U_] || (t[U_] = {})
        }
        Gm.registerAction({
            type: "takeGlobalCursor",
            event: "globalCursorTaken",
            update: "update"
        }, function() {});
        var j_ = {
            take: function(t, e, i) {
                Y_(t)[e] = i
            },
            release: function(t, e, i) {
                var n = Y_(t);
                n[e] === i && (n[e] = null)
            },
            isTaken: function(t, e) {
                return !!Y_(t)[e]
            }
        };
        function X_(i) {
            this.pointerChecker,
            this._zr = i,
            this._opt = {};
            var t = it.bind
              , n = t(q_, this)
              , a = t(K_, this)
              , r = t($_, this)
              , o = t(J_, this)
              , s = t(Q_, this);
            nt.call(this),
            this.setPointerChecker = function(t) {
                this.pointerChecker = t
            }
            ,
            this.enable = function(t, e) {
                this.disable(),
                this._opt = it.defaults(it.clone(e) || {}, {
                    zoomOnMouseWheel: !0,
                    moveOnMouseMove: !0,
                    moveOnMouseWheel: !1,
                    preventDefaultMouseMove: !0
                }),
                null == t && (t = !0),
                !0 !== t && "move" !== t && "pan" !== t || (i.on("mousedown", n),
                i.on("mousemove", a),
                i.on("mouseup", r)),
                !0 !== t && "scale" !== t && "zoom" !== t || (i.on("mousewheel", o),
                i.on("pinch", s))
            }
            ,
            this.disable = function() {
                i.off("mousedown", n),
                i.off("mousemove", a),
                i.off("mouseup", r),
                i.off("mousewheel", o),
                i.off("pinch", s)
            }
            ,
            this.dispose = this.disable,
            this.isDragging = function() {
                return this._dragging
            }
            ,
            this.isPinching = function() {
                return this._pinching
            }
        }
        function q_(t) {
            if (!(j.isMiddleOrRightButtonOnMouseUpDown(t) || t.target && t.target.draggable)) {
                var e = t.offsetX
                  , i = t.offsetY;
                this.pointerChecker && this.pointerChecker(t, e, i) && (this._x = e,
                this._y = i,
                this._dragging = !0)
            }
        }
        function K_(t) {
            if (this._dragging && ib("moveOnMouseMove", t, this._opt) && "pinch" !== t.gestureEvent && !j_.isTaken(this._zr, "globalPan")) {
                var e = t.offsetX
                  , i = t.offsetY
                  , n = this._x
                  , a = this._y
                  , r = e - n
                  , o = i - a;
                this._x = e,
                this._y = i,
                this._opt.preventDefaultMouseMove && j.stop(t.event),
                eb(this, "pan", "moveOnMouseMove", t, {
                    dx: r,
                    dy: o,
                    oldX: n,
                    oldY: a,
                    newX: e,
                    newY: i
                })
            }
        }
        function $_(t) {
            j.isMiddleOrRightButtonOnMouseUpDown(t) || (this._dragging = !1)
        }
        function J_(t) {
            var e = ib("zoomOnMouseWheel", t, this._opt)
              , i = ib("moveOnMouseWheel", t, this._opt)
              , n = t.wheelDelta
              , a = Math.abs(n)
              , r = t.offsetX
              , o = t.offsetY;
            if (0 !== n && (e || i)) {
                if (e) {
                    var s = 3 < a ? 1.4 : 1 < a ? 1.2 : 1.1;
                    tb(this, "zoom", "zoomOnMouseWheel", t, {
                        scale: 0 < n ? s : 1 / s,
                        originX: r,
                        originY: o
                    })
                }
                if (i) {
                    var l = Math.abs(n);
                    tb(this, "scrollMove", "moveOnMouseWheel", t, {
                        scrollDelta: (0 < n ? 1 : -1) * (3 < l ? .4 : 1 < l ? .15 : .05),
                        originX: r,
                        originY: o
                    })
                }
            }
        }
        function Q_(t) {
            j_.isTaken(this._zr, "globalPan") || tb(this, "zoom", null, t, {
                scale: 1 < t.pinchScale ? 1.1 : 1 / 1.1,
                originX: t.pinchX,
                originY: t.pinchY
            })
        }
        function tb(t, e, i, n, a) {
            t.pointerChecker && t.pointerChecker(n, a.originX, a.originY) && (j.stop(n.event),
            eb(t, e, i, n, a))
        }
        function eb(t, e, i, n, a) {
            a.isAvailableBehavior = it.bind(ib, null, i, n),
            t.trigger(e, a)
        }
        function ib(t, e, i) {
            var n = i[t];
            return !t || n && (!it.isString(n) || e.event[n + "Key"])
        }
        it.mixin(X_, nt);
        var nb = X_;
        var ab = {
            updateViewOnPan: function(t, e, i) {
                var n = t.target
                  , a = n.position;
                a[0] += e,
                a[1] += i,
                n.dirty()
            },
            updateViewOnZoom: function(t, e, i, n) {
                var a = t.target
                  , r = t.zoomLimit
                  , o = a.position
                  , s = a.scale
                  , l = t.zoom = t.zoom || 1;
                if (l *= e,
                r) {
                    var u = r.min || 0
                      , h = r.max || 1 / 0;
                    l = Math.max(Math.min(h, l), u)
                }
                var c = l / t.zoom;
                t.zoom = l,
                o[0] -= (i - o[0]) * (c - 1),
                o[1] -= (n - o[1]) * (c - 1),
                s[0] *= c,
                s[1] *= c,
                a.dirty()
            }
        }
          , rb = {
            axisPointer: 1,
            tooltip: 1,
            brush: 1
        };
        var ob = {
            onIrrelevantElement: function(t, e, i) {
                var n = e.getComponentByElement(t.topTarget)
                  , a = n && n.coordinateSystem;
                return n && n !== i && !rb[n.mainType] && a && a.model !== i
            }
        }
          , sb = ob.onIrrelevantElement
          , lb = nl.getUID;
        function ub(t) {
            var e = t.getItemStyle()
              , i = t.get("areaColor");
            return null != i && (e.fill = i),
            e
        }
        function hb(i, t) {
            t.eachChild(function(e) {
                it.each(e.__regions, function(t) {
                    e.trigger(i.isSelected(t.name) ? "emphasis" : "normal")
                })
            })
        }
        function cb(t, e) {
            var i = new Fs.Group;
            this.uid = lb("ec_map_draw"),
            this._controller = new nb(t.getZr()),
            this._controllerHost = {
                target: e ? i : null
            },
            this.group = i,
            this._updateGroup = e,
            this._mouseDownFlag,
            this._mapName,
            this._initialized,
            i.add(this._regionsGroup = new Fs.Group),
            i.add(this._backgroundGroup = new Fs.Group)
        }
        cb.prototype = {
            constructor: cb,
            draw: function(x, t, e, i, n) {
                var _ = "geo" === x.mainType
                  , b = x.getData && x.getData();
                _ && t.eachComponent({
                    mainType: "series",
                    subType: "map"
                }, function(t) {
                    b || t.getHostGeoModel() !== x || (b = t.getData())
                });
                var a = x.coordinateSystem;
                this._updateBackground(a);
                var w = this._regionsGroup
                  , r = this.group
                  , S = a.scale
                  , o = {
                    position: a.position,
                    scale: S
                };
                !w.childAt(0) || n ? r.attr(o) : Fs.updateProps(r, o, x),
                w.removeAll();
                var M = ["itemStyle"]
                  , I = ["emphasis", "itemStyle"]
                  , A = ["label"]
                  , T = ["emphasis", "label"]
                  , C = it.createHashMap();
                it.each(a.regions, function(t) {
                    var e = C.get(t.name) || C.set(t.name, new Fs.Group)
                      , i = new Fs.CompoundPath({
                        shape: {
                            paths: []
                        }
                    });
                    e.add(i);
                    var n, a = (y = x.getRegionModel(t.name) || x).getModel(M), r = y.getModel(I), o = ub(a), s = ub(r), l = y.getModel(A), u = y.getModel(T);
                    if (b) {
                        n = b.indexOfName(t.name);
                        var h = b.getItemVisual(n, "color", !0);
                        h && (o.fill = h)
                    }
                    it.each(t.geometries, function(t) {
                        if ("polygon" === t.type) {
                            i.shape.paths.push(new Fs.Polygon({
                                shape: {
                                    points: t.exterior
                                }
                            }));
                            for (var e = 0; e < (t.interiors ? t.interiors.length : 0); e++)
                                i.shape.paths.push(new Fs.Polygon({
                                    shape: {
                                        points: t.interiors[e]
                                    }
                                }))
                        }
                    }),
                    i.setStyle(o),
                    i.style.strokeNoScale = !0,
                    i.culling = !0;
                    var c = l.get("show")
                      , d = u.get("show")
                      , p = b && isNaN(b.get(b.mapDimension("value"), n))
                      , f = b && b.getItemLayout(n);
                    if (_ || p && (c || d) || f && f.showLabel) {
                        var g, m = _ ? t.name : n;
                        (!b || 0 <= n) && (g = x);
                        var v = new Fs.Text({
                            position: t.center.slice(),
                            scale: [1 / S[0], 1 / S[1]],
                            z2: 10,
                            silent: !0
                        });
                        Fs.setLabelStyle(v.style, v.hoverStyle = {}, l, u, {
                            labelFetcher: g,
                            labelDataIndex: m,
                            defaultText: t.name,
                            useInsideStyle: !1
                        }, {
                            textAlign: "center",
                            textVerticalAlign: "middle"
                        }),
                        e.add(v)
                    }
                    if (b)
                        b.setItemGraphicEl(n, e);
                    else {
                        var y = x.getRegionModel(t.name);
                        i.eventData = {
                            componentType: "geo",
                            componentIndex: x.componentIndex,
                            geoIndex: x.componentIndex,
                            name: t.name,
                            region: y && y.option || {}
                        }
                    }
                    (e.__regions || (e.__regions = [])).push(t),
                    Fs.setHoverStyle(e, s, {
                        hoverSilentOnTouch: !!x.get("selectedMode")
                    }),
                    w.add(e)
                }),
                this._updateController(x, t, e),
                function(n, a, r, o, s) {
                    r.off("click"),
                    r.off("mousedown"),
                    a.get("selectedMode") && (r.on("mousedown", function() {
                        n._mouseDownFlag = !0
                    }),
                    r.on("click", function(t) {
                        if (n._mouseDownFlag) {
                            n._mouseDownFlag = !1;
                            for (var e = t.target; !e.__regions; )
                                e = e.parent;
                            if (e) {
                                var i = {
                                    type: ("geo" === a.mainType ? "geo" : "map") + "ToggleSelect",
                                    batch: it.map(e.__regions, function(t) {
                                        return {
                                            name: t.name,
                                            from: s.uid
                                        }
                                    })
                                };
                                i[a.mainType + "Id"] = a.id,
                                o.dispatchAction(i),
                                hb(a, r)
                            }
                        }
                    }))
                }(this, x, w, e, i),
                hb(x, w)
            },
            remove: function() {
                this._regionsGroup.removeAll(),
                this._backgroundGroup.removeAll(),
                this._controller.dispose(),
                this._mapName && G_.removeGraphic(this._mapName, this.uid),
                this._mapName = null,
                this._controllerHost = {}
            },
            _updateBackground: function(t) {
                var e = t.map;
                this._mapName !== e && it.each(G_.makeGraphic(e, this.uid), function(t) {
                    this._backgroundGroup.add(t)
                }, this),
                this._mapName = e
            },
            _updateController: function(n, t, a) {
                var r = n.coordinateSystem
                  , e = this._controller
                  , i = this._controllerHost;
                i.zoomLimit = n.get("scaleLimit"),
                i.zoom = r.getZoom(),
                e.enable(n.get("roam") || !1);
                var o = n.mainType;
                function s() {
                    var t = {
                        type: "geoRoam",
                        componentType: o
                    };
                    return t[o + "Id"] = n.id,
                    t
                }
                e.off("pan").on("pan", function(t) {
                    this._mouseDownFlag = !1,
                    ab.updateViewOnPan(i, t.dx, t.dy),
                    a.dispatchAction(it.extend(s(), {
                        dx: t.dx,
                        dy: t.dy
                    }))
                }, this),
                e.off("zoom").on("zoom", function(t) {
                    if (this._mouseDownFlag = !1,
                    ab.updateViewOnZoom(i, t.scale, t.originX, t.originY),
                    a.dispatchAction(it.extend(s(), {
                        zoom: t.scale,
                        originX: t.originX,
                        originY: t.originY
                    })),
                    this._updateGroup) {
                        var e = this.group.scale;
                        this._regionsGroup.traverse(function(t) {
                            "text" === t.type && t.attr("scale", [1 / e[0], 1 / e[1]])
                        })
                    }
                }, this),
                e.setPointerChecker(function(t, e, i) {
                    return r.getViewRectAfterRoam().contain(e, i) && !sb(t, a, n)
                })
            }
        };
        var db = cb
          , pb = "__seriesMapHighDown"
          , fb = "__seriesMapCallKey";
        Gm.extendChartView({
            type: "map",
            render: function(t, e, i, n) {
                if (!n || "mapToggleSelect" !== n.type || n.from !== this.uid) {
                    var a = this.group;
                    if (a.removeAll(),
                    !t.getHostGeoModel()) {
                        if (n && "geoRoam" === n.type && "series" === n.componentType && n.seriesId === t.id)
                            (r = this._mapDraw) && a.add(r.group);
                        else if (t.needsDrawMap) {
                            var r = this._mapDraw || new db(i,!0);
                            a.add(r.group),
                            r.draw(t, e, i, this, n),
                            this._mapDraw = r
                        } else
                            this._mapDraw && this._mapDraw.remove(),
                            this._mapDraw = null;
                        t.get("showLegendSymbol") && e.getComponent("legend") && this._renderSymbols(t, e, i)
                    }
                }
            },
            remove: function() {
                this._mapDraw && this._mapDraw.remove(),
                this._mapDraw = null,
                this.group.removeAll()
            },
            dispose: function() {
                this._mapDraw && this._mapDraw.remove(),
                this._mapDraw = null
            },
            _renderSymbols: function(x, t, e) {
                var _ = x.originalData
                  , b = this.group;
                _.each(_.mapDimension("value"), function(t, e) {
                    if (!isNaN(t)) {
                        var i = _.getItemLayout(e);
                        if (i && i.point) {
                            var n = i.point
                              , a = i.offset
                              , r = new Fs.Circle({
                                style: {
                                    fill: x.getData().getVisual("color")
                                },
                                shape: {
                                    cx: n[0] + 9 * a,
                                    cy: n[1],
                                    r: 3
                                },
                                silent: !0,
                                z2: 8 + (a ? 0 : Fs.Z2_EMPHASIS_LIFT + 1)
                            });
                            if (!a) {
                                var o = x.mainSeries.getData()
                                  , s = _.getName(e)
                                  , l = o.indexOfName(s)
                                  , u = _.getItemModel(e)
                                  , h = u.getModel("label")
                                  , c = u.getModel("emphasis.label")
                                  , d = o.getItemGraphicEl(l)
                                  , p = it.retrieve2(x.getFormattedLabel(l, "normal"), s)
                                  , f = it.retrieve2(x.getFormattedLabel(l, "emphasis"), p)
                                  , g = d[pb]
                                  , m = Math.random();
                                if (!g) {
                                    g = d[pb] = {};
                                    var v = it.curry(gb, !0)
                                      , y = it.curry(gb, !1);
                                    d.on("mouseover", v).on("mouseout", y).on("emphasis", v).on("normal", y)
                                }
                                d[fb] = m,
                                it.extend(g, {
                                    recordVersion: m,
                                    circle: r,
                                    labelModel: h,
                                    hoverLabelModel: c,
                                    emphasisText: f,
                                    normalText: p
                                }),
                                mb(g, !1)
                            }
                            b.add(r)
                        }
                    }
                })
            }
        });
        function gb(t) {
            var e = this[pb];
            e && e.recordVersion === this[fb] && mb(e, t)
        }
        function mb(t, e) {
            var i = t.circle
              , n = t.labelModel
              , a = t.hoverLabelModel
              , r = t.emphasisText
              , o = t.normalText;
            e ? (i.style.extendFrom(Fs.setTextStyle({}, a, {
                text: a.get("show") ? r : null
            }, {
                isRectText: !0,
                useInsideStyle: !1
            }, !0)),
            i.__mapOriginalZ2 = i.z2,
            i.z2 += Fs.Z2_EMPHASIS_LIFT) : (Fs.setTextStyle(i.style, n, {
                text: n.get("show") ? o : null,
                textPosition: n.getShallow("position") || "bottom"
            }, {
                isRectText: !0,
                useInsideStyle: !1
            }),
            i.dirty(!1),
            null != i.__mapOriginalZ2 && (i.z2 = i.__mapOriginalZ2,
            i.__mapOriginalZ2 = null))
        }
        var vb = {
            updateCenterAndZoom: function(t, e, i) {
                var n = t.getZoom()
                  , a = t.getCenter()
                  , r = e.zoom
                  , o = t.dataToPoint(a);
                if (null != e.dx && null != e.dy) {
                    o[0] -= e.dx,
                    o[1] -= e.dy;
                    a = t.pointToData(o);
                    t.setCenter(a)
                }
                if (null != r) {
                    if (i) {
                        var s = i.min || 0
                          , l = i.max || 1 / 0;
                        r = Math.max(Math.min(n * r, l), s) / n
                    }
                    t.scale[0] *= r,
                    t.scale[1] *= r;
                    var u = t.position
                      , h = (e.originX - u[0]) * (r - 1)
                      , c = (e.originY - u[1]) * (r - 1);
                    u[0] -= h,
                    u[1] -= c,
                    t.updateTransform();
                    a = t.pointToData(o);
                    t.setCenter(a),
                    t.setZoom(r * n)
                }
                return {
                    center: t.getCenter(),
                    zoom: t.getZoom()
                }
            }
        }
          , yb = vb.updateCenterAndZoom;
        Gm.registerAction({
            type: "geoRoam",
            event: "geoRoam",
            update: "updateTransform"
        }, function(n, t) {
            var a = n.componentType || "series";
            t.eachComponent({
                mainType: a,
                query: n
            }, function(t) {
                var e = t.coordinateSystem;
                if ("geo" === e.type) {
                    var i = yb(e, n, t.get("scaleLimit"));
                    t.setCenter && t.setCenter(i.center),
                    t.setZoom && t.setZoom(i.zoom),
                    "series" === a && it.each(t.seriesGroup, function(t) {
                        t.setCenter(i.center),
                        t.setZoom(i.zoom)
                    })
                }
            })
        });
        var xb = R.applyTransform;
        function _b() {
            xt.call(this)
        }
        function bb(t) {
            this.name = t,
            this.zoomLimit,
            xt.call(this),
            this._roamTransformable = new _b,
            this._rawTransformable = new _b,
            this._center,
            this._zoom
        }
        function wb(t, e, i, n) {
            var a = i.seriesModel
              , r = a ? a.coordinateSystem : null;
            return r === this ? r[t](n) : null
        }
        it.mixin(_b, xt),
        bb.prototype = {
            constructor: bb,
            type: "view",
            dimensions: ["x", "y"],
            setBoundingRect: function(t, e, i, n) {
                return this._rect = new Oe(t,e,i,n),
                this._rect
            },
            getBoundingRect: function() {
                return this._rect
            },
            setViewRect: function(t, e, i, n) {
                this.transformTo(t, e, i, n),
                this._viewRect = new Oe(t,e,i,n)
            },
            transformTo: function(t, e, i, n) {
                var a = this.getBoundingRect()
                  , r = this._rawTransformable;
                r.transform = a.calculateTransform(new Oe(t,e,i,n)),
                r.decomposeTransform(),
                this._updateTransform()
            },
            setCenter: function(t) {
                t && (this._center = t,
                this._updateCenterAndZoom())
            },
            setZoom: function(t) {
                t = t || 1;
                var e = this.zoomLimit;
                e && (null != e.max && (t = Math.min(e.max, t)),
                null != e.min && (t = Math.max(e.min, t))),
                this._zoom = t,
                this._updateCenterAndZoom()
            },
            getDefaultCenter: function() {
                var t = this.getBoundingRect();
                return [t.x + t.width / 2, t.y + t.height / 2]
            },
            getCenter: function() {
                return this._center || this.getDefaultCenter()
            },
            getZoom: function() {
                return this._zoom || 1
            },
            getRoamTransform: function() {
                return this._roamTransformable.getLocalTransform()
            },
            _updateCenterAndZoom: function() {
                var t = this._rawTransformable.getLocalTransform()
                  , e = this._roamTransformable
                  , i = this.getDefaultCenter()
                  , n = this.getCenter()
                  , a = this.getZoom();
                n = R.applyTransform([], n, t),
                i = R.applyTransform([], i, t),
                e.origin = n,
                e.position = [i[0] - n[0], i[1] - n[1]],
                e.scale = [a, a],
                this._updateTransform()
            },
            _updateTransform: function() {
                var t = this._roamTransformable
                  , e = this._rawTransformable;
                (e.parent = t).updateTransform(),
                e.updateTransform(),
                ct.copy(this.transform || (this.transform = []), e.transform || ct.create()),
                this._rawTransform = e.getLocalTransform(),
                this.invTransform = this.invTransform || [],
                ct.invert(this.invTransform, this.transform),
                this.decomposeTransform()
            },
            getViewRect: function() {
                return this._viewRect
            },
            getViewRectAfterRoam: function() {
                var t = this.getBoundingRect().clone();
                return t.applyTransform(this.transform),
                t
            },
            dataToPoint: function(t, e, i) {
                var n = e ? this._rawTransform : this.transform;
                return i = i || [],
                n ? xb(i, t, n) : R.copy(i, t)
            },
            pointToData: function(t) {
                var e = this.invTransform;
                return e ? xb([], t, e) : [t[0], t[1]]
            },
            convertToPixel: it.curry(wb, "dataToPoint"),
            convertFromPixel: it.curry(wb, "pointToData"),
            containPoint: function(t) {
                return this.getViewRectAfterRoam().contain(t[0], t[1])
            }
        },
        it.mixin(bb, xt);
        var Sb = bb;
        function Mb(t, e, i, n) {
            Sb.call(this, t),
            this.map = e;
            var a = G_.load(e, i);
            this._nameCoordMap = a.nameCoordMap,
            this._regionsMap = a.regionsMap,
            this._invertLongitute = null == n || n,
            this.regions = a.regions,
            this._rect = a.boundingRect
        }
        function Ib(t, e, i, n) {
            var a = i.geoModel
              , r = i.seriesModel
              , o = a ? a.coordinateSystem : r ? r.coordinateSystem || (r.getReferringComponents("geo")[0] || {}).coordinateSystem : null;
            return o === this ? o[t](n) : null
        }
        Mb.prototype = {
            constructor: Mb,
            type: "geo",
            dimensions: ["lng", "lat"],
            containCoord: function(t) {
                for (var e = this.regions, i = 0; i < e.length; i++)
                    if (e[i].contain(t))
                        return !0;
                return !1
            },
            transformTo: function(t, e, i, n) {
                var a = this.getBoundingRect()
                  , r = this._invertLongitute;
                a = a.clone(),
                r && (a.y = -a.y - a.height);
                var o = this._rawTransformable;
                if (o.transform = a.calculateTransform(new Oe(t,e,i,n)),
                o.decomposeTransform(),
                r) {
                    var s = o.scale;
                    s[1] = -s[1]
                }
                o.updateTransform(),
                this._updateTransform()
            },
            getRegion: function(t) {
                return this._regionsMap.get(t)
            },
            getRegionByCoord: function(t) {
                for (var e = this.regions, i = 0; i < e.length; i++)
                    if (e[i].contain(t))
                        return e[i]
            },
            addGeoCoord: function(t, e) {
                this._nameCoordMap.set(t, e)
            },
            getGeoCoord: function(t) {
                return this._nameCoordMap.get(t)
            },
            getBoundingRect: function() {
                return this._rect
            },
            dataToPoint: function(t, e, i) {
                if ("string" == typeof t && (t = this.getGeoCoord(t)),
                t)
                    return Sb.prototype.dataToPoint.call(this, t, e, i)
            },
            convertToPixel: it.curry(Ib, "dataToPoint"),
            convertFromPixel: it.curry(Ib, "pointToData")
        },
        it.mixin(Mb, Sb);
        var Ab = Mb;
        function Tb(t, e) {
            var i = t.get("boundingCoords");
            if (null != i) {
                var n = i[0]
                  , a = i[1];
                isNaN(n[0]) || isNaN(n[1]) || isNaN(a[0]) || isNaN(a[1]) || this.setBoundingRect(n[0], n[1], a[0] - n[0], a[1] - n[1])
            }
            var r, o = this.getBoundingRect(), s = t.get("layoutCenter"), l = t.get("layoutSize"), u = e.getWidth(), h = e.getHeight(), c = o.width / o.height * this.aspectScale, d = !1;
            if (s && l && (s = [ol.parsePercent(s[0], u), ol.parsePercent(s[1], h)],
            l = ol.parsePercent(l, Math.min(u, h)),
            isNaN(s[0]) || isNaN(s[1]) || isNaN(l) || (d = !0)),
            d) {
                var p = {};
                1 < c ? (p.width = l,
                p.height = l / c) : (p.height = l,
                p.width = l * c),
                p.y = s[1] - p.height / 2,
                p.x = s[0] - p.width / 2
            } else
                (r = t.getBoxLayoutParams()).aspect = c,
                p = Il.getLayoutRect(r, {
                    width: u,
                    height: h
                });
            this.setViewRect(p.x, p.y, p.width, p.height),
            this.setCenter(t.get("center")),
            this.setZoom(t.get("zoom"))
        }
        function Cb(i, t) {
            it.each(t.get("geoCoord"), function(t, e) {
                i.addGeoCoord(e, t)
            })
        }
        var Db = {
            dimensions: Ab.prototype.dimensions,
            create: function(t, s) {
                var l = [];
                t.eachComponent("geo", function(t, e) {
                    var i = t.get("map")
                      , n = t.get("aspectScale")
                      , a = !0
                      , r = yp.retrieveMap(i);
                    r && r[0] && "svg" === r[0].type ? (null == n && (n = 1),
                    a = !1) : null == n && (n = .75);
                    var o = new Ab(i + e,i,t.get("nameMap"),a);
                    o.aspectScale = n,
                    o.zoomLimit = t.get("scaleLimit"),
                    l.push(o),
                    Cb(o, t),
                    (t.coordinateSystem = o).model = t,
                    o.resize = Tb,
                    o.resize(t, s)
                }),
                t.eachSeries(function(t) {
                    if ("geo" === t.get("coordinateSystem")) {
                        var e = t.get("geoIndex") || 0;
                        t.coordinateSystem = l[e]
                    }
                });
                var i = {};
                return t.eachSeriesByType("map", function(t) {
                    if (!t.getHostGeoModel()) {
                        var e = t.getMapType();
                        i[e] = i[e] || [],
                        i[e].push(t)
                    }
                }),
                it.each(i, function(t, e) {
                    var i = it.map(t, function(t) {
                        return t.get("nameMap")
                    })
                      , n = new Ab(e,e,it.mergeAll(i));
                    n.zoomLimit = it.retrieve.apply(null, it.map(t, function(t) {
                        return t.get("scaleLimit")
                    })),
                    l.push(n),
                    n.resize = Tb,
                    n.aspectScale = t[0].get("aspectScale"),
                    n.resize(t[0], s),
                    it.each(t, function(t) {
                        Cb(t.coordinateSystem = n, t)
                    })
                }),
                l
            },
            getFilledRegions: function(t, e, i) {
                for (var n = (t || []).slice(), a = it.createHashMap(), r = 0; r < n.length; r++)
                    a.set(n[r].name, n[r]);
                var o = G_.load(e, i);
                return it.each(o.regions, function(t) {
                    var e = t.name;
                    a.get(e) || n.push({
                        name: e
                    })
                }),
                n
            }
        };
        Gm.registerCoordinateSystem("geo", Db);
        var Lb = Db;
        function Pb(i) {
            var a = {};
            i.eachSeriesByType("map", function(t) {
                var e = t.getMapType();
                if (!t.getHostGeoModel() && !a[e]) {
                    var l = {};
                    it.each(t.seriesGroup, function(t) {
                        var o = t.coordinateSystem
                          , s = t.originalData;
                        t.get("showLegendSymbol") && i.getComponent("legend") && s.each(s.mapDimension("value"), function(t, e) {
                            var i = s.getName(e)
                              , n = o.getRegion(i);
                            if (n && !isNaN(t)) {
                                var a = l[i] || 0
                                  , r = o.dataToPoint(n.center);
                                l[i] = a + 1,
                                s.setItemLayout(e, {
                                    point: r,
                                    offset: a
                                })
                            }
                        })
                    });
                    var n = t.getData();
                    n.each(function(t) {
                        var e = n.getName(t)
                          , i = n.getItemLayout(t) || {};
                        i.showLabel = !l[e],
                        n.setItemLayout(t, i)
                    }),
                    a[e] = !0
                }
            })
        }
        function kb(t) {
            t.eachSeriesByType("map", function(t) {
                var e = t.get("color")
                  , i = t.getModel("itemStyle")
                  , n = i.get("areaColor")
                  , a = i.get("color") || e[t.seriesIndex % e.length];
                t.getData().setVisual({
                    areaColor: n,
                    color: a
                })
            })
        }
        function Ob(t) {
            var n = {};
            t.eachSeriesByType("map", function(t) {
                var e = t.getHostGeoModel()
                  , i = e ? "o" + e.id : "i" + t.getMapType();
                (n[i] = n[i] || []).push(t)
            }),
            it.each(n, function(t, e) {
                for (var i = function(u, h) {
                    var c = {};
                    return it.each(u, function(n) {
                        n.each(n.mapDimension("value"), function(t, e) {
                            var i = "ec-" + n.getName(e);
                            c[i] = c[i] || [],
                            isNaN(t) || c[i].push(t)
                        })
                    }),
                    u[0].map(u[0].mapDimension("value"), function(t, e) {
                        for (var i, n = "ec-" + u[0].getName(e), a = 0, r = 1 / 0, o = -1 / 0, s = c[n].length, l = 0; l < s; l++)
                            r = Math.min(r, c[n][l]),
                            o = Math.max(o, c[n][l]),
                            a += c[n][l];
                        return i = "min" === h ? r : "max" === h ? o : "average" === h ? a / s : a,
                        0 === s ? NaN : i
                    })
                }(it.map(t, function(t) {
                    return t.getData()
                }), t[0].get("mapValueCalculation")), n = 0; n < t.length; n++)
                    t[n].originalData = t[n].getData();
                for (n = 0; n < t.length; n++)
                    (t[n].seriesGroup = t)[n].needsDrawMap = 0 === n && !t[n].getHostGeoModel(),
                    t[n].setData(i.cloneShallow()),
                    t[n].mainSeries = t[0]
            })
        }
        function Rb(t) {
            it.each(t.series, function(t) {
                t && "map" === t.type && (t.map = t.map || t.mapType,
                it.defaults(t, t.mapLocation))
            })
        }
        Gm.registerLayout(Pb),
        Gm.registerVisual(kb),
        Gm.registerProcessor(Gm.PRIORITY.PROCESSOR.STATISTIC, Ob),
        Gm.registerPreprocessor(Rb),
        Bx("map", [{
            type: "mapToggleSelect",
            event: "mapselectchanged",
            method: "toggleSelected"
        }, {
            type: "mapSelect",
            event: "mapselected",
            method: "select"
        }, {
            type: "mapUnSelect",
            event: "mapunselected",
            method: "unSelect"
        }]);
        var Nb = it.each
          , Eb = "\0__link_datas"
          , zb = "\0__link_mainData";
        function Vb(t, e) {
            if (function(t) {
                return t[zb] === t
            }(this)) {
                var i = it.extend({}, this[Eb]);
                Hb(i[this.dataType] = e, i, t)
            } else
                Wb(e, this.dataType, this[zb], t);
            return e
        }
        function Bb(t, e) {
            return t.struct && t.struct.update(this),
            e
        }
        function Gb(i, n) {
            return Nb(n[Eb], function(t, e) {
                t !== n && Wb(t.cloneShallow(), e, n, i)
            }),
            n
        }
        function Fb(t) {
            var e = this[zb];
            return null == t || null == e ? e : e[Eb][t]
        }
        function Hb(i, t, n) {
            i[Eb] = {},
            Nb(t, function(t, e) {
                Wb(t, e, i, n)
            })
        }
        function Wb(t, e, i, n) {
            (i[Eb][e] = t)[zb] = i,
            t.dataType = e,
            n.struct && (t[n.structAttr] = n.struct,
            n.struct[n.datasAttr[e]] = t),
            t.getLinkedData = Fb
        }
        function Zb(t, e) {
            this.name = t || "",
            this.depth = 0,
            this.height = 0,
            this.parentNode = null,
            this.dataIndex = -1,
            this.children = [],
            this.viewChildren = [],
            this.hostTree = e
        }
        var Ub = function(i) {
            var n = i.mainData
              , t = i.datas;
            t || (t = {
                main: n
            },
            i.datasAttr = {
                main: "data"
            }),
            i.datas = i.mainData = null,
            Hb(n, t, i),
            Nb(t, function(e) {
                Nb(n.TRANSFERABLE_METHODS, function(t) {
                    e.wrapMethod(t, it.curry(Vb, i))
                })
            }),
            n.wrapMethod("cloneShallow", it.curry(Gb, i)),
            Nb(n.CHANGABLE_METHODS, function(t) {
                n.wrapMethod(t, it.curry(Bb, i))
            }),
            it.assert(t[n.dataType] === n)
        };
        function Yb(e, t, i) {
            this.root,
            this.data,
            this._nodes = [],
            this.hostModel = e,
            this.levelModels = it.map(t || [], function(t) {
                return new tl(t,e,e.ecModel)
            }),
            this.leavesModel = new tl(i || {},e,e.ecModel)
        }
        function jb(t, e) {
            var i = e.children;
            t.parentNode !== e && (i.push(t),
            t.parentNode = e)
        }
        Zb.prototype = {
            constructor: Zb,
            isRemoved: function() {
                return this.dataIndex < 0
            },
            eachNode: function(t, e, i) {
                "function" == typeof t && (i = e,
                e = t,
                t = null),
                t = t || {},
                it.isString(t) && (t = {
                    order: t
                });
                var n, a = t.order || "preorder", r = this[t.attr || "children"];
                "preorder" === a && (n = e.call(i, this));
                for (var o = 0; !n && o < r.length; o++)
                    r[o].eachNode(t, e, i);
                "postorder" === a && e.call(i, this)
            },
            updateDepthAndHeight: function(t) {
                var e = 0;
                this.depth = t;
                for (var i = 0; i < this.children.length; i++) {
                    var n = this.children[i];
                    n.updateDepthAndHeight(t + 1),
                    n.height > e && (e = n.height)
                }
                this.height = e + 1
            },
            getNodeById: function(t) {
                if (this.getId() === t)
                    return this;
                for (var e = 0, i = this.children, n = i.length; e < n; e++) {
                    var a = i[e].getNodeById(t);
                    if (a)
                        return a
                }
            },
            contains: function(t) {
                if (t === this)
                    return !0;
                for (var e = 0, i = this.children, n = i.length; e < n; e++) {
                    var a = i[e].contains(t);
                    if (a)
                        return a
                }
            },
            getAncestors: function(t) {
                for (var e = [], i = t ? this : this.parentNode; i; )
                    e.push(i),
                    i = i.parentNode;
                return e.reverse(),
                e
            },
            getValue: function(t) {
                var e = this.hostTree.data;
                return e.get(e.getDimension(t || "value"), this.dataIndex)
            },
            setLayout: function(t, e) {
                0 <= this.dataIndex && this.hostTree.data.setItemLayout(this.dataIndex, t, e)
            },
            getLayout: function() {
                return this.hostTree.data.getItemLayout(this.dataIndex)
            },
            getModel: function(t) {
                if (!(this.dataIndex < 0)) {
                    var e, i = this.hostTree, n = i.data.getItemModel(this.dataIndex), a = this.getLevelModel();
                    return a || 0 !== this.children.length && (0 === this.children.length || !1 !== this.isExpand) || (e = this.getLeavesModel()),
                    n.getModel(t, (a || e || i.hostModel).getModel(t))
                }
            },
            getLevelModel: function() {
                return (this.hostTree.levelModels || [])[this.depth]
            },
            getLeavesModel: function() {
                return this.hostTree.leavesModel
            },
            setVisual: function(t, e) {
                0 <= this.dataIndex && this.hostTree.data.setItemVisual(this.dataIndex, t, e)
            },
            getVisual: function(t, e) {
                return this.hostTree.data.getItemVisual(this.dataIndex, t, e)
            },
            getRawIndex: function() {
                return this.hostTree.data.getRawIndex(this.dataIndex)
            },
            getId: function() {
                return this.hostTree.data.getId(this.dataIndex)
            },
            isAncestorOf: function(t) {
                for (var e = t.parentNode; e; ) {
                    if (e === this)
                        return !0;
                    e = e.parentNode
                }
                return !1
            },
            isDescendantOf: function(t) {
                return t !== this && t.isAncestorOf(this)
            }
        },
        Yb.prototype = {
            constructor: Yb,
            type: "tree",
            eachNode: function(t, e, i) {
                this.root.eachNode(t, e, i)
            },
            getNodeByDataIndex: function(t) {
                var e = this.data.getRawIndex(t);
                return this._nodes[e]
            },
            getNodeByName: function(t) {
                return this.root.getNodeByName(t)
            },
            update: function() {
                for (var t = this.data, e = this._nodes, i = 0, n = e.length; i < n; i++)
                    e[i].dataIndex = -1;
                for (i = 0,
                n = t.count(); i < n; i++)
                    e[t.getRawIndex(i)].dataIndex = i
            },
            clearLayouts: function() {
                this.data.clearItemLayouts()
            }
        },
        Yb.createTree = function(t, e, i) {
            var s = new Yb(e,i.levels,i.leaves)
              , l = []
              , u = 1;
            !function t(e, i) {
                var n = e.value;
                u = Math.max(u, it.isArray(n) ? n.length : 1);
                l.push(e);
                var a = new Zb(e.name,s);
                i ? jb(a, i) : s.root = a;
                s._nodes.push(a);
                var r = e.children;
                if (r)
                    for (var o = 0; o < r.length; o++)
                        t(r[o], a)
            }(t),
            s.root.updateDepthAndHeight(0);
            var n = pf(l, {
                coordDimensions: ["value"],
                dimensionsCount: u
            })
              , a = new Qp(n,e);
            return a.initData(l),
            Ub({
                mainData: a,
                struct: s,
                structAttr: "tree"
            }),
            s.update(),
            s
        }
        ;
        var Xb = Yb
          , qb = fl.encodeHTML;
        kc.extend({
            type: "series.tree",
            layoutInfo: null,
            layoutMode: "box",
            getInitialData: function(t) {
                var e = {
                    name: t.name,
                    children: t.data
                }
                  , i = t.leaves || {}
                  , n = {};
                n.leaves = i;
                var a = Xb.createTree(e, this, n)
                  , r = 0;
                a.eachNode("preorder", function(t) {
                    t.depth > r && (r = t.depth)
                });
                var o = t.expandAndCollapse && 0 <= t.initialTreeDepth ? t.initialTreeDepth : r;
                return a.root.eachNode("preorder", function(t) {
                    var e = t.hostTree.data.getRawDataItem(t.dataIndex);
                    t.isExpand = e && null != e.collapsed ? !e.collapsed : t.depth <= o
                }),
                a.data
            },
            getOrient: function() {
                var t = this.get("orient");
                return "horizontal" === t ? t = "LR" : "vertical" === t && (t = "TB"),
                t
            },
            setZoom: function(t) {
                this.option.zoom = t
            },
            setCenter: function(t) {
                this.option.center = t
            },
            formatTooltip: function(t) {
                for (var e = this.getData().tree, i = e.root.children[0], n = e.getNodeByDataIndex(t), a = n.getValue(), r = n.name; n && n !== i; )
                    r = n.parentNode.name + "." + r,
                    n = n.parentNode;
                return qb(r + (isNaN(a) || null == a ? "" : " : " + a))
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "view",
                left: "12%",
                top: "12%",
                right: "12%",
                bottom: "12%",
                layout: "orthogonal",
                roam: !1,
                nodeScaleRatio: .4,
                center: null,
                zoom: 1,
                orient: "LR",
                symbol: "emptyCircle",
                symbolSize: 7,
                expandAndCollapse: !0,
                initialTreeDepth: 2,
                lineStyle: {
                    color: "#ccc",
                    width: 1.5,
                    curveness: .5
                },
                itemStyle: {
                    color: "lightsteelblue",
                    borderColor: "#c23531",
                    borderWidth: 1.5
                },
                label: {
                    show: !0,
                    color: "#555"
                },
                leaves: {
                    label: {
                        show: !0
                    }
                },
                animationEasing: "linear",
                animationDuration: 700,
                animationDurationUpdate: 1e3
            }
        });
        function Kb(t) {
            var e = t.children;
            return e.length && t.isExpand ? e[e.length - 1] : t.hierNode.thread
        }
        function $b(t) {
            var e = t.children;
            return e.length && t.isExpand ? e[0] : t.hierNode.thread
        }
        function Jb(t, e, i) {
            var n = i / (e.hierNode.i - t.hierNode.i);
            e.hierNode.change -= n,
            e.hierNode.shift += i,
            e.hierNode.modifier += i,
            e.hierNode.prelim += i,
            t.hierNode.change += n
        }
        function Qb(t, e) {
            return t.parentNode === e.parentNode ? 1 : 2
        }
        var tw = {
            init: function(t) {
                t.hierNode = {
                    defaultAncestor: null,
                    ancestor: t,
                    prelim: 0,
                    modifier: 0,
                    change: 0,
                    shift: 0,
                    i: 0,
                    thread: null
                };
                for (var e, i, n = [t]; e = n.pop(); )
                    if (i = e.children,
                    e.isExpand && i.length)
                        for (var a = i.length - 1; 0 <= a; a--) {
                            var r = i[a];
                            r.hierNode = {
                                defaultAncestor: null,
                                ancestor: r,
                                prelim: 0,
                                modifier: 0,
                                change: 0,
                                shift: 0,
                                i: a,
                                thread: null
                            },
                            n.push(r)
                        }
            },
            firstWalk: function(t, e) {
                var i = t.isExpand ? t.children : []
                  , n = t.parentNode.children
                  , a = t.hierNode.i ? n[t.hierNode.i - 1] : null;
                if (i.length) {
                    !function(t) {
                        var e = t.children
                          , i = e.length
                          , n = 0
                          , a = 0;
                        for (; 0 <= --i; ) {
                            var r = e[i];
                            r.hierNode.prelim += n,
                            r.hierNode.modifier += n,
                            a += r.hierNode.change,
                            n += r.hierNode.shift + a
                        }
                    }(t);
                    var r = (i[0].hierNode.prelim + i[i.length - 1].hierNode.prelim) / 2;
                    a ? (t.hierNode.prelim = a.hierNode.prelim + e(t, a),
                    t.hierNode.modifier = t.hierNode.prelim - r) : t.hierNode.prelim = r
                } else
                    a && (t.hierNode.prelim = a.hierNode.prelim + e(t, a));
                t.parentNode.hierNode.defaultAncestor = function(t, e, i, n) {
                    if (e) {
                        for (var a = t, r = t, o = r.parentNode.children[0], s = e, l = a.hierNode.modifier, u = r.hierNode.modifier, h = o.hierNode.modifier, c = s.hierNode.modifier; s = Kb(s),
                        r = $b(r),
                        s && r; ) {
                            a = Kb(a),
                            o = $b(o),
                            a.hierNode.ancestor = t;
                            var d = s.hierNode.prelim + c - r.hierNode.prelim - u + n(s, r);
                            0 < d && (Jb((f = t,
                            g = i,
                            (p = s).hierNode.ancestor.parentNode === f.parentNode ? p.hierNode.ancestor : g), t, d),
                            u += d,
                            l += d),
                            c += s.hierNode.modifier,
                            u += r.hierNode.modifier,
                            l += a.hierNode.modifier,
                            h += o.hierNode.modifier
                        }
                        s && !Kb(a) && (a.hierNode.thread = s,
                        a.hierNode.modifier += c - l),
                        r && !$b(o) && (o.hierNode.thread = r,
                        o.hierNode.modifier += u - h,
                        i = t)
                    }
                    var p, f, g;
                    return i
                }(t, a, t.parentNode.hierNode.defaultAncestor || n[0], e)
            },
            secondWalk: function(t) {
                var e = t.hierNode.prelim + t.parentNode.hierNode.modifier;
                t.setLayout({
                    x: e
                }, !0),
                t.hierNode.modifier += t.parentNode.hierNode.modifier
            },
            separation: function(t) {
                return arguments.length ? t : Qb
            },
            radialCoordinate: function(t, e) {
                var i = {};
                return t -= Math.PI / 2,
                i.x = e * Math.cos(t),
                i.y = e * Math.sin(t),
                i
            },
            getViewRect: function(t, e) {
                return Il.getLayoutRect(t.getBoxLayoutParams(), {
                    width: e.getWidth(),
                    height: e.getHeight()
                })
            }
        }
          , ew = tw.radialCoordinate
          , iw = ob.onIrrelevantElement;
        Gm.extendChartView({
            type: "tree",
            init: function(t, e) {
                this._oldTree,
                this._mainGroup = new Fs.Group,
                this._controller = new nb(e.getZr()),
                this._controllerHost = {
                    target: this.group
                },
                this.group.add(this._mainGroup)
            },
            render: function(n, t, i, e) {
                var a = n.getData()
                  , r = n.layoutInfo
                  , o = this._mainGroup
                  , s = n.get("layout");
                "radial" === s ? o.attr("position", [r.x + r.width / 2, r.y + r.height / 2]) : o.attr("position", [r.x, r.y]),
                this._updateViewCoordSys(n),
                this._updateController(n, t, i);
                var l = this._data
                  , u = {
                    expandAndCollapse: n.get("expandAndCollapse"),
                    layout: s,
                    orient: n.getOrient(),
                    curvature: n.get("lineStyle.curveness"),
                    symbolRotate: n.get("symbolRotate"),
                    symbolOffset: n.get("symbolOffset"),
                    hoverAnimation: n.get("hoverAnimation"),
                    useNameLabel: !0,
                    fadeIn: !0
                };
                a.diff(l).add(function(t) {
                    nw(a, t) && rw(a, t, null, o, n, u)
                }).update(function(t, e) {
                    var i = l.getItemGraphicEl(e);
                    nw(a, t) ? rw(a, t, i, o, n, u) : i && ow(l, e, i, o, n, u)
                }).remove(function(t) {
                    var e = l.getItemGraphicEl(t);
                    e && ow(l, t, e, o, n, u)
                }).execute(),
                this._nodeScaleRatio = n.get("nodeScaleRatio"),
                this._updateNodeAndLinkScale(n),
                !0 === u.expandAndCollapse && a.eachItemGraphicEl(function(t, e) {
                    t.off("click").on("click", function() {
                        i.dispatchAction({
                            type: "treeExpandAndCollapse",
                            seriesId: n.id,
                            dataIndex: e
                        })
                    })
                }),
                this._data = a
            },
            _updateViewCoordSys: function(t) {
                var i = t.getData()
                  , n = [];
                i.each(function(t) {
                    var e = i.getItemLayout(t);
                    !e || isNaN(e.x) || isNaN(e.y) || n.push([+e.x, +e.y])
                });
                var e = []
                  , a = [];
                Ha.fromPoints(n, e, a),
                a[0] - e[0] == 0 && (a[0] += 1,
                e[0] -= 1),
                a[1] - e[1] == 0 && (a[1] += 1,
                e[1] -= 1);
                var r = t.coordinateSystem = new Sb;
                r.zoomLimit = t.get("scaleLimit"),
                r.setBoundingRect(e[0], e[1], a[0] - e[0], a[1] - e[1]),
                r.setCenter(t.get("center")),
                r.setZoom(t.get("zoom")),
                this.group.attr({
                    position: r.position,
                    scale: r.scale
                }),
                this._viewCoordSys = r
            },
            _updateController: function(a, t, r) {
                var e = this._controller
                  , i = this._controllerHost
                  , o = this.group;
                e.setPointerChecker(function(t, e, i) {
                    var n = o.getBoundingRect();
                    return n.applyTransform(o.transform),
                    n.contain(e, i) && !iw(t, r, a)
                }),
                e.enable(a.get("roam")),
                i.zoomLimit = a.get("scaleLimit"),
                i.zoom = a.coordinateSystem.getZoom(),
                e.off("pan").off("zoom").on("pan", function(t) {
                    ab.updateViewOnPan(i, t.dx, t.dy),
                    r.dispatchAction({
                        seriesId: a.id,
                        type: "treeRoam",
                        dx: t.dx,
                        dy: t.dy
                    })
                }, this).on("zoom", function(t) {
                    ab.updateViewOnZoom(i, t.scale, t.originX, t.originY),
                    r.dispatchAction({
                        seriesId: a.id,
                        type: "treeRoam",
                        zoom: t.scale,
                        originX: t.originX,
                        originY: t.originY
                    }),
                    this._updateNodeAndLinkScale(a)
                }, this)
            },
            _updateNodeAndLinkScale: function(t) {
                var e = t.getData()
                  , i = this._getNodeGlobalScale(t)
                  , n = [i, i];
                e.eachItemGraphicEl(function(t, e) {
                    t.attr("scale", n)
                })
            },
            _getNodeGlobalScale: function(t) {
                var e = t.coordinateSystem;
                if ("view" !== e.type)
                    return 1;
                var i = this._nodeScaleRatio
                  , n = e.scale
                  , a = n && n[0] || 1;
                return ((e.getZoom() - 1) * i + 1) / a
            },
            dispose: function() {
                this._controller && this._controller.dispose(),
                this._controllerHost = {}
            },
            remove: function() {
                this._mainGroup.removeAll(),
                this._data = null
            }
        });
        function nw(t, e) {
            var i = t.getItemLayout(e);
            return i && !isNaN(i.x) && !isNaN(i.y) && "none" !== t.getItemVisual(e, "symbol")
        }
        function aw(t, e, i) {
            return i.itemModel = e,
            i.itemStyle = e.getModel("itemStyle").getItemStyle(),
            i.hoverItemStyle = e.getModel("emphasis.itemStyle").getItemStyle(),
            i.lineStyle = e.getModel("lineStyle").getLineStyle(),
            i.labelModel = e.getModel("label"),
            i.hoverLabelModel = e.getModel("emphasis.label"),
            !1 === t.isExpand && 0 !== t.children.length ? i.symbolInnerColor = i.itemStyle.fill : i.symbolInnerColor = "#fff",
            i
        }
        function rw(t, e, i, n, a, r) {
            var o = !i
              , s = t.tree.getNodeByDataIndex(e)
              , l = s.getModel()
              , u = (r = aw(s, l, r),
            t.tree.root)
              , h = s.parentNode === u ? s : s.parentNode || s
              , c = t.getItemGraphicEl(h.dataIndex)
              , d = h.getLayout()
              , p = c ? {
                x: c.position[0],
                y: c.position[1],
                rawX: c.__radialOldRawX,
                rawY: c.__radialOldRawY
            } : d
              , f = s.getLayout();
            o ? (i = new rv(t,e,r)).attr("position", [p.x, p.y]) : i.updateData(t, e, r),
            i.__radialOldRawX = i.__radialRawX,
            i.__radialOldRawY = i.__radialRawY,
            i.__radialRawX = f.rawX,
            i.__radialRawY = f.rawY,
            n.add(i),
            t.setItemGraphicEl(e, i),
            Fs.updateProps(i, {
                position: [f.x, f.y]
            }, a);
            var g = i.getSymbolPath();
            if ("radial" === r.layout) {
                var m, v, y = u.children[0], x = y.getLayout(), _ = y.children.length;
                if (f.x === x.x && !0 === s.isExpand) {
                    var b = {};
                    b.x = (y.children[0].getLayout().x + y.children[_ - 1].getLayout().x) / 2,
                    b.y = (y.children[0].getLayout().y + y.children[_ - 1].getLayout().y) / 2,
                    (m = Math.atan2(b.y - x.y, b.x - x.x)) < 0 && (m = 2 * Math.PI + m),
                    (v = b.x < x.x) && (m -= Math.PI)
                } else
                    (m = Math.atan2(f.y - x.y, f.x - x.x)) < 0 && (m = 2 * Math.PI + m),
                    0 === s.children.length || 0 !== s.children.length && !1 === s.isExpand ? (v = f.x < x.x) && (m -= Math.PI) : (v = f.x > x.x) || (m -= Math.PI);
                var w = v ? "left" : "right";
                g.setStyle({
                    textPosition: w,
                    textRotation: -m,
                    textOrigin: "center",
                    verticalAlign: "middle"
                })
            }
            if (s.parentNode && s.parentNode !== u) {
                var S = i.__edge;
                S = S || (i.__edge = new Fs.BezierCurve({
                    shape: sw(r, p, p),
                    style: it.defaults({
                        opacity: 0,
                        strokeNoScale: !0
                    }, r.lineStyle)
                })),
                Fs.updateProps(S, {
                    shape: sw(r, d, f),
                    style: {
                        opacity: 1
                    }
                }, a),
                n.add(S)
            }
        }
        function ow(t, e, i, n, a, r) {
            for (var o, s = t.tree.getNodeByDataIndex(e), l = t.tree.root, u = s.getModel(), h = (r = aw(s, u, r),
            s.parentNode === l ? s : s.parentNode || s); null == (o = h.getLayout()); )
                h = h.parentNode === l ? h : h.parentNode || h;
            Fs.updateProps(i, {
                position: [o.x + 1, o.y + 1]
            }, a, function() {
                n.remove(i),
                t.setItemGraphicEl(e, null)
            }),
            i.fadeOut(null, {
                keepLabel: !0
            });
            var c = i.__edge;
            c && Fs.updateProps(c, {
                shape: sw(r, o, o),
                style: {
                    opacity: 0
                }
            }, a, function() {
                n.remove(c)
            })
        }
        function sw(t, e, i) {
            var n, a, r, o, s, l, u, h, c = t.orient;
            if ("radial" !== t.layout)
                return s = e.x,
                u = e.y,
                l = i.x,
                h = i.y,
                "LR" !== c && "RL" !== c || (n = s + (l - s) * t.curvature,
                a = u,
                r = l + (s - l) * t.curvature,
                o = h),
                "TB" !== c && "BT" !== c || (n = s,
                a = u + (h - u) * t.curvature,
                r = l,
                o = h + (u - h) * t.curvature),
                {
                    x1: s,
                    y1: u,
                    x2: l,
                    y2: h,
                    cpx1: n,
                    cpy1: a,
                    cpx2: r,
                    cpy2: o
                };
            s = e.rawX,
            u = e.rawY,
            l = i.rawX,
            h = i.rawY;
            var d = ew(s, u)
              , p = ew(s, u + (h - u) * t.curvature)
              , f = ew(l, h + (u - h) * t.curvature)
              , g = ew(l, h);
            return {
                x1: d.x,
                y1: d.y,
                x2: g.x,
                y2: g.y,
                cpx1: p.x,
                cpy1: p.y,
                cpx2: f.x,
                cpy2: f.y
            }
        }
        var lw = vb.updateCenterAndZoom;
        Gm.registerAction({
            type: "treeExpandAndCollapse",
            event: "treeExpandAndCollapse",
            update: "update"
        }, function(n, t) {
            t.eachComponent({
                mainType: "series",
                subType: "tree",
                query: n
            }, function(t) {
                var e = n.dataIndex
                  , i = t.getData().tree.getNodeByDataIndex(e);
                i.isExpand = !i.isExpand
            })
        }),
        Gm.registerAction({
            type: "treeRoam",
            event: "treeRoam",
            update: "none"
        }, function(n, t) {
            t.eachComponent({
                mainType: "series",
                subType: "tree",
                query: n
            }, function(t) {
                var e = t.coordinateSystem
                  , i = lw(e, n);
                t.setCenter && t.setCenter(i.center),
                t.setZoom && t.setZoom(i.zoom)
            })
        });
        var uw = {
            eachAfter: function(t, e, i) {
                for (var n, a = [t], r = []; n = a.pop(); )
                    if (r.push(n),
                    n.isExpand) {
                        var o = n.children;
                        if (o.length)
                            for (var s = 0; s < o.length; s++)
                                a.push(o[s])
                    }
                for (; n = r.pop(); )
                    e(n, i)
            },
            eachBefore: function(t, e) {
                for (var i, n = [t]; i = n.pop(); )
                    if (e(i),
                    i.isExpand) {
                        var a = i.children;
                        if (a.length)
                            for (var r = a.length - 1; 0 <= r; r--)
                                n.push(a[r])
                    }
            }
        }
          , hw = uw.eachAfter
          , cw = uw.eachBefore
          , dw = tw.init
          , pw = tw.firstWalk
          , fw = tw.secondWalk
          , gw = tw.separation
          , mw = tw.radialCoordinate
          , vw = tw.getViewRect;
        function yw(t, e) {
            t.eachSeriesByType("tree", function(t) {
                !function(t, e) {
                    var i = vw(t, e);
                    t.layoutInfo = i;
                    var n = t.get("layout")
                      , a = 0
                      , r = 0
                      , o = null;
                    o = "radial" === n ? (a = 2 * Math.PI,
                    r = Math.min(i.height, i.width) / 2,
                    gw(function(t, e) {
                        return (t.parentNode === e.parentNode ? 1 : 2) / t.depth
                    })) : (a = i.width,
                    r = i.height,
                    gw());
                    var s = t.getData().tree.root
                      , l = s.children[0];
                    if (l) {
                        dw(s),
                        hw(l, pw, o),
                        s.hierNode.modifier = -l.hierNode.prelim,
                        cw(l, fw);
                        var u = l
                          , h = l
                          , c = l;
                        cw(l, function(t) {
                            var e = t.getLayout().x;
                            e < u.getLayout().x && (u = t),
                            e > h.getLayout().x && (h = t),
                            t.depth > c.depth && (c = t)
                        });
                        var d = u === h ? 1 : o(u, h) / 2
                          , p = d - u.getLayout().x
                          , f = 0
                          , g = 0
                          , m = 0
                          , v = 0;
                        if ("radial" === n)
                            f = a / (h.getLayout().x + d + p),
                            g = r / (c.depth - 1 || 1),
                            cw(l, function(t) {
                                m = (t.getLayout().x + p) * f,
                                v = (t.depth - 1) * g;
                                var e = mw(m, v);
                                t.setLayout({
                                    x: e.x,
                                    y: e.y,
                                    rawX: m,
                                    rawY: v
                                }, !0)
                            });
                        else {
                            var y = t.getOrient();
                            "RL" === y || "LR" === y ? (g = r / (h.getLayout().x + d + p),
                            f = a / (c.depth - 1 || 1),
                            cw(l, function(t) {
                                v = (t.getLayout().x + p) * g,
                                m = "LR" === y ? (t.depth - 1) * f : a - (t.depth - 1) * f,
                                t.setLayout({
                                    x: m,
                                    y: v
                                }, !0)
                            })) : "TB" !== y && "BT" !== y || (f = a / (h.getLayout().x + d + p),
                            g = r / (c.depth - 1 || 1),
                            cw(l, function(t) {
                                m = (t.getLayout().x + p) * f,
                                v = "TB" === y ? (t.depth - 1) * g : r - (t.depth - 1) * g,
                                t.setLayout({
                                    x: m,
                                    y: v
                                }, !0)
                            }))
                        }
                    }
                }(t, e)
            })
        }
        function xw(t) {
            for (var e = []; t; )
                (t = t.parentNode) && e.push(t);
            return e.reverse()
        }
        Gm.registerVisual(Fv("tree", "circle")),
        Gm.registerLayout(yw);
        var _w = {
            retrieveTargetInfo: function(t, e, i) {
                if (t && 0 <= it.indexOf(e, t.type)) {
                    var n = i.getData().tree.root
                      , a = t.targetNode;
                    if ("string" == typeof a && (a = n.getNodeById(a)),
                    a && n.contains(a))
                        return {
                            node: a
                        };
                    var r = t.targetNodeId;
                    if (null != r && (a = n.getNodeById(r)))
                        return {
                            node: a
                        }
                }
            },
            getPathToRoot: xw,
            aboveViewRoot: function(t, e) {
                var i = xw(t);
                return 0 <= it.indexOf(i, e)
            },
            wrapTreePathInfo: function(t, e) {
                for (var i = []; t; ) {
                    var n = t.dataIndex;
                    i.push({
                        name: t.name,
                        dataIndex: n,
                        value: e.getRawValue(n)
                    }),
                    t = t.parentNode
                }
                return i.reverse(),
                i
            }
        }
          , bw = fl.encodeHTML
          , ww = fl.addCommas
          , Sw = _w.wrapTreePathInfo;
        kc.extend({
            type: "series.treemap",
            layoutMode: "box",
            dependencies: ["grid", "polar"],
            _viewRoot: null,
            defaultOption: {
                progressive: 0,
                hoverLayerThreshold: 1 / 0,
                left: "center",
                top: "middle",
                right: null,
                bottom: null,
                width: "80%",
                height: "80%",
                sort: !0,
                clipWindow: "origin",
                squareRatio: .5 * (1 + Math.sqrt(5)),
                leafDepth: null,
                drillDownIcon: "",
                zoomToNodeRatio: .1024,
                roam: !0,
                nodeClick: "zoomToNode",
                animation: !0,
                animationDurationUpdate: 900,
                animationEasing: "quinticInOut",
                breadcrumb: {
                    show: !0,
                    height: 22,
                    left: "center",
                    top: "bottom",
                    emptyItemWidth: 25,
                    itemStyle: {
                        color: "rgba(0,0,0,0.7)",
                        borderColor: "rgba(255,255,255,0.7)",
                        borderWidth: 1,
                        shadowColor: "rgba(150,150,150,1)",
                        shadowBlur: 3,
                        shadowOffsetX: 0,
                        shadowOffsetY: 0,
                        textStyle: {
                            color: "#fff"
                        }
                    },
                    emphasis: {
                        textStyle: {}
                    }
                },
                label: {
                    show: !0,
                    distance: 0,
                    padding: 5,
                    position: "inside",
                    color: "#fff",
                    ellipsis: !0
                },
                upperLabel: {
                    show: !1,
                    position: [0, "50%"],
                    height: 20,
                    color: "#fff",
                    ellipsis: !0,
                    verticalAlign: "middle"
                },
                itemStyle: {
                    color: null,
                    colorAlpha: null,
                    colorSaturation: null,
                    borderWidth: 0,
                    gapWidth: 0,
                    borderColor: "#fff",
                    borderColorSaturation: null
                },
                emphasis: {
                    upperLabel: {
                        show: !0,
                        position: [0, "50%"],
                        color: "#fff",
                        ellipsis: !0,
                        verticalAlign: "middle"
                    }
                },
                visualDimension: 0,
                visualMin: null,
                visualMax: null,
                color: [],
                colorAlpha: null,
                colorSaturation: null,
                colorMappingBy: "index",
                visibleMin: 10,
                childrenVisibleMin: null,
                levels: []
            },
            getInitialData: function(t, e) {
                var i = {
                    name: t.name,
                    children: t.data
                };
                !function i(t) {
                    var n = 0;
                    it.each(t.children, function(t) {
                        i(t);
                        var e = t.value;
                        it.isArray(e) && (e = e[0]),
                        n += e
                    });
                    var e = t.value;
                    it.isArray(e) && (e = e[0]);
                    null != e && !isNaN(e) || (e = n);
                    e < 0 && (e = 0);
                    it.isArray(t.value) ? t.value[0] = e : t.value = e
                }(i);
                var n = t.levels || [];
                n = t.levels = function(t, e) {
                    var n, i = e.get("color");
                    if (!i)
                        return;
                    if (t = t || [],
                    it.each(t, function(t) {
                        var e = new tl(t)
                          , i = e.get("color");
                        (e.get("itemStyle.color") || i && "none" !== i) && (n = !0)
                    }),
                    !n) {
                        (t[0] || (t[0] = {})).color = i.slice()
                    }
                    return t
                }(n, e);
                var a = {};
                return a.levels = n,
                Xb.createTree(i, this, a).data
            },
            optionUpdated: function() {
                this.resetViewRoot()
            },
            formatTooltip: function(t) {
                var e = this.getData()
                  , i = this.getRawValue(t)
                  , n = it.isArray(i) ? ww(i[0]) : ww(i)
                  , a = e.getName(t);
                return bw(a + ": " + n)
            },
            getDataParams: function(t) {
                var e = kc.prototype.getDataParams.apply(this, arguments)
                  , i = this.getData().tree.getNodeByDataIndex(t);
                return e.treePathInfo = Sw(i, this),
                e
            },
            setLayoutInfo: function(t) {
                this.layoutInfo = this.layoutInfo || {},
                it.extend(this.layoutInfo, t)
            },
            mapIdToIndex: function(t) {
                var e = this._idIndexMap;
                e || (e = this._idIndexMap = it.createHashMap(),
                this._idIndexMapCount = 0);
                var i = e.get(t);
                return null == i && e.set(t, i = this._idIndexMapCount++),
                i
            },
            getViewRoot: function() {
                return this._viewRoot
            },
            resetViewRoot: function(t) {
                t ? this._viewRoot = t : t = this._viewRoot;
                var e = this.getRawData().tree.root;
                t && (t === e || e.contains(t)) || (this._viewRoot = e)
            }
        });
        var Mw = _w.wrapTreePathInfo
          , Iw = 5;
        function Aw(t) {
            this.group = new Fs.Group,
            t.add(this.group)
        }
        function Tw(t, e, i, n, a, r) {
            var o = [[a ? t : t - Iw, e], [t + i, e], [t + i, e + n], [a ? t : t - Iw, e + n]];
            return r || o.splice(2, 0, [t + i + Iw, e + n / 2]),
            a || o.push([t, e + n / 2]),
            o
        }
        Aw.prototype = {
            constructor: Aw,
            render: function(t, e, i, n) {
                var a = t.getModel("breadcrumb")
                  , r = this.group;
                if (r.removeAll(),
                a.get("show") && i) {
                    var o = a.getModel("itemStyle")
                      , s = o.getModel("textStyle")
                      , l = {
                        pos: {
                            left: a.get("left"),
                            right: a.get("right"),
                            top: a.get("top"),
                            bottom: a.get("bottom")
                        },
                        box: {
                            width: e.getWidth(),
                            height: e.getHeight()
                        },
                        emptyItemWidth: a.get("emptyItemWidth"),
                        totalWidth: 0,
                        renderList: []
                    };
                    this._prepare(i, l, s),
                    this._renderContent(t, l, o, s, n),
                    Il.positionElement(r, l.pos, l.box)
                }
            },
            _prepare: function(t, e, i) {
                for (var n = t; n; n = n.parentNode) {
                    var a = n.getModel().get("name")
                      , r = i.getTextRect(a)
                      , o = Math.max(r.width + 16, e.emptyItemWidth);
                    e.totalWidth += o + 8,
                    e.renderList.push({
                        node: n,
                        text: a,
                        width: o
                    })
                }
            },
            _renderContent: function(t, e, i, n, a) {
                for (var r, o, s = 0, l = e.emptyItemWidth, u = t.get("breadcrumb.height"), h = Il.getAvailableSize(e.pos, e.box), c = e.totalWidth, d = e.renderList, p = d.length - 1; 0 <= p; p--) {
                    var f = d[p]
                      , g = f.node
                      , m = f.width
                      , v = f.text;
                    c > h.width && (c -= m - l,
                    m = l,
                    v = null);
                    var y = new Fs.Polygon({
                        shape: {
                            points: Tw(s, 0, m, u, p === d.length - 1, 0 === p)
                        },
                        style: it.defaults(i.getItemStyle(), {
                            lineJoin: "bevel",
                            text: v,
                            textFill: n.getTextColor(),
                            textFont: n.getFont()
                        }),
                        z: 10,
                        onclick: it.curry(a, g)
                    });
                    this.group.add(y),
                    r = t,
                    o = g,
                    y.eventData = {
                        componentType: "series",
                        componentSubType: "treemap",
                        componentIndex: r.componentIndex,
                        seriesIndex: r.componentIndex,
                        seriesName: r.name,
                        seriesType: "treemap",
                        selfType: "breadcrumb",
                        nodeData: {
                            dataIndex: o && o.dataIndex,
                            name: o && o.name
                        },
                        treePathInfo: o && Mw(o, r)
                    },
                    s += m + 8
                }
            },
            remove: function() {
                this.group.removeAll()
            }
        };
        var Cw = Aw;
        function Dw(t) {
            var e = Gw(t);
            return e.stroke = e.fill = e.lineWidth = null,
            e
        }
        var Lw = {
            createWrap: function() {
                var r, o = [], s = {};
                return {
                    add: function(t, e, i, n, a) {
                        return it.isString(n) && (a = n,
                        n = 0),
                        !s[t.id] && (s[t.id] = 1,
                        o.push({
                            el: t,
                            target: e,
                            time: i,
                            delay: n,
                            easing: a
                        }),
                        !0)
                    },
                    done: function(t) {
                        return r = t,
                        this
                    },
                    start: function() {
                        for (var t = o.length, e = 0, i = o.length; e < i; e++) {
                            var n = o[e];
                            n.el.animateTo(n.target, n.time, n.delay, n.easing, a)
                        }
                        return this;
                        function a() {
                            --t || (o.length = 0,
                            s = {},
                            r && r())
                        }
                    }
                }
            }
        }
          , Pw = it.bind
          , kw = Fs.Group
          , Ow = Fs.Rect
          , Rw = it.each
          , Nw = ["label"]
          , Ew = ["emphasis", "label"]
          , zw = ["upperLabel"]
          , Vw = ["emphasis", "upperLabel"]
          , Bw = 10
          , Gw = da([["fill", "color"], ["stroke", "strokeColor"], ["lineWidth", "strokeWidth"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]);
        Gm.extendChartView({
            type: "treemap",
            init: function(t, e) {
                this._containerGroup,
                this._storage = {
                    nodeGroup: [],
                    background: [],
                    content: []
                },
                this._oldTree,
                this._breadcrumb,
                this._controller,
                this._state = "ready"
            },
            render: function(t, e, i, n) {
                var a = e.findComponents({
                    mainType: "series",
                    subType: "treemap",
                    query: n
                });
                if (!(it.indexOf(a, t) < 0)) {
                    this.seriesModel = t,
                    this.api = i,
                    this.ecModel = e;
                    var r = _w.retrieveTargetInfo(n, ["treemapZoomToNode", "treemapRootToNode"], t)
                      , o = n && n.type
                      , s = t.layoutInfo
                      , l = !this._oldTree
                      , u = this._storage
                      , h = "treemapRootToNode" === o && r && u ? {
                        rootNodeGroup: u.nodeGroup[r.node.getRawIndex()],
                        direction: n.direction
                    } : null
                      , c = this._giveContainerGroup(s)
                      , d = this._doRender(c, t, h);
                    l || o && "treemapZoomToNode" !== o && "treemapRootToNode" !== o ? d.renderFinally() : this._doAnimation(c, d, t, h),
                    this._resetController(i),
                    this._renderBreadcrumb(t, i, r)
                }
            },
            _giveContainerGroup: function(t) {
                var e = this._containerGroup;
                return e || (e = this._containerGroup = new kw,
                this._initEvents(e),
                this.group.add(e)),
                e.attr("position", [t.x, t.y]),
                e
            },
            _doRender: function(t, e, i) {
                var n = e.getData().tree
                  , a = this._oldTree
                  , r = {
                    nodeGroup: [],
                    background: [],
                    content: []
                }
                  , o = {
                    nodeGroup: [],
                    background: [],
                    content: []
                }
                  , s = this._storage
                  , l = []
                  , c = it.curry(Fw, e, o, s, i, r, l);
                !function r(o, s, l, u, h) {
                    u ? Rw(s = o, function(t, e) {
                        t.isRemoved() || i(e, e)
                    }) : new wp(s,o,t,t).add(i).update(i).remove(it.curry(i, null)).execute();
                    function t(t) {
                        return t.getId()
                    }
                    function i(t, e) {
                        var i = null != t ? o[t] : null
                          , n = null != e ? s[e] : null
                          , a = c(i, n, l, h);
                        a && r(i && i.viewChildren || [], n && n.viewChildren || [], a, u, h + 1)
                    }
                }(n.root ? [n.root] : [], a && a.root ? [a.root] : [], t, n === a || !a, 0);
                var u, h, d = (h = {
                    nodeGroup: [],
                    background: [],
                    content: []
                },
                (u = s) && Rw(u, function(t, e) {
                    var i = h[e];
                    Rw(t, function(t) {
                        t && (i.push(t),
                        t.__tmWillDelete = 1)
                    })
                }),
                h);
                return this._oldTree = n,
                this._storage = o,
                {
                    lastsForAnimation: r,
                    willDeleteEls: d,
                    renderFinally: function() {
                        Rw(d, function(t) {
                            Rw(t, function(t) {
                                t.parent && t.parent.remove(t)
                            })
                        }),
                        Rw(l, function(t) {
                            t.invisible = !0,
                            t.dirty()
                        })
                    }
                }
            },
            _doAnimation: function(t, r, e, s) {
                if (e.get("animation")) {
                    var l = e.get("animationDurationUpdate")
                      , u = e.get("animationEasing")
                      , h = Lw.createWrap();
                    Rw(r.willDeleteEls, function(t, o) {
                        Rw(t, function(t, e) {
                            if (!t.invisible) {
                                var i, n = t.parent;
                                if (s && "drillDown" === s.direction)
                                    i = n === s.rootNodeGroup ? {
                                        shape: {
                                            x: 0,
                                            y: 0,
                                            width: n.__tmNodeWidth,
                                            height: n.__tmNodeHeight
                                        },
                                        style: {
                                            opacity: 0
                                        }
                                    } : {
                                        style: {
                                            opacity: 0
                                        }
                                    };
                                else {
                                    var a = 0
                                      , r = 0;
                                    n.__tmWillDelete || (a = n.__tmNodeWidth / 2,
                                    r = n.__tmNodeHeight / 2),
                                    i = "nodeGroup" === o ? {
                                        position: [a, r],
                                        style: {
                                            opacity: 0
                                        }
                                    } : {
                                        shape: {
                                            x: a,
                                            y: r,
                                            width: 0,
                                            height: 0
                                        },
                                        style: {
                                            opacity: 0
                                        }
                                    }
                                }
                                i && h.add(t, i, l, u)
                            }
                        })
                    }),
                    Rw(this._storage, function(t, a) {
                        Rw(t, function(t, e) {
                            var i = r.lastsForAnimation[a][e]
                              , n = {};
                            i && ("nodeGroup" === a ? i.old && (n.position = t.position.slice(),
                            t.attr("position", i.old)) : (i.old && (n.shape = it.extend({}, t.shape),
                            t.setShape(i.old)),
                            i.fadein ? (t.setStyle("opacity", 0),
                            n.style = {
                                opacity: 1
                            }) : 1 !== t.style.opacity && (n.style = {
                                opacity: 1
                            })),
                            h.add(t, n, l, u))
                        })
                    }, this),
                    this._state = "animating",
                    h.done(Pw(function() {
                        this._state = "ready",
                        r.renderFinally()
                    }, this)).start()
                }
            },
            _resetController: function(t) {
                var e = this._controller;
                e || ((e = this._controller = new nb(t.getZr())).enable(this.seriesModel.get("roam")),
                e.on("pan", Pw(this._onPan, this)),
                e.on("zoom", Pw(this._onZoom, this)));
                var n = new Oe(0,0,t.getWidth(),t.getHeight());
                e.setPointerChecker(function(t, e, i) {
                    return n.contain(e, i)
                })
            },
            _clearController: function() {
                var t = this._controller;
                t && (t.dispose(),
                t = null)
            },
            _onPan: function(t) {
                if ("animating" !== this._state && (3 < Math.abs(t.dx) || 3 < Math.abs(t.dy))) {
                    var e = this.seriesModel.getData().tree.root;
                    if (!e)
                        return;
                    var i = e.getLayout();
                    if (!i)
                        return;
                    this.api.dispatchAction({
                        type: "treemapMove",
                        from: this.uid,
                        seriesId: this.seriesModel.id,
                        rootRect: {
                            x: i.x + t.dx,
                            y: i.y + t.dy,
                            width: i.width,
                            height: i.height
                        }
                    })
                }
            },
            _onZoom: function(t) {
                var e = t.originX
                  , i = t.originY;
                if ("animating" !== this._state) {
                    var n = this.seriesModel.getData().tree.root;
                    if (!n)
                        return;
                    var a = n.getLayout();
                    if (!a)
                        return;
                    var r = new Oe(a.x,a.y,a.width,a.height)
                      , o = this.seriesModel.layoutInfo;
                    e -= o.x,
                    i -= o.y;
                    var s = ct.create();
                    ct.translate(s, s, [-e, -i]),
                    ct.scale(s, s, [t.scale, t.scale]),
                    ct.translate(s, s, [e, i]),
                    r.applyTransform(s),
                    this.api.dispatchAction({
                        type: "treemapRender",
                        from: this.uid,
                        seriesId: this.seriesModel.id,
                        rootRect: {
                            x: r.x,
                            y: r.y,
                            width: r.width,
                            height: r.height
                        }
                    })
                }
            },
            _initEvents: function(t) {
                t.on("click", function(t) {
                    if ("ready" === this._state) {
                        var e = this.seriesModel.get("nodeClick", !0);
                        if (e) {
                            var i = this.findTarget(t.offsetX, t.offsetY);
                            if (i) {
                                var n = i.node;
                                if (n.getLayout().isLeafRoot)
                                    this._rootToNode(i);
                                else if ("zoomToNode" === e)
                                    this._zoomToNode(i);
                                else if ("link" === e) {
                                    var a = n.hostTree.data.getItemModel(n.dataIndex)
                                      , r = a.get("link", !0)
                                      , o = a.get("target", !0) || "blank";
                                    r && window.open(r, o)
                                }
                            }
                        }
                    }
                }, this)
            },
            _renderBreadcrumb: function(e, t, i) {
                i = i || ((i = null != e.get("leafDepth", !0) ? {
                    node: e.getViewRoot()
                } : this.findTarget(t.getWidth() / 2, t.getHeight() / 2)) || {
                    node: e.getData().tree.root
                }),
                (this._breadcrumb || (this._breadcrumb = new Cw(this.group))).render(e, t, i.node, Pw(function(t) {
                    "animating" !== this._state && (_w.aboveViewRoot(e.getViewRoot(), t) ? this._rootToNode({
                        node: t
                    }) : this._zoomToNode({
                        node: t
                    }))
                }, this))
            },
            remove: function() {
                this._clearController(),
                this._containerGroup && this._containerGroup.removeAll(),
                this._storage = {
                    nodeGroup: [],
                    background: [],
                    content: []
                },
                this._state = "ready",
                this._breadcrumb && this._breadcrumb.remove()
            },
            dispose: function() {
                this._clearController()
            },
            _zoomToNode: function(t) {
                this.api.dispatchAction({
                    type: "treemapZoomToNode",
                    from: this.uid,
                    seriesId: this.seriesModel.id,
                    targetNode: t.node
                })
            },
            _rootToNode: function(t) {
                this.api.dispatchAction({
                    type: "treemapRootToNode",
                    from: this.uid,
                    seriesId: this.seriesModel.id,
                    targetNode: t.node
                })
            },
            findTarget: function(a, r) {
                var o;
                return this.seriesModel.getViewRoot().eachNode({
                    attr: "viewChildren",
                    order: "preorder"
                }, function(t) {
                    var e = this._storage.background[t.getRawIndex()];
                    if (e) {
                        var i = e.transformCoordToLocal(a, r)
                          , n = e.shape;
                        if (!(n.x <= i[0] && i[0] <= n.x + n.width && n.y <= i[1] && i[1] <= n.y + n.height))
                            return !1;
                        o = {
                            node: t,
                            offsetX: i[0],
                            offsetY: i[1]
                        }
                    }
                }, this),
                o
            }
        });
        function Fw(d, o, s, l, u, i, p, t, e, n) {
            if (p) {
                var f = p.getLayout();
                if (f && f.isInView) {
                    var h = f.width
                      , c = f.height
                      , g = f.borderWidth
                      , m = f.invisible
                      , v = p.getRawIndex()
                      , y = t && t.getRawIndex()
                      , a = p.viewChildren
                      , x = f.upperHeight
                      , r = a && a.length
                      , _ = p.getModel("itemStyle")
                      , b = p.getModel("emphasis.itemStyle")
                      , w = T("nodeGroup", kw);
                    if (w) {
                        if (e.add(w),
                        w.attr("position", [f.x || 0, f.y || 0]),
                        w.__tmNodeWidth = h,
                        w.__tmNodeHeight = c,
                        f.isAboveViewRoot)
                            return w;
                        var S = T("background", Ow, n, 1);
                        if (S && function(t, n, a) {
                            n.dataIndex = p.dataIndex,
                            n.seriesIndex = d.seriesIndex,
                            n.setShape({
                                x: 0,
                                y: 0,
                                width: h,
                                height: c
                            });
                            var r = p.getVisual("borderColor", !0)
                              , o = b.get("borderColor");
                            I(n, function() {
                                var t = Dw(_);
                                t.fill = r;
                                var e = Gw(b);
                                if (e.fill = o,
                                a) {
                                    var i = h - 2 * g;
                                    A(t, e, r, i, x, {
                                        x: g,
                                        y: 0,
                                        width: i,
                                        height: x
                                    })
                                } else
                                    t.text = e.text = null;
                                n.setStyle(t),
                                Fs.setHoverStyle(n, e)
                            }),
                            t.add(n)
                        }(w, S, r && f.upperHeight),
                        !r) {
                            var M = T("content", Ow, n, 2);
                            M && function(t, i) {
                                i.dataIndex = p.dataIndex,
                                i.seriesIndex = d.seriesIndex;
                                var n = Math.max(h - 2 * g, 0)
                                  , a = Math.max(c - 2 * g, 0);
                                i.culling = !0,
                                i.setShape({
                                    x: g,
                                    y: g,
                                    width: n,
                                    height: a
                                });
                                var r = p.getVisual("color", !0);
                                I(i, function() {
                                    var t = Dw(_);
                                    t.fill = r;
                                    var e = Gw(b);
                                    A(t, e, r, n, a),
                                    i.setStyle(t),
                                    Fs.setHoverStyle(i, e)
                                }),
                                t.add(i)
                            }(w, M)
                        }
                        return w
                    }
                }
            }
            function I(t, e) {
                m ? t.invisible || i.push(t) : (e(),
                t.__tmWillVisible || (t.invisible = !1))
            }
            function A(t, e, i, n, a, r) {
                var o = p.getModel()
                  , s = it.retrieve(d.getFormattedLabel(p.dataIndex, "normal", null, null, r ? "upperLabel" : "label"), o.get("name"));
                if (!r && f.isLeafRoot) {
                    var l = d.get("drillDownIcon", !0);
                    s = l ? l + " " + s : s
                }
                var u = o.getModel(r ? zw : Nw)
                  , h = o.getModel(r ? Vw : Ew)
                  , c = u.getShallow("show");
                Fs.setLabelStyle(t, e, u, h, {
                    defaultText: c ? s : null,
                    autoColor: i,
                    isRectText: !0
                }),
                r && (t.textRect = it.clone(r)),
                t.truncate = c && u.get("ellipsis") ? {
                    outerWidth: n,
                    outerHeight: a,
                    minChar: 2
                } : null
            }
            function T(t, e, i, n) {
                var a = null != y && s[t][y]
                  , r = u[t];
                return a ? (s[t][y] = null,
                function(t, e, i) {
                    (t[v] = {}).old = "nodeGroup" === i ? e.position.slice() : it.extend({}, e.shape)
                }(r, a, t)) : m || ((a = new e({
                    z: function(t, e) {
                        var i = t * Bw + e;
                        return (i - 1) / i
                    }(i, n)
                })).__tmDepth = i,
                function(t, e, i) {
                    var n = t[v] = {}
                      , a = p.parentNode;
                    if (a && (!l || "drillDown" === l.direction)) {
                        var r = 0
                          , o = 0
                          , s = u.background[a.getRawIndex()];
                        !l && s && s.old && (r = s.old.width,
                        o = s.old.height),
                        n.old = "nodeGroup" === i ? [0, o] : {
                            x: r,
                            y: o,
                            width: 0,
                            height: 0
                        }
                    }
                    n.fadein = "nodeGroup" !== i
                }(r, 0, a.__tmStorageName = t)),
                o[t][v] = a
            }
        }
        for (var Hw = function() {}, Ww = ["treemapZoomToNode", "treemapRender", "treemapMove"], Zw = 0; Zw < Ww.length; Zw++)
            Gm.registerAction({
                type: Ww[Zw],
                update: "updateView"
            }, Hw);
        Gm.registerAction({
            type: "treemapRootToNode",
            update: "updateView"
        }, function(a, t) {
            t.eachComponent({
                mainType: "series",
                subType: "treemap",
                query: a
            }, function(t, e) {
                var i = _w.retrieveTargetInfo(a, ["treemapZoomToNode", "treemapRootToNode"], t);
                if (i) {
                    var n = t.getViewRoot();
                    n && (a.direction = _w.aboveViewRoot(n, i.node) ? "rollUp" : "drillDown"),
                    t.resetViewRoot(i.node)
                }
            })
        });
        var Uw = ol.linearMap
          , Yw = it.each
          , jw = it.isObject
          , Xw = -1
          , qw = function(t) {
            var e = t.mappingMethod
              , i = t.type
              , n = this.option = it.clone(t);
            this.type = i,
            this.mappingMethod = e,
            this._normalizeData = oS[e];
            var a = Kw[i];
            this.applyVisual = a.applyVisual,
            this.getColorMapper = a.getColorMapper,
            this._doMap = a._doMap[e],
            "piecewise" === e ? ($w(n),
            function(i) {
                var t = i.pieceList;
                i.hasSpecialVisual = !1,
                it.each(t, function(t, e) {
                    t.originIndex = e,
                    null != t.visual && (i.hasSpecialVisual = !0)
                })
            }(n)) : "category" === e ? n.categories ? function(t) {
                var e = t.categories
                  , i = t.visual
                  , n = t.categoryMap = {};
                if (Yw(e, function(t, e) {
                    n[t] = e
                }),
                !it.isArray(i)) {
                    var a = [];
                    it.isObject(i) ? Yw(i, function(t, e) {
                        var i = n[e];
                        a[null != i ? i : Xw] = t
                    }) : a[Xw] = i,
                    i = rS(t, a)
                }
                for (var r = e.length - 1; 0 <= r; r--)
                    null == i[r] && (delete n[e[r]],
                    e.pop())
            }(n) : $w(n, !0) : (it.assert("linear" !== e || n.dataExtent),
            $w(n))
        };
        qw.prototype = {
            constructor: qw,
            mapValueToVisual: function(t) {
                var e = this._normalizeData(t);
                return this._doMap(e, t)
            },
            getNormalizer: function() {
                return it.bind(this._normalizeData, this)
            }
        };
        var Kw = qw.visualHandlers = {
            color: {
                applyVisual: tS("color"),
                getColorMapper: function() {
                    var a = this.option;
                    return it.bind("category" === a.mappingMethod ? function(t, e) {
                        return e || (t = this._normalizeData(t)),
                        eS.call(this, t)
                    }
                    : function(t, e, i) {
                        var n = !!i;
                        return e || (t = this._normalizeData(t)),
                        i = jt.fastLerp(t, a.parsedVisual, i),
                        n ? i : jt.stringify(i, "rgba")
                    }
                    , this)
                },
                _doMap: {
                    linear: function(t) {
                        return jt.stringify(jt.fastLerp(t, this.option.parsedVisual), "rgba")
                    },
                    category: eS,
                    piecewise: function(t, e) {
                        var i = aS.call(this, e);
                        return null == i && (i = jt.stringify(jt.fastLerp(t, this.option.parsedVisual), "rgba")),
                        i
                    },
                    fixed: iS
                }
            },
            colorHue: Jw(function(t, e) {
                return jt.modifyHSL(t, e)
            }),
            colorSaturation: Jw(function(t, e) {
                return jt.modifyHSL(t, null, e)
            }),
            colorLightness: Jw(function(t, e) {
                return jt.modifyHSL(t, null, null, e)
            }),
            colorAlpha: Jw(function(t, e) {
                return jt.modifyAlpha(t, e)
            }),
            opacity: {
                applyVisual: tS("opacity"),
                _doMap: nS([0, 1])
            },
            liftZ: {
                applyVisual: tS("liftZ"),
                _doMap: {
                    linear: iS,
                    category: iS,
                    piecewise: iS,
                    fixed: iS
                }
            },
            symbol: {
                applyVisual: function(t, e, i) {
                    var n = this.mapValueToVisual(t);
                    if (it.isString(n))
                        i("symbol", n);
                    else if (jw(n))
                        for (var a in n)
                            n.hasOwnProperty(a) && i(a, n[a])
                },
                _doMap: {
                    linear: Qw,
                    category: eS,
                    piecewise: function(t, e) {
                        var i = aS.call(this, e);
                        return null == i && (i = Qw.call(this, t)),
                        i
                    },
                    fixed: iS
                }
            },
            symbolSize: {
                applyVisual: tS("symbolSize"),
                _doMap: nS([0, 1])
            }
        };
        function $w(t, e) {
            var i = t.visual
              , n = [];
            it.isObject(i) ? Yw(i, function(t) {
                n.push(t)
            }) : null != i && n.push(i);
            e || 1 !== n.length || {
                color: 1,
                symbol: 1
            }.hasOwnProperty(t.type) || (n[1] = n[0]),
            rS(t, n)
        }
        function Jw(n) {
            return {
                applyVisual: function(t, e, i) {
                    t = this.mapValueToVisual(t),
                    i("color", n(e("color"), t))
                },
                _doMap: nS([0, 1])
            }
        }
        function Qw(t) {
            var e = this.option.visual;
            return e[Math.round(Uw(t, [0, 1], [0, e.length - 1], !0))] || {}
        }
        function tS(n) {
            return function(t, e, i) {
                i(n, this.mapValueToVisual(t))
            }
        }
        function eS(t) {
            var e = this.option.visual;
            return e[this.option.loop && t !== Xw ? t % e.length : t]
        }
        function iS() {
            return this.option.visual[0]
        }
        function nS(n) {
            return {
                linear: function(t) {
                    return Uw(t, n, this.option.visual, !0)
                },
                category: eS,
                piecewise: function(t, e) {
                    var i = aS.call(this, e);
                    return null == i && (i = Uw(t, n, this.option.visual, !0)),
                    i
                },
                fixed: iS
            }
        }
        function aS(t) {
            var e = this.option
              , i = e.pieceList;
            if (e.hasSpecialVisual) {
                var n = i[qw.findPieceIndex(t, i)];
                if (n && n.visual)
                    return n.visual[this.type]
            }
        }
        function rS(t, e) {
            return t.visual = e,
            "color" === t.type && (t.parsedVisual = it.map(e, function(t) {
                return jt.parse(t)
            })),
            e
        }
        var oS = {
            linear: function(t) {
                return Uw(t, this.option.dataExtent, [0, 1], !0)
            },
            piecewise: function(t) {
                var e = this.option.pieceList
                  , i = qw.findPieceIndex(t, e, !0);
                if (null != i)
                    return Uw(i, [0, e.length - 1], [0, 1], !0)
            },
            category: function(t) {
                var e = this.option.categories ? this.option.categoryMap[t] : t;
                return null == e ? Xw : e
            },
            fixed: it.noop
        };
        function sS(t, e, i) {
            return t ? e <= i : e < i
        }
        qw.listVisualTypes = function() {
            var i = [];
            return it.each(Kw, function(t, e) {
                i.push(e)
            }),
            i
        }
        ,
        qw.addVisualHandler = function(t, e) {
            Kw[t] = e
        }
        ,
        qw.isValidType = function(t) {
            return Kw.hasOwnProperty(t)
        }
        ,
        qw.eachVisual = function(t, e, i) {
            it.isObject(t) ? it.each(t, e, i) : e.call(i, t)
        }
        ,
        qw.mapVisual = function(t, n, a) {
            var r, o = it.isArray(t) ? [] : it.isObject(t) ? {} : (r = !0,
            null);
            return qw.eachVisual(t, function(t, e) {
                var i = n.call(a, t, e);
                r ? o = i : o[e] = i
            }),
            o
        }
        ,
        qw.retrieveVisuals = function(i) {
            var n, a = {};
            return i && Yw(Kw, function(t, e) {
                i.hasOwnProperty(e) && (a[e] = i[e],
                n = !0)
            }),
            n ? a : null
        }
        ,
        qw.prepareVisualTypes = function(t) {
            if (jw(t)) {
                var i = [];
                Yw(t, function(t, e) {
                    i.push(e)
                }),
                t = i
            } else {
                if (!it.isArray(t))
                    return [];
                t = t.slice()
            }
            return t.sort(function(t, e) {
                return "color" === e && "color" !== t && 0 === t.indexOf("color") ? 1 : -1
            }),
            t
        }
        ,
        qw.dependsOn = function(t, e) {
            return "color" === e ? !(!t || 0 !== t.indexOf(e)) : t === e
        }
        ,
        qw.findPieceIndex = function(n, t, e) {
            for (var a, r = 1 / 0, i = 0, o = t.length; i < o; i++) {
                var s = t[i].value;
                if (null != s) {
                    if (s === n || "string" == typeof s && s === n + "")
                        return i;
                    e && c(s, i)
                }
            }
            for (i = 0,
            o = t.length; i < o; i++) {
                var l = t[i]
                  , u = l.interval
                  , h = l.close;
                if (u) {
                    if (u[0] === -1 / 0) {
                        if (sS(h[1], n, u[1]))
                            return i
                    } else if (u[1] === 1 / 0) {
                        if (sS(h[0], u[0], n))
                            return i
                    } else if (sS(h[0], u[0], n) && sS(h[1], n, u[1]))
                        return i;
                    e && c(u[0], i),
                    e && c(u[1], i)
                }
            }
            if (e)
                return n === 1 / 0 ? t.length - 1 : n === -1 / 0 ? 0 : a;
            function c(t, e) {
                var i = Math.abs(t - n);
                i < r && (r = i,
                a = e)
            }
        }
        ;
        var lS = qw
          , uS = it.isArray
          , hS = "itemStyle";
        function cS(i, n, a, r) {
            var o = it.extend({}, n);
            return it.each(["color", "colorAlpha", "colorSaturation"], function(t) {
                var e = i.get(t, !0);
                null == e && a && (e = a[t]),
                null == e && (e = n[t]),
                null == e && (e = r.get(t)),
                null != e && (o[t] = e)
            }),
            o
        }
        function dS(t) {
            var e = pS(t, "color");
            if (e) {
                var i = pS(t, "colorAlpha")
                  , n = pS(t, "colorSaturation");
                return n && (e = jt.modifyHSL(e, null, null, n)),
                i && (e = jt.modifyAlpha(e, i)),
                e
            }
        }
        function pS(t, e) {
            var i = t[e];
            if (null != i && "none" !== i)
                return i
        }
        function fS(t, e, i, n, a, r) {
            if (r && r.length) {
                var o = gS(e, "color") || null != a.color && "none" !== a.color && (gS(e, "colorAlpha") || gS(e, "colorSaturation"));
                if (o) {
                    var s = e.get("visualMin")
                      , l = e.get("visualMax")
                      , u = i.dataExtent.slice();
                    null != s && s < u[0] && (u[0] = s),
                    null != l && l > u[1] && (u[1] = l);
                    var h = e.get("colorMappingBy")
                      , c = {
                        type: o.name,
                        dataExtent: u,
                        visual: o.range
                    };
                    "color" !== c.type || "index" !== h && "id" !== h ? c.mappingMethod = "linear" : (c.mappingMethod = "category",
                    c.loop = !0);
                    var d = new lS(c);
                    return d.__drColorMappingBy = h,
                    d
                }
            }
        }
        function gS(t, e) {
            var i = t.get(e);
            return uS(i) && i.length ? {
                name: e,
                range: i
            } : null
        }
        function mS(t, e, i, n, a, r) {
            var o = it.extend({}, e);
            if (a) {
                var s = a.type
                  , l = "color" === s && a.__drColorMappingBy
                  , u = "index" === l ? n : "id" === l ? r.mapIdToIndex(i.getId()) : i.getValue(t.get("visualDimension"));
                o[s] = a.mapValueToVisual(u)
            }
            return o
        }
        var vS = {
            seriesType: "treemap",
            reset: function(t, e, i, n) {
                var a = t.getData().tree
                  , r = a.root
                  , o = t.getModel(hS);
                r.isRemoved() || !function n(t, e, a, r, o, s) {
                    var l = t.getModel();
                    var i = t.getLayout();
                    if (!i || i.invisible || !i.isInView)
                        return;
                    var u = t.getModel(hS);
                    var h = a[t.depth];
                    var c = cS(u, e, h, r);
                    var d = u.get("borderColor");
                    var p = u.get("borderColorSaturation");
                    var f;
                    null != p && (f = dS(c),
                    g = p,
                    d = null != (m = f) ? jt.modifyHSL(m, null, null, g) : null);
                    var g, m;
                    t.setVisual("borderColor", d);
                    var v = t.viewChildren;
                    if (v && v.length) {
                        var y = fS(t, l, i, u, c, v);
                        it.each(v, function(t, e) {
                            if (t.depth >= o.length || t === o[t.depth]) {
                                var i = mS(l, c, t, e, y, s);
                                n(t, i, a, r, o, s)
                            }
                        })
                    } else
                        f = dS(c),
                        t.setVisual("color", f)
                }(r, {}, it.map(a.levelModels, function(t) {
                    return t ? t.get(hS) : null
                }), o, t.getViewRoot().getAncestors(), t)
            }
        }
          , yS = ol.parsePercent
          , xS = ol.MAX_SAFE_INTEGER
          , _S = Math.max
          , bS = Math.min
          , wS = it.retrieve
          , SS = it.each
          , MS = ["itemStyle", "borderWidth"]
          , IS = ["itemStyle", "gapWidth"]
          , AS = ["upperLabel", "show"]
          , TS = ["upperLabel", "height"];
        function CS(t, e, i, n, a, r) {
            var o = t.children || []
              , s = n.sort;
            "asc" !== s && "desc" !== s && (s = null);
            var l = null != n.leafDepth && n.leafDepth <= r;
            if (a && !l)
                return t.viewChildren = [];
            !function(t, n) {
                n && t.sort(function(t, e) {
                    var i = "asc" === n ? t.getValue() - e.getValue() : e.getValue() - t.getValue();
                    return 0 == i ? "asc" === n ? t.dataIndex - e.dataIndex : e.dataIndex - t.dataIndex : i
                })
            }(o = it.filter(o, function(t) {
                return !t.isRemoved()
            }), s);
            var u = function(t, e, i) {
                for (var n = 0, a = 0, r = e.length; a < r; a++)
                    n += e[a].getValue();
                var o = t.get("visualDimension");
                if (e && e.length)
                    if ("value" === o && i)
                        s = [e[e.length - 1].getValue(), e[0].getValue()],
                        "asc" === i && s.reverse();
                    else {
                        var s = [1 / 0, -1 / 0];
                        SS(e, function(t) {
                            var e = t.getValue(o);
                            e < s[0] && (s[0] = e),
                            e > s[1] && (s[1] = e)
                        })
                    }
                else
                    s = [NaN, NaN];
                return {
                    sum: n,
                    dataExtent: s
                }
            }(e, o, s);
            if (0 === u.sum)
                return t.viewChildren = [];
            if (u.sum = function(t, e, i, n, a) {
                if (!n)
                    return i;
                for (var r = t.get("visibleMin"), o = a.length, s = o, l = o - 1; 0 <= l; l--) {
                    var u = a["asc" === n ? o - l - 1 : l].getValue();
                    u / i * e < r && (s = l,
                    i -= u)
                }
                return "asc" === n ? a.splice(0, o - s) : a.splice(s, o - s),
                i
            }(e, i, u.sum, s, o),
            0 === u.sum)
                return t.viewChildren = [];
            for (var h = 0, c = o.length; h < c; h++) {
                var d = o[h].getValue() / u.sum * i;
                o[h].setLayout({
                    area: d
                })
            }
            return l && (o.length && t.setLayout({
                isLeafRoot: !0
            }, !0),
            o.length = 0),
            t.viewChildren = o,
            t.setLayout({
                dataExtent: u.dataExtent
            }, !0),
            o
        }
        function DS(t, e, i) {
            for (var n, a = 0, r = 1 / 0, o = 0, s = t.length; o < s; o++)
                (n = t[o].getLayout().area) && (n < r && (r = n),
                a < n && (a = n));
            var l = t.area * t.area
              , u = e * e * i;
            return l ? _S(u * a / l, l / (u * r)) : 1 / 0
        }
        function LS(t, e, i, n, a) {
            var r = e === i.width ? 0 : 1
              , o = 1 - r
              , s = ["x", "y"]
              , l = ["width", "height"]
              , u = i[s[r]]
              , h = e ? t.area / e : 0;
            (a || h > i[l[o]]) && (h = i[l[o]]);
            for (var c = 0, d = t.length; c < d; c++) {
                var p = t[c]
                  , f = {}
                  , g = h ? p.getLayout().area / h : 0
                  , m = f[l[o]] = _S(h - 2 * n, 0)
                  , v = i[s[r]] + i[l[r]] - u
                  , y = c === d - 1 || v < g ? v : g
                  , x = f[l[r]] = _S(y - 2 * n, 0);
                f[s[o]] = i[s[o]] + bS(n, m / 2),
                f[s[r]] = u + bS(n, x / 2),
                u += y,
                p.setLayout(f, !0)
            }
            i[s[o]] += h,
            i[l[o]] -= h
        }
        function PS(t) {
            return t.get(AS) ? t.get(TS) : 0
        }
        var kS = {
            seriesType: "treemap",
            reset: function(t, e, i, n) {
                var a = i.getWidth()
                  , r = i.getHeight()
                  , o = t.option
                  , s = Il.getLayoutRect(t.getBoxLayoutParams(), {
                    width: i.getWidth(),
                    height: i.getHeight()
                })
                  , l = o.size || []
                  , u = yS(wS(s.width, l[0]), a)
                  , h = yS(wS(s.height, l[1]), r)
                  , c = n && n.type
                  , d = _w.retrieveTargetInfo(n, ["treemapZoomToNode", "treemapRootToNode"], t)
                  , p = "treemapRender" === c || "treemapMove" === c ? n.rootRect : null
                  , f = t.getViewRoot()
                  , g = _w.getPathToRoot(f);
                if ("treemapMove" !== c) {
                    var m = "treemapZoomToNode" === c ? function(t, e, i, n, a) {
                        var r, o = (e || {}).node, s = [n, a];
                        if (!o || o === i)
                            return s;
                        var l = n * a
                          , u = l * t.option.zoomToNodeRatio;
                        for (; r = o.parentNode; ) {
                            for (var h = 0, c = r.children, d = 0, p = c.length; d < p; d++)
                                h += c[d].getValue();
                            var f = o.getValue();
                            if (0 === f)
                                return s;
                            u *= h / f;
                            var g = r.getModel()
                              , m = g.get(MS)
                              , v = Math.max(m, PS(g));
                            u += 4 * m * m + (3 * m + v) * Math.pow(u, .5),
                            xS < u && (u = xS),
                            o = r
                        }
                        u < l && (u = l);
                        var y = Math.pow(u / l, .5);
                        return [n * y, a * y]
                    }(t, d, f, u, h) : p ? [p.width, p.height] : [u, h]
                      , v = o.sort;
                    v && "asc" !== v && "desc" !== v && (v = "desc");
                    var y = {
                        squareRatio: o.squareRatio,
                        sort: v,
                        leafDepth: o.leafDepth
                    };
                    f.hostTree.clearLayouts();
                    var x = {
                        x: 0,
                        y: 0,
                        width: m[0],
                        height: m[1],
                        area: m[0] * m[1]
                    };
                    f.setLayout(x),
                    function t(e, i, n, a) {
                        var r;
                        var o;
                        if (e.isRemoved())
                            return;
                        var s = e.getLayout();
                        r = s.width;
                        o = s.height;
                        var l = e.getModel();
                        var u = l.get(MS);
                        var h = l.get(IS) / 2;
                        var c = PS(l);
                        var d = Math.max(u, c);
                        var p = u - h;
                        var f = d - h;
                        var l = e.getModel();
                        e.setLayout({
                            borderWidth: u,
                            upperHeight: d,
                            upperLabelHeight: c
                        }, !0);
                        r = _S(r - 2 * p, 0);
                        o = _S(o - p - f, 0);
                        var g = r * o;
                        var m = CS(e, l, g, i, n, a);
                        if (!m.length)
                            return;
                        var v = {
                            x: p,
                            y: f,
                            width: r,
                            height: o
                        };
                        var y = bS(r, o);
                        var x = 1 / 0;
                        var _ = [];
                        _.area = 0;
                        for (var b = 0, w = m.length; b < w; ) {
                            var S = m[b];
                            _.push(S),
                            _.area += S.getLayout().area;
                            var M = DS(_, y, i.squareRatio);
                            x = M <= x ? (b++,
                            M) : (_.area -= _.pop().getLayout().area,
                            LS(_, y, v, h, !1),
                            y = bS(v.width, v.height),
                            _.length = _.area = 0,
                            1 / 0)
                        }
                        _.length && LS(_, y, v, h, !0);
                        if (!n) {
                            var I = l.get("childrenVisibleMin");
                            null != I && g < I && (n = !0)
                        }
                        for (var b = 0, w = m.length; b < w; b++)
                            t(m[b], i, n, a + 1)
                    }(f, y, !1, 0);
                    x = f.getLayout();
                    SS(g, function(t, e) {
                        var i = (g[e + 1] || f).getValue();
                        t.setLayout(it.extend({
                            dataExtent: [i, i],
                            borderWidth: 0,
                            upperHeight: 0
                        }, x))
                    })
                }
                var _ = t.getData().tree.root;
                _.setLayout(function(t, e, i) {
                    if (e)
                        return {
                            x: e.x,
                            y: e.y
                        };
                    var n = {
                        x: 0,
                        y: 0
                    };
                    if (!i)
                        return n;
                    var a = i.node
                      , r = a.getLayout();
                    if (!r)
                        return n;
                    var o = [r.width / 2, r.height / 2]
                      , s = a;
                    for (; s; ) {
                        var l = s.getLayout();
                        o[0] += l.x,
                        o[1] += l.y,
                        s = s.parentNode
                    }
                    return {
                        x: t.width / 2 - o[0],
                        y: t.height / 2 - o[1]
                    }
                }(s, p, d), !0),
                t.setLayoutInfo(s),
                function e(t, i, n, a, r) {
                    var o = t.getLayout();
                    var s = n[r];
                    var l = s && s === t;
                    if (s && !l || r === n.length && t !== a)
                        return;
                    t.setLayout({
                        isInView: !0,
                        invisible: !l && !i.intersect(o),
                        isAboveViewRoot: l
                    }, !0);
                    var u = new Oe(i.x - o.x,i.y - o.y,i.width,i.height);
                    SS(t.viewChildren || [], function(t) {
                        e(t, u, n, a, r + 1)
                    })
                }(_, new Oe(-s.x,-s.y,a,r), g, f, 0)
            }
        };
        Gm.registerVisual(vS),
        Gm.registerLayout(kS);
        var OS = ca.enableClassCheck;
        function RS(t) {
            return "_EC_" + t
        }
        function NS(t) {
            this._directed = t || !1,
            this.nodes = [],
            this.edges = [],
            this._nodesMap = {},
            this._edgesMap = {},
            this.data,
            this.edgeData
        }
        var ES = NS.prototype;
        function zS(t, e) {
            this.id = null == t ? "" : t,
            this.inEdges = [],
            this.outEdges = [],
            this.edges = [],
            this.hostGraph,
            this.dataIndex = null == e ? -1 : e
        }
        function VS(t, e, i) {
            this.node1 = t,
            this.node2 = e,
            this.dataIndex = null == i ? -1 : i
        }
        ES.type = "graph",
        ES.isDirected = function() {
            return this._directed
        }
        ,
        ES.addNode = function(t, e) {
            t = t || "" + e;
            var i = this._nodesMap;
            if (!i[RS(t)]) {
                var n = new zS(t,e);
                return (n.hostGraph = this).nodes.push(n),
                i[RS(t)] = n
            }
        }
        ,
        ES.getNodeByIndex = function(t) {
            var e = this.data.getRawIndex(t);
            return this.nodes[e]
        }
        ,
        ES.getNodeById = function(t) {
            return this._nodesMap[RS(t)]
        }
        ,
        ES.addEdge = function(t, e, i) {
            var n = this._nodesMap
              , a = this._edgesMap;
            if ("number" == typeof t && (t = this.nodes[t]),
            "number" == typeof e && (e = this.nodes[e]),
            zS.isInstance(t) || (t = n[RS(t)]),
            zS.isInstance(e) || (e = n[RS(e)]),
            t && e) {
                var r = t.id + "-" + e.id;
                if (!a[r]) {
                    var o = new VS(t,e,i);
                    return (o.hostGraph = this)._directed && (t.outEdges.push(o),
                    e.inEdges.push(o)),
                    t.edges.push(o),
                    t !== e && e.edges.push(o),
                    this.edges.push(o),
                    a[r] = o
                }
            }
        }
        ,
        ES.getEdgeByIndex = function(t) {
            var e = this.edgeData.getRawIndex(t);
            return this.edges[e]
        }
        ,
        ES.getEdge = function(t, e) {
            zS.isInstance(t) && (t = t.id),
            zS.isInstance(e) && (e = e.id);
            var i = this._edgesMap;
            return this._directed ? i[t + "-" + e] : i[t + "-" + e] || i[e + "-" + t]
        }
        ,
        ES.eachNode = function(t, e) {
            for (var i = this.nodes, n = i.length, a = 0; a < n; a++)
                0 <= i[a].dataIndex && t.call(e, i[a], a)
        }
        ,
        ES.eachEdge = function(t, e) {
            for (var i = this.edges, n = i.length, a = 0; a < n; a++)
                0 <= i[a].dataIndex && 0 <= i[a].node1.dataIndex && 0 <= i[a].node2.dataIndex && t.call(e, i[a], a)
        }
        ,
        ES.breadthFirstTraverse = function(t, e, i, n) {
            if (zS.isInstance(e) || (e = this._nodesMap[RS(e)]),
            e) {
                for (var a = "out" === i ? "outEdges" : "in" === i ? "inEdges" : "edges", r = 0; r < this.nodes.length; r++)
                    this.nodes[r].__visited = !1;
                if (!t.call(n, e, null))
                    for (var o = [e]; o.length; ) {
                        var s = o.shift()
                          , l = s[a];
                        for (r = 0; r < l.length; r++) {
                            var u = l[r]
                              , h = u.node1 === s ? u.node2 : u.node1;
                            if (!h.__visited) {
                                if (t.call(n, h, s))
                                    return;
                                o.push(h),
                                h.__visited = !0
                            }
                        }
                    }
            }
        }
        ,
        ES.update = function() {
            for (var t = this.data, i = this.edgeData, e = this.nodes, n = this.edges, a = 0, r = e.length; a < r; a++)
                e[a].dataIndex = -1;
            for (a = 0,
            r = t.count(); a < r; a++)
                e[t.getRawIndex(a)].dataIndex = a;
            i.filterSelf(function(t) {
                var e = n[i.getRawIndex(t)];
                return 0 <= e.node1.dataIndex && 0 <= e.node2.dataIndex
            });
            for (a = 0,
            r = n.length; a < r; a++)
                n[a].dataIndex = -1;
            for (a = 0,
            r = i.count(); a < r; a++)
                n[i.getRawIndex(a)].dataIndex = a
        }
        ,
        ES.clone = function() {
            for (var t = new NS(this._directed), e = this.nodes, i = this.edges, n = 0; n < e.length; n++)
                t.addNode(e[n].id, e[n].dataIndex);
            for (n = 0; n < i.length; n++) {
                var a = i[n];
                t.addEdge(a.node1.id, a.node2.id, a.dataIndex)
            }
            return t
        }
        ,
        zS.prototype = {
            constructor: zS,
            degree: function() {
                return this.edges.length
            },
            inDegree: function() {
                return this.inEdges.length
            },
            outDegree: function() {
                return this.outEdges.length
            },
            getModel: function(t) {
                if (!(this.dataIndex < 0))
                    return this.hostGraph.data.getItemModel(this.dataIndex).getModel(t)
            }
        },
        VS.prototype.getModel = function(t) {
            if (!(this.dataIndex < 0))
                return this.hostGraph.edgeData.getItemModel(this.dataIndex).getModel(t)
        }
        ;
        function BS(i, n) {
            return {
                getValue: function(t) {
                    var e = this[i][n];
                    return e.get(e.getDimension(t || "value"), this.dataIndex)
                },
                setVisual: function(t, e) {
                    0 <= this.dataIndex && this[i][n].setItemVisual(this.dataIndex, t, e)
                },
                getVisual: function(t, e) {
                    return this[i][n].getItemVisual(this.dataIndex, t, e)
                },
                setLayout: function(t, e) {
                    0 <= this.dataIndex && this[i][n].setItemLayout(this.dataIndex, t, e)
                },
                getLayout: function() {
                    return this[i][n].getItemLayout(this.dataIndex)
                },
                getGraphicEl: function() {
                    return this[i][n].getItemGraphicEl(this.dataIndex)
                },
                getRawIndex: function() {
                    return this[i][n].getRawIndex(this.dataIndex)
                }
            }
        }
        it.mixin(zS, BS("hostGraph", "data")),
        it.mixin(VS, BS("hostGraph", "edgeData")),
        NS.Node = zS,
        NS.Edge = VS,
        OS(zS),
        OS(VS);
        var GS = NS;
        var FS = function(t, e, i, n, a) {
            for (var r = new GS(n), o = 0; o < t.length; o++)
                r.addNode(it.retrieve(t[o].id, t[o].name, o), o);
            var s = []
              , l = []
              , u = 0;
            for (o = 0; o < e.length; o++) {
                var h = e[o]
                  , c = h.source
                  , d = h.target;
                r.addEdge(c, d, u) && (l.push(h),
                s.push(it.retrieve(h.id, c + " > " + d)),
                u++)
            }
            var p, f = i.get("coordinateSystem");
            if ("cartesian2d" === f || "polar" === f)
                p = Sf(t, i);
            else {
                var g = ju.get(f)
                  , m = g && "view" !== g.type && g.dimensions || [];
                it.indexOf(m, "value") < 0 && m.concat(["value"]);
                var v = pf(t, {
                    coordDimensions: m
                });
                (p = new Qp(v,i)).initData(t)
            }
            var y = new Qp(["value"],i);
            return y.initData(l, s),
            a && a(p, y),
            Ub({
                mainData: p,
                struct: r,
                structAttr: "graph",
                datas: {
                    node: p,
                    edge: y
                },
                datasAttr: {
                    node: "data",
                    edge: "edgeData"
                }
            }),
            r.update(),
            r
        }
          , HS = aa.defaultEmphasis
          , WS = fl.encodeHTML
          , ZS = Gm.extendSeriesModel({
            type: "series.graph",
            init: function(t) {
                ZS.superApply(this, "init", arguments),
                this.legendDataProvider = function() {
                    return this._categoriesData
                }
                ,
                this.fillDataTextStyle(t.edges || t.links),
                this._updateCategoriesData()
            },
            mergeOption: function(t) {
                ZS.superApply(this, "mergeOption", arguments),
                this.fillDataTextStyle(t.edges || t.links),
                this._updateCategoriesData()
            },
            mergeDefaultAndTheme: function(t) {
                ZS.superApply(this, "mergeDefaultAndTheme", arguments),
                HS(t, ["edgeLabel"], ["show"])
            },
            getInitialData: function(t, s) {
                var e = t.edges || t.links || []
                  , i = t.data || t.nodes || []
                  , l = this;
                if (i && e)
                    return FS(i, e, this, !0, function(t, e) {
                        t.wrapMethod("getItemModel", function(t) {
                            var e = l._categoriesModels[t.getShallow("category")];
                            return e && (e.parentModel = t.parentModel,
                            t.parentModel = e),
                            t
                        });
                        var i = l.getModel("edgeLabel")
                          , n = new tl({
                            label: i.option
                        },i.parentModel,s)
                          , a = l.getModel("emphasis.edgeLabel")
                          , r = new tl({
                            emphasis: {
                                label: a.option
                            }
                        },a.parentModel,s);
                        function o(t) {
                            return (t = this.parsePath(t)) && "label" === t[0] ? n : t && "emphasis" === t[0] && "label" === t[1] ? r : this.parentModel
                        }
                        e.wrapMethod("getItemModel", function(t) {
                            return t.customizeGetParent(o),
                            t
                        })
                    }).data
            },
            getGraph: function() {
                return this.getData().graph
            },
            getEdgeData: function() {
                return this.getGraph().edgeData
            },
            getCategoriesData: function() {
                return this._categoriesData
            },
            formatTooltip: function(t, e, i) {
                if ("edge" !== i)
                    return ZS.superApply(this, "formatTooltip", arguments);
                var n = this.getData()
                  , a = this.getDataParams(t, i)
                  , r = n.graph.getEdgeByIndex(t)
                  , o = n.getName(r.node1.dataIndex)
                  , s = n.getName(r.node2.dataIndex)
                  , l = [];
                return null != o && l.push(o),
                null != s && l.push(s),
                l = WS(l.join(" > ")),
                a.value && (l += " : " + WS(a.value)),
                l
            },
            _updateCategoriesData: function() {
                var t = it.map(this.option.categories || [], function(t) {
                    return null != t.value ? t : it.extend({
                        value: 0
                    }, t)
                })
                  , e = new Qp(["value"],this);
                e.initData(t),
                this._categoriesData = e,
                this._categoriesModels = e.mapArray(function(t) {
                    return e.getItemModel(t, !0)
                })
            },
            setZoom: function(t) {
                this.option.zoom = t
            },
            setCenter: function(t) {
                this.option.center = t
            },
            isAnimationEnabled: function() {
                return ZS.superCall(this, "isAnimationEnabled") && !("force" === this.get("layout") && this.get("force.layoutAnimation"))
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "view",
                legendHoverLink: !0,
                hoverAnimation: !0,
                layout: null,
                focusNodeAdjacency: !1,
                circular: {
                    rotateLabel: !1
                },
                force: {
                    initLayout: null,
                    repulsion: [0, 50],
                    gravity: .1,
                    edgeLength: 30,
                    layoutAnimation: !0
                },
                left: "center",
                top: "center",
                symbol: "circle",
                symbolSize: 10,
                edgeSymbol: ["none", "none"],
                edgeSymbolSize: 10,
                edgeLabel: {
                    position: "middle"
                },
                draggable: !1,
                roam: !1,
                center: null,
                zoom: 1,
                nodeScaleRatio: .6,
                label: {
                    show: !1,
                    formatter: "{b}"
                },
                itemStyle: {},
                lineStyle: {
                    color: "#aaa",
                    width: 1,
                    curveness: 0,
                    opacity: .5
                },
                emphasis: {
                    label: {
                        show: !0
                    }
                }
            }
        })
          , US = Fs.Line.prototype
          , YS = Fs.BezierCurve.prototype;
        function jS(t) {
            return isNaN(+t.cpx1) || isNaN(+t.cpy1)
        }
        var XS = Fs.extendShape({
            type: "ec-line",
            style: {
                stroke: "#000",
                fill: null
            },
            shape: {
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                percent: 1,
                cpx1: null,
                cpy1: null
            },
            buildPath: function(t, e) {
                (jS(e) ? US : YS).buildPath(t, e)
            },
            pointAt: function(t) {
                return jS(this.shape) ? US.pointAt.call(this, t) : YS.pointAt.call(this, t)
            },
            tangentAt: function(t) {
                var e = this.shape
                  , i = jS(e) ? [e.x2 - e.x1, e.y2 - e.y1] : YS.tangentAt.call(this, t);
                return R.normalize(i, i)
            }
        })
          , qS = ol.round
          , KS = ["fromSymbol", "toSymbol"];
        function $S(t) {
            return "_" + t + "Type"
        }
        function JS(t, e, i) {
            var n = e.getItemVisual(i, "color")
              , a = e.getItemVisual(i, t)
              , r = e.getItemVisual(i, t + "Size");
            if (a && "none" !== a) {
                it.isArray(r) || (r = [r, r]);
                var o = Fg.createSymbol(a, -r[0] / 2, -r[1] / 2, r[0], r[1], n);
                return o.name = t,
                o
            }
        }
        function QS(t, e) {
            var i = e[0]
              , n = e[1]
              , a = e[2];
            t.x1 = i[0],
            t.y1 = i[1],
            t.x2 = n[0],
            t.y2 = n[1],
            t.percent = 1,
            a ? (t.cpx1 = a[0],
            t.cpy1 = a[1]) : (t.cpx1 = NaN,
            t.cpy1 = NaN)
        }
        function tM(t, e, i) {
            Fs.Group.call(this),
            this._createLine(t, e, i)
        }
        var eM = tM.prototype;
        eM.beforeUpdate = function() {
            var t = this.childOfName("fromSymbol")
              , e = this.childOfName("toSymbol")
              , i = this.childOfName("label");
            if (t || e || !i.ignore) {
                for (var n = 1, a = this.parent; a; )
                    a.scale && (n /= a.scale[0]),
                    a = a.parent;
                var r = this.childOfName("line");
                if (this.__dirty || r.__dirty) {
                    var o = r.shape.percent
                      , s = r.pointAt(0)
                      , l = r.pointAt(o)
                      , u = R.sub([], l, s);
                    if (R.normalize(u, u),
                    t) {
                        t.attr("position", s);
                        var h = r.tangentAt(0);
                        t.attr("rotation", Math.PI / 2 - Math.atan2(h[1], h[0])),
                        t.attr("scale", [n * o, n * o])
                    }
                    if (e) {
                        e.attr("position", l);
                        h = r.tangentAt(1);
                        e.attr("rotation", -Math.PI / 2 - Math.atan2(h[1], h[0])),
                        e.attr("scale", [n * o, n * o])
                    }
                    if (!i.ignore) {
                        var c, d, p;
                        i.attr("position", l);
                        var f = 5 * n;
                        if ("end" === i.__position)
                            c = [u[0] * f + l[0], u[1] * f + l[1]],
                            d = .8 < u[0] ? "left" : u[0] < -.8 ? "right" : "center",
                            p = .8 < u[1] ? "top" : u[1] < -.8 ? "bottom" : "middle";
                        else if ("middle" === i.__position) {
                            var g = o / 2
                              , m = [(h = r.tangentAt(g))[1], -h[0]]
                              , v = r.pointAt(g);
                            0 < m[1] && (m[0] = -m[0],
                            m[1] = -m[1]),
                            c = [v[0] + m[0] * f, v[1] + m[1] * f],
                            d = "center",
                            p = "bottom";
                            var y = -Math.atan2(h[1], h[0]);
                            l[0] < s[0] && (y = Math.PI + y),
                            i.attr("rotation", y)
                        } else
                            c = [-u[0] * f + s[0], -u[1] * f + s[1]],
                            d = .8 < u[0] ? "right" : u[0] < -.8 ? "left" : "center",
                            p = .8 < u[1] ? "bottom" : u[1] < -.8 ? "top" : "middle";
                        i.attr({
                            style: {
                                textVerticalAlign: i.__verticalAlign || p,
                                textAlign: i.__textAlign || d
                            },
                            position: c,
                            scale: [n, n]
                        })
                    }
                }
            }
        }
        ,
        eM._createLine = function(i, n, t) {
            var e = i.hostModel
              , a = function(t) {
                var e = new XS({
                    name: "line"
                });
                return QS(e.shape, t),
                e
            }(i.getItemLayout(n));
            a.shape.percent = 0,
            Fs.initProps(a, {
                shape: {
                    percent: 1
                }
            }, e, n),
            this.add(a);
            var r = new Fs.Text({
                name: "label",
                lineLabelOriginalOpacity: 1
            });
            this.add(r),
            it.each(KS, function(t) {
                var e = JS(t, i, n);
                this.add(e),
                this[$S(t)] = i.getItemVisual(n, t)
            }, this),
            this._updateCommonStl(i, n, t)
        }
        ,
        eM.updateData = function(a, r, t) {
            var e = a.hostModel
              , i = this.childOfName("line")
              , n = a.getItemLayout(r)
              , o = {
                shape: {}
            };
            QS(o.shape, n),
            Fs.updateProps(i, o, e, r),
            it.each(KS, function(t) {
                var e = a.getItemVisual(r, t)
                  , i = $S(t);
                if (this[i] !== e) {
                    this.remove(this.childOfName(t));
                    var n = JS(t, a, r);
                    this.add(n)
                }
                this[i] = e
            }, this),
            this._updateCommonStl(a, r, t)
        }
        ,
        eM._updateCommonStl = function(t, e, i) {
            var n = t.hostModel
              , a = this.childOfName("line")
              , r = i && i.lineStyle
              , o = i && i.hoverLineStyle
              , s = i && i.labelModel
              , l = i && i.hoverLabelModel;
            if (!i || t.hasItemOption) {
                var u = t.getItemModel(e);
                r = u.getModel("lineStyle").getLineStyle(),
                o = u.getModel("emphasis.lineStyle").getLineStyle(),
                s = u.getModel("label"),
                l = u.getModel("emphasis.label")
            }
            var h = t.getItemVisual(e, "color")
              , c = it.retrieve3(t.getItemVisual(e, "opacity"), r.opacity, 1);
            a.useStyle(it.defaults({
                strokeNoScale: !0,
                fill: "none",
                stroke: h,
                opacity: c
            }, r)),
            a.hoverStyle = o,
            it.each(KS, function(t) {
                var e = this.childOfName(t);
                e && (e.setColor(h),
                e.setStyle({
                    opacity: c
                }))
            }, this);
            var d, p, f = s.getShallow("show"), g = l.getShallow("show"), m = this.childOfName("label");
            if ((f || g) && (d = h || "#000",
            null == (p = n.getFormattedLabel(e, "normal", t.dataType)))) {
                var v = n.getRawValue(e);
                p = null == v ? t.getName(e) : isFinite(v) ? qS(v) : v
            }
            var y = f ? p : null
              , x = g ? it.retrieve2(n.getFormattedLabel(e, "emphasis", t.dataType), p) : null
              , _ = m.style;
            null == y && null == x || (Fs.setTextStyle(m.style, s, {
                text: y
            }, {
                autoColor: d
            }),
            m.__textAlign = _.textAlign,
            m.__verticalAlign = _.textVerticalAlign,
            m.__position = s.get("position") || "middle"),
            m.hoverStyle = null != x ? {
                text: x,
                textFill: l.getTextColor(!0),
                fontStyle: l.getShallow("fontStyle"),
                fontWeight: l.getShallow("fontWeight"),
                fontSize: l.getShallow("fontSize"),
                fontFamily: l.getShallow("fontFamily")
            } : {
                text: null
            },
            m.ignore = !f && !g,
            Fs.setHoverStyle(this)
        }
        ,
        eM.highlight = function() {
            this.trigger("emphasis")
        }
        ,
        eM.downplay = function() {
            this.trigger("normal")
        }
        ,
        eM.updateLayout = function(t, e) {
            this.setLinePoints(t.getItemLayout(e))
        }
        ,
        eM.setLinePoints = function(t) {
            var e = this.childOfName("line");
            QS(e.shape, t),
            e.dirty()
        }
        ,
        it.inherits(tM, Fs.Group);
        var iM = tM;
        function nM(t) {
            this._ctor = t || iM,
            this.group = new Fs.Group
        }
        var aM = nM.prototype;
        function rM(t) {
            var e = t.hostModel;
            return {
                lineStyle: e.getModel("lineStyle").getLineStyle(),
                hoverLineStyle: e.getModel("emphasis.lineStyle").getLineStyle(),
                labelModel: e.getModel("label"),
                hoverLabelModel: e.getModel("emphasis.label")
            }
        }
        function oM(t) {
            return isNaN(t[0]) || isNaN(t[1])
        }
        function sM(t) {
            return !oM(t[0]) && !oM(t[1])
        }
        aM.isPersistent = function() {
            return !0
        }
        ,
        aM.updateData = function(i) {
            var n = this
              , e = n.group
              , a = n._lineData;
            n._lineData = i,
            a || e.removeAll();
            var r = rM(i);
            i.diff(a).add(function(t) {
                !function(t, e, i, n) {
                    if (!sM(e.getItemLayout(i)))
                        return;
                    var a = new t._ctor(e,i,n);
                    e.setItemGraphicEl(i, a),
                    t.group.add(a)
                }(n, i, t, r)
            }).update(function(t, e) {
                !function(t, e, i, n, a, r) {
                    var o = e.getItemGraphicEl(n);
                    if (!sM(i.getItemLayout(a)))
                        return t.group.remove(o);
                    o ? o.updateData(i, a, r) : o = new t._ctor(i,a,r);
                    i.setItemGraphicEl(a, o),
                    t.group.add(o)
                }(n, a, i, e, t, r)
            }).remove(function(t) {
                e.remove(a.getItemGraphicEl(t))
            }).execute()
        }
        ,
        aM.updateLayout = function() {
            var i = this._lineData;
            i && i.eachItemGraphicEl(function(t, e) {
                t.updateLayout(i, e)
            }, this)
        }
        ,
        aM.incrementalPrepareUpdate = function(t) {
            this._seriesScope = rM(t),
            this._lineData = null,
            this.group.removeAll()
        }
        ,
        aM.incrementalUpdate = function(t, e) {
            function i(t) {
                t.isGroup || (t.incremental = t.useHoverLayer = !0)
            }
            for (var n = t.start; n < t.end; n++) {
                if (sM(e.getItemLayout(n))) {
                    var a = new this._ctor(e,n,this._seriesScope);
                    a.traverse(i),
                    this.group.add(a),
                    e.setItemGraphicEl(n, a)
                }
            }
        }
        ,
        aM.remove = function() {
            this._clearIncremental(),
            this._incremental = null,
            this.group.removeAll()
        }
        ,
        aM._clearIncremental = function() {
            var t = this._incremental;
            t && t.clearDisplaybles()
        }
        ;
        var lM = nM
          , uM = []
          , hM = []
          , cM = []
          , dM = La.quadraticAt
          , pM = R.distSquare
          , fM = Math.abs;
        function gM(t, e, i) {
            for (var n, a = t[0], r = t[1], o = t[2], s = 1 / 0, l = i * i, u = .1, h = .1; h <= .9; h += .1) {
                uM[0] = dM(a[0], r[0], o[0], h),
                uM[1] = dM(a[1], r[1], o[1], h),
                (p = fM(pM(uM, e) - l)) < s && (s = p,
                n = h)
            }
            for (var c = 0; c < 32; c++) {
                var d = n + u;
                hM[0] = dM(a[0], r[0], o[0], n),
                hM[1] = dM(a[1], r[1], o[1], n),
                cM[0] = dM(a[0], r[0], o[0], d),
                cM[1] = dM(a[1], r[1], o[1], d);
                var p = pM(hM, e) - l;
                if (fM(p) < .01)
                    break;
                var f = pM(cM, e) - l;
                u /= 2,
                p < 0 ? 0 <= f ? n += u : n -= u : 0 <= f ? n -= u : n += u
            }
            return n
        }
        var mM = function(t, l) {
            var u = []
              , h = La.quadraticSubdivide
              , c = [[], [], []]
              , d = [[], []]
              , p = [];
            function f(t) {
                var e = t.getVisual("symbolSize");
                return e instanceof Array && (e = (e[0] + e[1]) / 2),
                e
            }
            l /= 2,
            t.eachEdge(function(t, e) {
                var i = t.getLayout()
                  , n = t.getVisual("fromSymbol")
                  , a = t.getVisual("toSymbol");
                i.__original || (i.__original = [R.clone(i[0]), R.clone(i[1])],
                i[2] && i.__original.push(R.clone(i[2])));
                var r = i.__original;
                if (null != i[2]) {
                    if (R.copy(c[0], r[0]),
                    R.copy(c[1], r[2]),
                    R.copy(c[2], r[1]),
                    n && "none" !== n) {
                        var o = f(t.node1)
                          , s = gM(c, r[0], o * l);
                        h(c[0][0], c[1][0], c[2][0], s, u),
                        c[0][0] = u[3],
                        c[1][0] = u[4],
                        h(c[0][1], c[1][1], c[2][1], s, u),
                        c[0][1] = u[3],
                        c[1][1] = u[4]
                    }
                    if (a && "none" !== a) {
                        o = f(t.node2),
                        s = gM(c, r[1], o * l);
                        h(c[0][0], c[1][0], c[2][0], s, u),
                        c[1][0] = u[1],
                        c[2][0] = u[2],
                        h(c[0][1], c[1][1], c[2][1], s, u),
                        c[1][1] = u[1],
                        c[2][1] = u[2]
                    }
                    R.copy(i[0], c[0]),
                    R.copy(i[1], c[2]),
                    R.copy(i[2], c[1])
                } else {
                    if (R.copy(d[0], r[0]),
                    R.copy(d[1], r[1]),
                    R.sub(p, d[1], d[0]),
                    R.normalize(p, p),
                    n && "none" !== n) {
                        o = f(t.node1);
                        R.scaleAndAdd(d[0], d[0], p, o * l)
                    }
                    if (a && "none" !== a) {
                        o = f(t.node2);
                        R.scaleAndAdd(d[1], d[1], p, -o * l)
                    }
                    R.copy(i[0], d[0]),
                    R.copy(i[1], d[1])
                }
            })
        }
          , vM = ob.onIrrelevantElement
          , yM = "__focusNodeAdjacency"
          , xM = "__unfocusNodeAdjacency"
          , _M = ["itemStyle", "opacity"]
          , bM = ["lineStyle", "opacity"];
        function wM(t, e) {
            return t.getVisual("opacity") || t.getModel().get(e)
        }
        function SM(t, e, i) {
            var n = t.getGraphicEl()
              , a = wM(t, e);
            null != i && (null == a && (a = 1),
            a *= i),
            n.downplay && n.downplay(),
            n.traverse(function(t) {
                if ("group" !== t.type) {
                    var e = t.lineLabelOriginalOpacity;
                    null != e && null == i || (e = a),
                    t.setStyle("opacity", e)
                }
            })
        }
        function MM(t, e) {
            var i = wM(t, e)
              , n = t.getGraphicEl();
            n.highlight && n.highlight(),
            n.traverse(function(t) {
                "group" !== t.type && t.setStyle("opacity", i)
            })
        }
        Gm.extendChartView({
            type: "graph",
            init: function(t, e) {
                var i = new dv
                  , n = new lM
                  , a = this.group;
                this._controller = new nb(e.getZr()),
                this._controllerHost = {
                    target: a
                },
                a.add(i.group),
                a.add(n.group),
                this._symbolDraw = i,
                this._lineDraw = n,
                this._firstRender = !0
            },
            render: function(a, t, r) {
                var e = a.coordinateSystem;
                this._model = a,
                this._nodeScaleRatio = a.get("nodeScaleRatio");
                var i = this._symbolDraw
                  , n = this._lineDraw
                  , o = this.group;
                if ("view" === e.type) {
                    var s = {
                        position: e.position,
                        scale: e.scale
                    };
                    this._firstRender ? o.attr(s) : Fs.updateProps(o, s, a)
                }
                mM(a.getGraph(), this._getNodeGlobalScale(a));
                var l = a.getData();
                i.updateData(l);
                var u = a.getEdgeData();
                n.updateData(u),
                this._updateNodeAndLinkScale(),
                this._updateController(a, t, r),
                clearTimeout(this._layoutTimeout);
                var h = a.forceLayout
                  , c = a.get("force.layoutAnimation");
                h && this._startForceLayoutIteration(h, c),
                l.eachItemGraphicEl(function(t, e) {
                    var i = l.getItemModel(e);
                    t.off("drag").off("dragend");
                    var n = i.get("draggable");
                    n && t.on("drag", function() {
                        h && (h.warmUp(),
                        this._layouting || this._startForceLayoutIteration(h, c),
                        h.setFixed(e),
                        l.setItemLayout(e, t.position))
                    }, this).on("dragend", function() {
                        h && h.setUnfixed(e)
                    }, this),
                    t.setDraggable(n && h),
                    t[yM] && t.off("mouseover", t[yM]),
                    t[xM] && t.off("mouseout", t[xM]),
                    i.get("focusNodeAdjacency") && (t.on("mouseover", t[yM] = function() {
                        r.dispatchAction({
                            type: "focusNodeAdjacency",
                            seriesId: a.id,
                            dataIndex: t.dataIndex
                        })
                    }
                    ),
                    t.on("mouseout", t[xM] = function() {
                        r.dispatchAction({
                            type: "unfocusNodeAdjacency",
                            seriesId: a.id
                        })
                    }
                    ))
                }, this),
                l.graph.eachEdge(function(t) {
                    var e = t.getGraphicEl();
                    e[yM] && e.off("mouseover", e[yM]),
                    e[xM] && e.off("mouseout", e[xM]),
                    t.getModel().get("focusNodeAdjacency") && (e.on("mouseover", e[yM] = function() {
                        r.dispatchAction({
                            type: "focusNodeAdjacency",
                            seriesId: a.id,
                            edgeDataIndex: t.dataIndex
                        })
                    }
                    ),
                    e.on("mouseout", e[xM] = function() {
                        r.dispatchAction({
                            type: "unfocusNodeAdjacency",
                            seriesId: a.id
                        })
                    }
                    ))
                });
                var d = "circular" === a.get("layout") && a.get("circular.rotateLabel")
                  , p = l.getLayout("cx")
                  , f = l.getLayout("cy");
                l.eachItemGraphicEl(function(t, e) {
                    var i = t.getSymbolPath();
                    if (d) {
                        var n = l.getItemLayout(e)
                          , a = Math.atan2(n[1] - f, n[0] - p);
                        a < 0 && (a = 2 * Math.PI + a);
                        var r = n[0] < p;
                        r && (a -= Math.PI);
                        var o = r ? "left" : "right";
                        i.setStyle({
                            textRotation: -a,
                            textPosition: o,
                            textOrigin: "center"
                        }),
                        i.hoverStyle && (i.hoverStyle.textPosition = o)
                    } else
                        i.setStyle({
                            textRotation: 0
                        })
                }),
                this._firstRender = !1
            },
            dispose: function() {
                this._controller && this._controller.dispose(),
                this._controllerHost = {}
            },
            focusNodeAdjacency: function(t, e, i, n) {
                var a = this._model.getData().graph
                  , r = n.dataIndex
                  , o = n.edgeDataIndex
                  , s = a.getNodeByIndex(r)
                  , l = a.getEdgeByIndex(o);
                (s || l) && (a.eachNode(function(t) {
                    SM(t, _M, .1)
                }),
                a.eachEdge(function(t) {
                    SM(t, bM, .1)
                }),
                s && (MM(s, _M),
                it.each(s.edges, function(t) {
                    t.dataIndex < 0 || (MM(t, bM),
                    MM(t.node1, _M),
                    MM(t.node2, _M))
                })),
                l && (MM(l, bM),
                MM(l.node1, _M),
                MM(l.node2, _M)))
            },
            unfocusNodeAdjacency: function(t, e, i, n) {
                var a = this._model.getData().graph;
                a.eachNode(function(t) {
                    SM(t, _M)
                }),
                a.eachEdge(function(t) {
                    SM(t, bM)
                })
            },
            _startForceLayoutIteration: function(t, i) {
                var n = this;
                !function e() {
                    t.step(function(t) {
                        n.updateLayout(n._model),
                        (n._layouting = !t) && (i ? n._layoutTimeout = setTimeout(e, 16) : e())
                    })
                }()
            },
            _updateController: function(a, t, r) {
                var e = this._controller
                  , i = this._controllerHost
                  , o = this.group;
                e.setPointerChecker(function(t, e, i) {
                    var n = o.getBoundingRect();
                    return n.applyTransform(o.transform),
                    n.contain(e, i) && !vM(t, r, a)
                }),
                "view" === a.coordinateSystem.type ? (e.enable(a.get("roam")),
                i.zoomLimit = a.get("scaleLimit"),
                i.zoom = a.coordinateSystem.getZoom(),
                e.off("pan").off("zoom").on("pan", function(t) {
                    ab.updateViewOnPan(i, t.dx, t.dy),
                    r.dispatchAction({
                        seriesId: a.id,
                        type: "graphRoam",
                        dx: t.dx,
                        dy: t.dy
                    })
                }).on("zoom", function(t) {
                    ab.updateViewOnZoom(i, t.scale, t.originX, t.originY),
                    r.dispatchAction({
                        seriesId: a.id,
                        type: "graphRoam",
                        zoom: t.scale,
                        originX: t.originX,
                        originY: t.originY
                    }),
                    this._updateNodeAndLinkScale(),
                    mM(a.getGraph(), this._getNodeGlobalScale(a)),
                    this._lineDraw.updateLayout()
                }, this)) : e.disable()
            },
            _updateNodeAndLinkScale: function() {
                var t = this._model
                  , e = t.getData()
                  , i = this._getNodeGlobalScale(t)
                  , n = [i, i];
                e.eachItemGraphicEl(function(t, e) {
                    t.attr("scale", n)
                })
            },
            _getNodeGlobalScale: function(t) {
                var e = t.coordinateSystem;
                if ("view" !== e.type)
                    return 1;
                var i = this._nodeScaleRatio
                  , n = e.scale
                  , a = n && n[0] || 1;
                return ((e.getZoom() - 1) * i + 1) / a
            },
            updateLayout: function(t) {
                mM(t.getGraph(), this._getNodeGlobalScale(t)),
                this._symbolDraw.updateLayout(),
                this._lineDraw.updateLayout()
            },
            remove: function(t, e) {
                this._symbolDraw && this._symbolDraw.remove(),
                this._lineDraw && this._lineDraw.remove()
            }
        });
        Gm.registerAction({
            type: "focusNodeAdjacency",
            event: "focusNodeAdjacency",
            update: "series:focusNodeAdjacency"
        }, function() {}),
        Gm.registerAction({
            type: "unfocusNodeAdjacency",
            event: "unfocusNodeAdjacency",
            update: "series:unfocusNodeAdjacency"
        }, function() {});
        var IM = vb.updateCenterAndZoom;
        Gm.registerAction({
            type: "graphRoam",
            event: "graphRoam",
            update: "none"
        }, function(n, t) {
            t.eachComponent({
                mainType: "series",
                query: n
            }, function(t) {
                var e = t.coordinateSystem
                  , i = IM(e, n);
                t.setCenter && t.setCenter(i.center),
                t.setZoom && t.setZoom(i.zoom)
            })
        });
        function AM(t) {
            var r = t.findComponents({
                mainType: "legend"
            });
            r && r.length && t.eachSeriesByType("graph", function(t) {
                var e = t.getCategoriesData()
                  , n = t.getGraph().data
                  , a = e.mapArray(e.getName);
                n.filterSelf(function(t) {
                    var e = n.getItemModel(t).getShallow("category");
                    if (null != e) {
                        "number" == typeof e && (e = a[e]);
                        for (var i = 0; i < r.length; i++)
                            if (!r[i].isSelected(e))
                                return !1
                    }
                    return !0
                })
            }, this)
        }
        function TM(t) {
            var o = {};
            t.eachSeriesByType("graph", function(n) {
                var a = n.getCategoriesData()
                  , i = n.getData()
                  , r = {};
                a.each(function(t) {
                    var e = a.getName(t);
                    r["ec-" + e] = t;
                    var i = a.getItemModel(t).get("itemStyle.color") || n.getColorFromPalette(e, o);
                    a.setItemVisual(t, "color", i)
                }),
                a.count() && i.each(function(t) {
                    var e = i.getItemModel(t).getShallow("category");
                    null != e && ("string" == typeof e && (e = r["ec-" + e]),
                    i.getItemVisual(t, "color", !0) || i.setItemVisual(t, "color", a.getItemVisual(e, "color")))
                })
            })
        }
        function CM(t) {
            return t instanceof Array || (t = [t, t]),
            t
        }
        function DM(t) {
            t.eachSeriesByType("graph", function(t) {
                var s = t.getGraph()
                  , l = t.getEdgeData()
                  , e = CM(t.get("edgeSymbol"))
                  , i = CM(t.get("edgeSymbolSize"))
                  , u = "lineStyle.color".split(".")
                  , h = "lineStyle.opacity".split(".");
                l.setVisual("fromSymbol", e && e[0]),
                l.setVisual("toSymbol", e && e[1]),
                l.setVisual("fromSymbolSize", i && i[0]),
                l.setVisual("toSymbolSize", i && i[1]),
                l.setVisual("color", t.get(u)),
                l.setVisual("opacity", t.get(h)),
                l.each(function(t) {
                    var e = l.getItemModel(t)
                      , i = s.getEdgeByIndex(t)
                      , n = CM(e.getShallow("symbol", !0))
                      , a = CM(e.getShallow("symbolSize", !0))
                      , r = e.get(u)
                      , o = e.get(h);
                    switch (r) {
                    case "source":
                        r = i.node1.getVisual("color");
                        break;
                    case "target":
                        r = i.node2.getVisual("color")
                    }
                    n[0] && i.setVisual("fromSymbol", n[0]),
                    n[1] && i.setVisual("toSymbol", n[1]),
                    a[0] && i.setVisual("fromSymbolSize", a[0]),
                    a[1] && i.setVisual("toSymbolSize", a[1]),
                    i.setVisual("color", r),
                    i.setVisual("opacity", o)
                })
            })
        }
        function LM(t) {
            t.eachEdge(function(t) {
                var e = t.getModel().get("lineStyle.curveness") || 0
                  , i = R.clone(t.node1.getLayout())
                  , n = R.clone(t.node2.getLayout())
                  , a = [i, n];
                +e && a.push([(i[0] + n[0]) / 2 - (i[1] - n[1]) * e, (i[1] + n[1]) / 2 - (n[0] - i[0]) * e]),
                t.setLayout(a)
            })
        }
        var PM = {
            simpleLayout: function(t) {
                var e = t.coordinateSystem;
                if (!e || "view" === e.type) {
                    var i = t.getGraph();
                    i.eachNode(function(t) {
                        var e = t.getModel();
                        t.setLayout([+e.get("x"), +e.get("y")])
                    }),
                    LM(i)
                }
            },
            simpleLayoutEdge: LM
        }
          , kM = it.each
          , OM = PM.simpleLayout
          , RM = PM.simpleLayoutEdge;
        function NM(t, e) {
            t.eachSeriesByType("graph", function(t) {
                var e = t.get("layout")
                  , i = t.coordinateSystem;
                if (i && "view" !== i.type) {
                    var n = t.getData()
                      , a = [];
                    kM(i.dimensions, function(t) {
                        a = a.concat(n.mapDimension(t, !0))
                    });
                    for (var r = 0; r < n.count(); r++) {
                        for (var o = [], s = !1, l = 0; l < a.length; l++) {
                            var u = n.get(a[l], r);
                            isNaN(u) || (s = !0),
                            o.push(u)
                        }
                        s ? n.setItemLayout(r, i.dataToPoint(o)) : n.setItemLayout(r, [NaN, NaN])
                    }
                    RM(n.graph)
                } else
                    e && "none" !== e || OM(t)
            })
        }
        var EM = {
            circularLayout: function(t) {
                var e = t.coordinateSystem;
                if (!e || "view" === e.type) {
                    var i = e.getBoundingRect()
                      , n = t.getData()
                      , a = n.graph
                      , r = 0
                      , o = n.getSum("value")
                      , s = 2 * Math.PI / (o || n.count())
                      , l = i.width / 2 + i.x
                      , u = i.height / 2 + i.y
                      , h = Math.min(i.width, i.height) / 2;
                    a.eachNode(function(t) {
                        var e = t.getValue("value");
                        r += s * (o ? e : 1) / 2,
                        t.setLayout([h * Math.cos(r) + l, h * Math.sin(r) + u]),
                        r += s * (o ? e : 1) / 2
                    }),
                    n.setLayout({
                        cx: l,
                        cy: u
                    }),
                    a.eachEdge(function(t) {
                        var e, i = t.getModel().get("lineStyle.curveness") || 0, n = R.clone(t.node1.getLayout()), a = R.clone(t.node2.getLayout()), r = (n[0] + a[0]) / 2, o = (n[1] + a[1]) / 2;
                        +i && (e = [l * (i *= 3) + r * (1 - i), u * i + o * (1 - i)]),
                        t.setLayout([n, a, e])
                    })
                }
            }
        }
          , zM = EM.circularLayout;
        function VM(t) {
            t.eachSeriesByType("graph", function(t) {
                "circular" === t.get("layout") && zM(t)
            })
        }
        var BM = R.scaleAndAdd;
        var GM = {
            forceLayout: function(p, f, t) {
                for (var e = t.rect, i = e.width, n = e.height, g = [e.x + i / 2, e.y + n / 2], m = null == t.gravity ? .1 : t.gravity, a = 0; a < p.length; a++) {
                    var r = p[a];
                    r.p || (r.p = R.create(i * (Math.random() - .5) + g[0], n * (Math.random() - .5) + g[1])),
                    r.pp = R.clone(r.p),
                    r.edges = null
                }
                var v = .6;
                return {
                    warmUp: function() {
                        v = .5
                    },
                    setFixed: function(t) {
                        p[t].fixed = !0
                    },
                    setUnfixed: function(t) {
                        p[t].fixed = !1
                    },
                    step: function(t) {
                        for (var e = [], i = p.length, n = 0; n < f.length; n++) {
                            var a = f[n]
                              , r = a.n1
                              , o = a.n2;
                            R.sub(e, o.p, r.p);
                            var s = R.len(e) - a.d
                              , l = o.w / (r.w + o.w);
                            isNaN(l) && (l = 0),
                            R.normalize(e, e),
                            r.fixed || BM(r.p, r.p, e, l * s * v),
                            o.fixed || BM(o.p, o.p, e, -(1 - l) * s * v)
                        }
                        for (n = 0; n < i; n++) {
                            (d = p[n]).fixed || (R.sub(e, g, d.p),
                            BM(d.p, d.p, e, m * v))
                        }
                        for (n = 0; n < i; n++) {
                            r = p[n];
                            for (var u = n + 1; u < i; u++) {
                                o = p[u];
                                R.sub(e, o.p, r.p),
                                0 === (s = R.len(e)) && (R.set(e, Math.random() - .5, Math.random() - .5),
                                s = 1);
                                var h = (r.rep + o.rep) / s / s;
                                r.fixed || BM(r.pp, r.pp, e, h),
                                o.fixed || BM(o.pp, o.pp, e, -h)
                            }
                        }
                        var c = [];
                        for (n = 0; n < i; n++) {
                            var d;
                            (d = p[n]).fixed || (R.sub(c, d.p, d.pp),
                            BM(d.p, d.p, c, v),
                            R.copy(d.pp, d.p))
                        }
                        v *= .992,
                        t && t(p, f, v < .01)
                    }
                }
            }
        }.forceLayout
          , FM = PM.simpleLayout
          , HM = EM.circularLayout
          , WM = ol.linearMap;
        function ZM(t) {
            t.eachSeriesByType("graph", function(t) {
                if (!(l = t.coordinateSystem) || "view" === l.type)
                    if ("force" === t.get("layout")) {
                        var c = t.preservedPoints || {}
                          , d = t.getGraph()
                          , p = d.data
                          , e = d.edgeData
                          , i = t.getModel("force")
                          , n = i.get("initLayout");
                        t.preservedPoints ? p.each(function(t) {
                            var e = p.getId(t);
                            p.setItemLayout(t, c[e] || [NaN, NaN])
                        }) : n && "none" !== n ? "circular" === n && HM(t) : FM(t);
                        var a = p.getDataExtent("value")
                          , r = e.getDataExtent("value")
                          , o = i.get("repulsion")
                          , s = i.get("edgeLength");
                        it.isArray(o) || (o = [o, o]),
                        it.isArray(s) || (s = [s, s]),
                        s = [s[1], s[0]];
                        var l, u = p.mapArray("value", function(t, e) {
                            var i = p.getItemLayout(e)
                              , n = WM(t, a, o);
                            return isNaN(n) && (n = (o[0] + o[1]) / 2),
                            {
                                w: n,
                                rep: n,
                                fixed: p.getItemModel(e).get("fixed"),
                                p: !i || isNaN(i[0]) || isNaN(i[1]) ? null : i
                            }
                        }), h = e.mapArray("value", function(t, e) {
                            var i = d.getEdgeByIndex(e)
                              , n = WM(t, r, s);
                            return isNaN(n) && (n = (s[0] + s[1]) / 2),
                            {
                                n1: u[i.node1.dataIndex],
                                n2: u[i.node2.dataIndex],
                                d: n,
                                curveness: i.getModel().get("lineStyle.curveness") || 0
                            }
                        }), f = (l = t.coordinateSystem).getBoundingRect(), g = GM(u, h, {
                            rect: f,
                            gravity: i.get("gravity")
                        }), m = g.step;
                        g.step = function(h) {
                            for (var t = 0, e = u.length; t < e; t++)
                                u[t].fixed && R.copy(u[t].p, d.getNodeByIndex(t).getLayout());
                            m(function(t, e, i) {
                                for (var n = 0, a = t.length; n < a; n++)
                                    t[n].fixed || d.getNodeByIndex(n).setLayout(t[n].p),
                                    c[p.getId(n)] = t[n].p;
                                for (n = 0,
                                a = e.length; n < a; n++) {
                                    var r = e[n]
                                      , o = d.getEdgeByIndex(n)
                                      , s = r.n1.p
                                      , l = r.n2.p
                                      , u = o.getLayout();
                                    (u = u ? u.slice() : [])[0] = u[0] || [],
                                    u[1] = u[1] || [],
                                    R.copy(u[0], s),
                                    R.copy(u[1], l),
                                    +r.curveness && (u[2] = [(s[0] + l[0]) / 2 - (s[1] - l[1]) * r.curveness, (s[1] + l[1]) / 2 - (l[0] - s[0]) * r.curveness]),
                                    o.setLayout(u)
                                }
                                h && h(i)
                            })
                        }
                        ,
                        t.forceLayout = g,
                        t.preservedPoints = c,
                        g.step()
                    } else
                        t.forceLayout = null
            })
        }
        var UM = Il.getLayoutRect;
        function YM(t, p) {
            var f = [];
            return t.eachSeriesByType("graph", function(t) {
                var e = t.get("coordinateSystem");
                if (!e || "view" === e) {
                    var i = t.getData()
                      , n = i.mapArray(function(t) {
                        var e = i.getItemModel(t);
                        return [+e.get("x"), +e.get("y")]
                    })
                      , a = []
                      , r = [];
                    Ha.fromPoints(n, a, r),
                    r[0] - a[0] == 0 && (r[0] += 1,
                    a[0] -= 1),
                    r[1] - a[1] == 0 && (r[1] += 1,
                    a[1] -= 1);
                    var o = (r[0] - a[0]) / (r[1] - a[1])
                      , s = function(t, e, i) {
                        var n = t.getBoxLayoutParams();
                        return n.aspect = i,
                        UM(n, {
                            width: e.getWidth(),
                            height: e.getHeight()
                        })
                    }(t, p, o);
                    isNaN(o) && (a = [s.x, s.y],
                    r = [s.x + s.width, s.y + s.height]);
                    var l = r[0] - a[0]
                      , u = r[1] - a[1]
                      , h = s.width
                      , c = s.height
                      , d = t.coordinateSystem = new Sb;
                    d.zoomLimit = t.get("scaleLimit"),
                    d.setBoundingRect(a[0], a[1], l, u),
                    d.setViewRect(s.x, s.y, h, c),
                    d.setCenter(t.get("center")),
                    d.setZoom(t.get("zoom")),
                    f.push(d)
                }
            }),
            f
        }
        Gm.registerProcessor(AM),
        Gm.registerVisual(Fv("graph", "circle", null)),
        Gm.registerVisual(TM),
        Gm.registerVisual(DM),
        Gm.registerLayout(NM),
        Gm.registerLayout(VM),
        Gm.registerLayout(ZM),
        Gm.registerCoordinateSystem("graphView", {
            create: YM
        });
        kc.extend({
            type: "series.gauge",
            getInitialData: function(t, e) {
                var i = t.data || [];
                return it.isArray(i) || (i = [i]),
                t.data = i,
                Lx(this, ["value"])
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                center: ["50%", "50%"],
                legendHoverLink: !0,
                radius: "75%",
                startAngle: 225,
                endAngle: -45,
                clockwise: !0,
                min: 0,
                max: 100,
                splitNumber: 10,
                axisLine: {
                    show: !0,
                    lineStyle: {
                        color: [[.2, "#91c7ae"], [.8, "#63869e"], [1, "#c23531"]],
                        width: 30
                    }
                },
                splitLine: {
                    show: !0,
                    length: 30,
                    lineStyle: {
                        color: "#eee",
                        width: 2,
                        type: "solid"
                    }
                },
                axisTick: {
                    show: !0,
                    splitNumber: 5,
                    length: 8,
                    lineStyle: {
                        color: "#eee",
                        width: 1,
                        type: "solid"
                    }
                },
                axisLabel: {
                    show: !0,
                    distance: 5,
                    color: "auto"
                },
                pointer: {
                    show: !0,
                    length: "80%",
                    width: 8
                },
                itemStyle: {
                    color: "auto"
                },
                title: {
                    show: !0,
                    offsetCenter: [0, "-40%"],
                    color: "#333",
                    fontSize: 15
                },
                detail: {
                    show: !0,
                    backgroundColor: "rgba(0,0,0,0)",
                    borderWidth: 0,
                    borderColor: "#ccc",
                    width: 100,
                    height: null,
                    padding: [5, 10],
                    offsetCenter: [0, "40%"],
                    color: "auto",
                    fontSize: 30
                }
            }
        });
        var jM = Cr.extend({
            type: "echartsGaugePointer",
            shape: {
                angle: 0,
                width: 10,
                r: 10,
                x: 0,
                y: 0
            },
            buildPath: function(t, e) {
                var i = Math.cos
                  , n = Math.sin
                  , a = e.r
                  , r = e.width
                  , o = e.angle
                  , s = e.x - i(o) * r * (a / 3 <= r ? 1 : 2)
                  , l = e.y - n(o) * r * (a / 3 <= r ? 1 : 2);
                o = e.angle - Math.PI / 2,
                t.moveTo(s, l),
                t.lineTo(e.x + i(o) * r, e.y + n(o) * r),
                t.lineTo(e.x + i(e.angle) * a, e.y + n(e.angle) * a),
                t.lineTo(e.x - i(o) * r, e.y - n(o) * r),
                t.lineTo(s, l)
            }
        })
          , XM = ol.parsePercent
          , qM = ol.round
          , KM = ol.linearMap;
        function $M(t, e) {
            return e && ("string" == typeof e ? t = e.replace("{value}", null != t ? t : "") : "function" == typeof e && (t = e(t))),
            t
        }
        var JM = 2 * Math.PI
          , QM = (Xc.extend({
            type: "gauge",
            render: function(t, e, i) {
                this.group.removeAll();
                var n = t.get("axisLine.lineStyle.color")
                  , a = function(t, e) {
                    var i = t.get("center")
                      , n = e.getWidth()
                      , a = e.getHeight()
                      , r = Math.min(n, a);
                    return {
                        cx: XM(i[0], e.getWidth()),
                        cy: XM(i[1], e.getHeight()),
                        r: XM(t.get("radius"), r / 2)
                    }
                }(t, i);
                this._renderMain(t, e, i, n, a)
            },
            dispose: function() {},
            _renderMain: function(t, e, i, n, a) {
                for (var r = this.group, o = t.getModel("axisLine").getModel("lineStyle"), s = t.get("clockwise"), l = -t.get("startAngle") / 180 * Math.PI, u = ((p = -t.get("endAngle") / 180 * Math.PI) - l) % JM, h = l, c = o.get("width"), d = 0; d < n.length; d++) {
                    var p = l + u * Math.min(Math.max(n[d][0], 0), 1)
                      , f = new Fs.Sector({
                        shape: {
                            startAngle: h,
                            endAngle: p,
                            cx: a.cx,
                            cy: a.cy,
                            clockwise: s,
                            r0: a.r - c,
                            r: a.r
                        },
                        silent: !0
                    });
                    f.setStyle({
                        fill: n[d][1]
                    }),
                    f.setStyle(o.getLineStyle(["color", "borderWidth", "borderColor"])),
                    r.add(f),
                    h = p
                }
                function g(t) {
                    if (t <= 0)
                        return n[0][1];
                    for (var e = 0; e < n.length; e++)
                        if (n[e][0] >= t && (0 === e ? 0 : n[e - 1][0]) < t)
                            return n[e][1];
                    return n[e - 1][1]
                }
                if (!s) {
                    var m = l;
                    l = p,
                    p = m
                }
                this._renderTicks(t, e, i, g, a, l, p, s),
                this._renderPointer(t, e, i, g, a, l, p, s),
                this._renderTitle(t, e, i, g, a),
                this._renderDetail(t, e, i, g, a)
            },
            _renderTicks: function(t, e, i, n, a, r, o, s) {
                for (var l = this.group, u = a.cx, h = a.cy, c = a.r, d = +t.get("min"), p = +t.get("max"), f = t.getModel("splitLine"), g = t.getModel("axisTick"), m = t.getModel("axisLabel"), v = t.get("splitNumber"), y = g.get("splitNumber"), x = XM(f.get("length"), c), _ = XM(g.get("length"), c), b = r, w = (o - r) / v, S = w / y, M = f.getModel("lineStyle").getLineStyle(), I = g.getModel("lineStyle").getLineStyle(), A = 0; A <= v; A++) {
                    var T = Math.cos(b)
                      , C = Math.sin(b);
                    if (f.get("show")) {
                        var D = new Fs.Line({
                            shape: {
                                x1: T * c + u,
                                y1: C * c + h,
                                x2: T * (c - x) + u,
                                y2: C * (c - x) + h
                            },
                            style: M,
                            silent: !0
                        });
                        "auto" === M.stroke && D.setStyle({
                            stroke: n(A / v)
                        }),
                        l.add(D)
                    }
                    if (m.get("show")) {
                        var L = $M(qM(A / v * (p - d) + d), m.get("formatter"))
                          , P = m.get("distance")
                          , k = n(A / v);
                        l.add(new Fs.Text({
                            style: Fs.setTextStyle({}, m, {
                                text: L,
                                x: T * (c - x - P) + u,
                                y: C * (c - x - P) + h,
                                textVerticalAlign: C < -.4 ? "top" : .4 < C ? "bottom" : "middle",
                                textAlign: T < -.4 ? "left" : .4 < T ? "right" : "center"
                            }, {
                                autoColor: k
                            }),
                            silent: !0
                        }))
                    }
                    if (g.get("show") && A !== v) {
                        for (var O = 0; O <= y; O++) {
                            T = Math.cos(b),
                            C = Math.sin(b);
                            var R = new Fs.Line({
                                shape: {
                                    x1: T * c + u,
                                    y1: C * c + h,
                                    x2: T * (c - _) + u,
                                    y2: C * (c - _) + h
                                },
                                silent: !0,
                                style: I
                            });
                            "auto" === I.stroke && R.setStyle({
                                stroke: n((A + O / y) / v)
                            }),
                            l.add(R),
                            b += S
                        }
                        b -= S
                    } else
                        b += w
                }
            },
            _renderPointer: function(n, t, e, a, r, i, o, s) {
                var l = this.group
                  , u = this._data;
                if (n.get("pointer.show")) {
                    var h = [+n.get("min"), +n.get("max")]
                      , c = [i, o]
                      , d = n.getData()
                      , p = d.mapDimension("value");
                    d.diff(u).add(function(t) {
                        var e = new jM({
                            shape: {
                                angle: i
                            }
                        });
                        Fs.initProps(e, {
                            shape: {
                                angle: KM(d.get(p, t), h, c, !0)
                            }
                        }, n),
                        l.add(e),
                        d.setItemGraphicEl(t, e)
                    }).update(function(t, e) {
                        var i = u.getItemGraphicEl(e);
                        Fs.updateProps(i, {
                            shape: {
                                angle: KM(d.get(p, t), h, c, !0)
                            }
                        }, n),
                        l.add(i),
                        d.setItemGraphicEl(t, i)
                    }).remove(function(t) {
                        var e = u.getItemGraphicEl(t);
                        l.remove(e)
                    }).execute(),
                    d.eachItemGraphicEl(function(t, e) {
                        var i = d.getItemModel(e)
                          , n = i.getModel("pointer");
                        t.setShape({
                            x: r.cx,
                            y: r.cy,
                            width: XM(n.get("width"), r.r),
                            r: XM(n.get("length"), r.r)
                        }),
                        t.useStyle(i.getModel("itemStyle").getItemStyle()),
                        "auto" === t.style.fill && t.setStyle("fill", a(KM(d.get(p, e), h, [0, 1], !0))),
                        Fs.setHoverStyle(t, i.getModel("emphasis.itemStyle").getItemStyle())
                    }),
                    this._data = d
                } else
                    u && u.eachItemGraphicEl(function(t) {
                        l.remove(t)
                    })
            },
            _renderTitle: function(t, e, i, n, a) {
                var r = t.getData()
                  , o = r.mapDimension("value")
                  , s = t.getModel("title");
                if (s.get("show")) {
                    var l = s.get("offsetCenter")
                      , u = a.cx + XM(l[0], a.r)
                      , h = a.cy + XM(l[1], a.r)
                      , c = +t.get("min")
                      , d = +t.get("max")
                      , p = t.getData().get(o, 0)
                      , f = n(KM(p, [c, d], [0, 1], !0));
                    this.group.add(new Fs.Text({
                        silent: !0,
                        style: Fs.setTextStyle({}, s, {
                            x: u,
                            y: h,
                            text: r.getName(0),
                            textAlign: "center",
                            textVerticalAlign: "middle"
                        }, {
                            autoColor: f,
                            forceRich: !0
                        })
                    }))
                }
            },
            _renderDetail: function(t, e, i, n, a) {
                var r = t.getModel("detail")
                  , o = +t.get("min")
                  , s = +t.get("max");
                if (r.get("show")) {
                    var l = r.get("offsetCenter")
                      , u = a.cx + XM(l[0], a.r)
                      , h = a.cy + XM(l[1], a.r)
                      , c = XM(r.get("width"), a.r)
                      , d = XM(r.get("height"), a.r)
                      , p = t.getData()
                      , f = p.get(p.mapDimension("value"), 0)
                      , g = n(KM(f, [o, s], [0, 1], !0));
                    this.group.add(new Fs.Text({
                        silent: !0,
                        style: Fs.setTextStyle({}, r, {
                            x: u,
                            y: h,
                            text: $M(f, r.get("formatter")),
                            textWidth: isNaN(c) ? null : c,
                            textHeight: isNaN(d) ? null : d,
                            textAlign: "center",
                            textVerticalAlign: "middle"
                        }, {
                            autoColor: g,
                            forceRich: !0
                        })
                    }))
                }
            }
        }),
        aa.defaultEmphasis)
          , tI = Gm.extendSeriesModel({
            type: "series.funnel",
            init: function(t) {
                tI.superApply(this, "init", arguments),
                this.legendDataProvider = function() {
                    return this.getRawData()
                }
                ,
                this._defaultLabelLine(t)
            },
            getInitialData: function(t, e) {
                return Lx(this, ["value"])
            },
            _defaultLabelLine: function(t) {
                QM(t, "labelLine", ["show"]);
                var e = t.labelLine
                  , i = t.emphasis.labelLine;
                e.show = e.show && t.label.show,
                i.show = i.show && t.emphasis.label.show
            },
            getDataParams: function(t) {
                var e = this.getData()
                  , i = tI.superCall(this, "getDataParams", t)
                  , n = e.mapDimension("value")
                  , a = e.getSum(n);
                return i.percent = a ? +(e.get(n, t) / a * 100).toFixed(2) : 0,
                i.$vars.push("percent"),
                i
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                legendHoverLink: !0,
                left: 80,
                top: 60,
                right: 80,
                bottom: 60,
                minSize: "0%",
                maxSize: "100%",
                sort: "descending",
                gap: 0,
                funnelAlign: "center",
                label: {
                    show: !0,
                    position: "outer"
                },
                labelLine: {
                    show: !0,
                    length: 20,
                    lineStyle: {
                        width: 1,
                        type: "solid"
                    }
                },
                itemStyle: {
                    borderColor: "#fff",
                    borderWidth: 1
                },
                emphasis: {
                    label: {
                        show: !0
                    }
                }
            }
        });
        function eI(t, e) {
            Fs.Group.call(this);
            var i = new Fs.Polygon
              , n = new Fs.Polyline
              , a = new Fs.Text;
            function r() {
                n.ignore = n.hoverIgnore,
                a.ignore = a.hoverIgnore
            }
            function o() {
                n.ignore = n.normalIgnore,
                a.ignore = a.normalIgnore
            }
            this.add(i),
            this.add(n),
            this.add(a),
            this.updateData(t, e, !0),
            this.on("emphasis", r).on("normal", o).on("mouseover", r).on("mouseout", o)
        }
        var iI = eI.prototype
          , nI = ["itemStyle", "opacity"];
        iI.updateData = function(t, e, i) {
            var n = this.childAt(0)
              , a = t.hostModel
              , r = t.getItemModel(e)
              , o = t.getItemLayout(e)
              , s = t.getItemModel(e).get(nI);
            s = null == s ? 1 : s,
            n.useStyle({}),
            i ? (n.setShape({
                points: o.points
            }),
            n.setStyle({
                opacity: 0
            }),
            Fs.initProps(n, {
                style: {
                    opacity: s
                }
            }, a, e)) : Fs.updateProps(n, {
                style: {
                    opacity: s
                },
                shape: {
                    points: o.points
                }
            }, a, e);
            var l = r.getModel("itemStyle")
              , u = t.getItemVisual(e, "color");
            n.setStyle(it.defaults({
                lineJoin: "round",
                fill: u
            }, l.getItemStyle(["opacity"]))),
            n.hoverStyle = l.getModel("emphasis").getItemStyle(),
            this._updateLabel(t, e),
            Fs.setHoverStyle(this)
        }
        ,
        iI._updateLabel = function(t, e) {
            var i = this.childAt(1)
              , n = this.childAt(2)
              , a = t.hostModel
              , r = t.getItemModel(e)
              , o = t.getItemLayout(e).label
              , s = t.getItemVisual(e, "color");
            Fs.updateProps(i, {
                shape: {
                    points: o.linePoints || o.linePoints
                }
            }, a, e),
            Fs.updateProps(n, {
                style: {
                    x: o.x,
                    y: o.y
                }
            }, a, e),
            n.attr({
                rotation: o.rotation,
                origin: [o.x, o.y],
                z2: 10
            });
            var l = r.getModel("label")
              , u = r.getModel("emphasis.label")
              , h = r.getModel("labelLine")
              , c = r.getModel("emphasis.labelLine");
            s = t.getItemVisual(e, "color");
            Fs.setLabelStyle(n.style, n.hoverStyle = {}, l, u, {
                labelFetcher: t.hostModel,
                labelDataIndex: e,
                defaultText: t.getName(e),
                autoColor: s,
                useInsideStyle: !!o.inside
            }, {
                textAlign: o.textAlign,
                textVerticalAlign: o.verticalAlign
            }),
            n.ignore = n.normalIgnore = !l.get("show"),
            n.hoverIgnore = !u.get("show"),
            i.ignore = i.normalIgnore = !h.get("show"),
            i.hoverIgnore = !c.get("show"),
            i.setStyle({
                stroke: s
            }),
            i.setStyle(h.getModel("lineStyle").getLineStyle()),
            i.hoverStyle = c.getModel("lineStyle").getLineStyle()
        }
        ,
        it.inherits(eI, Fs.Group);
        Xc.extend({
            type: "funnel",
            render: function(t, e, i) {
                var n = t.getData()
                  , a = this._data
                  , r = this.group;
                n.diff(a).add(function(t) {
                    var e = new eI(n,t);
                    n.setItemGraphicEl(t, e),
                    r.add(e)
                }).update(function(t, e) {
                    var i = a.getItemGraphicEl(e);
                    i.updateData(n, t),
                    r.add(i),
                    n.setItemGraphicEl(t, i)
                }).remove(function(t) {
                    var e = a.getItemGraphicEl(t);
                    r.remove(e)
                }).execute(),
                this._data = n
            },
            remove: function() {
                this.group.removeAll(),
                this._data = null
            },
            dispose: function() {}
        });
        var aI = ol.parsePercent
          , rI = ol.linearMap;
        function oI(t, b, e) {
            t.eachSeriesByType("funnel", function(t) {
                var r = t.getData()
                  , o = r.mapDimension("value")
                  , e = t.get("sort")
                  , s = function(t, e) {
                    return Il.getLayoutRect(t.getBoxLayoutParams(), {
                        width: e.getWidth(),
                        height: e.getHeight()
                    })
                }(t, b)
                  , i = function(t, e) {
                    for (var i = t.mapDimension("value"), n = t.mapArray(i, function(t) {
                        return t
                    }), a = [], r = "ascending" === e, o = 0, s = t.count(); o < s; o++)
                        a[o] = o;
                    return "function" == typeof e ? a.sort(e) : "none" !== e && a.sort(function(t, e) {
                        return r ? n[t] - n[e] : n[e] - n[t]
                    }),
                    a
                }(r, e)
                  , l = [aI(t.get("minSize"), s.width), aI(t.get("maxSize"), s.width)]
                  , n = r.getDataExtent(o)
                  , u = t.get("min")
                  , h = t.get("max");
                null == u && (u = Math.min(n[0], 0)),
                null == h && (h = n[1]);
                function a(t, e) {
                    var i, n = r.get(o, t) || 0, a = rI(n, [u, h], l, !0);
                    switch (c) {
                    case "left":
                        i = s.x;
                        break;
                    case "center":
                        i = s.x + (s.width - a) / 2;
                        break;
                    case "right":
                        i = s.x + s.width - a
                    }
                    return [[i, e], [i + a, e]]
                }
                var c = t.get("funnelAlign")
                  , d = t.get("gap")
                  , p = (s.height - d * (r.count() - 1)) / r.count()
                  , f = s.y;
                "ascending" === e && (p = -p,
                d = -d,
                f += s.height,
                i = i.reverse());
                for (var g = 0; g < i.length; g++) {
                    var m = i[g]
                      , v = i[g + 1]
                      , y = r.getItemModel(m).get("itemStyle.height");
                    null == y ? y = p : (y = aI(y, s.height),
                    "ascending" === e && (y = -y));
                    var x = a(m, f)
                      , _ = a(v, f + y);
                    f += y + d,
                    r.setItemLayout(m, {
                        points: x.concat(_.slice().reverse())
                    })
                }
                !function(g) {
                    g.each(function(t) {
                        var e, i, n, a, r = g.getItemModel(t), o = r.getModel("label").get("position"), s = r.getModel("labelLine"), l = g.getItemLayout(t), u = l.points, h = "inner" === o || "inside" === o || "center" === o;
                        if (h)
                            e = "center",
                            a = [[i = (u[0][0] + u[1][0] + u[2][0] + u[3][0]) / 4, n = (u[0][1] + u[1][1] + u[2][1] + u[3][1]) / 4], [i, n]];
                        else {
                            var c, d, p, f = s.get("length");
                            e = "left" === o ? (c = (u[3][0] + u[0][0]) / 2,
                            d = (u[3][1] + u[0][1]) / 2,
                            i = (p = c - f) - 5,
                            "right") : (c = (u[1][0] + u[2][0]) / 2,
                            d = (u[1][1] + u[2][1]) / 2,
                            i = (p = c + f) + 5,
                            "left");
                            a = [[c, d], [p, d]],
                            n = d
                        }
                        l.label = {
                            linePoints: a,
                            x: i,
                            y: n,
                            verticalAlign: "middle",
                            textAlign: e,
                            inside: h
                        }
                    })
                }(r)
            })
        }
        Gm.registerVisual(Fx("funnel")),
        Gm.registerLayout(oI),
        Gm.registerProcessor(Kx("funnel"));
        function sI(t) {
            !function(t) {
                if (t.parallel)
                    return;
                var e = !1;
                it.each(t.series, function(t) {
                    t && "parallel" === t.type && (e = !0)
                }),
                e && (t.parallel = [{}])
            }(t),
            function(n) {
                var t = aa.normalizeToArray(n.parallelAxis);
                it.each(t, function(t) {
                    if (it.isObject(t)) {
                        var e = t.parallelIndex || 0
                          , i = aa.normalizeToArray(n.parallel)[e];
                        i && i.parallelAxisDefault && it.merge(t, i.parallelAxisDefault, !1)
                    }
                })
            }(t)
        }
        function lI(t, e, i, n, a) {
            wm.call(this, t, e, i),
            this.type = n || "value",
            this.axisIndex = a
        }
        lI.prototype = {
            constructor: lI,
            model: null,
            isHorizontal: function() {
                return "horizontal" !== this.coordinateSystem.getModel().get("layout")
            }
        },
        it.inherits(lI, wm);
        var uI = lI;
        function hI(t, e) {
            var i = t[e] - t[1 - e];
            return {
                span: Math.abs(i),
                sign: 0 < i ? -1 : i < 0 ? 1 : e ? -1 : 1
            }
        }
        function cI(t, e) {
            return Math.min(e[1], Math.max(e[0], t))
        }
        var dI = function(t, e, i, n, a, r) {
            e[0] = cI(e[0], i),
            e[1] = cI(e[1], i),
            t = t || 0;
            var o = i[1] - i[0];
            null != a && (a = cI(a, [0, o])),
            null != r && (r = Math.max(r, null != a ? a : 0)),
            "all" === n && (a = r = Math.abs(e[1] - e[0]),
            n = 0);
            var s = hI(e, n);
            e[n] += t;
            var l = a || 0
              , u = i.slice();
            s.sign < 0 ? u[0] += l : u[1] -= l,
            e[n] = cI(e[n], u);
            var h = hI(e, n);
            return null != a && (h.sign !== s.sign || h.span < a) && (e[1 - n] = e[n] + s.sign * a),
            h = hI(e, n),
            null != r && h.span > r && (e[1 - n] = e[n] + h.sign * r),
            e
        }
          , pI = it.each
          , fI = Math.min
          , gI = Math.max
          , mI = Math.floor
          , vI = Math.ceil
          , yI = ol.round
          , xI = Math.PI;
        function _I(t, e, i) {
            this._axesMap = it.createHashMap(),
            this._axesLayout = {},
            this.dimensions = t.dimensions,
            this._rect,
            this._model = t,
            this._init(t, e, i)
        }
        function bI(t, e) {
            return fI(gI(t, e[0]), e[1])
        }
        _I.prototype = {
            type: "parallel",
            constructor: _I,
            _init: function(t, o, e) {
                var i = t.dimensions
                  , s = t.parallelAxisIndex;
                pI(i, function(t, e) {
                    var i = s[e]
                      , n = o.getComponent("parallelAxis", i)
                      , a = this._axesMap.set(t, new uI(t,Lg.createScaleByModel(n),[0, 0],n.get("type"),i))
                      , r = "category" === a.type;
                    a.onBand = r && n.get("boundaryGap"),
                    a.inverse = n.get("inverse"),
                    (n.axis = a).model = n,
                    a.coordinateSystem = n.coordinateSystem = this
                }, this)
            },
            update: function(t, e) {
                this._updateAxesFromSeries(this._model, t)
            },
            containPoint: function(t) {
                var e = this._makeLayoutInfo()
                  , i = e.axisBase
                  , n = e.layoutBase
                  , a = e.pixelDimIndex
                  , r = t[1 - a]
                  , o = t[a];
                return i <= r && r <= i + e.axisLength && n <= o && o <= n + e.layoutLength
            },
            getModel: function() {
                return this._model
            },
            _updateAxesFromSeries: function(e, n) {
                n.eachSeries(function(t) {
                    if (e.contains(t, n)) {
                        var i = t.getData();
                        pI(this.dimensions, function(t) {
                            var e = this._axesMap.get(t);
                            e.scale.unionExtentFromData(i, i.mapDimension(t)),
                            Lg.niceScaleExtent(e.scale, e.model)
                        }, this)
                    }
                }, this)
            },
            resize: function(t, e) {
                this._rect = Il.getLayoutRect(t.getBoxLayoutParams(), {
                    width: e.getWidth(),
                    height: e.getHeight()
                }),
                this._layoutAxes()
            },
            getRect: function() {
                return this._rect
            },
            _makeLayoutInfo: function() {
                var t, e = this._model, i = this._rect, n = ["x", "y"], a = ["width", "height"], r = e.get("layout"), o = "horizontal" === r ? 0 : 1, s = i[a[o]], l = [0, s], u = this.dimensions.length, h = bI(e.get("axisExpandWidth"), l), c = bI(e.get("axisExpandCount") || 0, [0, u]), d = e.get("axisExpandable") && 3 < u && c < u && 1 < c && 0 < h && 0 < s, p = e.get("axisExpandWindow");
                p ? (t = bI(p[1] - p[0], l),
                p[1] = p[0] + t) : (t = bI(h * (c - 1), l),
                (p = [h * (e.get("axisExpandCenter") || mI(u / 2)) - t / 2])[1] = p[0] + t);
                var f = (s - t) / (u - c);
                f < 3 && (f = 0);
                var g = [mI(yI(p[0] / h, 1)) + 1, vI(yI(p[1] / h, 1)) - 1]
                  , m = f / h * p[0];
                return {
                    layout: r,
                    pixelDimIndex: o,
                    layoutBase: i[n[o]],
                    layoutLength: s,
                    axisBase: i[n[1 - o]],
                    axisLength: i[a[1 - o]],
                    axisExpandable: d,
                    axisExpandWidth: h,
                    axisCollapseWidth: f,
                    axisExpandWindow: p,
                    axisCount: u,
                    winInnerIndices: g,
                    axisExpandWindow0Pos: m
                }
            },
            _layoutAxes: function() {
                var l = this._rect
                  , t = this._axesMap
                  , e = this.dimensions
                  , u = this._makeLayoutInfo()
                  , h = u.layout;
                t.each(function(t) {
                    var e = [0, u.axisLength]
                      , i = t.inverse ? 1 : 0;
                    t.setExtent(e[i], e[1 - i])
                }),
                pI(e, function(t, e) {
                    var i = (u.axisExpandable ? function(t, e) {
                        var i, n, a = e.layoutLength, r = e.axisExpandWidth, o = e.axisCount, s = e.axisCollapseWidth, l = e.winInnerIndices, u = s, h = !1;
                        t < l[0] ? (i = t * s,
                        n = s) : t <= l[1] ? (i = e.axisExpandWindow0Pos + t * r - e.axisExpandWindow[0],
                        u = r,
                        h = !0) : (i = a - (o - 1 - t) * s,
                        n = s);
                        return {
                            position: i,
                            axisNameAvailableWidth: u,
                            axisLabelShow: h,
                            nameTruncateMaxWidth: n
                        }
                    }
                    : function(t, e) {
                        var i = e.layoutLength / (e.axisCount - 1);
                        return {
                            position: i * t,
                            axisNameAvailableWidth: i,
                            axisLabelShow: !0
                        }
                    }
                    )(e, u)
                      , n = {
                        horizontal: {
                            x: i.position,
                            y: u.axisLength
                        },
                        vertical: {
                            x: 0,
                            y: i.position
                        }
                    }
                      , a = {
                        horizontal: xI / 2,
                        vertical: 0
                    }
                      , r = [n[h].x + l.x, n[h].y + l.y]
                      , o = a[h]
                      , s = ct.create();
                    ct.rotate(s, s, o),
                    ct.translate(s, s, r),
                    this._axesLayout[t] = {
                        position: r,
                        rotation: o,
                        transform: s,
                        axisNameAvailableWidth: i.axisNameAvailableWidth,
                        axisLabelShow: i.axisLabelShow,
                        nameTruncateMaxWidth: i.nameTruncateMaxWidth,
                        tickDirection: 1,
                        labelDirection: 1
                    }
                }, this)
            },
            getAxis: function(t) {
                return this._axesMap.get(t)
            },
            dataToPoint: function(t, e) {
                return this.axisCoordToPoint(this._axesMap.get(e).dataToCoord(t), e)
            },
            eachActiveState: function(e, t, i, n) {
                null == i && (i = 0),
                null == n && (n = e.count());
                var a = this._axesMap
                  , r = this.dimensions
                  , o = []
                  , s = [];
                it.each(r, function(t) {
                    o.push(e.mapDimension(t)),
                    s.push(a.get(t).model)
                });
                for (var l = this.hasAxisBrushed(), u = i; u < n; u++) {
                    var h;
                    if (l) {
                        h = "active";
                        for (var c = e.getValues(o, u), d = 0, p = r.length; d < p; d++) {
                            if ("inactive" === s[d].getActiveState(c[d])) {
                                h = "inactive";
                                break
                            }
                        }
                    } else
                        h = "normal";
                    t(h, u)
                }
            },
            hasAxisBrushed: function() {
                for (var t = this.dimensions, e = this._axesMap, i = !1, n = 0, a = t.length; n < a; n++)
                    "normal" !== e.get(t[n]).model.getActiveState() && (i = !0);
                return i
            },
            axisCoordToPoint: function(t, e) {
                var i = this._axesLayout[e];
                return Fs.applyTransform([t, 0], i.transform)
            },
            getAxisLayout: function(t) {
                return it.clone(this._axesLayout[t])
            },
            getSlidedAxisExpandWindow: function(t) {
                var e = this._makeLayoutInfo()
                  , i = e.pixelDimIndex
                  , n = e.axisExpandWindow.slice()
                  , a = n[1] - n[0]
                  , r = [0, e.axisExpandWidth * (e.axisCount - 1)];
                if (!this.containPoint(t))
                    return {
                        behavior: "none",
                        axisExpandWindow: n
                    };
                var o, s = t[i] - e.layoutBase - e.axisExpandWindow0Pos, l = "slide", u = e.axisCollapseWidth, h = this._model.get("axisExpandSlideTriggerArea"), c = null != h[0];
                if (u)
                    c && u && s < a * h[0] ? (l = "jump",
                    o = s - a * h[2]) : c && u && s > a * (1 - h[0]) ? (l = "jump",
                    o = s - a * (1 - h[2])) : 0 <= (o = s - a * h[1]) && (o = s - a * (1 - h[1])) <= 0 && (o = 0),
                    (o *= e.axisExpandWidth / u) ? dI(o, n, r, "all") : l = "none";
                else {
                    a = n[1] - n[0];
                    (n = [gI(0, r[1] * s / a - a / 2)])[1] = fI(r[1], n[0] + a),
                    n[0] = n[1] - a
                }
                return {
                    axisExpandWindow: n,
                    behavior: l
                }
            }
        };
        var wI = _I;
        ju.register("parallel", {
            create: function(n, a) {
                var r = [];
                return n.eachComponent("parallel", function(t, e) {
                    var i = new wI(t,n,a);
                    i.name = "parallel_" + e,
                    i.resize(t, a),
                    (t.coordinateSystem = i).model = t,
                    r.push(i)
                }),
                n.eachSeries(function(t) {
                    if ("parallel" === t.get("coordinateSystem")) {
                        var e = n.queryComponents({
                            mainType: "parallel",
                            index: t.get("parallelIndex"),
                            id: t.get("parallelId")
                        })[0];
                        t.coordinateSystem = e.coordinateSystem
                    }
                }),
                r
            }
        });
        var SI = Pl.extend({
            type: "baseParallelAxis",
            axis: null,
            activeIntervals: [],
            getAreaSelectStyle: function() {
                return da([["fill", "color"], ["lineWidth", "borderWidth"], ["stroke", "borderColor"], ["width", "width"], ["opacity", "opacity"]])(this.getModel("areaSelectStyle"))
            },
            setActiveIntervals: function(t) {
                var e = this.activeIntervals = it.clone(t);
                if (e)
                    for (var i = e.length - 1; 0 <= i; i--)
                        ol.asc(e[i])
            },
            getActiveState: function(t) {
                var e = this.activeIntervals;
                if (!e.length)
                    return "normal";
                if (null == t || isNaN(t))
                    return "inactive";
                if (1 === e.length) {
                    var i = e[0];
                    if (i[0] <= t && t <= i[1])
                        return "active"
                } else
                    for (var n = 0, a = e.length; n < a; n++)
                        if (e[n][0] <= t && t <= e[n][1])
                            return "active";
                return "inactive"
            }
        });
        it.merge(SI.prototype, Pg),
        sy("parallel", SI, function(t, e) {
            return e.type || (e.data ? "category" : "value")
        }, {
            type: "value",
            dim: null,
            areaSelectStyle: {
                width: 20,
                borderWidth: 1,
                borderColor: "rgba(160,197,232)",
                color: "rgba(160,197,232)",
                opacity: .3
            },
            realtime: !0,
            z: 10
        });
        Pl.extend({
            type: "parallel",
            dependencies: ["parallelAxis"],
            coordinateSystem: null,
            dimensions: null,
            parallelAxisIndex: null,
            layoutMode: "box",
            defaultOption: {
                zlevel: 0,
                z: 0,
                left: 80,
                top: 60,
                right: 80,
                bottom: 60,
                layout: "horizontal",
                axisExpandable: !1,
                axisExpandCenter: null,
                axisExpandCount: 0,
                axisExpandWidth: 50,
                axisExpandRate: 17,
                axisExpandDebounce: 50,
                axisExpandSlideTriggerArea: [-.15, .05, .4],
                axisExpandTriggerOn: "click",
                parallelAxisDefault: null
            },
            init: function() {
                Pl.prototype.init.apply(this, arguments),
                this.mergeOption({})
            },
            mergeOption: function(t) {
                var e = this.option;
                t && it.merge(e, t, !0),
                this._initDimensions()
            },
            contains: function(t, e) {
                var i = t.get("parallelIndex");
                return null != i && e.getComponent("parallel", i) === this
            },
            setAxisExpand: function(e) {
                it.each(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function(t) {
                    e.hasOwnProperty(t) && (this.option[t] = e[t])
                }, this)
            },
            _initDimensions: function() {
                var e = this.dimensions = []
                  , i = this.parallelAxisIndex = []
                  , t = it.filter(this.dependentModels.parallelAxis, function(t) {
                    return (t.get("parallelIndex") || 0) === this.componentIndex
                }, this);
                it.each(t, function(t) {
                    e.push("dim" + t.get("dim")),
                    i.push(t.componentIndex)
                })
            }
        });
        Gm.registerAction({
            type: "axisAreaSelect",
            event: "axisAreaSelected"
        }, function(e, t) {
            t.eachComponent({
                mainType: "parallelAxis",
                query: e
            }, function(t) {
                t.axis.model.setActiveIntervals(e.intervals)
            })
        }),
        Gm.registerAction("parallelAxisExpand", function(e, t) {
            t.eachComponent({
                mainType: "parallel",
                query: e
            }, function(t) {
                t.setAxisExpand(e)
            })
        });
        var MI = it.curry
          , II = it.each
          , AI = it.map
          , TI = Math.min
          , CI = Math.max
          , DI = Math.pow
          , LI = 1e4
          , PI = 6
          , kI = 6
          , OI = "globalPan"
          , RI = {
            w: [0, 0],
            e: [0, 1],
            n: [1, 0],
            s: [1, 1]
        }
          , NI = {
            w: "ew",
            e: "ew",
            n: "ns",
            s: "ns",
            ne: "nesw",
            sw: "nesw",
            nw: "nwse",
            se: "nwse"
        }
          , EI = {
            brushStyle: {
                lineWidth: 2,
                stroke: "rgba(0,0,0,0.3)",
                fill: "rgba(0,0,0,0.1)"
            },
            transformable: !0,
            brushMode: "single",
            removeOnClick: !1
        }
          , zI = 0;
        function VI(t) {
            nt.call(this),
            this._zr = t,
            this.group = new Fs.Group,
            this._brushType,
            this._brushOption,
            this._panels,
            this._track = [],
            this._dragging,
            this._covers = [],
            this._creatingCover,
            this._creatingPanel,
            this._enableGlobalPan,
            this._uid = "brushController_" + zI++,
            this._handlers = {},
            II(hA, function(t, e) {
                this._handlers[e] = it.bind(t, this)
            }, this)
        }
        function BI(t, e) {
            var i = dA[e.brushType].createCover(t, e);
            return i.__brushOption = e,
            HI(i, e),
            t.group.add(i),
            i
        }
        function GI(t, e) {
            var i = ZI(e);
            return i.endCreating && (i.endCreating(t, e),
            HI(e, e.__brushOption)),
            e
        }
        function FI(t, e) {
            var i = e.__brushOption;
            ZI(e).updateCoverShape(t, e, i.range, i)
        }
        function HI(t, e) {
            var i = e.z;
            null == i && (i = LI),
            t.traverse(function(t) {
                t.z = i,
                t.z2 = i
            })
        }
        function WI(t, e) {
            ZI(e).updateCommon(t, e),
            FI(t, e)
        }
        function ZI(t) {
            return dA[t.__brushOption.brushType]
        }
        function UI(t, e, i) {
            var n, a = t._panels;
            if (!a)
                return !0;
            var r = t._transform;
            return II(a, function(t) {
                t.isTargetByCursor(e, i, r) && (n = t)
            }),
            n
        }
        function YI(t, e) {
            var i = t._panels;
            if (!i)
                return !0;
            var n = e.__brushOption.panelId;
            return null == n || i[n]
        }
        function jI(e) {
            var t = e._covers
              , i = t.length;
            return II(t, function(t) {
                e.group.remove(t)
            }, e),
            t.length = 0,
            !!i
        }
        function XI(t, e) {
            var i = AI(t._covers, function(t) {
                var e = t.__brushOption
                  , i = it.clone(e.range);
                return {
                    brushType: e.brushType,
                    panelId: e.panelId,
                    range: i
                }
            });
            t.trigger("brush", i, {
                isEnd: !!e.isEnd,
                removeOnClick: !!e.removeOnClick
            })
        }
        function qI(t) {
            var e = t.length - 1;
            return e < 0 && (e = 0),
            [t[0], t[e]]
        }
        function KI(e, i, t, n) {
            var a = new Fs.Group;
            return a.add(new Fs.Rect({
                name: "main",
                style: tA(t),
                silent: !0,
                draggable: !0,
                cursor: "move",
                drift: MI(e, i, a, "nswe"),
                ondragend: MI(XI, i, {
                    isEnd: !0
                })
            })),
            II(n, function(t) {
                a.add(new Fs.Rect({
                    name: t,
                    style: {
                        opacity: 0
                    },
                    draggable: !0,
                    silent: !0,
                    invisible: !0,
                    drift: MI(e, i, a, t),
                    ondragend: MI(XI, i, {
                        isEnd: !0
                    })
                }))
            }),
            a
        }
        function $I(t, e, i, n) {
            var a = n.brushStyle.lineWidth || 0
              , r = CI(a, kI)
              , o = i[0][0]
              , s = i[1][0]
              , l = o - a / 2
              , u = s - a / 2
              , h = i[0][1]
              , c = i[1][1]
              , d = h - r + a / 2
              , p = c - r + a / 2
              , f = h - o
              , g = c - s
              , m = f + a
              , v = g + a;
            QI(t, e, "main", o, s, f, g),
            n.transformable && (QI(t, e, "w", l, u, r, v),
            QI(t, e, "e", d, u, r, v),
            QI(t, e, "n", l, u, m, r),
            QI(t, e, "s", l, p, m, r),
            QI(t, e, "nw", l, u, r, r),
            QI(t, e, "ne", d, u, r, r),
            QI(t, e, "sw", l, p, r, r),
            QI(t, e, "se", d, p, r, r))
        }
        function JI(n, a) {
            var t = a.__brushOption
              , r = t.transformable
              , e = a.childAt(0);
            e.useStyle(tA(t)),
            e.attr({
                silent: !r,
                cursor: r ? "move" : "default"
            }),
            II(["w", "e", "n", "s", "se", "sw", "ne", "nw"], function(t) {
                var e = a.childOfName(t)
                  , i = function t(e, i) {
                    {
                        if (1 < i.length) {
                            i = i.split("");
                            var n = [t(e, i[0]), t(e, i[1])];
                            return "e" !== n[0] && "w" !== n[0] || n.reverse(),
                            n.join("")
                        }
                        var a = {
                            w: "left",
                            e: "right",
                            n: "top",
                            s: "bottom"
                        }
                          , r = {
                            left: "w",
                            right: "e",
                            top: "n",
                            bottom: "s"
                        }
                          , n = Fs.transformDirection(a[i], (o = e,
                        Fs.getTransform(o.group)));
                        return r[n]
                    }
                    var o
                }(n, t);
                e && e.attr({
                    silent: !r,
                    invisible: !r,
                    cursor: r ? NI[i] + "-resize" : null
                })
            })
        }
        function QI(t, e, i, n, a, r, o) {
            var s = e.childOfName(i);
            s && s.setShape(function(t) {
                var e = TI(t[0][0], t[1][0])
                  , i = TI(t[0][1], t[1][1])
                  , n = CI(t[0][0], t[1][0])
                  , a = CI(t[0][1], t[1][1]);
                return {
                    x: e,
                    y: i,
                    width: n - e,
                    height: a - i
                }
            }(rA(t, e, [[n, a], [n + r, a + o]])))
        }
        function tA(t) {
            return it.defaults({
                strokeNoScale: !0
            }, t.brushStyle)
        }
        function eA(t, e, i, n) {
            var a = [TI(t, i), TI(e, n)]
              , r = [CI(t, i), CI(e, n)];
            return [[a[0], r[0]], [a[1], r[1]]]
        }
        function iA(t, e, i, n, a, r, o, s) {
            var l = n.__brushOption
              , u = t(l.range)
              , h = aA(i, r, o);
            II(a.split(""), function(t) {
                var e = RI[t];
                u[e[0]][e[1]] += h[e[0]]
            }),
            l.range = e(eA(u[0][0], u[1][0], u[0][1], u[1][1])),
            WI(i, n),
            XI(i, {
                isEnd: !1
            })
        }
        function nA(t, e, i, n, a) {
            var r = e.__brushOption.range
              , o = aA(t, i, n);
            II(r, function(t) {
                t[0] += o[0],
                t[1] += o[1]
            }),
            WI(t, e),
            XI(t, {
                isEnd: !1
            })
        }
        function aA(t, e, i) {
            var n = t.group
              , a = n.transformCoordToLocal(e, i)
              , r = n.transformCoordToLocal(0, 0);
            return [a[0] - r[0], a[1] - r[1]]
        }
        function rA(t, e, i) {
            var n = YI(t, e);
            return n && !0 !== n ? n.clipPath(i, t._transform) : it.clone(i)
        }
        function oA(t) {
            var e = t.event;
            e.preventDefault && e.preventDefault()
        }
        function sA(t, e, i) {
            return t.childOfName("main").contain(e, i)
        }
        function lA(t, e, i, n) {
            var a, r = t._creatingCover, o = t._creatingPanel, s = t._brushOption;
            if (t._track.push(i.slice()),
            function(t) {
                var e = t._track;
                if (!e.length)
                    return !1;
                var i = e[e.length - 1]
                  , n = e[0]
                  , a = i[0] - n[0]
                  , r = i[1] - n[1]
                  , o = DI(a * a + r * r, .5);
                return PI < o
            }(t) || r) {
                if (o && !r) {
                    "single" === s.brushMode && jI(t);
                    var l = it.clone(s);
                    l.brushType = uA(l.brushType, o),
                    l.panelId = !0 === o ? null : o.panelId,
                    r = t._creatingCover = BI(t, l),
                    t._covers.push(r)
                }
                if (r) {
                    var u = dA[uA(t._brushType, o)];
                    r.__brushOption.range = u.getCreatingRange(rA(t, r, t._track)),
                    n && (GI(t, r),
                    u.updateCommon(t, r)),
                    FI(t, r),
                    a = {
                        isEnd: n
                    }
                }
            } else
                n && "single" === s.brushMode && s.removeOnClick && UI(t, e, i) && jI(t) && (a = {
                    isEnd: n,
                    removeOnClick: !0
                });
            return a
        }
        function uA(t, e) {
            return "auto" === t ? e.defaultBrushType : t
        }
        VI.prototype = {
            constructor: VI,
            enableBrush: function(t) {
                return this._brushType && function(t) {
                    var i = t._zr;
                    j_.release(i, OI, t._uid),
                    II(t._handlers, function(t, e) {
                        i.off(e, t)
                    }),
                    t._brushType = t._brushOption = null
                }(this),
                t.brushType && function(t, e) {
                    var i = t._zr;
                    t._enableGlobalPan || j_.take(i, OI, t._uid);
                    II(t._handlers, function(t, e) {
                        i.on(e, t)
                    }),
                    t._brushType = e.brushType,
                    t._brushOption = it.merge(it.clone(EI), e, !0)
                }(this, t),
                this
            },
            setPanels: function(t) {
                if (t && t.length) {
                    var e = this._panels = {};
                    it.each(t, function(t) {
                        e[t.panelId] = it.clone(t)
                    })
                } else
                    this._panels = null;
                return this
            },
            mount: function(t) {
                t = t || {},
                this._enableGlobalPan = t.enableGlobalPan;
                var e = this.group;
                return this._zr.add(e),
                e.attr({
                    position: t.position || [0, 0],
                    rotation: t.rotation || 0,
                    scale: t.scale || [1, 1]
                }),
                this._transform = e.getLocalTransform(),
                this
            },
            eachCover: function(t, e) {
                II(this._covers, t, e)
            },
            updateCovers: function(a) {
                a = it.map(a, function(t) {
                    return it.merge(it.clone(EI), t, !0)
                });
                var i = "\0-brush-index-"
                  , r = this._covers
                  , o = this._covers = []
                  , s = this
                  , l = this._creatingCover;
                return new wp(r,a,function(t, e) {
                    return n(t.__brushOption, e)
                }
                ,n).add(t).update(t).remove(function(t) {
                    r[t] !== l && s.group.remove(r[t])
                }).execute(),
                this;
                function n(t, e) {
                    return (null != t.id ? t.id : i + e) + "-" + t.brushType
                }
                function t(t, e) {
                    var i = a[t];
                    if (null != e && r[e] === l)
                        o[t] = r[e];
                    else {
                        var n = o[t] = null != e ? (r[e].__brushOption = i,
                        r[e]) : GI(s, BI(s, i));
                        WI(s, n)
                    }
                }
            },
            unmount: function() {
                return this.enableBrush(!1),
                jI(this),
                this._zr.remove(this.group),
                this
            },
            dispose: function() {
                this.unmount(),
                this.off()
            }
        },
        it.mixin(VI, nt);
        var hA = {
            mousedown: function(t) {
                if (this._dragging)
                    cA.call(this, t);
                else if (!t.target || !t.target.draggable) {
                    oA(t);
                    var e = this.group.transformCoordToLocal(t.offsetX, t.offsetY);
                    this._creatingCover = null,
                    (this._creatingPanel = UI(this, t, e)) && (this._dragging = !0,
                    this._track = [e.slice()])
                }
            },
            mousemove: function(t) {
                var e = this.group.transformCoordToLocal(t.offsetX, t.offsetY);
                if (function(t, e, i) {
                    if (t._brushType) {
                        var n = t._zr
                          , a = t._covers
                          , r = UI(t, e, i);
                        if (!t._dragging)
                            for (var o = 0; o < a.length; o++) {
                                var s = a[o].__brushOption;
                                if (r && (!0 === r || s.panelId === r.panelId) && dA[s.brushType].contain(a[o], i[0], i[1]))
                                    return
                            }
                        r && n.setCursorStyle("crosshair")
                    }
                }(this, t, e),
                this._dragging) {
                    oA(t);
                    var i = lA(this, t, e, !1);
                    i && XI(this, i)
                }
            },
            mouseup: cA
        };
        function cA(t) {
            if (this._dragging) {
                oA(t);
                var e = this.group.transformCoordToLocal(t.offsetX, t.offsetY)
                  , i = lA(this, t, e, !0);
                this._dragging = !1,
                this._track = [],
                this._creatingCover = null,
                i && XI(this, i)
            }
        }
        var dA = {
            lineX: pA(0),
            lineY: pA(1),
            rect: {
                createCover: function(t, e) {
                    return KI(MI(iA, function(t) {
                        return t
                    }, function(t) {
                        return t
                    }), t, e, ["w", "e", "n", "s", "se", "sw", "ne", "nw"])
                },
                getCreatingRange: function(t) {
                    var e = qI(t);
                    return eA(e[1][0], e[1][1], e[0][0], e[0][1])
                },
                updateCoverShape: function(t, e, i, n) {
                    $I(t, e, i, n)
                },
                updateCommon: JI,
                contain: sA
            },
            polygon: {
                createCover: function(t, e) {
                    var i = new Fs.Group;
                    return i.add(new Fs.Polyline({
                        name: "main",
                        style: tA(e),
                        silent: !0
                    })),
                    i
                },
                getCreatingRange: function(t) {
                    return t
                },
                endCreating: function(t, e) {
                    e.remove(e.childAt(0)),
                    e.add(new Fs.Polygon({
                        name: "main",
                        draggable: !0,
                        drift: MI(nA, t, e),
                        ondragend: MI(XI, t, {
                            isEnd: !0
                        })
                    }))
                },
                updateCoverShape: function(t, e, i, n) {
                    e.childAt(0).setShape({
                        points: rA(t, e, i)
                    })
                },
                updateCommon: JI,
                contain: sA
            }
        };
        function pA(l) {
            return {
                createCover: function(t, e) {
                    return KI(MI(iA, function(t) {
                        var e = [t, [0, 100]];
                        return l && e.reverse(),
                        e
                    }, function(t) {
                        return t[l]
                    }), t, e, [["w", "e"], ["n", "s"]][l])
                },
                getCreatingRange: function(t) {
                    var e = qI(t);
                    return [TI(e[0][l], e[1][l]), CI(e[0][l], e[1][l])]
                },
                updateCoverShape: function(t, e, i, n) {
                    var a, r = YI(t, e);
                    if (!0 !== r && r.getLinearBrushOtherExtent)
                        a = r.getLinearBrushOtherExtent(l, t._transform);
                    else {
                        var o = t._zr;
                        a = [0, [o.getWidth(), o.getHeight()][1 - l]]
                    }
                    var s = [i, a];
                    l && s.reverse(),
                    $I(t, e, s, n)
                },
                updateCommon: JI,
                contain: sA
            }
        }
        var fA = VI
          , gA = ob.onIrrelevantElement;
        function mA(t) {
            return Oe.create(t)
        }
        var vA = {
            makeRectPanelClipPath: function(i) {
                return i = mA(i),
                function(t, e) {
                    return Fs.clipPointsByRect(t, i)
                }
            },
            makeLinearBrushOtherExtent: function(a, r) {
                return a = mA(a),
                function(t) {
                    var e = null != r ? r : t
                      , i = e ? a.width : a.height
                      , n = e ? a.x : a.y;
                    return [n, n + (i || 0)]
                }
            },
            makeRectIsTargetByCursor: function(n, a, r) {
                return n = mA(n),
                function(t, e, i) {
                    return n.contain(e[0], e[1]) && !gA(t, a, r)
                }
            }
        }
          , yA = ["axisLine", "axisTickLabel", "axisName"]
          , xA = Gm.extendComponentView({
            type: "parallelAxis",
            init: function(t, e) {
                xA.superApply(this, "init", arguments),
                (this._brushController = new fA(e.getZr())).on("brush", it.bind(this._onBrush, this))
            },
            render: function(t, e, i, n) {
                if (!function(t, e, i) {
                    return i && "axisAreaSelect" === i.type && e.findComponents({
                        mainType: "parallelAxis",
                        query: i
                    })[0] === t
                }(t, e, n)) {
                    this.axisModel = t,
                    this.api = i,
                    this.group.removeAll();
                    var a = this._axisGroup;
                    if (this._axisGroup = new Fs.Group,
                    this.group.add(this._axisGroup),
                    t.get("show")) {
                        var r = function(t, e) {
                            return e.getComponent("parallel", t.get("parallelIndex"))
                        }(t, e)
                          , o = r.coordinateSystem
                          , s = t.getAreaSelectStyle()
                          , l = s.width
                          , u = t.axis.dim
                          , h = o.getAxisLayout(u)
                          , c = it.extend({
                            strokeContainThreshold: l
                        }, h)
                          , d = new jy(t,c);
                        it.each(yA, d.add, d),
                        this._axisGroup.add(d.getGroup()),
                        this._refreshBrushController(c, s, t, r, l, i);
                        var p = n && !1 === n.animation ? null : t;
                        Fs.groupTransition(a, this._axisGroup, p)
                    }
                }
            },
            _refreshBrushController: function(t, e, i, n, a, r) {
                var o = i.axis.getExtent()
                  , s = o[1] - o[0]
                  , l = Math.min(30, .1 * Math.abs(s))
                  , u = Fs.BoundingRect.create({
                    x: o[0],
                    y: -a / 2,
                    width: s,
                    height: a
                });
                u.x -= l,
                u.width += 2 * l,
                this._brushController.mount({
                    enableGlobalPan: !0,
                    rotation: t.rotation,
                    position: t.position
                }).setPanels([{
                    panelId: "pl",
                    clipPath: vA.makeRectPanelClipPath(u),
                    isTargetByCursor: vA.makeRectIsTargetByCursor(u, r, n),
                    getLinearBrushOtherExtent: vA.makeLinearBrushOtherExtent(u, 0)
                }]).enableBrush({
                    brushType: "lineX",
                    brushStyle: e,
                    removeOnClick: !0
                }).updateCovers(function(t) {
                    var e = t.axis;
                    return it.map(t.activeIntervals, function(t) {
                        return {
                            brushType: "lineX",
                            panelId: "pl",
                            range: [e.dataToCoord(t[0], !0), e.dataToCoord(t[1], !0)]
                        }
                    })
                }(i))
            },
            _onBrush: function(t, e) {
                var i = this.axisModel
                  , n = i.axis
                  , a = it.map(t, function(t) {
                    return [n.coordToData(t.range[0], !0), n.coordToData(t.range[1], !0)]
                });
                !i.option.realtime !== e.isEnd && !e.removeOnClick || this.api.dispatchAction({
                    type: "axisAreaSelect",
                    parallelAxisId: i.id,
                    intervals: a
                })
            },
            dispose: function() {
                this._brushController.dispose()
            }
        });
        Gm.extendComponentView({
            type: "parallel",
            render: function(t, e, i) {
                this._model = t,
                this._api = i,
                this._handlers || (this._handlers = {},
                it.each(_A, function(t, e) {
                    i.getZr().on(e, this._handlers[e] = it.bind(t, this))
                }, this)),
                Qc.createOrUpdate(this, "_throttledDispatchExpand", t.get("axisExpandRate"), "fixRate")
            },
            dispose: function(t, i) {
                it.each(this._handlers, function(t, e) {
                    i.getZr().off(e, t)
                }),
                this._handlers = null
            },
            _throttledDispatchExpand: function(t) {
                this._dispatchExpand(t)
            },
            _dispatchExpand: function(t) {
                t && this._api.dispatchAction(it.extend({
                    type: "parallelAxisExpand"
                }, t))
            }
        });
        var _A = {
            mousedown: function(t) {
                bA(this, "click") && (this._mouseDownPoint = [t.offsetX, t.offsetY])
            },
            mouseup: function(t) {
                var e = this._mouseDownPoint;
                if (bA(this, "click") && e) {
                    var i = [t.offsetX, t.offsetY];
                    if (5 < Math.pow(e[0] - i[0], 2) + Math.pow(e[1] - i[1], 2))
                        return;
                    var n = this._model.coordinateSystem.getSlidedAxisExpandWindow([t.offsetX, t.offsetY]);
                    "none" !== n.behavior && this._dispatchExpand({
                        axisExpandWindow: n.axisExpandWindow
                    })
                }
                this._mouseDownPoint = null
            },
            mousemove: function(t) {
                if (!this._mouseDownPoint && bA(this, "mousemove")) {
                    var e = this._model
                      , i = e.coordinateSystem.getSlidedAxisExpandWindow([t.offsetX, t.offsetY])
                      , n = i.behavior;
                    "jump" === n && this._throttledDispatchExpand.debounceNextCall(e.get("axisExpandDebounce")),
                    this._throttledDispatchExpand("none" === n ? null : {
                        axisExpandWindow: i.axisExpandWindow,
                        animation: "jump" === n && null
                    })
                }
            }
        };
        function bA(t, e) {
            var i = t._model;
            return i.get("axisExpandable") && i.get("axisExpandTriggerOn") === e
        }
        Gm.registerPreprocessor(sI);
        var wA = it.each
          , SA = it.createHashMap;
        kc.extend({
            type: "series.parallel",
            dependencies: ["parallel"],
            visualColorAccessPath: "lineStyle.color",
            getInitialData: function(t, e) {
                var i = this.getSource();
                return function(t, e) {
                    if (t.encodeDefine)
                        return;
                    var i = e.ecModel.getComponent("parallel", e.get("parallelIndex"));
                    if (!i)
                        return;
                    var n = t.encodeDefine = SA();
                    wA(i.dimensions, function(t) {
                        var e = function(t) {
                            return +t.replace("dim", "")
                        }(t);
                        n.set(t, e)
                    })
                }(i, this),
                Sf(i, this)
            },
            getRawIndicesByActiveState: function(i) {
                var t = this.coordinateSystem
                  , n = this.getData()
                  , a = [];
                return t.eachActiveState(n, function(t, e) {
                    i === t && a.push(n.getRawIndex(e))
                }),
                a
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "parallel",
                parallelIndex: 0,
                label: {
                    show: !1
                },
                inactiveOpacity: .05,
                activeOpacity: 1,
                lineStyle: {
                    width: 1,
                    opacity: .45,
                    type: "solid"
                },
                emphasis: {
                    label: {
                        show: !1
                    }
                },
                progressive: 500,
                smooth: !1,
                animationEasing: "linear"
            }
        });
        Xc.extend({
            type: "parallel",
            init: function() {
                this._dataGroup = new Fs.Group,
                this.group.add(this._dataGroup),
                this._data,
                this._initialized
            },
            render: function(r, t, e, o) {
                var i = this._dataGroup
                  , s = r.getData()
                  , l = this._data
                  , u = r.coordinateSystem
                  , h = u.dimensions
                  , c = AA(r);
                if (s.diff(l).add(function(t) {
                    TA(IA(s, i, t, h, u), s, t, c)
                }).update(function(t, e) {
                    var i = l.getItemGraphicEl(e)
                      , n = MA(s, t, h, u);
                    s.setItemGraphicEl(t, i);
                    var a = o && !1 === o.animation ? null : r;
                    Fs.updateProps(i, {
                        shape: {
                            points: n
                        }
                    }, a, t),
                    TA(i, s, t, c)
                }).remove(function(t) {
                    var e = l.getItemGraphicEl(t);
                    i.remove(e)
                }).execute(),
                !this._initialized) {
                    this._initialized = !0;
                    var n = function(t, e, i) {
                        var n = t.model
                          , a = t.getRect()
                          , r = new Fs.Rect({
                            shape: {
                                x: a.x,
                                y: a.y,
                                width: a.width,
                                height: a.height
                            }
                        })
                          , o = "horizontal" === n.get("layout") ? "width" : "height";
                        return r.setShape(o, 0),
                        Fs.initProps(r, {
                            shape: {
                                width: a.width,
                                height: a.height
                            }
                        }, e, i),
                        r
                    }(u, r, function() {
                        setTimeout(function() {
                            i.removeClipPath()
                        })
                    });
                    i.setClipPath(n)
                }
                this._data = s
            },
            incrementalPrepareRender: function(t, e, i) {
                this._initialized = !0,
                this._data = null,
                this._dataGroup.removeAll()
            },
            incrementalRender: function(t, e, i) {
                for (var n = e.getData(), a = e.coordinateSystem, r = a.dimensions, o = AA(e), s = t.start; s < t.end; s++) {
                    var l = IA(n, this._dataGroup, s, r, a);
                    l.incremental = !0,
                    TA(l, n, s, o)
                }
            },
            dispose: function() {},
            remove: function() {
                this._dataGroup && this._dataGroup.removeAll(),
                this._data = null
            }
        });
        function MA(t, e, i, n) {
            for (var a, r = [], o = 0; o < i.length; o++) {
                var s = i[o]
                  , l = t.get(t.mapDimension(s), e);
                a = l,
                ("category" === n.getAxis(s).type ? null == a : null == a || isNaN(a)) || r.push(n.dataToPoint(l, s))
            }
            return r
        }
        function IA(t, e, i, n, a) {
            var r = MA(t, i, n, a)
              , o = new Fs.Polyline({
                shape: {
                    points: r
                },
                silent: !0,
                z2: 10
            });
            return e.add(o),
            t.setItemGraphicEl(i, o),
            o
        }
        function AA(t) {
            var e = t.get("smooth", !0);
            return !0 === e && (e = .3),
            {
                lineStyle: t.getModel("lineStyle").getLineStyle(),
                smooth: null != e ? e : .3
            }
        }
        function TA(t, e, i, n) {
            var a = n.lineStyle;
            e.hasItemOption && (a = e.getItemModel(i).getModel("lineStyle").getLineStyle());
            t.useStyle(a);
            var r = t.style;
            r.fill = null,
            r.stroke = e.getItemVisual(i, "color"),
            r.opacity = e.getItemVisual(i, "opacity"),
            n.smooth && (t.shape.smooth = n.smooth)
        }
        var CA = ["lineStyle", "normal", "opacity"]
          , DA = {
            seriesType: "parallel",
            reset: function(t, e, i) {
                var n = t.getModel("itemStyle")
                  , a = t.getModel("lineStyle")
                  , r = e.get("color")
                  , o = a.get("color") || n.get("color") || r[t.seriesIndex % r.length]
                  , s = t.get("inactiveOpacity")
                  , l = t.get("activeOpacity")
                  , u = t.getModel("lineStyle").getLineStyle()
                  , h = t.coordinateSystem
                  , c = t.getData()
                  , d = {
                    normal: u.opacity,
                    active: l,
                    inactive: s
                };
                return c.setVisual("color", o),
                {
                    progress: function(t, a) {
                        h.eachActiveState(a, function(t, e) {
                            var i = d[t];
                            if ("normal" === t && a.hasItemOption) {
                                var n = a.getItemModel(e).get(CA, !0);
                                null != n && (i = n)
                            }
                            a.setItemVisual(e, "opacity", i)
                        }, t.start, t.end)
                    }
                }
            }
        };
        Gm.registerVisual(DA);
        var LA = fl.encodeHTML
          , PA = kc.extend({
            type: "series.sankey",
            layoutInfo: null,
            getInitialData: function(t) {
                var e = t.edges || t.links
                  , i = t.data || t.nodes;
                if (i && e)
                    return FS(i, e, this, !0).data
            },
            setNodePosition: function(t, e) {
                var i = this.option.data[t];
                i.localX = e[0],
                i.localY = e[1]
            },
            getGraph: function() {
                return this.getData().graph
            },
            getEdgeData: function() {
                return this.getGraph().edgeData
            },
            formatTooltip: function(t, e, i) {
                if ("edge" !== i)
                    return PA.superCall(this, "formatTooltip", t, e);
                var n = this.getDataParams(t, i)
                  , a = n.data
                  , r = a.source + " -- " + a.target;
                return n.value && (r += " : " + n.value),
                LA(r)
            },
            optionUpdated: function() {
                var t = this.option;
                !0 === t.focusNodeAdjacency && (t.focusNodeAdjacency = "allEdges")
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "view",
                layout: null,
                left: "5%",
                top: "5%",
                right: "20%",
                bottom: "5%",
                orient: "horizontal",
                nodeWidth: 20,
                nodeGap: 8,
                draggable: !0,
                focusNodeAdjacency: !1,
                layoutIterations: 32,
                label: {
                    show: !0,
                    position: "right",
                    color: "#000",
                    fontSize: 12
                },
                itemStyle: {
                    borderWidth: 1,
                    borderColor: "#333"
                },
                lineStyle: {
                    color: "#314656",
                    opacity: .2,
                    curveness: .5
                },
                emphasis: {
                    label: {
                        show: !0
                    },
                    lineStyle: {
                        opacity: .6
                    }
                },
                animationEasing: "linear",
                animationDuration: 1e3
            }
        })
          , kA = ["itemStyle", "opacity"]
          , OA = ["lineStyle", "opacity"];
        function RA(t, e) {
            return t.getVisual("opacity") || t.getModel().get(e)
        }
        function NA(t, e, i) {
            var n = t.getGraphicEl()
              , a = RA(t, e);
            null != i && (null == a && (a = 1),
            a *= i),
            n.downplay && n.downplay(),
            n.traverse(function(t) {
                "group" !== t.type && t.setStyle("opacity", a)
            })
        }
        function EA(t, e) {
            var i = RA(t, e)
              , n = t.getGraphicEl();
            n.highlight && n.highlight(),
            n.traverse(function(t) {
                "group" !== t.type && t.setStyle("opacity", i)
            })
        }
        var zA = Fs.extendShape({
            shape: {
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 0,
                cpx1: 0,
                cpy1: 0,
                cpx2: 0,
                cpy2: 0,
                extent: 0,
                orient: ""
            },
            buildPath: function(t, e) {
                var i = e.extent;
                "vertical" === e.orient ? (t.moveTo(e.x1, e.y1),
                t.bezierCurveTo(e.cpx1, e.cpy1, e.cpx2, e.cpy2, e.x2, e.y2),
                t.lineTo(e.x2 + i, e.y2),
                t.bezierCurveTo(e.cpx2 + i, e.cpy2, e.cpx1 + i, e.cpy1, e.x1 + i, e.y1)) : (t.moveTo(e.x1, e.y1),
                t.bezierCurveTo(e.cpx1, e.cpy1, e.cpx2, e.cpy2, e.x2, e.y2),
                t.lineTo(e.x2, e.y2 + i),
                t.bezierCurveTo(e.cpx2, e.cpy2 + i, e.cpx1, e.cpy1 + i, e.x1, e.y1 + i)),
                t.closePath()
            }
        });
        Gm.extendChartView({
            type: "sankey",
            _model: null,
            _focusAdjacencyDisabled: !1,
            render: function(b, t, n) {
                var a = this
                  , e = b.getGraph()
                  , w = this.group
                  , i = b.layoutInfo
                  , S = i.width
                  , M = i.height
                  , u = b.getData()
                  , I = b.getData("edge")
                  , A = b.get("orient");
                this._model = b,
                w.removeAll(),
                w.attr("position", [i.x, i.y]),
                e.eachEdge(function(t) {
                    var e = new zA;
                    e.dataIndex = t.dataIndex,
                    e.seriesIndex = b.seriesIndex,
                    e.dataType = "edge";
                    var i, n, a, r, o, s, l, u, h = t.getModel("lineStyle"), c = h.get("curveness"), d = t.node1.getLayout(), p = t.node1.getModel(), f = p.get("localX"), g = p.get("localY"), m = t.node2.getLayout(), v = t.node2.getModel(), y = v.get("localX"), x = v.get("localY"), _ = t.getLayout();
                    switch (e.shape.extent = Math.max(1, _.dy),
                    u = "vertical" === (e.shape.orient = A) ? (i = (null != f ? f * S : d.x) + _.sy,
                    n = (null != g ? g * M : d.y) + d.dy,
                    a = (null != y ? y * S : m.x) + _.ty,
                    o = i,
                    s = n * (1 - c) + (r = null != x ? x * M : m.y) * c,
                    l = a,
                    n * c + r * (1 - c)) : (i = (null != f ? f * S : d.x) + d.dx,
                    n = (null != g ? g * M : d.y) + _.sy,
                    o = i * (1 - c) + (a = null != y ? y * S : m.x) * c,
                    s = n,
                    l = i * c + a * (1 - c),
                    r = (null != x ? x * M : m.y) + _.ty),
                    e.setShape({
                        x1: i,
                        y1: n,
                        x2: a,
                        y2: r,
                        cpx1: o,
                        cpy1: s,
                        cpx2: l,
                        cpy2: u
                    }),
                    e.setStyle(h.getItemStyle()),
                    e.style.fill) {
                    case "source":
                        e.style.fill = t.node1.getVisual("color");
                        break;
                    case "target":
                        e.style.fill = t.node2.getVisual("color")
                    }
                    Fs.setHoverStyle(e, t.getModel("emphasis.lineStyle").getItemStyle()),
                    w.add(e),
                    I.setItemGraphicEl(t.dataIndex, e)
                }),
                e.eachNode(function(t) {
                    var e = t.getLayout()
                      , i = t.getModel()
                      , n = i.get("localX")
                      , a = i.get("localY")
                      , r = i.getModel("label")
                      , o = i.getModel("emphasis.label")
                      , s = new Fs.Rect({
                        shape: {
                            x: null != n ? n * S : e.x,
                            y: null != a ? a * M : e.y,
                            width: e.dx,
                            height: e.dy
                        },
                        style: i.getModel("itemStyle").getItemStyle()
                    })
                      , l = t.getModel("emphasis.itemStyle").getItemStyle();
                    Fs.setLabelStyle(s.style, l, r, o, {
                        labelFetcher: b,
                        labelDataIndex: t.dataIndex,
                        defaultText: t.id,
                        isRectText: !0
                    }),
                    s.setStyle("fill", t.getVisual("color")),
                    Fs.setHoverStyle(s, l),
                    w.add(s),
                    u.setItemGraphicEl(t.dataIndex, s),
                    s.dataType = "node"
                }),
                u.eachItemGraphicEl(function(t, i) {
                    var e = u.getItemModel(i);
                    e.get("draggable") && (t.drift = function(t, e) {
                        a._focusAdjacencyDisabled = !0,
                        this.shape.x += t,
                        this.shape.y += e,
                        this.dirty(),
                        n.dispatchAction({
                            type: "dragNode",
                            seriesId: b.id,
                            dataIndex: u.getRawIndex(i),
                            localX: this.shape.x / S,
                            localY: this.shape.y / M
                        })
                    }
                    ,
                    t.ondragend = function() {
                        a._focusAdjacencyDisabled = !1
                    }
                    ,
                    t.draggable = !0,
                    t.cursor = "move"),
                    e.get("focusNodeAdjacency") && (t.off("mouseover").on("mouseover", function() {
                        a._focusAdjacencyDisabled || n.dispatchAction({
                            type: "focusNodeAdjacency",
                            seriesId: b.id,
                            dataIndex: t.dataIndex
                        })
                    }),
                    t.off("mouseout").on("mouseout", function() {
                        a._focusAdjacencyDisabled || n.dispatchAction({
                            type: "unfocusNodeAdjacency",
                            seriesId: b.id
                        })
                    }))
                }),
                I.eachItemGraphicEl(function(t, e) {
                    I.getItemModel(e).get("focusNodeAdjacency") && (t.off("mouseover").on("mouseover", function() {
                        a._focusAdjacencyDisabled || n.dispatchAction({
                            type: "focusNodeAdjacency",
                            seriesId: b.id,
                            edgeDataIndex: t.dataIndex
                        })
                    }),
                    t.off("mouseout").on("mouseout", function() {
                        a._focusAdjacencyDisabled || n.dispatchAction({
                            type: "unfocusNodeAdjacency",
                            seriesId: b.id
                        })
                    }))
                }),
                !this._data && b.get("animation") && w.setClipPath(function(t, e, i) {
                    var n = new Fs.Rect({
                        shape: {
                            x: t.x - 10,
                            y: t.y - 10,
                            width: 0,
                            height: t.height + 20
                        }
                    });
                    return Fs.initProps(n, {
                        shape: {
                            width: t.width + 20,
                            height: t.height + 20
                        }
                    }, e, i),
                    n
                }(w.getBoundingRect(), b, function() {
                    w.removeClipPath()
                })),
                this._data = b.getData()
            },
            dispose: function() {},
            focusNodeAdjacency: function(t, e, i, n) {
                var a = this._model.getData()
                  , r = a.graph
                  , o = n.dataIndex
                  , s = a.getItemModel(o)
                  , l = n.edgeDataIndex;
                if (null != o || null != l) {
                    var u = r.getNodeByIndex(o)
                      , h = r.getEdgeByIndex(l);
                    if (r.eachNode(function(t) {
                        NA(t, kA, .1)
                    }),
                    r.eachEdge(function(t) {
                        NA(t, OA, .1)
                    }),
                    u) {
                        EA(u, kA);
                        var c = s.get("focusNodeAdjacency");
                        "outEdges" === c ? it.each(u.outEdges, function(t) {
                            t.dataIndex < 0 || (EA(t, OA),
                            EA(t.node2, kA))
                        }) : "inEdges" === c ? it.each(u.inEdges, function(t) {
                            t.dataIndex < 0 || (EA(t, OA),
                            EA(t.node1, kA))
                        }) : "allEdges" === c && it.each(u.edges, function(t) {
                            t.dataIndex < 0 || (EA(t, OA),
                            EA(t.node1, kA),
                            EA(t.node2, kA))
                        })
                    }
                    h && (EA(h, OA),
                    EA(h.node1, kA),
                    EA(h.node2, kA))
                }
            },
            unfocusNodeAdjacency: function(t, e, i, n) {
                var a = this._model.getGraph();
                a.eachNode(function(t) {
                    NA(t, kA)
                }),
                a.eachEdge(function(t) {
                    NA(t, OA)
                })
            }
        });
        Gm.registerAction({
            type: "dragNode",
            event: "dragNode",
            update: "update"
        }, function(e, t) {
            t.eachComponent({
                mainType: "series",
                subType: "sankey",
                query: e
            }, function(t) {
                t.setNodePosition(e.dataIndex, [e.localX, e.localY])
            })
        });
        var VA = aa.groupData;
        function BA(t, l, u, h, c) {
            it.each(t, function(t) {
                var e, i, n, a = 0, r = t.length;
                if ("vertical" === c) {
                    var o;
                    for (t.sort(function(t, e) {
                        return t.getLayout().x - e.getLayout().x
                    }),
                    n = 0; n < r; n++)
                        0 < (i = a - (e = t[n]).getLayout().x) && (o = e.getLayout().x + i,
                        e.setLayout({
                            x: o
                        }, !0)),
                        a = e.getLayout().x + e.getLayout().dx + l;
                    if (0 < (i = a - l - h))
                        for (o = e.getLayout().x - i,
                        e.setLayout({
                            x: o
                        }, !0),
                        a = o,
                        n = r - 2; 0 <= n; --n)
                            0 < (i = (e = t[n]).getLayout().x + e.getLayout().dx + l - a) && (o = e.getLayout().x - i,
                            e.setLayout({
                                x: o
                            }, !0)),
                            a = e.getLayout().x
                } else {
                    var s;
                    for (t.sort(function(t, e) {
                        return t.getLayout().y - e.getLayout().y
                    }),
                    n = 0; n < r; n++)
                        0 < (i = a - (e = t[n]).getLayout().y) && (s = e.getLayout().y + i,
                        e.setLayout({
                            y: s
                        }, !0)),
                        a = e.getLayout().y + e.getLayout().dy + l;
                    if (0 < (i = a - l - u))
                        for (s = e.getLayout().y - i,
                        e.setLayout({
                            y: s
                        }, !0),
                        a = s,
                        n = r - 2; 0 <= n; --n)
                            0 < (i = (e = t[n]).getLayout().y + e.getLayout().dy + l - a) && (s = e.getLayout().y - i,
                            e.setLayout({
                                y: s
                            }, !0)),
                            a = e.getLayout().y
                }
            })
        }
        function GA(t, a, r) {
            it.each(t.slice().reverse(), function(t) {
                it.each(t, function(t) {
                    if (t.outEdges.length) {
                        var e = UA(t.outEdges, FA, r) / UA(t.outEdges, ZA, r);
                        if ("vertical" === r) {
                            var i = t.getLayout().x + (e - WA(t, r)) * a;
                            t.setLayout({
                                x: i
                            }, !0)
                        } else {
                            var n = t.getLayout().y + (e - WA(t, r)) * a;
                            t.setLayout({
                                y: n
                            }, !0)
                        }
                    }
                })
            })
        }
        function FA(t, e) {
            return WA(t.node2, e) * t.getValue()
        }
        function HA(t, e) {
            return WA(t.node1, e) * t.getValue()
        }
        function WA(t, e) {
            return "vertical" === e ? t.getLayout().x + t.getLayout().dx / 2 : t.getLayout().y + t.getLayout().dy / 2
        }
        function ZA(t) {
            return t.getValue()
        }
        function UA(t, e, i) {
            for (var n = 0, a = t.length, r = -1; ++r < a; ) {
                var o = +e.call(t, t[r], i);
                isNaN(o) || (n += o)
            }
            return n
        }
        function YA(t, a, r) {
            it.each(t, function(t) {
                it.each(t, function(t) {
                    if (t.inEdges.length) {
                        var e = UA(t.inEdges, HA, r) / UA(t.inEdges, ZA, r);
                        if ("vertical" === r) {
                            var i = t.getLayout().x + (e - WA(t, r)) * a;
                            t.setLayout({
                                x: i
                            }, !0)
                        } else {
                            var n = t.getLayout().y + (e - WA(t, r)) * a;
                            t.setLayout({
                                y: n
                            }, !0)
                        }
                    }
                })
            })
        }
        function jA(t, u, e) {
            t.eachSeriesByType("sankey", function(t) {
                var e = t.get("nodeWidth")
                  , i = t.get("nodeGap")
                  , n = function(t, e) {
                    return Il.getLayoutRect(t.getBoxLayoutParams(), {
                        width: e.getWidth(),
                        height: e.getHeight()
                    })
                }(t, u)
                  , a = (t.layoutInfo = n).width
                  , r = n.height
                  , o = t.getGraph()
                  , s = o.nodes
                  , l = o.edges;
                !function(t) {
                    it.each(t, function(t) {
                        var e = UA(t.outEdges, ZA)
                          , i = UA(t.inEdges, ZA)
                          , n = Math.max(e, i);
                        t.setLayout({
                            value: n
                        }, !0)
                    })
                }(s),
                function(t, e, i, n, a, r, o, s) {
                    (function(t, e, i, n, a, r) {
                        for (var o = [], s = [], l = [], u = [], h = 0, c = 0, d = 0; d < e.length; d++)
                            o[d] = 1;
                        for (d = 0; d < t.length; d++)
                            s[d] = t[d].inEdges.length,
                            0 === s[d] && l.push(t[d]);
                        for (; l.length; ) {
                            for (var p = 0; p < l.length; p++) {
                                var f = l[p];
                                "vertical" === r ? (f.setLayout({
                                    y: h
                                }, !0),
                                f.setLayout({
                                    dy: i
                                }, !0)) : (f.setLayout({
                                    x: h
                                }, !0),
                                f.setLayout({
                                    dx: i
                                }, !0));
                                for (var g = 0; g < f.outEdges.length; g++) {
                                    var m = f.outEdges[g]
                                      , v = e.indexOf(m);
                                    o[v] = 0;
                                    var y = m.node2
                                      , x = t.indexOf(y);
                                    0 == --s[x] && u.push(y)
                                }
                            }
                            ++h,
                            l = u,
                            u = []
                        }
                        for (d = 0; d < o.length; d++)
                            ;
                        (function(t, e, i) {
                            it.each(t, function(t) {
                                t.outEdges.length || ("vertical" === i ? t.setLayout({
                                    y: e - 1
                                }, !0) : t.setLayout({
                                    x: e - 1
                                }, !0))
                            })
                        }
                        )(t, h, r),
                        c = "vertical" === r ? (a - i) / (h - 1) : (n - i) / (h - 1);
                        !function(t, n, a) {
                            it.each(t, function(t) {
                                if ("vertical" === a) {
                                    var e = t.getLayout().y * n;
                                    t.setLayout({
                                        y: e
                                    }, !0)
                                } else {
                                    var i = t.getLayout().x * n;
                                    t.setLayout({
                                        x: i
                                    }, !0)
                                }
                            })
                        }(t, c, r)
                    }
                    )(t, e, i, a, r, s),
                    function(t, e, i, n, a, r, o) {
                        var s = function(t, e) {
                            var i = []
                              , n = "vertical" === e ? "y" : "x"
                              , a = VA(t, function(t) {
                                return t.getLayout()[n]
                            });
                            return a.keys.sort(function(t, e) {
                                return t - e
                            }),
                            it.each(a.keys, function(t) {
                                i.push(a.buckets.get(t))
                            }),
                            i
                        }(t, o);
                        (function(t, e, i, a, r, o, s) {
                            var l = [];
                            it.each(e, function(t) {
                                var e = t.length
                                  , i = 0
                                  , n = 0;
                                it.each(t, function(t) {
                                    i += t.getLayout().value
                                }),
                                n = "vertical" === s ? (r - (e - 1) * o) / i : (a - (e - 1) * o) / i,
                                l.push(n)
                            }),
                            l.sort(function(t, e) {
                                return t - e
                            });
                            var n = l[0];
                            it.each(e, function(t) {
                                it.each(t, function(t, e) {
                                    var i = t.getLayout().value * n;
                                    "vertical" === s ? (t.setLayout({
                                        x: e
                                    }, !0),
                                    t.setLayout({
                                        dx: i
                                    }, !0)) : (t.setLayout({
                                        y: e
                                    }, !0),
                                    t.setLayout({
                                        dy: i
                                    }, !0))
                                })
                            }),
                            it.each(i, function(t) {
                                var e = +t.getValue() * n;
                                t.setLayout({
                                    dy: e
                                }, !0)
                            })
                        }
                        )(0, s, e, i, n, a, o),
                        BA(s, a, i, n, o);
                        for (var l = 1; 0 < r; r--)
                            GA(s, l *= .99, o),
                            BA(s, a, i, n, o),
                            YA(s, l, o),
                            BA(s, a, i, n, o)
                    }(t, e, r, a, n, o, s),
                    function(t, e) {
                        it.each(t, function(t) {
                            "vertical" === e ? (t.outEdges.sort(function(t, e) {
                                return t.node2.getLayout().x - e.node2.getLayout().x
                            }),
                            t.inEdges.sort(function(t, e) {
                                return t.node1.getLayout().x - e.node1.getLayout().x
                            })) : (t.outEdges.sort(function(t, e) {
                                return t.node2.getLayout().y - e.node2.getLayout().y
                            }),
                            t.inEdges.sort(function(t, e) {
                                return t.node1.getLayout().y - e.node1.getLayout().y
                            }))
                        }),
                        it.each(t, function(t) {
                            var e = 0
                              , i = 0;
                            it.each(t.outEdges, function(t) {
                                t.setLayout({
                                    sy: e
                                }, !0),
                                e += t.getLayout().dy
                            }),
                            it.each(t.inEdges, function(t) {
                                t.setLayout({
                                    ty: i
                                }, !0),
                                i += t.getLayout().dy
                            })
                        })
                    }(t, s)
                }(s, l, e, i, a, r, 0 !== it.filter(s, function(t) {
                    return 0 === t.getLayout().value
                }).length ? 0 : t.get("layoutIterations"), t.get("orient"))
            })
        }
        function XA(t, e) {
            t.eachSeriesByType("sankey", function(n) {
                var t = n.getGraph().nodes;
                if (t.length) {
                    var a = 1 / 0
                      , r = -1 / 0;
                    it.each(t, function(t) {
                        var e = t.getLayout().value;
                        e < a && (a = e),
                        r < e && (r = e)
                    }),
                    it.each(t, function(t) {
                        var e = new lS({
                            type: "color",
                            mappingMethod: "linear",
                            dataExtent: [a, r],
                            visual: n.get("color")
                        }).mapValueToVisual(t.getLayout().value);
                        t.setVisual("color", e);
                        var i = t.getModel().get("itemStyle.color");
                        null != i && t.setVisual("color", i)
                    })
                }
            })
        }
        Gm.registerLayout(jA),
        Gm.registerVisual(XA);
        var qA = Ap.getDimensionTypeByAxis
          , KA = {
            seriesModelMixin: {
                _baseAxisDim: null,
                getInitialData: function(t, e) {
                    var i, n, a = e.getComponent("xAxis", this.get("xAxisIndex")), r = e.getComponent("yAxis", this.get("yAxisIndex")), o = a.get("type"), s = r.get("type");
                    "category" === o ? (t.layout = "horizontal",
                    i = a.getOrdinalMeta(),
                    n = !0) : "category" === s ? (t.layout = "vertical",
                    i = r.getOrdinalMeta(),
                    n = !0) : t.layout = t.layout || "horizontal";
                    var l = ["x", "y"]
                      , u = "horizontal" === t.layout ? 0 : 1
                      , h = this._baseAxisDim = l[u]
                      , c = l[1 - u]
                      , d = [a, r]
                      , p = d[u].get("type")
                      , f = d[1 - u].get("type")
                      , g = t.data;
                    if (g && n) {
                        var m = [];
                        it.each(g, function(t, e) {
                            var i;
                            t.value && it.isArray(t.value) ? (i = t.value.slice(),
                            t.value.unshift(e)) : it.isArray(t) ? (i = t.slice(),
                            t.unshift(e)) : i = t,
                            m.push(i)
                        }),
                        t.data = m
                    }
                    var v = this.defaultValueDimensions;
                    return Lx(this, {
                        coordDimensions: [{
                            name: h,
                            type: qA(p),
                            ordinalMeta: i,
                            otherDims: {
                                tooltip: !1,
                                itemName: 0
                            },
                            dimsDef: ["base"]
                        }, {
                            name: c,
                            type: qA(f),
                            dimsDef: v.slice()
                        }],
                        dimensionsCount: v.length + 1
                    })
                },
                getBaseAxis: function() {
                    var t = this._baseAxisDim;
                    return this.ecModel.getComponent(t + "Axis", this.get(t + "AxisIndex")).axis
                }
            }
        }
          , $A = KA.seriesModelMixin
          , JA = kc.extend({
            type: "series.boxplot",
            dependencies: ["xAxis", "yAxis", "grid"],
            defaultValueDimensions: [{
                name: "min",
                defaultTooltip: !0
            }, {
                name: "Q1",
                defaultTooltip: !0
            }, {
                name: "median",
                defaultTooltip: !0
            }, {
                name: "Q3",
                defaultTooltip: !0
            }, {
                name: "max",
                defaultTooltip: !0
            }],
            dimensions: null,
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "cartesian2d",
                legendHoverLink: !0,
                hoverAnimation: !0,
                layout: null,
                boxWidth: [7, 50],
                itemStyle: {
                    color: "#fff",
                    borderWidth: 1
                },
                emphasis: {
                    itemStyle: {
                        borderWidth: 2,
                        shadowBlur: 5,
                        shadowOffsetX: 2,
                        shadowOffsetY: 2,
                        shadowColor: "rgba(0,0,0,0.4)"
                    }
                },
                animationEasing: "elasticOut",
                animationDuration: 800
            }
        });
        it.mixin(JA, $A, !0);
        var QA = ["itemStyle"]
          , tT = ["emphasis", "itemStyle"]
          , eT = (Xc.extend({
            type: "boxplot",
            render: function(t, e, i) {
                var a = t.getData()
                  , r = this.group
                  , o = this._data;
                this._data || r.removeAll();
                var s = "horizontal" === t.get("layout") ? 1 : 0;
                a.diff(o).add(function(t) {
                    if (a.hasValue(t)) {
                        var e = iT(a.getItemLayout(t), a, t, s, !0);
                        a.setItemGraphicEl(t, e),
                        r.add(e)
                    }
                }).update(function(t, e) {
                    var i = o.getItemGraphicEl(e);
                    if (a.hasValue(t)) {
                        var n = a.getItemLayout(t);
                        i ? nT(n, i, a, t) : i = iT(n, a, t, s),
                        r.add(i),
                        a.setItemGraphicEl(t, i)
                    } else
                        r.remove(i)
                }).remove(function(t) {
                    var e = o.getItemGraphicEl(t);
                    e && r.remove(e)
                }).execute(),
                this._data = a
            },
            remove: function(t) {
                var e = this.group
                  , i = this._data;
                this._data = null,
                i && i.eachItemGraphicEl(function(t) {
                    t && e.remove(t)
                })
            },
            dispose: it.noop
        }),
        Cr.extend({
            type: "boxplotBoxPath",
            shape: {},
            buildPath: function(t, e) {
                var i = e.points
                  , n = 0;
                for (t.moveTo(i[n][0], i[n][1]),
                n++; n < 4; n++)
                    t.lineTo(i[n][0], i[n][1]);
                for (t.closePath(); n < i.length; n++)
                    t.moveTo(i[n][0], i[n][1]),
                    n++,
                    t.lineTo(i[n][0], i[n][1])
            }
        }));
        function iT(t, e, i, n, a) {
            var r = t.ends
              , o = new eT({
                shape: {
                    points: a ? function(t, e, i) {
                        return it.map(t, function(t) {
                            return (t = t.slice())[e] = i.initBaseline,
                            t
                        })
                    }(r, n, t) : r
                }
            });
            return nT(t, o, e, i, a),
            o
        }
        function nT(t, e, i, n, a) {
            var r = i.hostModel;
            (0,
            Fs[a ? "initProps" : "updateProps"])(e, {
                shape: {
                    points: t.ends
                }
            }, r, n);
            var o = i.getItemModel(n)
              , s = o.getModel(QA)
              , l = i.getItemVisual(n, "color")
              , u = s.getItemStyle(["borderColor"]);
            u.stroke = l,
            u.strokeNoScale = !0,
            e.useStyle(u),
            e.z2 = 100;
            var h = o.getModel(tT).getItemStyle();
            Fs.setHoverStyle(e, h)
        }
        var aT = ["itemStyle", "borderColor"];
        function rT(n, t) {
            var a = n.get("color");
            n.eachRawSeriesByType("boxplot", function(t) {
                var e = a[t.seriesIndex % a.length]
                  , i = t.getData();
                i.setVisual({
                    legendSymbol: "roundRect",
                    color: t.get(aT) || e
                }),
                n.isSeriesFiltered(t) || i.each(function(t) {
                    var e = i.getItemModel(t);
                    i.setItemVisual(t, {
                        color: e.get(aT, !0)
                    })
                })
            })
        }
        var oT = ol.parsePercent
          , sT = it.each;
        function lT(t) {
            var e = function(t) {
                var n = []
                  , a = [];
                return t.eachSeriesByType("boxplot", function(t) {
                    var e = t.getBaseAxis()
                      , i = it.indexOf(a, e);
                    i < 0 && (i = a.length,
                    a[i] = e,
                    n[i] = {
                        axis: e,
                        seriesModels: []
                    }),
                    n[i].seriesModels.push(t)
                }),
                n
            }(t);
            sT(e, function(i) {
                var t = i.seriesModels;
                t.length && (function(t) {
                    var e, i, n = t.axis, a = t.seriesModels, r = a.length, o = t.boxWidthList = [], s = t.boxOffsetList = [], l = [];
                    if ("category" === n.type)
                        i = n.getBandWidth();
                    else {
                        var u = 0;
                        sT(a, function(t) {
                            u = Math.max(u, t.getData().count())
                        }),
                        e = n.getExtent(),
                        Math.abs(e[1] - e[0])
                    }
                    sT(a, function(t) {
                        var e = t.get("boxWidth");
                        it.isArray(e) || (e = [e, e]),
                        l.push([oT(e[0], i) || 0, oT(e[1], i) || 0])
                    });
                    var h = .8 * i - 2
                      , c = h / r * .3
                      , d = (h - c * (r - 1)) / r
                      , p = d / 2 - h / 2;
                    sT(a, function(t, e) {
                        s.push(p),
                        p += c + d,
                        o.push(Math.min(Math.max(d, l[e][0]), l[e][1]))
                    })
                }(i),
                sT(t, function(t, e) {
                    !function(t, o, e) {
                        var s = t.coordinateSystem
                          , l = t.getData()
                          , r = e / 2
                          , u = "horizontal" === t.get("layout") ? 0 : 1
                          , h = 1 - u
                          , i = ["x", "y"]
                          , n = l.mapDimension(i[u])
                          , a = l.mapDimension(i[h], !0);
                        if (null == n || a.length < 5)
                            return;
                        for (var c = 0; c < l.count(); c++) {
                            var d = l.get(n, c)
                              , p = x(d, a[2], c)
                              , f = x(d, a[0], c)
                              , g = x(d, a[1], c)
                              , m = x(d, a[3], c)
                              , v = x(d, a[4], c)
                              , y = [];
                            _(y, g, 0),
                            _(y, m, 1),
                            y.push(f, g, v, m),
                            b(y, f),
                            b(y, v),
                            b(y, p),
                            l.setItemLayout(c, {
                                initBaseline: p[h],
                                ends: y
                            })
                        }
                        function x(t, e, i) {
                            var n, a = l.get(e, i), r = [];
                            return r[u] = t,
                            r[h] = a,
                            isNaN(t) || isNaN(a) ? n = [NaN, NaN] : (n = s.dataToPoint(r))[u] += o,
                            n
                        }
                        function _(t, e, i) {
                            var n = e.slice()
                              , a = e.slice();
                            n[u] += r,
                            a[u] -= r,
                            i ? t.push(n, a) : t.push(a, n)
                        }
                        function b(t, e) {
                            var i = e.slice()
                              , n = e.slice();
                            i[u] -= r,
                            n[u] += r,
                            t.push(i, n)
                        }
                    }(t, i.boxOffsetList[e], i.boxWidthList[e])
                }))
            })
        }
        Gm.registerVisual(rT),
        Gm.registerLayout(lT);
        var uT = KA.seriesModelMixin
          , hT = kc.extend({
            type: "series.candlestick",
            dependencies: ["xAxis", "yAxis", "grid"],
            defaultValueDimensions: [{
                name: "open",
                defaultTooltip: !0
            }, {
                name: "close",
                defaultTooltip: !0
            }, {
                name: "lowest",
                defaultTooltip: !0
            }, {
                name: "highest",
                defaultTooltip: !0
            }],
            dimensions: null,
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "cartesian2d",
                legendHoverLink: !0,
                hoverAnimation: !0,
                layout: null,
                itemStyle: {
                    color: "#c23531",
                    color0: "#314656",
                    borderWidth: 1,
                    borderColor: "#c23531",
                    borderColor0: "#314656"
                },
                emphasis: {
                    itemStyle: {
                        borderWidth: 2
                    }
                },
                barMaxWidth: null,
                barMinWidth: null,
                barWidth: null,
                large: !0,
                largeThreshold: 600,
                progressive: 3e3,
                progressiveThreshold: 1e4,
                progressiveChunkMode: "mod",
                animationUpdate: !1,
                animationEasing: "linear",
                animationDuration: 300
            },
            getShadowDim: function() {
                return "open"
            },
            brushSelector: function(t, e, i) {
                var n = e.getItemLayout(t);
                return n && i.rect(n.brushRect)
            }
        });
        it.mixin(hT, uT, !0);
        var cT = ["itemStyle"]
          , dT = ["emphasis", "itemStyle"]
          , pT = ["color", "color0", "borderColor", "borderColor0"]
          , fT = (Xc.extend({
            type: "candlestick",
            render: function(t, e, i) {
                this._updateDrawMode(t),
                this._isLargeDraw ? this._renderLarge(t) : this._renderNormal(t)
            },
            incrementalPrepareRender: function(t, e, i) {
                this._clear(),
                this._updateDrawMode(t)
            },
            incrementalRender: function(t, e, i, n) {
                this._isLargeDraw ? this._incrementalRenderLarge(t, e) : this._incrementalRenderNormal(t, e)
            },
            _updateDrawMode: function(t) {
                var e = t.pipelineContext.large;
                (null == this._isLargeDraw || e ^ this._isLargeDraw) && (this._isLargeDraw = e,
                this._clear())
            },
            _renderNormal: function(a) {
                var r = a.getData()
                  , o = this._data
                  , s = this.group
                  , l = r.getLayout("isSimpleBox");
                this._data || s.removeAll(),
                r.diff(o).add(function(t) {
                    if (r.hasValue(t)) {
                        var e, i = r.getItemLayout(t);
                        e = gT(i, t, !0),
                        Fs.initProps(e, {
                            shape: {
                                points: i.ends
                            }
                        }, a, t),
                        mT(e, r, t, l),
                        s.add(e),
                        r.setItemGraphicEl(t, e)
                    }
                }).update(function(t, e) {
                    var i = o.getItemGraphicEl(e);
                    if (r.hasValue(t)) {
                        var n = r.getItemLayout(t);
                        i ? Fs.updateProps(i, {
                            shape: {
                                points: n.ends
                            }
                        }, a, t) : i = gT(n),
                        mT(i, r, t, l),
                        s.add(i),
                        r.setItemGraphicEl(t, i)
                    } else
                        s.remove(i)
                }).remove(function(t) {
                    var e = o.getItemGraphicEl(t);
                    e && s.remove(e)
                }).execute(),
                this._data = r
            },
            _renderLarge: function(t) {
                this._clear(),
                yT(t, this.group)
            },
            _incrementalRenderNormal: function(t, e) {
                for (var i, n = e.getData(), a = n.getLayout("isSimpleBox"); null != (i = t.next()); ) {
                    var r;
                    mT(r = gT(n.getItemLayout(i)), n, i, a),
                    r.incremental = !0,
                    this.group.add(r)
                }
            },
            _incrementalRenderLarge: function(t, e) {
                yT(e, this.group, !0)
            },
            remove: function(t) {
                this._clear()
            },
            _clear: function() {
                this.group.removeAll(),
                this._data = null
            },
            dispose: it.noop
        }),
        Cr.extend({
            type: "normalCandlestickBox",
            shape: {},
            buildPath: function(t, e) {
                var i = e.points;
                this.__simpleBox ? (t.moveTo(i[4][0], i[4][1]),
                t.lineTo(i[6][0], i[6][1])) : (t.moveTo(i[0][0], i[0][1]),
                t.lineTo(i[1][0], i[1][1]),
                t.lineTo(i[2][0], i[2][1]),
                t.lineTo(i[3][0], i[3][1]),
                t.closePath(),
                t.moveTo(i[4][0], i[4][1]),
                t.lineTo(i[5][0], i[5][1]),
                t.moveTo(i[6][0], i[6][1]),
                t.lineTo(i[7][0], i[7][1]))
            }
        }));
        function gT(t, e, i) {
            var n = t.ends;
            return new fT({
                shape: {
                    points: i ? function(t, e) {
                        return it.map(t, function(t) {
                            return (t = t.slice())[1] = e.initBaseline,
                            t
                        })
                    }(n, t) : n
                },
                z2: 100
            })
        }
        function mT(t, e, i, n) {
            var a = e.getItemModel(i)
              , r = a.getModel(cT)
              , o = e.getItemVisual(i, "color")
              , s = e.getItemVisual(i, "borderColor") || o
              , l = r.getItemStyle(pT);
            t.useStyle(l),
            t.style.strokeNoScale = !0,
            t.style.fill = o,
            t.style.stroke = s,
            t.__simpleBox = n;
            var u = a.getModel(dT).getItemStyle();
            Fs.setHoverStyle(t, u)
        }
        var vT = Cr.extend({
            type: "largeCandlestickBox",
            shape: {},
            buildPath: function(t, e) {
                for (var i = e.points, n = 0; n < i.length; )
                    if (this.__sign === i[n++]) {
                        var a = i[n++];
                        t.moveTo(a, i[n++]),
                        t.lineTo(a, i[n++])
                    } else
                        n += 3
            }
        });
        function yT(t, e, i) {
            var n = t.getData()
              , a = n.getLayout("largePoints")
              , r = new vT({
                shape: {
                    points: a
                },
                __sign: 1
            });
            e.add(r);
            var o = new vT({
                shape: {
                    points: a
                },
                __sign: -1
            });
            e.add(o),
            xT(1, r, t, n),
            xT(-1, o, t, n),
            i && (r.incremental = !0,
            o.incremental = !0)
        }
        function xT(t, e, i, n) {
            var a = 0 < t ? "P" : "N"
              , r = n.getVisual("borderColor" + a) || n.getVisual("color" + a)
              , o = i.getModel(cT).getItemStyle(pT);
            e.useStyle(o),
            e.style.fill = null,
            e.style.stroke = r
        }
        function _T(t) {
            t && it.isArray(t.series) && it.each(t.series, function(t) {
                it.isObject(t) && "k" === t.type && (t.type = "candlestick")
            })
        }
        var bT = ["itemStyle", "borderColor"]
          , wT = ["itemStyle", "borderColor0"]
          , ST = ["itemStyle", "color"]
          , MT = ["itemStyle", "color0"]
          , IT = {
            seriesType: "candlestick",
            plan: Ec(),
            performRawSeries: !0,
            reset: function(t, e) {
                var i = t.getData()
                  , n = t.pipelineContext.large;
                if (i.setVisual({
                    legendSymbol: "roundRect",
                    colorP: r(1, t),
                    colorN: r(-1, t),
                    borderColorP: o(1, t),
                    borderColorN: o(-1, t)
                }),
                !e.isSeriesFiltered(t))
                    return !n && {
                        progress: function(t, e) {
                            var i;
                            for (; null != (i = t.next()); ) {
                                var n = e.getItemModel(i)
                                  , a = e.getItemLayout(i).sign;
                                e.setItemVisual(i, {
                                    color: r(a, n),
                                    borderColor: o(a, n)
                                })
                            }
                        }
                    };
                function r(t, e) {
                    return e.get(0 < t ? ST : MT)
                }
                function o(t, e) {
                    return e.get(0 < t ? bT : wT)
                }
            }
        }
          , AT = Fs.subPixelOptimize
          , TT = ol.parsePercent
          , CT = it.retrieve2
          , DT = "undefined" != typeof Float32Array ? Float32Array : Array;
        function LT(t, e, i, n, a) {
            return n < i ? -1 : i < n ? 1 : 0 < e ? t.get(a, e - 1) <= n ? 1 : -1 : 1
        }
        var PT = {
            seriesType: "candlestick",
            plan: Ec(),
            reset: function(t) {
                var x = t.coordinateSystem
                  , e = t.getData()
                  , _ = function(t, e) {
                    var i, n = t.getBaseAxis(), a = "category" === n.type ? n.getBandWidth() : (i = n.getExtent(),
                    Math.abs(i[1] - i[0]) / e.count()), r = TT(CT(t.get("barMaxWidth"), a), a), o = TT(CT(t.get("barMinWidth"), 1), a), s = t.get("barWidth");
                    return null != s ? TT(s, a) : Math.max(Math.min(a / 2, r), o)
                }(t, e)
                  , i = ["x", "y"]
                  , b = e.mapDimension(i[0])
                  , n = e.mapDimension(i[1], !0)
                  , w = n[0]
                  , S = n[1]
                  , M = n[2]
                  , I = n[3];
                if (e.setLayout({
                    candleWidth: _,
                    isSimpleBox: _ <= 1.3
                }),
                !(null == b || n.length < 4))
                    return {
                        progress: t.pipelineContext.large ? function(t, e) {
                            var i, n, a = new DT(5 * t.count), r = 0, o = [], s = [];
                            for (; null != (n = t.next()); ) {
                                var l = e.get(b, n)
                                  , u = e.get(w, n)
                                  , h = e.get(S, n)
                                  , c = e.get(M, n)
                                  , d = e.get(I, n);
                                isNaN(l) || isNaN(c) || isNaN(d) ? (a[r++] = NaN,
                                r += 4) : (a[r++] = LT(e, n, u, h, S),
                                o[0] = l,
                                o[1] = c,
                                i = x.dataToPoint(o, null, s),
                                a[r++] = i ? i[0] : NaN,
                                a[r++] = i ? i[1] : NaN,
                                o[1] = d,
                                i = x.dataToPoint(o, null, s),
                                a[r++] = i ? i[1] : NaN)
                            }
                            e.setLayout("largePoints", a)
                        }
                        : function(t, e) {
                            var i;
                            for (; null != (i = t.next()); ) {
                                var n = e.get(b, i)
                                  , a = e.get(w, i)
                                  , r = e.get(S, i)
                                  , o = e.get(M, i)
                                  , s = e.get(I, i)
                                  , l = Math.min(a, r)
                                  , u = Math.max(a, r)
                                  , h = g(l, n)
                                  , c = g(u, n)
                                  , d = g(o, n)
                                  , p = g(s, n)
                                  , f = [];
                                m(f, c, 0),
                                m(f, h, 1),
                                f.push(y(p), y(c), y(d), y(h)),
                                e.setItemLayout(i, {
                                    sign: LT(e, i, a, r, S),
                                    initBaseline: r < a ? c[1] : h[1],
                                    ends: f,
                                    brushRect: v(o, s, n)
                                })
                            }
                            function g(t, e) {
                                var i = [];
                                return i[0] = e,
                                i[1] = t,
                                isNaN(e) || isNaN(t) ? [NaN, NaN] : x.dataToPoint(i)
                            }
                            function m(t, e, i) {
                                var n = e.slice()
                                  , a = e.slice();
                                n[0] = AT(n[0] + _ / 2, 1, !1),
                                a[0] = AT(a[0] - _ / 2, 1, !0),
                                i ? t.push(n, a) : t.push(a, n)
                            }
                            function v(t, e, i) {
                                var n = g(t, i)
                                  , a = g(e, i);
                                return n[0] -= _ / 2,
                                a[0] -= _ / 2,
                                {
                                    x: n[0],
                                    y: n[1],
                                    width: _,
                                    height: a[1] - n[1]
                                }
                            }
                            function y(t) {
                                return t[0] = AT(t[0], 1),
                                t
                            }
                        }
                    }
            }
        };
        Gm.registerPreprocessor(_T),
        Gm.registerVisual(IT),
        Gm.registerLayout(PT);
        kc.extend({
            type: "series.effectScatter",
            dependencies: ["grid", "polar"],
            getInitialData: function(t, e) {
                return Sf(this.getSource(), this)
            },
            brushSelector: "point",
            defaultOption: {
                coordinateSystem: "cartesian2d",
                zlevel: 0,
                z: 2,
                legendHoverLink: !0,
                effectType: "ripple",
                progressive: 0,
                showEffectOn: "render",
                rippleEffect: {
                    period: 4,
                    scale: 2.5,
                    brushType: "fill"
                },
                symbolSize: 10
            }
        });
        var kT = Fg.createSymbol
          , OT = Fs.Group
          , RT = ol.parsePercent;
        function NT(t, e) {
            t.eachChild(function(t) {
                t.attr({
                    z: e.z,
                    zlevel: e.zlevel,
                    style: {
                        stroke: "stroke" === e.brushType ? e.color : null,
                        fill: "fill" === e.brushType ? e.color : null
                    }
                })
            })
        }
        function ET(t, e) {
            OT.call(this);
            var i = new rv(t,e)
              , n = new OT;
            this.add(i),
            this.add(n),
            n.beforeUpdate = function() {
                this.attr(i.getScale())
            }
            ,
            this.updateData(t, e)
        }
        var zT = ET.prototype;
        zT.stopEffectAnimation = function() {
            this.childAt(1).removeAll()
        }
        ,
        zT.startEffectAnimation = function(t) {
            for (var e = t.symbolType, i = t.color, n = this.childAt(1), a = 0; a < 3; a++) {
                var r = kT(e, -1, -1, 2, 2, i);
                r.attr({
                    style: {
                        strokeNoScale: !0
                    },
                    z2: 99,
                    silent: !0,
                    scale: [.5, .5]
                });
                var o = -a / 3 * t.period + t.effectOffset;
                r.animate("", !0).when(t.period, {
                    scale: [t.rippleScale / 2, t.rippleScale / 2]
                }).delay(o).start(),
                r.animateStyle(!0).when(t.period, {
                    opacity: 0
                }).delay(o).start(),
                n.add(r)
            }
            NT(n, t)
        }
        ,
        zT.updateEffectAnimation = function(t) {
            for (var e = this._effectCfg, i = this.childAt(1), n = ["symbolType", "period", "rippleScale"], a = 0; a < n.length; a++) {
                var r = n[a];
                if (e[r] !== t[r])
                    return this.stopEffectAnimation(),
                    void this.startEffectAnimation(t)
            }
            NT(i, t)
        }
        ,
        zT.highlight = function() {
            this.trigger("emphasis")
        }
        ,
        zT.downplay = function() {
            this.trigger("normal")
        }
        ,
        zT.updateData = function(t, e) {
            var i = t.hostModel;
            this.childAt(0).updateData(t, e);
            var n = this.childAt(1)
              , a = t.getItemModel(e)
              , r = t.getItemVisual(e, "symbol")
              , o = function(t) {
                return it.isArray(t) || (t = [+t, +t]),
                t
            }(t.getItemVisual(e, "symbolSize"))
              , s = t.getItemVisual(e, "color");
            n.attr("scale", o),
            n.traverse(function(t) {
                t.attr({
                    fill: s
                })
            });
            var l = a.getShallow("symbolOffset");
            if (l) {
                var u = n.position;
                u[0] = RT(l[0], o[0]),
                u[1] = RT(l[1], o[1])
            }
            n.rotation = (a.getShallow("symbolRotate") || 0) * Math.PI / 180 || 0;
            var h = {};
            if (h.showEffectOn = i.get("showEffectOn"),
            h.rippleScale = a.get("rippleEffect.scale"),
            h.brushType = a.get("rippleEffect.brushType"),
            h.period = 1e3 * a.get("rippleEffect.period"),
            h.effectOffset = e / t.count(),
            h.z = a.getShallow("z") || 0,
            h.zlevel = a.getShallow("zlevel") || 0,
            h.symbolType = r,
            h.color = s,
            this.off("mouseover").off("mouseout").off("emphasis").off("normal"),
            "render" === h.showEffectOn)
                this._effectCfg ? this.updateEffectAnimation(h) : this.startEffectAnimation(h),
                this._effectCfg = h;
            else {
                this._effectCfg = null,
                this.stopEffectAnimation();
                var c = this.childAt(0)
                  , d = function() {
                    c.highlight(),
                    "render" !== h.showEffectOn && this.startEffectAnimation(h)
                }
                  , p = function() {
                    c.downplay(),
                    "render" !== h.showEffectOn && this.stopEffectAnimation()
                };
                this.on("mouseover", d, this).on("mouseout", p, this).on("emphasis", d, this).on("normal", p, this)
            }
            this._effectCfg = h
        }
        ,
        zT.fadeOut = function(t) {
            this.off("mouseover").off("mouseout").off("emphasis").off("normal"),
            t && t()
        }
        ,
        it.inherits(ET, OT);
        var VT = ET;
        Gm.extendChartView({
            type: "effectScatter",
            init: function() {
                this._symbolDraw = new dv(VT)
            },
            render: function(t, e, i) {
                var n = t.getData()
                  , a = this._symbolDraw;
                a.updateData(n),
                this.group.add(a.group)
            },
            updateTransform: function(t, e, i) {
                var n = t.getData();
                this.group.dirty();
                var a = Uv().reset(t);
                a.progress && a.progress({
                    start: 0,
                    end: n.count()
                }, n),
                this._symbolDraw.updateLayout(n)
            },
            _updateGroupTransform: function(t) {
                var e = t.coordinateSystem;
                e && e.getRoamTransform && (this.group.transform = ct.clone(e.getRoamTransform()),
                this.group.decomposeTransform())
            },
            remove: function(t, e) {
                this._symbolDraw && this._symbolDraw.remove(e)
            },
            dispose: function() {}
        });
        Gm.registerVisual(Fv("effectScatter", "circle")),
        Gm.registerLayout(Uv("effectScatter"));
        var BT = it.concatArray
          , GT = it.mergeAll
          , FT = it.map
          , HT = fl.encodeHTML
          , WT = "undefined" == typeof Uint32Array ? Array : Uint32Array
          , ZT = "undefined" == typeof Float64Array ? Array : Float64Array;
        function UT(t) {
            var e = t.data;
            e && e[0] && e[0][0] && e[0][0].coord && (t.data = FT(e, function(t) {
                var e = {
                    coords: [t[0].coord, t[1].coord]
                };
                return t[0].name && (e.fromName = t[0].name),
                t[1].name && (e.toName = t[1].name),
                GT([e, t[0], t[1]])
            }))
        }
        var YT = kc.extend({
            type: "series.lines",
            dependencies: ["grid", "polar"],
            visualColorAccessPath: "lineStyle.color",
            init: function(t) {
                t.data = t.data || [],
                UT(t);
                var e = this._processFlatCoordsArray(t.data);
                this._flatCoords = e.flatCoords,
                this._flatCoordsOffset = e.flatCoordsOffset,
                e.flatCoords && (t.data = new Float32Array(e.count)),
                YT.superApply(this, "init", arguments)
            },
            mergeOption: function(t) {
                if (t.data = t.data || [],
                UT(t),
                t.data) {
                    var e = this._processFlatCoordsArray(t.data);
                    this._flatCoords = e.flatCoords,
                    this._flatCoordsOffset = e.flatCoordsOffset,
                    e.flatCoords && (t.data = new Float32Array(e.count))
                }
                YT.superApply(this, "mergeOption", arguments)
            },
            appendData: function(t) {
                var e = this._processFlatCoordsArray(t.data);
                e.flatCoords && (this._flatCoords ? (this._flatCoords = BT(this._flatCoords, e.flatCoords),
                this._flatCoordsOffset = BT(this._flatCoordsOffset, e.flatCoordsOffset)) : (this._flatCoords = e.flatCoords,
                this._flatCoordsOffset = e.flatCoordsOffset),
                t.data = new Float32Array(e.count)),
                this.getRawData().appendData(t.data)
            },
            _getCoordsFromItemModel: function(t) {
                var e = this.getData().getItemModel(t);
                return e.option instanceof Array ? e.option : e.getShallow("coords")
            },
            getLineCoordsCount: function(t) {
                return this._flatCoordsOffset ? this._flatCoordsOffset[2 * t + 1] : this._getCoordsFromItemModel(t).length
            },
            getLineCoords: function(t, e) {
                if (this._flatCoordsOffset) {
                    for (var i = this._flatCoordsOffset[2 * t], n = this._flatCoordsOffset[2 * t + 1], a = 0; a < n; a++)
                        e[a] = e[a] || [],
                        e[a][0] = this._flatCoords[i + 2 * a],
                        e[a][1] = this._flatCoords[i + 2 * a + 1];
                    return n
                }
                var r = this._getCoordsFromItemModel(t);
                for (a = 0; a < r.length; a++)
                    e[a] = e[a] || [],
                    e[a][0] = r[a][0],
                    e[a][1] = r[a][1];
                return r.length
            },
            _processFlatCoordsArray: function(t) {
                var e = 0;
                if (this._flatCoords && (e = this._flatCoords.length),
                "number" != typeof t[0])
                    return {
                        flatCoordsOffset: null,
                        flatCoords: null,
                        count: t.length
                    };
                for (var i = t.length, n = new WT(i), a = new ZT(i), r = 0, o = 0, s = 0, l = 0; l < i; ) {
                    s++;
                    var u = t[l++];
                    n[o++] = r + e,
                    n[o++] = u;
                    for (var h = 0; h < u; h++) {
                        var c = t[l++]
                          , d = t[l++];
                        a[r++] = c,
                        a[r++] = d
                    }
                }
                return {
                    flatCoordsOffset: new Uint32Array(n.buffer,0,o),
                    flatCoords: a,
                    count: s
                }
            },
            getInitialData: function(t, e) {
                var r = new Qp(["value"],this);
                return r.hasItemOption = !1,
                r.initData(t.data, [], function(t, e, i, n) {
                    if (t instanceof Array)
                        return NaN;
                    r.hasItemOption = !0;
                    var a = t.value;
                    return null != a ? a instanceof Array ? a[n] : a : void 0
                }),
                r
            },
            formatTooltip: function(t) {
                var e = this.getData().getItemModel(t)
                  , i = e.get("name");
                if (i)
                    return i;
                var n = e.get("fromName")
                  , a = e.get("toName")
                  , r = [];
                return null != n && r.push(n),
                null != a && r.push(a),
                HT(r.join(" > "))
            },
            preventIncremental: function() {
                return !!this.get("effect.show")
            },
            getProgressive: function() {
                var t = this.option.progressive;
                return null == t ? this.option.large ? 1e4 : this.get("progressive") : t
            },
            getProgressiveThreshold: function() {
                var t = this.option.progressiveThreshold;
                return null == t ? this.option.large ? 2e4 : this.get("progressiveThreshold") : t
            },
            defaultOption: {
                coordinateSystem: "geo",
                zlevel: 0,
                z: 2,
                legendHoverLink: !0,
                hoverAnimation: !0,
                xAxisIndex: 0,
                yAxisIndex: 0,
                symbol: ["none", "none"],
                symbolSize: [10, 10],
                geoIndex: 0,
                effect: {
                    show: !1,
                    period: 4,
                    constantSpeed: 0,
                    symbol: "circle",
                    symbolSize: 3,
                    loop: !0,
                    trailLength: .2
                },
                large: !1,
                largeThreshold: 2e3,
                polyline: !1,
                label: {
                    show: !1,
                    position: "end"
                },
                lineStyle: {
                    opacity: .5
                }
            }
        })
          , jT = Fg.createSymbol;
        function XT(t, e, i) {
            Fs.Group.call(this),
            this.add(this.createLine(t, e, i)),
            this._updateEffectSymbol(t, e)
        }
        var qT = XT.prototype;
        qT.createLine = function(t, e, i) {
            return new iM(t,e,i)
        }
        ,
        qT._updateEffectSymbol = function(t, e) {
            var i = t.getItemModel(e).getModel("effect")
              , n = i.get("symbolSize")
              , a = i.get("symbol");
            it.isArray(n) || (n = [n, n]);
            var r = i.get("color") || t.getItemVisual(e, "color")
              , o = this.childAt(1);
            this._symbolType !== a && (this.remove(o),
            (o = jT(a, -.5, -.5, 1, 1, r)).z2 = 100,
            o.culling = !0,
            this.add(o)),
            o && (o.setStyle("shadowColor", r),
            o.setStyle(i.getItemStyle(["color"])),
            o.attr("scale", n),
            o.setColor(r),
            o.attr("scale", n),
            this._symbolType = a,
            this._updateEffectAnimation(t, i, e))
        }
        ,
        qT._updateEffectAnimation = function(e, t, i) {
            var n = this.childAt(1);
            if (n) {
                var a = this
                  , r = e.getItemLayout(i)
                  , o = 1e3 * t.get("period")
                  , s = t.get("loop")
                  , l = t.get("constantSpeed")
                  , u = it.retrieve(t.get("delay"), function(t) {
                    return t / e.count() * o / 3
                })
                  , h = "function" == typeof u;
                if (n.ignore = !0,
                this.updateAnimationPoints(n, r),
                0 < l && (o = this.getLineLength(n) / l * 1e3),
                o !== this._period || s !== this._loop) {
                    n.stopAnimation();
                    var c = u;
                    h && (c = u(i)),
                    0 < n.__t && (c = -o * n.__t),
                    n.__t = 0;
                    var d = n.animate("", s).when(o, {
                        __t: 1
                    }).delay(c).during(function() {
                        a.updateSymbolPosition(n)
                    });
                    s || d.done(function() {
                        a.remove(n)
                    }),
                    d.start()
                }
                this._period = o,
                this._loop = s
            }
        }
        ,
        qT.getLineLength = function(t) {
            return R.dist(t.__p1, t.__cp1) + R.dist(t.__cp1, t.__p2)
        }
        ,
        qT.updateAnimationPoints = function(t, e) {
            t.__p1 = e[0],
            t.__p2 = e[1],
            t.__cp1 = e[2] || [(e[0][0] + e[1][0]) / 2, (e[0][1] + e[1][1]) / 2]
        }
        ,
        qT.updateData = function(t, e, i) {
            this.childAt(0).updateData(t, e, i),
            this._updateEffectSymbol(t, e)
        }
        ,
        qT.updateSymbolPosition = function(t) {
            var e = t.__p1
              , i = t.__p2
              , n = t.__cp1
              , a = t.__t
              , r = t.position
              , o = La.quadraticAt
              , s = La.quadraticDerivativeAt;
            r[0] = o(e[0], n[0], i[0], a),
            r[1] = o(e[1], n[1], i[1], a);
            var l = s(e[0], n[0], i[0], a)
              , u = s(e[1], n[1], i[1], a);
            t.rotation = -Math.atan2(u, l) - Math.PI / 2,
            t.ignore = !1
        }
        ,
        qT.updateLayout = function(t, e) {
            this.childAt(0).updateLayout(t, e);
            var i = t.getItemModel(e).getModel("effect");
            this._updateEffectAnimation(t, i, e)
        }
        ,
        it.inherits(XT, Fs.Group);
        var KT = XT;
        function $T(t, e, i) {
            Fs.Group.call(this),
            this._createPolyline(t, e, i)
        }
        var JT = $T.prototype;
        JT._createPolyline = function(t, e, i) {
            var n = t.getItemLayout(e)
              , a = new Fs.Polyline({
                shape: {
                    points: n
                }
            });
            this.add(a),
            this._updateCommonStl(t, e, i)
        }
        ,
        JT.updateData = function(t, e, i) {
            var n = t.hostModel
              , a = this.childAt(0)
              , r = {
                shape: {
                    points: t.getItemLayout(e)
                }
            };
            Fs.updateProps(a, r, n, e),
            this._updateCommonStl(t, e, i)
        }
        ,
        JT._updateCommonStl = function(t, e, i) {
            var n = this.childAt(0)
              , a = t.getItemModel(e)
              , r = t.getItemVisual(e, "color")
              , o = i && i.lineStyle
              , s = i && i.hoverLineStyle;
            i && !t.hasItemOption || (o = a.getModel("lineStyle").getLineStyle(),
            s = a.getModel("emphasis.lineStyle").getLineStyle()),
            n.useStyle(it.defaults({
                strokeNoScale: !0,
                fill: "none",
                stroke: r
            }, o)),
            n.hoverStyle = s,
            Fs.setHoverStyle(this)
        }
        ,
        JT.updateLayout = function(t, e) {
            this.childAt(0).setShape("points", t.getItemLayout(e))
        }
        ,
        it.inherits($T, Fs.Group);
        var QT = $T;
        function tC(t, e, i) {
            KT.call(this, t, e, i),
            this._lastFrame = 0,
            this._lastFramePercent = 0
        }
        var eC = tC.prototype;
        eC.createLine = function(t, e, i) {
            return new QT(t,e,i)
        }
        ,
        eC.updateAnimationPoints = function(t, e) {
            this._points = e;
            for (var i = [0], n = 0, a = 1; a < e.length; a++) {
                var r = e[a - 1]
                  , o = e[a];
                n += R.dist(r, o),
                i.push(n)
            }
            if (0 !== n) {
                for (a = 0; a < i.length; a++)
                    i[a] /= n;
                this._offsets = i,
                this._length = n
            }
        }
        ,
        eC.getLineLength = function(t) {
            return this._length
        }
        ,
        eC.updateSymbolPosition = function(t) {
            var e = t.__t
              , i = this._points
              , n = this._offsets
              , a = i.length;
            if (n) {
                var r = this._lastFrame;
                if (e < this._lastFramePercent) {
                    for (o = Math.min(r + 1, a - 1); 0 <= o && !(n[o] <= e); o--)
                        ;
                    o = Math.min(o, a - 2)
                } else {
                    for (var o = r; o < a && !(n[o] > e); o++)
                        ;
                    o = Math.min(o - 1, a - 2)
                }
                R.lerp(t.position, i[o], i[o + 1], (e - n[o]) / (n[o + 1] - n[o]));
                var s = i[o + 1][0] - i[o][0]
                  , l = i[o + 1][1] - i[o][1];
                t.rotation = -Math.atan2(l, s) - Math.PI / 2,
                this._lastFrame = o,
                this._lastFramePercent = e,
                t.ignore = !1
            }
        }
        ,
        it.inherits(tC, KT);
        var iC = tC
          , nC = Fs.extendShape({
            shape: {
                polyline: !1,
                curveness: 0,
                segs: []
            },
            buildPath: function(t, e) {
                var i = e.segs
                  , n = e.curveness;
                if (e.polyline)
                    for (var a = 0; a < i.length; ) {
                        var r = i[a++];
                        if (0 < r) {
                            t.moveTo(i[a++], i[a++]);
                            for (var o = 1; o < r; o++)
                                t.lineTo(i[a++], i[a++])
                        }
                    }
                else
                    for (a = 0; a < i.length; ) {
                        var s = i[a++]
                          , l = i[a++]
                          , u = i[a++]
                          , h = i[a++];
                        if (t.moveTo(s, l),
                        0 < n) {
                            var c = (s + u) / 2 - (l - h) * n
                              , d = (l + h) / 2 - (u - s) * n;
                            t.quadraticCurveTo(c, d, u, h)
                        } else
                            t.lineTo(u, h)
                    }
            },
            findDataIndex: function(t, e) {
                var i = this.shape
                  , n = i.segs
                  , a = i.curveness;
                if (i.polyline)
                    for (var r = 0, o = 0; o < n.length; ) {
                        var s = n[o++];
                        if (0 < s)
                            for (var l = n[o++], u = n[o++], h = 1; h < s; h++) {
                                var c = n[o++]
                                  , d = n[o++];
                                if (nr.containStroke(l, u, c, d))
                                    return r
                            }
                        r++
                    }
                else
                    for (r = 0,
                    o = 0; o < n.length; ) {
                        l = n[o++],
                        u = n[o++],
                        c = n[o++],
                        d = n[o++];
                        if (0 < a) {
                            var p = (l + c) / 2 - (u - d) * a
                              , f = (u + d) / 2 - (c - l) * a;
                            if (or.containStroke(l, u, p, f, c, d))
                                return r
                        } else if (nr.containStroke(l, u, c, d))
                            return r;
                        r++
                    }
                return -1
            }
        });
        function aC() {
            this.group = new Fs.Group
        }
        var rC = aC.prototype;
        rC.isPersistent = function() {
            return !this._incremental
        }
        ,
        rC.updateData = function(t) {
            this.group.removeAll();
            var e = new nC({
                rectHover: !0,
                cursor: "default"
            });
            e.setShape({
                segs: t.getLayout("linesPoints")
            }),
            this._setCommon(e, t),
            this.group.add(e),
            this._incremental = null
        }
        ,
        rC.incrementalPrepareUpdate = function(t) {
            this.group.removeAll(),
            this._clearIncremental(),
            5e5 < t.count() ? (this._incremental || (this._incremental = new Uo({
                silent: !0
            })),
            this.group.add(this._incremental)) : this._incremental = null
        }
        ,
        rC.incrementalUpdate = function(t, e) {
            var i = new nC;
            i.setShape({
                segs: e.getLayout("linesPoints")
            }),
            this._setCommon(i, e, !!this._incremental),
            this._incremental ? this._incremental.addDisplayable(i, !0) : (i.rectHover = !0,
            i.cursor = "default",
            i.__startIndex = t.start,
            this.group.add(i))
        }
        ,
        rC.remove = function() {
            this._clearIncremental(),
            this._incremental = null,
            this.group.removeAll()
        }
        ,
        rC._setCommon = function(i, t, e) {
            var n = t.hostModel;
            i.setShape({
                polyline: n.get("polyline"),
                curveness: n.get("lineStyle.curveness")
            }),
            i.useStyle(n.getModel("lineStyle").getLineStyle()),
            i.style.strokeNoScale = !0;
            var a = t.getVisual("color");
            a && i.setStyle("stroke", a),
            i.setStyle("fill"),
            e || (i.seriesIndex = n.seriesIndex,
            i.on("mousemove", function(t) {
                i.dataIndex = null;
                var e = i.findDataIndex(t.offsetX, t.offsetY);
                0 < e && (i.dataIndex = e + i.__startIndex)
            }))
        }
        ,
        rC._clearIncremental = function() {
            var t = this._incremental;
            t && t.clearDisplaybles()
        }
        ;
        var oC = aC
          , sC = {
            seriesType: "lines",
            plan: Ec(),
            reset: function(g) {
                var m = g.coordinateSystem
                  , v = g.get("polyline")
                  , y = g.pipelineContext.large;
                return {
                    progress: function(t, e) {
                        var i = [];
                        if (y) {
                            var n, a = t.end - t.start;
                            if (v) {
                                for (var r = 0, o = t.start; o < t.end; o++)
                                    r += g.getLineCoordsCount(o);
                                n = new Float32Array(a + 2 * r)
                            } else
                                n = new Float32Array(4 * a);
                            var s = 0
                              , l = [];
                            for (o = t.start; o < t.end; o++) {
                                var u = g.getLineCoords(o, i);
                                v && (n[s++] = u);
                                for (var h = 0; h < u; h++)
                                    l = m.dataToPoint(i[h], !1, l),
                                    n[s++] = l[0],
                                    n[s++] = l[1]
                            }
                            e.setLayout("linesPoints", n)
                        } else
                            for (o = t.start; o < t.end; o++) {
                                var c = e.getItemModel(o)
                                  , d = (u = g.getLineCoords(o, i),
                                []);
                                if (v)
                                    for (var p = 0; p < u; p++)
                                        d.push(m.dataToPoint(i[p]));
                                else {
                                    d[0] = m.dataToPoint(i[0]),
                                    d[1] = m.dataToPoint(i[1]);
                                    var f = c.get("lineStyle.curveness");
                                    +f && (d[2] = [(d[0][0] + d[1][0]) / 2 - (d[0][1] - d[1][1]) * f, (d[0][1] + d[1][1]) / 2 - (d[1][0] - d[0][0]) * f])
                                }
                                e.setItemLayout(o, d)
                            }
                    }
                }
            }
        };
        Gm.extendChartView({
            type: "lines",
            init: function() {},
            render: function(t, e, i) {
                var n = t.getData()
                  , a = this._updateLineDraw(n, t)
                  , r = t.get("zlevel")
                  , o = t.get("effect.trailLength")
                  , s = i.getZr()
                  , l = "svg" === s.painter.getType();
                l || s.painter.getLayer(r).clear(!0),
                null == this._lastZlevel || l || s.configLayer(this._lastZlevel, {
                    motionBlur: !1
                }),
                this._showEffect(t) && o && (l || s.configLayer(r, {
                    motionBlur: !0,
                    lastFrameAlpha: Math.max(Math.min(o / 10 + .9, 1), 0)
                })),
                a.updateData(n),
                this._lastZlevel = r,
                this._finished = !0
            },
            incrementalPrepareRender: function(t, e, i) {
                var n = t.getData();
                this._updateLineDraw(n, t).incrementalPrepareUpdate(n),
                this._clearLayer(i),
                this._finished = !1
            },
            incrementalRender: function(t, e, i) {
                this._lineDraw.incrementalUpdate(t, e.getData()),
                this._finished = t.end === e.getData().count()
            },
            updateTransform: function(t, e, i) {
                var n = t.getData()
                  , a = t.pipelineContext;
                if (!this._finished || a.large || a.progressiveRender)
                    return {
                        update: !0
                    };
                var r = sC.reset(t);
                r.progress && r.progress({
                    start: 0,
                    end: n.count()
                }, n),
                this._lineDraw.updateLayout(),
                this._clearLayer(i)
            },
            _updateLineDraw: function(t, e) {
                var i = this._lineDraw
                  , n = this._showEffect(e)
                  , a = !!e.get("polyline")
                  , r = e.pipelineContext.large;
                return i && n === this._hasEffet && a === this._isPolyline && r === this._isLargeDraw || (i && i.remove(),
                i = this._lineDraw = r ? new oC : new lM(a ? n ? iC : QT : n ? KT : iM),
                this._hasEffet = n,
                this._isPolyline = a,
                this._isLargeDraw = r,
                this.group.removeAll()),
                this.group.add(i.group),
                i
            },
            _showEffect: function(t) {
                return !!t.get("effect.show")
            },
            _clearLayer: function(t) {
                var e = t.getZr();
                "svg" === e.painter.getType() || null == this._lastZlevel || e.painter.getLayer(this._lastZlevel).clear(!0)
            },
            remove: function(t, e) {
                this._lineDraw && this._lineDraw.remove(),
                this._lineDraw = null,
                this._clearLayer(e)
            },
            dispose: function() {}
        });
        function lC(t) {
            return t instanceof Array || (t = [t, t]),
            t
        }
        var uC = "lineStyle.opacity".split(".")
          , hC = {
            seriesType: "lines",
            reset: function(t, e, i) {
                var n = lC(t.get("symbol"))
                  , a = lC(t.get("symbolSize"))
                  , r = t.getData();
                return r.setVisual("fromSymbol", n && n[0]),
                r.setVisual("toSymbol", n && n[1]),
                r.setVisual("fromSymbolSize", a && a[0]),
                r.setVisual("toSymbolSize", a && a[1]),
                r.setVisual("opacity", t.get(uC)),
                {
                    dataEach: r.hasItemOption ? function(t, e) {
                        var i = t.getItemModel(e)
                          , n = lC(i.getShallow("symbol", !0))
                          , a = lC(i.getShallow("symbolSize", !0))
                          , r = i.get(uC);
                        n[0] && t.setItemVisual(e, "fromSymbol", n[0]),
                        n[1] && t.setItemVisual(e, "toSymbol", n[1]),
                        a[0] && t.setItemVisual(e, "fromSymbolSize", a[0]),
                        a[1] && t.setItemVisual(e, "toSymbolSize", a[1]),
                        t.setItemVisual(e, "opacity", r)
                    }
                    : null
                }
            }
        };
        Gm.registerLayout(sC),
        Gm.registerVisual(hC);
        kc.extend({
            type: "series.heatmap",
            getInitialData: function(t, e) {
                return Sf(this.getSource(), this, {
                    generateCoord: "value"
                })
            },
            preventIncremental: function() {
                var t = ju.get(this.get("coordinateSystem"));
                if (t && t.dimensions)
                    return "lng" === t.dimensions[0] && "lat" === t.dimensions[1]
            },
            defaultOption: {
                coordinateSystem: "cartesian2d",
                zlevel: 0,
                z: 2,
                geoIndex: 0,
                blurSize: 30,
                pointSize: 20,
                maxOpacity: 1,
                minOpacity: 0
            }
        });
        function cC() {
            var t = it.createCanvas();
            this.canvas = t,
            this.blurSize = 30,
            this.pointSize = 20,
            this.maxOpacity = 1,
            this.minOpacity = 0,
            this._gradientPixels = {}
        }
        cC.prototype = {
            update: function(t, e, i, n, a, r) {
                var o = this._getBrush()
                  , s = this._getGradient(t, a, "inRange")
                  , l = this._getGradient(t, a, "outOfRange")
                  , u = this.pointSize + this.blurSize
                  , h = this.canvas
                  , c = h.getContext("2d")
                  , d = t.length;
                h.width = e,
                h.height = i;
                for (var p = 0; p < d; ++p) {
                    var f = t[p]
                      , g = f[0]
                      , m = f[1]
                      , v = n(f[2]);
                    c.globalAlpha = v,
                    c.drawImage(o, g - u, m - u)
                }
                if (!h.width || !h.height)
                    return h;
                for (var y = c.getImageData(0, 0, h.width, h.height), x = y.data, _ = 0, b = x.length, w = this.minOpacity, S = this.maxOpacity - w; _ < b; ) {
                    v = x[_ + 3] / 256;
                    var M = 4 * Math.floor(255 * v);
                    if (0 < v) {
                        var I = r(v) ? s : l;
                        0 < v && (v = v * S + w),
                        x[_++] = I[M],
                        x[_++] = I[1 + M],
                        x[_++] = I[2 + M],
                        x[_++] = I[3 + M] * v * 256
                    } else
                        _ += 4
                }
                return c.putImageData(y, 0, 0),
                h
            },
            _getBrush: function() {
                var t = this._brushCanvas || (this._brushCanvas = it.createCanvas())
                  , e = this.pointSize + this.blurSize
                  , i = 2 * e;
                t.width = i,
                t.height = i;
                var n = t.getContext("2d");
                return n.clearRect(0, 0, i, i),
                n.shadowOffsetX = i,
                n.shadowBlur = this.blurSize,
                n.shadowColor = "#000",
                n.beginPath(),
                n.arc(-e, e, this.pointSize, 0, 2 * Math.PI, !0),
                n.closePath(),
                n.fill(),
                t
            },
            _getGradient: function(t, e, i) {
                for (var n = this._gradientPixels, a = n[i] || (n[i] = new Uint8ClampedArray(1024)), r = [0, 0, 0, 0], o = 0, s = 0; s < 256; s++)
                    e[i](s / 255, !0, r),
                    a[o++] = r[0],
                    a[o++] = r[1],
                    a[o++] = r[2],
                    a[o++] = r[3];
                return a
            }
        };
        var dC = cC;
        Gm.extendChartView({
            type: "heatmap",
            render: function(i, t, e) {
                var n;
                t.eachComponent("visualMap", function(e) {
                    e.eachTargetSeries(function(t) {
                        t === i && (n = e)
                    })
                }),
                this.group.removeAll(),
                this._incrementalDisplayable = null;
                var a = i.coordinateSystem;
                "cartesian2d" === a.type || "calendar" === a.type ? this._renderOnCartesianAndCalendar(i, e, 0, i.getData().count()) : function(t) {
                    var e = t.dimensions;
                    return "lng" === e[0] && "lat" === e[1]
                }(a) && this._renderOnGeo(a, i, n, e)
            },
            incrementalPrepareRender: function(t, e, i) {
                this.group.removeAll()
            },
            incrementalRender: function(t, e, i, n) {
                e.coordinateSystem && this._renderOnCartesianAndCalendar(e, n, t.start, t.end, !0)
            },
            _renderOnCartesianAndCalendar: function(t, e, i, n, a) {
                var r, o, s = t.coordinateSystem;
                if ("cartesian2d" === s.type) {
                    var l = s.getAxis("x")
                      , u = s.getAxis("y");
                    r = l.getBandWidth(),
                    o = u.getBandWidth()
                }
                for (var h = this.group, c = t.getData(), d = "emphasis.itemStyle", p = "emphasis.label", f = t.getModel("itemStyle").getItemStyle(["color"]), g = t.getModel(d).getItemStyle(), m = t.getModel("label"), v = t.getModel(p), y = s.type, x = "cartesian2d" === y ? [c.mapDimension("x"), c.mapDimension("y"), c.mapDimension("value")] : [c.mapDimension("time"), c.mapDimension("value")], _ = i; _ < n; _++) {
                    var b;
                    if ("cartesian2d" === y) {
                        if (isNaN(c.get(x[2], _)))
                            continue;
                        var w = s.dataToPoint([c.get(x[0], _), c.get(x[1], _)]);
                        b = new Fs.Rect({
                            shape: {
                                x: w[0] - r / 2,
                                y: w[1] - o / 2,
                                width: r,
                                height: o
                            },
                            style: {
                                fill: c.getItemVisual(_, "color"),
                                opacity: c.getItemVisual(_, "opacity")
                            }
                        })
                    } else {
                        if (isNaN(c.get(x[1], _)))
                            continue;
                        b = new Fs.Rect({
                            z2: 1,
                            shape: s.dataToRect([c.get(x[0], _)]).contentShape,
                            style: {
                                fill: c.getItemVisual(_, "color"),
                                opacity: c.getItemVisual(_, "opacity")
                            }
                        })
                    }
                    var S = c.getItemModel(_);
                    c.hasItemOption && (f = S.getModel("itemStyle").getItemStyle(["color"]),
                    g = S.getModel(d).getItemStyle(),
                    m = S.getModel("label"),
                    v = S.getModel(p));
                    var M = t.getRawValue(_)
                      , I = "-";
                    M && null != M[2] && (I = M[2]),
                    Fs.setLabelStyle(f, g, m, v, {
                        labelFetcher: t,
                        labelDataIndex: _,
                        defaultText: I,
                        isRectText: !0
                    }),
                    b.setStyle(f),
                    Fs.setHoverStyle(b, c.hasItemOption ? g : it.extend({}, g)),
                    (b.incremental = a) && (b.useHoverLayer = !0),
                    h.add(b),
                    c.setItemGraphicEl(_, b)
                }
            },
            _renderOnGeo: function(a, t, e, i) {
                var n = e.targetVisuals.inRange
                  , r = e.targetVisuals.outOfRange
                  , o = t.getData()
                  , s = this._hmLayer || this._hmLayer || new dC;
                s.blurSize = t.get("blurSize"),
                s.pointSize = t.get("pointSize"),
                s.minOpacity = t.get("minOpacity"),
                s.maxOpacity = t.get("maxOpacity");
                var l = a.getViewRect().clone()
                  , u = a.getRoamTransform();
                l.applyTransform(u);
                var h = Math.max(l.x, 0)
                  , c = Math.max(l.y, 0)
                  , d = Math.min(l.width + l.x, i.getWidth())
                  , p = Math.min(l.height + l.y, i.getHeight())
                  , f = d - h
                  , g = p - c
                  , m = [o.mapDimension("lng"), o.mapDimension("lat"), o.mapDimension("value")]
                  , v = o.mapArray(m, function(t, e, i) {
                    var n = a.dataToPoint([t, e]);
                    return n[0] -= h,
                    n[1] -= c,
                    n.push(i),
                    n
                })
                  , y = e.getExtent()
                  , x = "visualMap.continuous" === e.type ? function(t, e) {
                    var i = t[1] - t[0];
                    return e = [(e[0] - t[0]) / i, (e[1] - t[0]) / i],
                    function(t) {
                        return t >= e[0] && t <= e[1]
                    }
                }(y, e.option.range) : function(e, n, a) {
                    var i = e[1] - e[0]
                      , r = (n = it.map(n, function(t) {
                        return {
                            interval: [(t.interval[0] - e[0]) / i, (t.interval[1] - e[0]) / i]
                        }
                    })).length
                      , o = 0;
                    return function(t) {
                        for (var e = o; e < r; e++) {
                            if ((i = n[e].interval)[0] <= t && t <= i[1]) {
                                o = e;
                                break
                            }
                        }
                        if (e === r)
                            for (e = o - 1; 0 <= e; e--) {
                                var i;
                                if ((i = n[e].interval)[0] <= t && t <= i[1]) {
                                    o = e;
                                    break
                                }
                            }
                        return 0 <= e && e < r && a[e]
                    }
                }(y, e.getPieceList(), e.option.selected);
                s.update(v, f, g, n.color.getNormalizer(), {
                    inRange: n.color.getColorMapper(),
                    outOfRange: r.color.getColorMapper()
                }, x);
                var _ = new Fs.Image({
                    style: {
                        width: f,
                        height: g,
                        x: h,
                        y: c,
                        image: s.canvas
                    },
                    silent: !0
                });
                this.group.add(_)
            },
            dispose: function() {}
        });
        var pC = hx.extend({
            type: "series.pictorialBar",
            dependencies: ["grid"],
            defaultOption: {
                symbol: "circle",
                symbolSize: null,
                symbolRotate: null,
                symbolPosition: null,
                symbolOffset: null,
                symbolMargin: null,
                symbolRepeat: !1,
                symbolRepeatDirection: "end",
                symbolClip: !1,
                symbolBoundingData: null,
                symbolPatternSize: 400,
                barGap: "-100%",
                progressive: 0,
                hoverAnimation: !1
            },
            getInitialData: function(t) {
                return t.stack = null,
                pC.superApply(this, "getInitialData", arguments)
            }
        })
          , fC = Fg.createSymbol
          , gC = ol.parsePercent
          , mC = ol.isNumeric
          , vC = px.setLabel
          , yC = ["itemStyle", "borderWidth"]
          , xC = [{
            xy: "x",
            wh: "width",
            index: 0,
            posDesc: ["left", "right"]
        }, {
            xy: "y",
            wh: "height",
            index: 1,
            posDesc: ["top", "bottom"]
        }]
          , _C = new Fs.Circle;
        Gm.extendChartView({
            type: "pictorialBar",
            render: function(t, e, i) {
                var o = this.group
                  , s = t.getData()
                  , l = this._data
                  , n = t.coordinateSystem
                  , a = !!n.getBaseAxis().isHorizontal()
                  , r = n.grid.getRect()
                  , u = {
                    ecSize: {
                        width: i.getWidth(),
                        height: i.getHeight()
                    },
                    seriesModel: t,
                    coordSys: n,
                    coordSysExtent: [[r.x, r.x + r.width], [r.y, r.y + r.height]],
                    isHorizontal: a,
                    valueDim: xC[+a],
                    categoryDim: xC[1 - a]
                };
                return s.diff(l).add(function(t) {
                    if (s.hasValue(t)) {
                        var e = CC(s, t)
                          , i = bC(s, t, e, u)
                          , n = kC(s, u, i);
                        s.setItemGraphicEl(t, n),
                        o.add(n),
                        zC(n, u, i)
                    }
                }).update(function(t, e) {
                    var i = l.getItemGraphicEl(e);
                    if (s.hasValue(t)) {
                        var n = CC(s, t)
                          , a = bC(s, t, n, u)
                          , r = RC(s, a);
                        i && r !== i.__pictorialShapeStr && (o.remove(i),
                        s.setItemGraphicEl(t, null),
                        i = null),
                        i ? function(t, e, i) {
                            var n = i.animationModel
                              , a = i.dataIndex
                              , r = t.__pictorialBundle;
                            Fs.updateProps(r, {
                                position: i.bundlePosition.slice()
                            }, n, a),
                            i.symbolRepeat ? MC(t, e, i, !0) : IC(t, e, i, !0);
                            AC(t, i, !0),
                            TC(t, e, i, !0)
                        }(i, u, a) : i = kC(s, u, a, !0),
                        s.setItemGraphicEl(t, i),
                        i.__pictorialSymbolMeta = a,
                        o.add(i),
                        zC(i, u, a)
                    } else
                        o.remove(i)
                }).remove(function(t) {
                    var e = l.getItemGraphicEl(t);
                    e && OC(l, t, e.__pictorialSymbolMeta.animationModel, e)
                }).execute(),
                this._data = s,
                this.group
            },
            dispose: it.noop,
            remove: function(e, t) {
                var i = this.group
                  , n = this._data;
                e.get("animation") ? n && n.eachItemGraphicEl(function(t) {
                    OC(n, t.dataIndex, e, t)
                }) : i.removeAll()
            }
        });
        function bC(t, e, i, n) {
            var a = t.getItemLayout(e)
              , r = i.get("symbolRepeat")
              , o = i.get("symbolClip")
              , s = i.get("symbolPosition") || "start"
              , l = (i.get("symbolRotate") || 0) * Math.PI / 180 || 0
              , u = i.get("symbolPatternSize") || 2
              , h = i.isAnimationEnabled()
              , c = {
                dataIndex: e,
                layout: a,
                itemModel: i,
                symbolType: t.getItemVisual(e, "symbol") || "circle",
                color: t.getItemVisual(e, "color"),
                symbolClip: o,
                symbolRepeat: r,
                symbolRepeatDirection: i.get("symbolRepeatDirection"),
                symbolPatternSize: u,
                rotation: l,
                animationModel: h ? i : null,
                hoverAnimation: h && i.get("hoverAnimation"),
                z2: i.getShallow("z", !0) || 0
            };
            !function(t, e, i, n, a) {
                var r, o = n.valueDim, s = t.get("symbolBoundingData"), l = n.coordSys.getOtherAxis(n.coordSys.getBaseAxis()), u = l.toGlobalCoord(l.dataToCoord(0)), h = 1 - +(i[o.wh] <= 0);
                if (it.isArray(s)) {
                    var c = [wC(l, s[0]) - u, wC(l, s[1]) - u];
                    c[1] < c[0] && c.reverse(),
                    r = c[h]
                } else
                    r = null != s ? wC(l, s) - u : e ? n.coordSysExtent[o.index][h] - u : i[o.wh];
                a.boundingLength = r,
                e && (a.repeatCutLength = i[o.wh]);
                a.pxSign = 0 < r ? 1 : r < 0 ? -1 : 0
            }(i, r, a, n, c),
            function(t, e, i, n, a, r, o, s, l, u) {
                var h = l.valueDim
                  , c = l.categoryDim
                  , d = Math.abs(i[c.wh])
                  , p = t.getItemVisual(e, "symbolSize");
                p = it.isArray(p) ? p.slice() : (null == p && (p = "100%"),
                [p, p]);
                p[c.index] = gC(p[c.index], d),
                p[h.index] = gC(p[h.index], n ? d : Math.abs(r)),
                u.symbolSize = p,
                (u.symbolScale = [p[0] / s, p[1] / s])[h.index] *= (l.isHorizontal ? -1 : 1) * o
            }(t, e, a, r, 0, c.boundingLength, c.pxSign, u, n, c),
            function(t, e, i, n, a) {
                var r = t.get(yC) || 0;
                r && (_C.attr({
                    scale: e.slice(),
                    rotation: i
                }),
                _C.updateTransform(),
                r /= _C.getLineScale(),
                r *= e[n.valueDim.index]);
                a.valueLineWidth = r
            }(i, c.symbolScale, l, n, c);
            var d = c.symbolSize
              , p = i.get("symbolOffset");
            return it.isArray(p) && (p = [gC(p[0], d[0]), gC(p[1], d[1])]),
            function(t, e, i, n, a, r, o, s, l, u, h, c) {
                var d = h.categoryDim
                  , p = h.valueDim
                  , f = c.pxSign
                  , g = Math.max(e[p.index] + s, 0)
                  , m = g;
                if (n) {
                    var v = Math.abs(l)
                      , y = it.retrieve(t.get("symbolMargin"), "15%") + ""
                      , x = !1;
                    y.lastIndexOf("!") === y.length - 1 && (x = !0,
                    y = y.slice(0, y.length - 1)),
                    y = gC(y, e[p.index]);
                    var _ = Math.max(g + 2 * y, 0)
                      , b = x ? 0 : 2 * y
                      , w = mC(n)
                      , S = w ? n : VC((v + b) / _);
                    _ = g + 2 * (y = (v - S * g) / 2 / (x ? S : S - 1)),
                    b = x ? 0 : 2 * y,
                    w || "fixed" === n || (S = u ? VC((Math.abs(u) + b) / _) : 0),
                    m = S * _ - b,
                    c.repeatTimes = S,
                    c.symbolMargin = y
                }
                var M = f * (m / 2)
                  , I = c.pathPosition = [];
                I[d.index] = i[d.wh] / 2,
                I[p.index] = "start" === o ? M : "end" === o ? l - M : l / 2,
                r && (I[0] += r[0],
                I[1] += r[1]);
                var A = c.bundlePosition = [];
                A[d.index] = i[d.xy],
                A[p.index] = i[p.xy];
                var T = c.barRectShape = it.extend({}, i);
                T[p.wh] = f * Math.max(Math.abs(i[p.wh]), Math.abs(I[p.index] + M)),
                T[d.wh] = i[d.wh];
                var C = c.clipShape = {};
                C[d.xy] = -i[d.xy],
                C[d.wh] = h.ecSize[d.wh],
                C[p.xy] = 0,
                C[p.wh] = i[p.wh]
            }(i, d, a, r, 0, p, s, c.valueLineWidth, c.boundingLength, c.repeatCutLength, n, c),
            c
        }
        function wC(t, e) {
            return t.toGlobalCoord(t.dataToCoord(t.scale.parse(e)))
        }
        function SC(t) {
            var e = t.symbolPatternSize
              , i = fC(t.symbolType, -e / 2, -e / 2, e, e, t.color);
            return i.attr({
                culling: !0
            }),
            "image" !== i.type && i.setStyle({
                strokeNoScale: !0
            }),
            i
        }
        function MC(t, e, a, i) {
            var n = t.__pictorialBundle
              , r = a.symbolSize
              , o = a.valueLineWidth
              , s = a.pathPosition
              , l = e.valueDim
              , u = a.repeatTimes || 0
              , h = 0
              , c = r[e.valueDim.index] + o + 2 * a.symbolMargin;
            for (NC(t, function(t) {
                t.__pictorialAnimationIndex = h,
                t.__pictorialRepeatTimes = u,
                h < u ? EC(t, null, f(h), a, i) : EC(t, null, {
                    scale: [0, 0]
                }, a, i, function() {
                    n.remove(t)
                }),
                PC(t, a),
                h++
            }); h < u; h++) {
                var d = SC(a);
                d.__pictorialAnimationIndex = h,
                d.__pictorialRepeatTimes = u,
                n.add(d);
                var p = f(h);
                EC(d, {
                    position: p.position,
                    scale: [0, 0]
                }, {
                    scale: p.scale,
                    rotation: p.rotation
                }, a, i),
                d.on("mouseover", g).on("mouseout", m),
                PC(d, a)
            }
            function f(t) {
                var e = s.slice()
                  , i = a.pxSign
                  , n = t;
                return ("start" === a.symbolRepeatDirection ? 0 < i : i < 0) && (n = u - 1 - t),
                e[l.index] = c * (n - u / 2 + .5) + s[l.index],
                {
                    position: e,
                    scale: a.symbolScale.slice(),
                    rotation: a.rotation
                }
            }
            function g() {
                NC(t, function(t) {
                    t.trigger("emphasis")
                })
            }
            function m() {
                NC(t, function(t) {
                    t.trigger("normal")
                })
            }
        }
        function IC(t, e, i, n) {
            var a = t.__pictorialBundle
              , r = t.__pictorialMainPath;
            r ? EC(r, null, {
                position: i.pathPosition.slice(),
                scale: i.symbolScale.slice(),
                rotation: i.rotation
            }, i, n) : (r = t.__pictorialMainPath = SC(i),
            a.add(r),
            EC(r, {
                position: i.pathPosition.slice(),
                scale: [0, 0],
                rotation: i.rotation
            }, {
                scale: i.symbolScale.slice()
            }, i, n),
            r.on("mouseover", function() {
                this.trigger("emphasis")
            }).on("mouseout", function() {
                this.trigger("normal")
            })),
            PC(r, i)
        }
        function AC(t, e, i) {
            var n = it.extend({}, e.barRectShape)
              , a = t.__pictorialBarRect;
            a ? EC(a, null, {
                shape: n
            }, e, i) : (a = t.__pictorialBarRect = new Fs.Rect({
                z2: 2,
                shape: n,
                silent: !0,
                style: {
                    stroke: "transparent",
                    fill: "transparent",
                    lineWidth: 0
                }
            }),
            t.add(a))
        }
        function TC(t, e, i, n) {
            if (i.symbolClip) {
                var a = t.__pictorialClipPath
                  , r = it.extend({}, i.clipShape)
                  , o = e.valueDim
                  , s = i.animationModel
                  , l = i.dataIndex;
                if (a)
                    Fs.updateProps(a, {
                        shape: r
                    }, s, l);
                else {
                    r[o.wh] = 0,
                    a = new Fs.Rect({
                        shape: r
                    }),
                    t.__pictorialBundle.setClipPath(a),
                    t.__pictorialClipPath = a;
                    var u = {};
                    u[o.wh] = i.clipShape[o.wh],
                    Fs[n ? "updateProps" : "initProps"](a, {
                        shape: u
                    }, s, l)
                }
            }
        }
        function CC(t, e) {
            var i = t.getItemModel(e);
            return i.getAnimationDelayParams = DC,
            i.isAnimationEnabled = LC,
            i
        }
        function DC(t) {
            return {
                index: t.__pictorialAnimationIndex,
                count: t.__pictorialRepeatTimes
            }
        }
        function LC() {
            return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation")
        }
        function PC(t, e) {
            t.off("emphasis").off("normal");
            var i = e.symbolScale.slice();
            e.hoverAnimation && t.on("emphasis", function() {
                this.animateTo({
                    scale: [1.1 * i[0], 1.1 * i[1]]
                }, 400, "elasticOut")
            }).on("normal", function() {
                this.animateTo({
                    scale: i.slice()
                }, 400, "elasticOut")
            })
        }
        function kC(t, e, i, n) {
            var a = new Fs.Group
              , r = new Fs.Group;
            return a.add(r),
            (a.__pictorialBundle = r).attr("position", i.bundlePosition.slice()),
            i.symbolRepeat ? MC(a, e, i) : IC(a, 0, i),
            AC(a, i, n),
            TC(a, e, i, n),
            a.__pictorialShapeStr = RC(t, i),
            a.__pictorialSymbolMeta = i,
            a
        }
        function OC(t, e, i, n) {
            var a = n.__pictorialBarRect;
            a && (a.style.text = null);
            var r = [];
            NC(n, function(t) {
                r.push(t)
            }),
            n.__pictorialMainPath && r.push(n.__pictorialMainPath),
            n.__pictorialClipPath && (i = null),
            it.each(r, function(t) {
                Fs.updateProps(t, {
                    scale: [0, 0]
                }, i, e, function() {
                    n.parent && n.parent.remove(n)
                })
            }),
            t.setItemGraphicEl(e, null)
        }
        function RC(t, e) {
            return [t.getItemVisual(e.dataIndex, "symbol") || "none", !!e.symbolRepeat, !!e.symbolClip].join(":")
        }
        function NC(e, i, n) {
            it.each(e.__pictorialBundle.children(), function(t) {
                t !== e.__pictorialBarRect && i.call(n, t)
            })
        }
        function EC(t, e, i, n, a, r) {
            e && t.attr(e),
            n.symbolClip && !a ? i && t.attr(i) : i && Fs[a ? "updateProps" : "initProps"](t, i, n.animationModel, n.dataIndex, r)
        }
        function zC(t, e, i) {
            var n = i.color
              , a = i.dataIndex
              , r = i.itemModel
              , o = r.getModel("itemStyle").getItemStyle(["color"])
              , s = r.getModel("emphasis.itemStyle").getItemStyle()
              , l = r.getShallow("cursor");
            NC(t, function(t) {
                t.setColor(n),
                t.setStyle(it.defaults({
                    fill: n,
                    opacity: i.opacity
                }, o)),
                Fs.setHoverStyle(t, s),
                l && (t.cursor = l),
                t.z2 = i.z2
            });
            var u = {}
              , h = e.valueDim.posDesc[+(0 < i.boundingLength)]
              , c = t.__pictorialBarRect;
            vC(c.style, u, r, n, e.seriesModel, a, h),
            Fs.setHoverStyle(c, u)
        }
        function VC(t) {
            var e = Math.round(t);
            return Math.abs(t - e) < 1e-4 ? e : Math.ceil(t)
        }
        var BC = rg.layout;
        Gm.registerLayout(it.curry(BC, "pictorialBar")),
        Gm.registerVisual(Fv("pictorialBar", "roundRect"));
        function GC(t, e, i, n, a) {
            wm.call(this, t, e, i),
            this.type = n || "value",
            this.position = a || "bottom",
            this.orient = null
        }
        GC.prototype = {
            constructor: GC,
            model: null,
            isHorizontal: function() {
                var t = this.position;
                return "top" === t || "bottom" === t
            },
            pointToData: function(t, e) {
                return this.coordinateSystem.pointToData(t, e)[0]
            },
            toGlobalCoord: null,
            toLocalCoord: null
        },
        it.inherits(GC, wm);
        var FC = GC
          , HC = Il.getLayoutRect
          , WC = it.each;
        function ZC(t, e, i) {
            this.dimension = "single",
            this.dimensions = ["single"],
            this._axis = null,
            this._rect,
            this._init(t, e, i),
            this.model = t
        }
        ZC.prototype = {
            type: "singleAxis",
            axisPointerEnabled: !0,
            constructor: ZC,
            _init: function(t, e, i) {
                var n = this.dimension
                  , a = new FC(n,Lg.createScaleByModel(t),[0, 0],t.get("type"),t.get("position"))
                  , r = "category" === a.type;
                a.onBand = r && t.get("boundaryGap"),
                a.inverse = t.get("inverse"),
                a.orient = t.get("orient"),
                (t.axis = a).model = t,
                (a.coordinateSystem = this)._axis = a
            },
            update: function(t, e) {
                t.eachSeries(function(t) {
                    if (t.coordinateSystem === this) {
                        var e = t.getData();
                        WC(e.mapDimension(this.dimension, !0), function(t) {
                            this._axis.scale.unionExtentFromData(e, t)
                        }, this),
                        Lg.niceScaleExtent(this._axis.scale, this._axis.model)
                    }
                }, this)
            },
            resize: function(t, e) {
                this._rect = HC({
                    left: t.get("left"),
                    top: t.get("top"),
                    right: t.get("right"),
                    bottom: t.get("bottom"),
                    width: t.get("width"),
                    height: t.get("height")
                }, {
                    width: e.getWidth(),
                    height: e.getHeight()
                }),
                this._adjustAxis()
            },
            getRect: function() {
                return this._rect
            },
            _adjustAxis: function() {
                var t = this._rect
                  , e = this._axis
                  , i = e.isHorizontal()
                  , n = i ? [0, t.width] : [0, t.height]
                  , a = e.reverse ? 1 : 0;
                e.setExtent(n[a], n[1 - a]),
                this._updateAxisTransform(e, i ? t.x : t.y)
            },
            _updateAxisTransform: function(t, e) {
                var i = t.getExtent()
                  , n = i[0] + i[1]
                  , a = t.isHorizontal();
                t.toGlobalCoord = a ? function(t) {
                    return t + e
                }
                : function(t) {
                    return n - t + e
                }
                ,
                t.toLocalCoord = a ? function(t) {
                    return t - e
                }
                : function(t) {
                    return n - t + e
                }
            },
            getAxis: function() {
                return this._axis
            },
            getBaseAxis: function() {
                return this._axis
            },
            getAxes: function() {
                return [this._axis]
            },
            getTooltipAxes: function() {
                return {
                    baseAxes: [this.getAxis()]
                }
            },
            containPoint: function(t) {
                var e = this.getRect()
                  , i = this.getAxis();
                return "horizontal" === i.orient ? i.contain(i.toLocalCoord(t[0])) && t[1] >= e.y && t[1] <= e.y + e.height : i.contain(i.toLocalCoord(t[1])) && t[0] >= e.y && t[0] <= e.y + e.height
            },
            pointToData: function(t) {
                var e = this.getAxis();
                return [e.coordToData(e.toLocalCoord(t["horizontal" === e.orient ? 0 : 1]))]
            },
            dataToPoint: function(t) {
                var e = this.getAxis()
                  , i = this.getRect()
                  , n = []
                  , a = "horizontal" === e.orient ? 0 : 1;
                return t instanceof Array && (t = t[0]),
                n[a] = e.toGlobalCoord(e.dataToCoord(+t)),
                n[1 - a] = 0 == a ? i.y + i.height / 2 : i.x + i.width / 2,
                n
            }
        };
        var UC = ZC;
        ju.register("single", {
            create: function(n, a) {
                var r = [];
                return n.eachComponent("singleAxis", function(t, e) {
                    var i = new UC(t,n,a);
                    i.name = "single_" + e,
                    i.resize(t, a),
                    t.coordinateSystem = i,
                    r.push(i)
                }),
                n.eachSeries(function(t) {
                    if ("singleAxis" === t.get("coordinateSystem")) {
                        var e = n.queryComponents({
                            mainType: "singleAxis",
                            index: t.get("singleAxisIndex"),
                            id: t.get("singleAxisId")
                        })[0];
                        t.coordinateSystem = e && e.coordinateSystem
                    }
                }),
                r
            },
            dimensions: UC.prototype.dimensions
        });
        var YC = {
            layout: function(t, e) {
                e = e || {};
                var i = t.coordinateSystem
                  , n = t.axis
                  , a = {}
                  , r = n.position
                  , o = n.orient
                  , s = i.getRect()
                  , l = [s.x, s.x + s.width, s.y, s.y + s.height]
                  , u = {
                    horizontal: {
                        top: l[2],
                        bottom: l[3]
                    },
                    vertical: {
                        left: l[0],
                        right: l[1]
                    }
                };
                a.position = ["vertical" === o ? u.vertical[r] : l[0], "horizontal" === o ? u.horizontal[r] : l[3]],
                a.rotation = Math.PI / 2 * {
                    horizontal: 0,
                    vertical: 1
                }[o],
                a.labelDirection = a.tickDirection = a.nameDirection = {
                    top: -1,
                    bottom: 1,
                    right: 1,
                    left: -1
                }[r],
                t.get("axisTick.inside") && (a.tickDirection = -a.tickDirection),
                it.retrieve(e.labelInside, t.get("axisLabel.inside")) && (a.labelDirection = -a.labelDirection);
                var h = e.rotate;
                return null == h && (h = t.get("axisLabel.rotate")),
                a.labelRotation = "top" === r ? -h : h,
                a.z2 = 1,
                a
            }
        }
          , jC = ["axisLine", "axisTickLabel", "axisName"]
          , XC = "splitLine"
          , qC = rx.extend({
            type: "singleAxis",
            axisPointerClass: "SingleAxisPointer",
            render: function(t, e, i, n) {
                var a = this.group;
                a.removeAll();
                var r = YC.layout(t)
                  , o = new jy(t,r);
                it.each(jC, o.add, o),
                a.add(o.getGroup()),
                t.get(XC + ".show") && this["_" + XC](t),
                qC.superCall(this, "render", t, e, i, n)
            },
            _splitLine: function(t) {
                var e = t.axis;
                if (!e.scale.isBlank()) {
                    var i = t.getModel("splitLine")
                      , n = i.getModel("lineStyle")
                      , a = n.get("width")
                      , r = n.get("color");
                    r = r instanceof Array ? r : [r];
                    for (var o = t.coordinateSystem.getRect(), s = e.isHorizontal(), l = [], u = 0, h = e.getTicksCoords({
                        tickModel: i
                    }), c = [], d = [], p = 0; p < h.length; ++p) {
                        var f = e.toGlobalCoord(h[p].coord);
                        s ? (c[0] = f,
                        c[1] = o.y,
                        d[0] = f,
                        d[1] = o.y + o.height) : (c[0] = o.x,
                        c[1] = f,
                        d[0] = o.x + o.width,
                        d[1] = f);
                        var g = u++ % r.length;
                        l[g] = l[g] || [],
                        l[g].push(new Fs.Line(Fs.subPixelOptimizeLine({
                            shape: {
                                x1: c[0],
                                y1: c[1],
                                x2: d[0],
                                y2: d[1]
                            },
                            style: {
                                lineWidth: a
                            },
                            silent: !0
                        })))
                    }
                    for (p = 0; p < l.length; ++p)
                        this.group.add(Fs.mergePath(l[p], {
                            style: {
                                stroke: r[p % r.length],
                                lineDash: n.getLineDash(a),
                                lineWidth: a
                            },
                            silent: !0
                        }))
                }
            }
        })
          , KC = Pl.extend({
            type: "singleAxis",
            layoutMode: "box",
            axis: null,
            coordinateSystem: null,
            getCoordSysModel: function() {
                return this
            }
        });
        it.merge(KC.prototype, Pg),
        sy("single", KC, function(t, e) {
            return e.type || (e.data ? "category" : "value")
        }, {
            left: "5%",
            top: "5%",
            right: "5%",
            bottom: "5%",
            type: "value",
            position: "bottom",
            orient: "horizontal",
            axisLine: {
                show: !0,
                lineStyle: {
                    width: 2,
                    type: "solid"
                }
            },
            tooltip: {
                show: !0
            },
            axisTick: {
                show: !0,
                length: 6,
                lineStyle: {
                    width: 2
                }
            },
            axisLabel: {
                show: !0,
                interval: "auto"
            },
            splitLine: {
                show: !0,
                lineStyle: {
                    type: "dashed",
                    opacity: .2
                }
            }
        });
        var $C = function(t, e) {
            var i, n = [], a = t.seriesIndex;
            if (null == a || !(i = e.getSeriesByIndex(a)))
                return {
                    point: []
                };
            var r = i.getData()
              , o = aa.queryDataIndex(r, t);
            if (null == o || o < 0 || it.isArray(o))
                return {
                    point: []
                };
            var s = r.getItemGraphicEl(o)
              , l = i.coordinateSystem;
            if (i.getTooltipPosition)
                n = i.getTooltipPosition(o) || [];
            else if (l && l.dataToPoint)
                n = l.dataToPoint(r.getValues(it.map(l.dimensions, function(t) {
                    return r.mapDimension(t)
                }), o, !0)) || [];
            else if (s) {
                var u = s.getBoundingRect().clone();
                u.applyTransform(s.transform),
                n = [u.x + u.width / 2, u.y + u.height / 2]
            }
            return {
                point: n,
                el: s
            }
        }
          , JC = aa.makeInner
          , QC = it.each
          , tD = it.curry
          , eD = JC();
        function iD(t, e, i, n, a) {
            var r = t.axis;
            if (!r.scale.isBlank() && r.containData(e))
                if (t.involveSeries) {
                    var o = function(l, t) {
                        var u = t.axis
                          , h = u.dim
                          , c = l
                          , d = []
                          , p = Number.MAX_VALUE
                          , f = -1;
                        return QC(t.seriesModels, function(e, t) {
                            var i, n, a = e.getData().mapDimension(h, !0);
                            if (e.getAxisTooltipData) {
                                var r = e.getAxisTooltipData(a, l, u);
                                n = r.dataIndices,
                                i = r.nestestValue
                            } else {
                                if (!(n = e.getData().indicesOfNearest(a[0], l, "category" === u.type ? .5 : null)).length)
                                    return;
                                i = e.getData().get(a[0], n[0])
                            }
                            if (null != i && isFinite(i)) {
                                var o = l - i
                                  , s = Math.abs(o);
                                s <= p && ((s < p || 0 <= o && f < 0) && (p = s,
                                f = o,
                                c = i,
                                d.length = 0),
                                QC(n, function(t) {
                                    d.push({
                                        seriesIndex: e.seriesIndex,
                                        dataIndexInside: t,
                                        dataIndex: e.getData().getRawIndex(t)
                                    })
                                }))
                            }
                        }),
                        {
                            payloadBatch: d,
                            snapToValue: c
                        }
                    }(e, t)
                      , s = o.payloadBatch
                      , l = o.snapToValue;
                    s[0] && null == a.seriesIndex && it.extend(a, s[0]),
                    !n && t.snap && r.containData(l) && null != l && (e = l),
                    i.showPointer(t, e, s, a),
                    i.showTooltip(t, o, l)
                } else
                    i.showPointer(t, e)
        }
        function nD(t, e, i, n) {
            t[e.key] = {
                value: i,
                payloadBatch: n
            }
        }
        function aD(t, e, i, n) {
            var a = i.payloadBatch
              , r = e.axis
              , o = r.model
              , s = e.axisPointerModel;
            if (e.triggerTooltip && a.length) {
                var l = e.coordSys.model
                  , u = tx.makeKey(l)
                  , h = t.map[u];
                h || (h = t.map[u] = {
                    coordSysId: l.id,
                    coordSysIndex: l.componentIndex,
                    coordSysType: l.type,
                    coordSysMainType: l.mainType,
                    dataByAxis: []
                },
                t.list.push(h)),
                h.dataByAxis.push({
                    axisDim: r.dim,
                    axisIndex: o.componentIndex,
                    axisType: o.type,
                    axisId: o.id,
                    value: n,
                    valueLabelOpt: {
                        precision: s.get("label.precision"),
                        formatter: s.get("label.formatter")
                    },
                    seriesDataIndices: a.slice()
                })
            }
        }
        function rD(t) {
            var e = t.axis.model
              , i = {}
              , n = i.axisDim = t.axis.dim;
            return i.axisIndex = i[n + "AxisIndex"] = e.componentIndex,
            i.axisName = i[n + "AxisName"] = e.name,
            i.axisId = i[n + "AxisId"] = e.id,
            i
        }
        function oD(t) {
            return !t || null == t[0] || isNaN(t[0]) || null == t[1] || isNaN(t[1])
        }
        function sD(t, e, i) {
            var n = t.currTrigger
              , o = [t.x, t.y]
              , a = t
              , r = t.dispatchAction || it.bind(i.dispatchAction, i)
              , s = e.getComponent("axisPointer").coordSysAxesInfo;
            if (s) {
                oD(o) && (o = $C({
                    seriesIndex: a.seriesIndex,
                    dataIndex: a.dataIndex
                }, e).point);
                var l = oD(o)
                  , u = a.axesInfo
                  , h = s.axesInfo
                  , c = "leave" === n || oD(o)
                  , d = {}
                  , p = {}
                  , f = {
                    list: [],
                    map: {}
                }
                  , g = {
                    showPointer: tD(nD, p),
                    showTooltip: tD(aD, f)
                };
                QC(s.coordSysMap, function(t, e) {
                    var r = l || t.containPoint(o);
                    QC(s.coordSysAxesInfo[e], function(t, e) {
                        var i = t.axis
                          , n = function(t, e) {
                            for (var i = 0; i < (t || []).length; i++) {
                                var n = t[i];
                                if (e.axis.dim === n.axisDim && e.axis.model.componentIndex === n.axisIndex)
                                    return n
                            }
                        }(u, t);
                        if (!c && r && (!u || n)) {
                            var a = n && n.value;
                            null != a || l || (a = i.pointToData(o)),
                            null != a && iD(t, a, g, !1, d)
                        }
                    })
                });
                var m = {};
                return QC(h, function(a, t) {
                    var r = a.linkGroup;
                    r && !p[t] && QC(r.axesInfo, function(t, e) {
                        var i = p[e];
                        if (t !== a && i) {
                            var n = i.value;
                            r.mapper && (n = a.axis.scale.parse(r.mapper(n, rD(t), rD(a)))),
                            m[a.key] = n
                        }
                    })
                }),
                QC(m, function(t, e) {
                    iD(h[e], t, g, !0, d)
                }),
                function(a, t, e) {
                    var r = e.axesInfo = [];
                    QC(t, function(t, e) {
                        var i = t.axisPointerModel.option
                          , n = a[e];
                        n ? (t.useHandle || (i.status = "show"),
                        i.value = n.value,
                        i.seriesDataIndices = (n.payloadBatch || []).slice()) : t.useHandle || (i.status = "hide"),
                        "show" === i.status && r.push({
                            axisDim: t.axis.dim,
                            axisIndex: t.axis.model.componentIndex,
                            value: i.value
                        })
                    })
                }(p, h, d),
                function(t, e, i, n) {
                    if (oD(e) || !t.list.length)
                        return n({
                            type: "hideTip"
                        });
                    var a = ((t.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
                    n({
                        type: "showTip",
                        escapeConnect: !0,
                        x: e[0],
                        y: e[1],
                        tooltipOption: i.tooltipOption,
                        position: i.position,
                        dataIndexInside: a.dataIndexInside,
                        dataIndex: a.dataIndex,
                        seriesIndex: a.seriesIndex,
                        dataByCoordSys: t.list
                    })
                }(f, o, t, r),
                function(t, e, i) {
                    var n = i.getZr()
                      , a = "axisPointerLastHighlights"
                      , r = eD(n)[a] || {}
                      , o = eD(n)[a] = {};
                    QC(t, function(t, e) {
                        var i = t.axisPointerModel.option;
                        "show" === i.status && QC(i.seriesDataIndices, function(t) {
                            var e = t.seriesIndex + " | " + t.dataIndex;
                            o[e] = t
                        })
                    });
                    var s = []
                      , l = [];
                    it.each(r, function(t, e) {
                        o[e] || l.push(t)
                    }),
                    it.each(o, function(t, e) {
                        r[e] || s.push(t)
                    }),
                    l.length && i.dispatchAction({
                        type: "downplay",
                        escapeConnect: !0,
                        batch: l
                    }),
                    s.length && i.dispatchAction({
                        type: "highlight",
                        escapeConnect: !0,
                        batch: s
                    })
                }(h, 0, i),
                d
            }
        }
        Gm.extendComponentModel({
            type: "axisPointer",
            coordSysAxesInfo: null,
            defaultOption: {
                show: "auto",
                triggerOn: null,
                zlevel: 0,
                z: 50,
                type: "line",
                snap: !1,
                triggerTooltip: !0,
                value: null,
                status: null,
                link: [],
                animation: null,
                animationDurationUpdate: 200,
                lineStyle: {
                    color: "#aaa",
                    width: 1,
                    type: "solid"
                },
                shadowStyle: {
                    color: "rgba(150,150,150,0.3)"
                },
                label: {
                    show: !0,
                    formatter: null,
                    precision: "auto",
                    margin: 3,
                    color: "#fff",
                    padding: [5, 7, 5, 7],
                    backgroundColor: "auto",
                    borderColor: null,
                    borderWidth: 0,
                    shadowBlur: 3,
                    shadowColor: "#aaa"
                },
                handle: {
                    show: !1,
                    icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
                    size: 45,
                    margin: 50,
                    color: "#333",
                    shadowBlur: 3,
                    shadowColor: "#aaa",
                    shadowOffsetX: 0,
                    shadowOffsetY: 2,
                    throttle: 40
                }
            }
        });
        var lD = (0,
        aa.makeInner)()
          , uD = it.each;
        function hD(t, e, i) {
            t.handler("leave", null, i)
        }
        function cD(t, e, i, n) {
            e.handler(t, i, n)
        }
        var dD = {
            register: function(t, e, i) {
                if (!et.node) {
                    var n = e.getZr();
                    lD(n).records || (lD(n).records = {}),
                    function(a, r) {
                        if (lD(a).initialized)
                            return;
                        function t(t, n) {
                            a.on(t, function(e) {
                                var i = function(i) {
                                    var n = {
                                        showTip: [],
                                        hideTip: []
                                    }
                                      , a = function(t) {
                                        var e = n[t.type];
                                        e ? e.push(t) : (t.dispatchAction = a,
                                        i.dispatchAction(t))
                                    };
                                    return {
                                        dispatchAction: a,
                                        pendings: n
                                    }
                                }(r);
                                uD(lD(a).records, function(t) {
                                    t && n(t, e, i.dispatchAction)
                                }),
                                function(t, e) {
                                    var i, n = t.showTip.length, a = t.hideTip.length;
                                    n ? i = t.showTip[n - 1] : a && (i = t.hideTip[a - 1]);
                                    i && (i.dispatchAction = null,
                                    e.dispatchAction(i))
                                }(i.pendings, r)
                            })
                        }
                        lD(a).initialized = !0,
                        t("click", it.curry(cD, "click")),
                        t("mousemove", it.curry(cD, "mousemove")),
                        t("globalout", hD)
                    }(n, e),
                    (lD(n).records[t] || (lD(n).records[t] = {})).handler = i
                }
            },
            unregister: function(t, e) {
                if (!et.node) {
                    var i = e.getZr();
                    (lD(i).records || {})[t] && (lD(i).records[t] = null)
                }
            }
        }
          , pD = Gm.extendComponentView({
            type: "axisPointer",
            render: function(t, e, i) {
                var n = e.getComponent("tooltip")
                  , a = t.get("triggerOn") || n && n.get("triggerOn") || "mousemove|click";
                dD.register("axisPointer", i, function(t, e, i) {
                    "none" !== a && ("leave" === t || 0 <= a.indexOf(t)) && i({
                        type: "updateAxisPointer",
                        currTrigger: t,
                        x: e && e.offsetX,
                        y: e && e.offsetY
                    })
                })
            },
            remove: function(t, e) {
                dD.unregister(e.getZr(), "axisPointer"),
                pD.superApply(this._model, "remove", arguments)
            },
            dispose: function(t, e) {
                dD.unregister("axisPointer", e),
                pD.superApply(this._model, "dispose", arguments)
            }
        })
          , fD = (0,
        aa.makeInner)()
          , gD = it.clone
          , mD = it.bind;
        function vD() {}
        function yD(t, e, i, n) {
            !function i(n, t) {
                {
                    if (it.isObject(n) && it.isObject(t)) {
                        var a = !0;
                        return it.each(t, function(t, e) {
                            a = a && i(n[e], t)
                        }),
                        !!a
                    }
                    return n === t
                }
            }(fD(i).lastProp, n) && (fD(i).lastProp = n,
            e ? Fs.updateProps(i, n, t) : (i.stopAnimation(),
            i.attr(n)))
        }
        function xD(t, e) {
            t[e.get("label.show") ? "show" : "hide"]()
        }
        function _D(t) {
            return {
                position: t.position.slice(),
                rotation: t.rotation || 0
            }
        }
        function bD(t, e, i) {
            var n = e.get("z")
              , a = e.get("zlevel");
            t && t.traverse(function(t) {
                "group" !== t.type && (null != n && (t.z = n),
                null != a && (t.zlevel = a),
                t.silent = i)
            })
        }
        (vD.prototype = {
            _group: null,
            _lastGraphicKey: null,
            _handle: null,
            _dragging: !1,
            _lastValue: null,
            _lastStatus: null,
            _payloadInfo: null,
            animationThreshold: 15,
            render: function(t, e, i, n) {
                var a = e.get("value")
                  , r = e.get("status");
                if (this._axisModel = t,
                this._axisPointerModel = e,
                this._api = i,
                n || this._lastValue !== a || this._lastStatus !== r) {
                    this._lastValue = a,
                    this._lastStatus = r;
                    var o = this._group
                      , s = this._handle;
                    if (!r || "hide" === r)
                        return o && o.hide(),
                        void (s && s.hide());
                    o && o.show(),
                    s && s.show();
                    var l = {};
                    this.makeElOption(l, a, t, e, i);
                    var u = l.graphicKey;
                    u !== this._lastGraphicKey && this.clear(i),
                    this._lastGraphicKey = u;
                    var h = this._moveAnimation = this.determineAnimation(t, e);
                    if (o) {
                        var c = it.curry(yD, e, h);
                        this.updatePointerEl(o, l, c, e),
                        this.updateLabelEl(o, l, c, e)
                    } else
                        o = this._group = new Fs.Group,
                        this.createPointerEl(o, l, t, e),
                        this.createLabelEl(o, l, t, e),
                        i.getZr().add(o);
                    bD(o, e, !0),
                    this._renderHandle(a)
                }
            },
            remove: function(t) {
                this.clear(t)
            },
            dispose: function(t) {
                this.clear(t)
            },
            determineAnimation: function(t, e) {
                var i = e.get("animation")
                  , n = t.axis
                  , a = "category" === n.type
                  , r = e.get("snap");
                if (!r && !a)
                    return !1;
                if ("auto" !== i && null != i)
                    return !0 === i;
                var o = this.animationThreshold;
                if (a && n.getBandWidth() > o)
                    return !0;
                if (r) {
                    var s = tx.getAxisInfo(t).seriesDataCount
                      , l = n.getExtent();
                    return Math.abs(l[0] - l[1]) / s > o
                }
                return !1
            },
            makeElOption: function(t, e, i, n, a) {},
            createPointerEl: function(t, e, i, n) {
                var a = e.pointer;
                if (a) {
                    var r = fD(t).pointerEl = new Fs[a.type](gD(e.pointer));
                    t.add(r)
                }
            },
            createLabelEl: function(t, e, i, n) {
                if (e.label) {
                    var a = fD(t).labelEl = new Fs.Rect(gD(e.label));
                    t.add(a),
                    xD(a, n)
                }
            },
            updatePointerEl: function(t, e, i) {
                var n = fD(t).pointerEl;
                n && (n.setStyle(e.pointer.style),
                i(n, {
                    shape: e.pointer.shape
                }))
            },
            updateLabelEl: function(t, e, i, n) {
                var a = fD(t).labelEl;
                a && (a.setStyle(e.label.style),
                i(a, {
                    shape: e.label.shape,
                    position: e.label.position
                }),
                xD(a, n))
            },
            _renderHandle: function(t) {
                if (!this._dragging && this.updateHandleTransform) {
                    var e, i = this._axisPointerModel, n = this._api.getZr(), a = this._handle, r = i.getModel("handle"), o = i.get("status");
                    if (!r.get("show") || !o || "hide" === o)
                        return a && n.remove(a),
                        void (this._handle = null);
                    this._handle || (e = !0,
                    a = this._handle = Fs.createIcon(r.get("icon"), {
                        cursor: "move",
                        draggable: !0,
                        onmousemove: function(t) {
                            j.stop(t.event)
                        },
                        onmousedown: mD(this._onHandleDragMove, this, 0, 0),
                        drift: mD(this._onHandleDragMove, this),
                        ondragend: mD(this._onHandleDragEnd, this)
                    }),
                    n.add(a)),
                    bD(a, i, !1);
                    a.setStyle(r.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
                    var s = r.get("size");
                    it.isArray(s) || (s = [s, s]),
                    a.attr("scale", [s[0] / 2, s[1] / 2]),
                    Qc.createOrUpdate(this, "_doDispatchAxisPointer", r.get("throttle") || 0, "fixRate"),
                    this._moveHandleToValue(t, e)
                }
            },
            _moveHandleToValue: function(t, e) {
                yD(this._axisPointerModel, !e && this._moveAnimation, this._handle, _D(this.getHandleTransform(t, this._axisModel, this._axisPointerModel)))
            },
            _onHandleDragMove: function(t, e) {
                var i = this._handle;
                if (i) {
                    this._dragging = !0;
                    var n = this.updateHandleTransform(_D(i), [t, e], this._axisModel, this._axisPointerModel);
                    this._payloadInfo = n,
                    i.stopAnimation(),
                    i.attr(_D(n)),
                    fD(i).lastProp = null,
                    this._doDispatchAxisPointer()
                }
            },
            _doDispatchAxisPointer: function() {
                if (this._handle) {
                    var t = this._payloadInfo
                      , e = this._axisModel;
                    this._api.dispatchAction({
                        type: "updateAxisPointer",
                        x: t.cursorPoint[0],
                        y: t.cursorPoint[1],
                        tooltipOption: t.tooltipOption,
                        axesInfo: [{
                            axisDim: e.axis.dim,
                            axisIndex: e.componentIndex
                        }]
                    })
                }
            },
            _onHandleDragEnd: function(t) {
                if (this._dragging = !1,
                this._handle) {
                    var e = this._axisPointerModel.get("value");
                    this._moveHandleToValue(e),
                    this._api.dispatchAction({
                        type: "hideTip"
                    })
                }
            },
            getHandleTransform: null,
            updateHandleTransform: null,
            clear: function(t) {
                this._lastValue = null,
                this._lastStatus = null;
                var e = t.getZr()
                  , i = this._group
                  , n = this._handle;
                e && i && (this._lastGraphicKey = null,
                i && e.remove(i),
                n && e.remove(n),
                this._group = null,
                this._handle = null,
                this._payloadInfo = null)
            },
            doClear: function() {},
            buildLabel: function(t, e, i) {
                return {
                    x: t[i = i || 0],
                    y: t[1 - i],
                    width: e[i],
                    height: e[1 - i]
                }
            }
        }).constructor = vD,
        ca.enableClassExtend(vD);
        var wD = vD;
        function SD(t, e, i, n, a) {
            var r = MD(i.get("value"), e.axis, e.ecModel, i.get("seriesDataIndices"), {
                precision: i.get("label.precision"),
                formatter: i.get("label.formatter")
            })
              , o = i.getModel("label")
              , s = fl.normalizeCssArray(o.get("padding") || 0)
              , l = o.getFont()
              , u = Bi.getBoundingRect(r, l)
              , h = a.position
              , c = u.width + s[1] + s[3]
              , d = u.height + s[0] + s[2]
              , p = a.align;
            "right" === p && (h[0] -= c),
            "center" === p && (h[0] -= c / 2);
            var f = a.verticalAlign;
            "bottom" === f && (h[1] -= d),
            "middle" === f && (h[1] -= d / 2),
            function(t, e, i, n) {
                var a = n.getWidth()
                  , r = n.getHeight();
                t[0] = Math.min(t[0] + e, a) - e,
                t[1] = Math.min(t[1] + i, r) - i,
                t[0] = Math.max(t[0], 0),
                t[1] = Math.max(t[1], 0)
            }(h, c, d, n);
            var g = o.get("backgroundColor");
            g && "auto" !== g || (g = e.get("axisLine.lineStyle.color")),
            t.label = {
                shape: {
                    x: 0,
                    y: 0,
                    width: c,
                    height: d,
                    r: o.get("borderRadius")
                },
                position: h.slice(),
                style: {
                    text: r,
                    textFont: l,
                    textFill: o.getTextColor(),
                    textPosition: "inside",
                    fill: g,
                    stroke: o.get("borderColor") || "transparent",
                    lineWidth: o.get("borderWidth") || 0,
                    shadowBlur: o.get("shadowBlur"),
                    shadowColor: o.get("shadowColor"),
                    shadowOffsetX: o.get("shadowOffsetX"),
                    shadowOffsetY: o.get("shadowOffsetY")
                },
                z2: 10
            }
        }
        function MD(t, e, a, i, n) {
            t = e.scale.parse(t);
            var r = e.scale.getLabel(t, {
                precision: n.precision
            })
              , o = n.formatter;
            if (o) {
                var s = {
                    value: Lg.getAxisRawValue(e, t),
                    seriesData: []
                };
                it.each(i, function(t) {
                    var e = a.getSeriesByIndex(t.seriesIndex)
                      , i = t.dataIndexInside
                      , n = e && e.getDataParams(i);
                    n && s.seriesData.push(n)
                }),
                it.isString(o) ? r = o.replace("{value}", r) : it.isFunction(o) && (r = o(s))
            }
            return r
        }
        function ID(t, e, i) {
            var n = ct.create();
            return ct.rotate(n, n, i.rotation),
            ct.translate(n, n, i.position),
            Fs.applyTransform([t.dataToCoord(e), (i.labelOffset || 0) + (i.labelDirection || 1) * (i.labelMargin || 0)], n)
        }
        var AD = {
            buildElStyle: function(t) {
                var e, i = t.get("type"), n = t.getModel(i + "Style");
                return "line" === i ? (e = n.getLineStyle()).fill = null : "shadow" === i && ((e = n.getAreaStyle()).stroke = null),
                e
            },
            buildLabelElOption: SD,
            getValueLabel: MD,
            getTransformedPosition: ID,
            buildCartesianSingleLabelElOption: function(t, e, i, n, a, r) {
                var o = jy.innerTextLayout(i.rotation, 0, i.labelDirection);
                i.labelMargin = a.get("label.margin"),
                SD(e, n, a, r, {
                    position: ID(n.axis, t, i),
                    align: o.textAlign,
                    verticalAlign: o.textVerticalAlign
                })
            },
            makeLineShape: function(t, e, i) {
                return {
                    x1: t[i = i || 0],
                    y1: t[1 - i],
                    x2: e[i],
                    y2: e[1 - i]
                }
            },
            makeRectShape: function(t, e, i) {
                return {
                    x: t[i = i || 0],
                    y: t[1 - i],
                    width: e[i],
                    height: e[1 - i]
                }
            },
            makeSectorShape: function(t, e, i, n, a, r) {
                return {
                    cx: t,
                    cy: e,
                    r0: i,
                    r: n,
                    startAngle: a,
                    endAngle: r,
                    clockwise: !0
                }
            }
        }
          , TD = wD.extend({
            makeElOption: function(t, e, i, n, a) {
                var r = i.axis
                  , o = r.grid
                  , s = n.get("type")
                  , l = CD(o, r).getOtherAxis(r).getGlobalExtent()
                  , u = r.toGlobalCoord(r.dataToCoord(e, !0));
                if (s && "none" !== s) {
                    var h = AD.buildElStyle(n)
                      , c = DD[s](r, u, l, h);
                    c.style = h,
                    t.graphicKey = c.type,
                    t.pointer = c
                }
                var d = ox.layout(o.model, i);
                AD.buildCartesianSingleLabelElOption(e, t, d, i, n, a)
            },
            getHandleTransform: function(t, e, i) {
                var n = ox.layout(e.axis.grid.model, e, {
                    labelInside: !1
                });
                return n.labelMargin = i.get("handle.margin"),
                {
                    position: AD.getTransformedPosition(e.axis, t, n),
                    rotation: n.rotation + (n.labelDirection < 0 ? Math.PI : 0)
                }
            },
            updateHandleTransform: function(t, e, i, n) {
                var a = i.axis
                  , r = a.grid
                  , o = a.getGlobalExtent(!0)
                  , s = CD(r, a).getOtherAxis(a).getGlobalExtent()
                  , l = "x" === a.dim ? 0 : 1
                  , u = t.position;
                u[l] += e[l],
                u[l] = Math.min(o[1], u[l]),
                u[l] = Math.max(o[0], u[l]);
                var h = (s[1] + s[0]) / 2
                  , c = [h, h];
                c[l] = u[l];
                return {
                    position: u,
                    rotation: t.rotation,
                    cursorPoint: c,
                    tooltipOption: [{
                        verticalAlign: "middle"
                    }, {
                        align: "center"
                    }][l]
                }
            }
        });
        function CD(t, e) {
            var i = {};
            return i[e.dim + "AxisIndex"] = e.index,
            t.getCartesian(i)
        }
        var DD = {
            line: function(t, e, i, n) {
                var a = AD.makeLineShape([e, i[0]], [e, i[1]], LD(t));
                return Fs.subPixelOptimizeLine({
                    shape: a,
                    style: n
                }),
                {
                    type: "Line",
                    shape: a
                }
            },
            shadow: function(t, e, i, n) {
                var a = Math.max(1, t.getBandWidth())
                  , r = i[1] - i[0];
                return {
                    type: "Rect",
                    shape: AD.makeRectShape([e - a / 2, i[0]], [a, r], LD(t))
                }
            }
        };
        function LD(t) {
            return "x" === t.dim ? 0 : 1
        }
        rx.registerAxisPointerClass("CartesianAxisPointer", TD),
        Gm.registerPreprocessor(function(t) {
            if (t) {
                t.axisPointer && 0 !== t.axisPointer.length || (t.axisPointer = {});
                var e = t.axisPointer.link;
                e && !it.isArray(e) && (t.axisPointer.link = [e])
            }
        }),
        Gm.registerProcessor(Gm.PRIORITY.PROCESSOR.STATISTIC, function(t, e) {
            t.getComponent("axisPointer").coordSysAxesInfo = tx.collect(t, e)
        }),
        Gm.registerAction({
            type: "updateAxisPointer",
            event: "updateAxisPointer",
            update: ":updateAxisPointer"
        }, sD);
        var PD = ["x", "y"]
          , kD = ["width", "height"]
          , OD = wD.extend({
            makeElOption: function(t, e, i, n, a) {
                var r = i.axis
                  , o = r.coordinateSystem
                  , s = ED(o, 1 - ND(r))
                  , l = o.dataToPoint(e)[0]
                  , u = n.get("type");
                if (u && "none" !== u) {
                    var h = AD.buildElStyle(n)
                      , c = RD[u](r, l, s, h);
                    c.style = h,
                    t.graphicKey = c.type,
                    t.pointer = c
                }
                var d = YC.layout(i);
                AD.buildCartesianSingleLabelElOption(e, t, d, i, n, a)
            },
            getHandleTransform: function(t, e, i) {
                var n = YC.layout(e, {
                    labelInside: !1
                });
                return n.labelMargin = i.get("handle.margin"),
                {
                    position: AD.getTransformedPosition(e.axis, t, n),
                    rotation: n.rotation + (n.labelDirection < 0 ? Math.PI : 0)
                }
            },
            updateHandleTransform: function(t, e, i, n) {
                var a = i.axis
                  , r = a.coordinateSystem
                  , o = ND(a)
                  , s = ED(r, o)
                  , l = t.position;
                l[o] += e[o],
                l[o] = Math.min(s[1], l[o]),
                l[o] = Math.max(s[0], l[o]);
                var u = ED(r, 1 - o)
                  , h = (u[1] + u[0]) / 2
                  , c = [h, h];
                return c[o] = l[o],
                {
                    position: l,
                    rotation: t.rotation,
                    cursorPoint: c,
                    tooltipOption: {
                        verticalAlign: "middle"
                    }
                }
            }
        })
          , RD = {
            line: function(t, e, i, n) {
                var a = AD.makeLineShape([e, i[0]], [e, i[1]], ND(t));
                return Fs.subPixelOptimizeLine({
                    shape: a,
                    style: n
                }),
                {
                    type: "Line",
                    shape: a
                }
            },
            shadow: function(t, e, i, n) {
                var a = t.getBandWidth()
                  , r = i[1] - i[0];
                return {
                    type: "Rect",
                    shape: AD.makeRectShape([e - a / 2, i[0]], [a, r], ND(t))
                }
            }
        };
        function ND(t) {
            return t.isHorizontal() ? 0 : 1
        }
        function ED(t, e) {
            var i = t.getRect();
            return [i[PD[e]], i[PD[e]] + i[kD[e]]]
        }
        rx.registerAxisPointerClass("SingleAxisPointer", OD),
        Gm.extendComponentView({
            type: "single"
        });
        var zD = Ap.getDimensionTypeByAxis
          , VD = aa.groupData
          , BD = fl.encodeHTML
          , GD = kc.extend({
            type: "series.themeRiver",
            dependencies: ["singleAxis"],
            nameMap: null,
            init: function(t) {
                GD.superApply(this, "init", arguments),
                this.legendDataProvider = function() {
                    return this.getRawData()
                }
            },
            fixData: function(t) {
                var e = t.length
                  , i = VD(t, function(t) {
                    return t[2]
                })
                  , n = [];
                i.buckets.each(function(t, e) {
                    n.push({
                        name: e,
                        dataList: t
                    })
                });
                for (var a = n.length, r = -1, o = -1, s = 0; s < a; ++s) {
                    var l = n[s].dataList.length;
                    r < l && (r = l,
                    o = s)
                }
                for (var u = 0; u < a; ++u)
                    if (u !== o)
                        for (var h = n[u].name, c = 0; c < r; ++c) {
                            for (var d = n[o].dataList[c][0], p = n[u].dataList.length, f = -1, g = 0; g < p; ++g) {
                                if (n[u].dataList[g][0] === d) {
                                    f = g;
                                    break
                                }
                            }
                            -1 === f && (t[e] = [],
                            t[e][0] = d,
                            t[e][1] = 0,
                            t[e][2] = h,
                            e++)
                        }
                return t
            },
            getInitialData: function(t, e) {
                for (var i = e.queryComponents({
                    mainType: "singleAxis",
                    index: this.get("singleAxisIndex"),
                    id: this.get("singleAxisId")
                })[0].get("type"), n = it.filter(t.data, function(t) {
                    return void 0 !== t[2]
                }), a = this.fixData(n || []), r = [], o = this.nameMap = it.createHashMap(), s = 0, l = 0; l < a.length; ++l)
                    r.push(a[l][2]),
                    o.get(a[l][2]) || (o.set(a[l][2], s),
                    s++);
                var u = pf(a, {
                    coordDimensions: ["single"],
                    dimensionsDefine: [{
                        name: "time",
                        type: zD(i)
                    }, {
                        name: "value",
                        type: "float"
                    }, {
                        name: "name",
                        type: "ordinal"
                    }],
                    encodeDefine: {
                        single: 0,
                        value: 1,
                        itemName: 2
                    }
                })
                  , h = new Qp(u,this);
                return h.initData(a),
                h
            },
            getLayerSeries: function() {
                for (var i = this.getData(), t = i.count(), e = [], n = 0; n < t; ++n)
                    e[n] = n;
                var a = i.mapDimension("single")
                  , r = VD(e, function(t) {
                    return i.get("name", t)
                })
                  , o = [];
                return r.buckets.each(function(t, e) {
                    t.sort(function(t, e) {
                        return i.get(a, t) - i.get(a, e)
                    }),
                    o.push({
                        name: e,
                        indices: t
                    })
                }),
                o
            },
            getAxisTooltipData: function(t, e, i) {
                it.isArray(t) || (t = t ? [t] : []);
                for (var n, a = this.getData(), r = this.getLayerSeries(), o = [], s = r.length, l = 0; l < s; ++l) {
                    for (var u = Number.MAX_VALUE, h = -1, c = r[l].indices.length, d = 0; d < c; ++d) {
                        var p = a.get(t[0], r[l].indices[d])
                          , f = Math.abs(p - e);
                        f <= u && (n = p,
                        u = f,
                        h = r[l].indices[d])
                    }
                    o.push(h)
                }
                return {
                    dataIndices: o,
                    nestestValue: n
                }
            },
            formatTooltip: function(t) {
                var e = this.getData()
                  , i = e.getName(t)
                  , n = e.get(e.mapDimension("value"), t);
                return !isNaN(n) && null != n || (n = "-"),
                BD(i + " : " + n)
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                coordinateSystem: "singleAxis",
                boundaryGap: ["10%", "10%"],
                singleAxisIndex: 0,
                animationEasing: "linear",
                label: {
                    margin: 4,
                    show: !0,
                    position: "left",
                    color: "#000",
                    fontSize: 11
                },
                emphasis: {
                    label: {
                        show: !0
                    }
                }
            }
        })
          , FD = Dv.Polygon
          , HD = it.bind
          , WD = it.extend;
        Gm.extendChartView({
            type: "themeRiver",
            init: function() {
                this._layers = []
            },
            render: function(w, t, e) {
                var S = w.getData()
                  , M = this.group
                  , I = w.getLayerSeries()
                  , i = S.getLayout("layoutInfo")
                  , n = i.rect
                  , a = i.boundaryGap;
                function r(t) {
                    return t.name
                }
                M.attr("position", [0, n.y + a[0]]);
                var o = new wp(this._layersSeries || [],I,r,r)
                  , A = {};
                function s(t, e, i) {
                    var n = this._layers;
                    if ("remove" !== t) {
                        for (var a, r, o, s = [], l = [], u = I[e].indices, h = 0; h < u.length; h++) {
                            var c = S.getItemLayout(u[h])
                              , d = c.x
                              , p = c.y0
                              , f = c.y;
                            s.push([d, p]),
                            l.push([d, p + f]),
                            a = S.getItemVisual(u[h], "color")
                        }
                        var g = S.getItemLayout(u[0])
                          , m = S.getItemModel(u[h - 1])
                          , v = m.getModel("label")
                          , y = v.get("margin");
                        if ("add" === t) {
                            var x = A[e] = new Fs.Group;
                            r = new FD({
                                shape: {
                                    points: s,
                                    stackedOnPoints: l,
                                    smooth: .4,
                                    stackedOnSmooth: .4,
                                    smoothConstraint: !1
                                },
                                z2: 0
                            }),
                            o = new Fs.Text({
                                style: {
                                    x: g.x - y,
                                    y: g.y0 + g.y / 2
                                }
                            }),
                            x.add(r),
                            x.add(o),
                            M.add(x),
                            r.setClipPath(function(t, e, i) {
                                var n = new Fs.Rect({
                                    shape: {
                                        x: t.x - 10,
                                        y: t.y - 10,
                                        width: 0,
                                        height: t.height + 20
                                    }
                                });
                                return Fs.initProps(n, {
                                    shape: {
                                        width: t.width + 20,
                                        height: t.height + 20
                                    }
                                }, e, i),
                                n
                            }(r.getBoundingRect(), w, function() {
                                r.removeClipPath()
                            }))
                        } else {
                            x = n[i];
                            r = x.childAt(0),
                            o = x.childAt(1),
                            M.add(x),
                            A[e] = x,
                            Fs.updateProps(r, {
                                shape: {
                                    points: s,
                                    stackedOnPoints: l
                                }
                            }, w),
                            Fs.updateProps(o, {
                                style: {
                                    x: g.x - y,
                                    y: g.y0 + g.y / 2
                                }
                            }, w)
                        }
                        var _ = m.getModel("emphasis.itemStyle")
                          , b = m.getModel("itemStyle");
                        Fs.setTextStyle(o.style, v, {
                            text: v.get("show") ? w.getFormattedLabel(u[h - 1], "normal") || S.getName(u[h - 1]) : null,
                            textVerticalAlign: "middle"
                        }),
                        r.setStyle(WD({
                            fill: a
                        }, b.getItemStyle(["color"]))),
                        Fs.setHoverStyle(r, _.getItemStyle())
                    } else
                        M.remove(n[e])
                }
                o.add(HD(s, this, "add")).update(HD(s, this, "update")).remove(HD(s, this, "remove")).execute(),
                this._layersSeries = I,
                this._layers = A
            },
            dispose: function() {}
        });
        function ZD(i, t, e) {
            if (i.count())
                for (var n, a = t.coordinateSystem, r = t.getLayerSeries(), o = i.mapDimension("single"), s = i.mapDimension("value"), l = it.map(r, function(t) {
                    return it.map(t.indices, function(t) {
                        var e = a.dataToPoint(i.get(o, t));
                        return e[1] = i.get(s, t),
                        e
                    })
                }), u = function(t) {
                    for (var e = t.length, i = t[0].length, n = [], a = [], r = 0, o = {}, s = 0; s < i; ++s) {
                        for (var l = 0, u = 0; l < e; ++l)
                            u += t[l][s][1];
                        r < u && (r = u),
                        n.push(u)
                    }
                    for (var h = 0; h < i; ++h)
                        a[h] = (r - n[h]) / 2;
                    for (var c = r = 0; c < i; ++c) {
                        var d = n[c] + a[c];
                        r < d && (r = d)
                    }
                    return o.y0 = a,
                    o.max = r,
                    o
                }(l), h = u.y0, c = e / u.max, d = r.length, p = r[0].indices.length, f = 0; f < p; ++f) {
                    n = h[f] * c,
                    i.setItemLayout(r[0].indices[f], {
                        layerIndex: 0,
                        x: l[0][f][0],
                        y0: n,
                        y: l[0][f][1] * c
                    });
                    for (var g = 1; g < d; ++g)
                        n += l[g - 1][f][1] * c,
                        i.setItemLayout(r[g].indices[f], {
                            layerIndex: g,
                            x: l[g][f][0],
                            y0: n,
                            y: l[g][f][1] * c
                        })
                }
        }
        function UD(t, e) {
            t.eachSeriesByType("themeRiver", function(t) {
                var e = t.getData()
                  , i = t.coordinateSystem
                  , n = {}
                  , a = i.getRect();
                n.rect = a;
                var r = t.get("boundaryGap")
                  , o = i.getAxis();
                (n.boundaryGap = r,
                "horizontal" === o.orient) ? (r[0] = ol.parsePercent(r[0], a.height),
                r[1] = ol.parsePercent(r[1], a.height),
                ZD(e, t, a.height - r[0] - r[1])) : (r[0] = ol.parsePercent(r[0], a.width),
                r[1] = ol.parsePercent(r[1], a.width),
                ZD(e, t, a.width - r[0] - r[1]));
                e.setLayout("layoutInfo", n)
            })
        }
        var YD = it.createHashMap;
        function jD(t) {
            t.eachSeriesByType("themeRiver", function(a) {
                var r = a.getData()
                  , o = a.getRawData()
                  , s = a.get("color")
                  , l = YD();
                r.each(function(t) {
                    l.set(r.getRawIndex(t), t)
                }),
                o.each(function(t) {
                    var e = o.getName(t)
                      , i = s[(a.nameMap.get(e) - 1) % s.length];
                    o.setItemVisual(t, "color", i);
                    var n = l.get(t);
                    null != n && r.setItemVisual(n, "color", i)
                })
            })
        }
        Gm.registerLayout(UD),
        Gm.registerVisual(jD),
        Gm.registerProcessor(Kx("themeRiver"));
        var XD = _w.wrapTreePathInfo;
        kc.extend({
            type: "series.sunburst",
            _viewRoot: null,
            getInitialData: function(t, e) {
                var i = {
                    name: t.name,
                    children: t.data
                };
                !function i(t) {
                    var n = 0;
                    it.each(t.children, function(t) {
                        i(t);
                        var e = t.value;
                        it.isArray(e) && (e = e[0]),
                        n += e
                    });
                    var e = t.value;
                    it.isArray(e) && (e = e[0]);
                    null != e && !isNaN(e) || (e = n);
                    e < 0 && (e = 0);
                    it.isArray(t.value) ? t.value[0] = e : t.value = e
                }(i);
                var n = t.levels || []
                  , a = {};
                return a.levels = n,
                Xb.createTree(i, this, a).data
            },
            optionUpdated: function() {
                this.resetViewRoot()
            },
            getDataParams: function(t) {
                var e = kc.prototype.getDataParams.apply(this, arguments)
                  , i = this.getData().tree.getNodeByDataIndex(t);
                return e.treePathInfo = XD(i, this),
                e
            },
            defaultOption: {
                zlevel: 0,
                z: 2,
                center: ["50%", "50%"],
                radius: [0, "75%"],
                clockwise: !0,
                startAngle: 90,
                minAngle: 0,
                percentPrecision: 2,
                stillShowZeroSum: !0,
                highlightPolicy: "descendant",
                nodeClick: "rootToNode",
                renderLabelForZeroData: !1,
                label: {
                    rotate: "radial",
                    show: !0,
                    opacity: 1,
                    align: "center",
                    position: "inside",
                    distance: 5,
                    silent: !0,
                    emphasis: {}
                },
                itemStyle: {
                    borderWidth: 1,
                    borderColor: "white",
                    borderType: "solid",
                    shadowBlur: 0,
                    shadowColor: "rgba(0, 0, 0, 0.2)",
                    shadowOffsetX: 0,
                    shadowOffsetY: 0,
                    opacity: 1,
                    emphasis: {},
                    highlight: {
                        opacity: 1
                    },
                    downplay: {
                        opacity: .9
                    }
                },
                animationType: "expansion",
                animationDuration: 1e3,
                animationDurationUpdate: 500,
                animationEasing: "cubicOut",
                data: [],
                levels: [],
                sort: "desc"
            },
            getViewRoot: function() {
                return this._viewRoot
            },
            resetViewRoot: function(t) {
                t ? this._viewRoot = t : t = this._viewRoot;
                var e = this.getRawData().tree.root;
                t && (t === e || e.contains(t)) || (this._viewRoot = e)
            }
        });
        var qD = "none"
          , KD = "ancestor"
          , $D = "self";
        function JD(t, e, i) {
            Fs.Group.call(this);
            var n = new Fs.Sector({
                z2: 2
            });
            n.seriesIndex = e.seriesIndex;
            var a = new Fs.Text({
                z2: 4,
                silent: t.getModel("label").get("silent")
            });
            function r() {
                a.ignore = a.hoverIgnore
            }
            function o() {
                a.ignore = a.normalIgnore
            }
            this.add(n),
            this.add(a),
            this.updateData(!0, t, "normal", e, i),
            this.on("emphasis", r).on("normal", o).on("mouseover", r).on("mouseout", o)
        }
        var QD = JD.prototype;
        QD.updateData = function(t, e, i, n, a) {
            (this.node = e).piece = this,
            n = n || this._seriesModel,
            a = a || this._ecModel;
            var r = this.childAt(0);
            r.dataIndex = e.dataIndex;
            var o = e.getModel()
              , s = e.getLayout()
              , l = it.extend({}, s);
            l.label = null;
            var u = function(t, e, i) {
                var n = t.getVisual("color")
                  , a = t.getVisual("visualMeta");
                a && 0 !== a.length || (n = null);
                var r = t.getModel("itemStyle").get("color");
                {
                    if (r)
                        return r;
                    if (n)
                        return n;
                    if (0 === t.depth)
                        return i.option.color[0];
                    var o = i.option.color.length;
                    r = i.option.color[function(t) {
                        var e = t;
                        for (; 1 < e.depth; )
                            e = e.parentNode;
                        var i = t.getAncestors()[0];
                        return it.indexOf(i.children, e)
                    }(t) % o]
                }
                return r
            }(e, 0, a);
            !function(t, e, i) {
                e.getData().setItemVisual(t.dataIndex, "color", i)
            }(e, n, u);
            var h, c = o.getModel("itemStyle").getItemStyle();
            if ("normal" === i)
                h = c;
            else {
                var d = o.getModel(i + ".itemStyle").getItemStyle();
                h = it.merge(d, c)
            }
            h = it.defaults({
                lineJoin: "bevel",
                fill: h.fill || u
            }, h),
            t ? (r.setShape(l),
            r.shape.r = s.r0,
            Fs.updateProps(r, {
                shape: {
                    r: s.r
                }
            }, n, e.dataIndex),
            r.useStyle(h)) : "object" == typeof h.fill && h.fill.type || "object" == typeof r.style.fill && r.style.fill.type ? (Fs.updateProps(r, {
                shape: l
            }, n),
            r.useStyle(h)) : Fs.updateProps(r, {
                shape: l,
                style: h
            }, n),
            this._updateLabel(n, u, i);
            var p = o.getShallow("cursor");
            if (p && r.attr("cursor", p),
            t) {
                var f = n.getShallow("highlightPolicy");
                this._initEvents(r, e, n, f)
            }
            this._seriesModel = n || this._seriesModel,
            this._ecModel = a || this._ecModel
        }
        ,
        QD.onEmphasis = function(e) {
            var i = this;
            this.node.hostTree.root.eachNode(function(t) {
                t.piece && (i.node === t ? t.piece.updateData(!1, t, "emphasis") : !function(t, e, i) {
                    return i !== qD && (i === $D ? t === e : i === KD ? t === e || t.isAncestorOf(e) : t === e || t.isDescendantOf(e))
                }(t, i.node, e) ? e !== qD && t.piece.childAt(0).trigger("downplay") : t.piece.childAt(0).trigger("highlight"))
            })
        }
        ,
        QD.onNormal = function() {
            this.node.hostTree.root.eachNode(function(t) {
                t.piece && t.piece.updateData(!1, t, "normal")
            })
        }
        ,
        QD.onHighlight = function() {
            this.updateData(!1, this.node, "highlight")
        }
        ,
        QD.onDownplay = function() {
            this.updateData(!1, this.node, "downplay")
        }
        ,
        QD._updateLabel = function(t, e, i) {
            var n = this.node.getModel()
              , a = n.getModel("label")
              , r = "normal" === i || "emphasis" === i ? a : n.getModel(i + ".label")
              , o = n.getModel("emphasis.label")
              , s = it.retrieve(t.getFormattedLabel(this.node.dataIndex, "normal", null, null, "label"), this.node.name);
            !1 === S("show") && (s = "");
            var l = this.node.getLayout()
              , u = r.get("minAngle");
            null == u && (u = a.get("minAngle")),
            u = u / 180 * Math.PI;
            var h = l.endAngle - l.startAngle;
            null != u && Math.abs(h) < u && (s = "");
            var c = this.childAt(1);
            Fs.setLabelStyle(c.style, c.hoverStyle || {}, a, o, {
                defaultText: r.getShallow("show") ? s : null,
                autoColor: e,
                useInsideStyle: !0
            });
            var d, p = (l.startAngle + l.endAngle) / 2, f = Math.cos(p), g = Math.sin(p), m = S("position"), v = S("distance") || 0, y = S("align");
            "outside" === m ? (d = l.r + v,
            y = p > Math.PI / 2 ? "right" : "left") : y && "center" !== y ? "left" === y ? (d = l.r0 + v,
            p > Math.PI / 2 && (y = "right")) : "right" === y && (d = l.r - v,
            p > Math.PI / 2 && (y = "left")) : (d = (l.r + l.r0) / 2,
            y = "center"),
            c.attr("style", {
                text: s,
                textAlign: y,
                textVerticalAlign: S("verticalAlign") || "middle",
                opacity: S("opacity")
            });
            var x = d * f + l.cx
              , _ = d * g + l.cy;
            c.attr("position", [x, _]);
            var b = S("rotate")
              , w = 0;
            function S(t) {
                var e = r.get(t);
                return null == e ? a.get(t) : e
            }
            "radial" === b ? (w = -p) < -Math.PI / 2 && (w += Math.PI) : "tangential" === b ? (w = Math.PI / 2 - p) > Math.PI / 2 ? w -= Math.PI : w < -Math.PI / 2 && (w += Math.PI) : "number" == typeof b && (w = b * Math.PI / 180),
            c.attr("rotation", w)
        }
        ,
        QD._initEvents = function(t, e, i, n) {
            t.off("mouseover").off("mouseout").off("emphasis").off("normal");
            function a() {
                o.onEmphasis(n)
            }
            function r() {
                o.onNormal()
            }
            var o = this;
            i.isAnimationEnabled() && t.on("mouseover", a).on("mouseout", r).on("emphasis", a).on("normal", r).on("downplay", function() {
                o.onDownplay()
            }).on("highlight", function() {
                o.onHighlight()
            })
        }
        ,
        it.inherits(JD, Fs.Group);
        var tL = JD
          , eL = (Xc.extend({
            type: "sunburst",
            init: function() {},
            render: function(a, r, t, e) {
                var n = this;
                this.seriesModel = a,
                this.api = t,
                this.ecModel = r;
                var o = a.getData()
                  , s = o.tree.root
                  , i = a.getViewRoot()
                  , l = this.group
                  , u = a.get("renderLabelForZeroData")
                  , h = [];
                i.eachNode(function(t) {
                    h.push(t)
                });
                var c = this._oldChildren || [];
                if (function(i, n) {
                    if (0 === i.length && 0 === n.length)
                        return;
                    function t(t) {
                        return t.getId()
                    }
                    function e(t, e) {
                        !function(t, e) {
                            u || !t || t.getValue() || (t = null);
                            if (t !== s && e !== s)
                                if (e && e.piece)
                                    t ? (e.piece.updateData(!1, t, "normal", a, r),
                                    o.setItemGraphicEl(t.dataIndex, e.piece)) : function(t) {
                                        if (!t)
                                            return;
                                        t.piece && (l.remove(t.piece),
                                        t.piece = null)
                                    }(e);
                                else if (t) {
                                    var i = new tL(t,a,r);
                                    l.add(i),
                                    o.setItemGraphicEl(t.dataIndex, i)
                                }
                        }(null == t ? null : i[t], null == e ? null : n[e])
                    }
                    new wp(n,i,t,t).add(e).update(e).remove(it.curry(e, null)).execute()
                }(h, c),
                function(t, e) {
                    if (0 < e.depth) {
                        n.virtualPiece ? n.virtualPiece.updateData(!1, t, "normal", a, r) : (n.virtualPiece = new tL(t,a,r),
                        l.add(n.virtualPiece)),
                        e.piece._onclickEvent && e.piece.off("click", e.piece._onclickEvent);
                        var i = function(t) {
                            n._rootToNode(e.parentNode)
                        };
                        e.piece._onclickEvent = i,
                        n.virtualPiece.on("click", i)
                    } else
                        n.virtualPiece && (l.remove(n.virtualPiece),
                        n.virtualPiece = null)
                }(s, i),
                e && e.highlight && e.highlight.piece) {
                    var d = a.getShallow("highlightPolicy");
                    e.highlight.piece.onEmphasis(d)
                } else if (e && e.unhighlight) {
                    var p = this.virtualPiece;
                    !p && s.children.length && (p = s.children[0].piece),
                    p && p.onNormal()
                }
                this._initEvents(),
                this._oldChildren = h
            },
            dispose: function() {},
            _initEvents: function() {
                function t(r) {
                    var o = !1;
                    s.seriesModel.getViewRoot().eachNode(function(t) {
                        if (!o && t.piece && t.piece.childAt(0) === r.target) {
                            var e = t.getModel().get("nodeClick");
                            if ("rootToNode" === e)
                                s._rootToNode(t);
                            else if ("link" === e) {
                                var i = t.getModel()
                                  , n = i.get("link");
                                if (n) {
                                    var a = i.get("target", !0) || "_blank";
                                    window.open(n, a)
                                }
                            }
                            o = !0
                        }
                    })
                }
                var s = this;
                this.group._onclickEvent && this.group.off("click", this.group._onclickEvent),
                this.group.on("click", t),
                this.group._onclickEvent = t
            },
            _rootToNode: function(t) {
                t !== this.seriesModel.getViewRoot() && this.api.dispatchAction({
                    type: "sunburstRootToNode",
                    from: this.uid,
                    seriesId: this.seriesModel.id,
                    targetNode: t
                })
            },
            containPoint: function(t, e) {
                var i = e.getData().getItemLayout(0);
                if (i) {
                    var n = t[0] - i.cx
                      , a = t[1] - i.cy
                      , r = Math.sqrt(n * n + a * a);
                    return r <= i.r && r >= i.r0
                }
            }
        }),
        "sunburstRootToNode");
        Gm.registerAction({
            type: eL,
            update: "updateView"
        }, function(a, t) {
            t.eachComponent({
                mainType: "series",
                subType: "sunburst",
                query: a
            }, function(t, e) {
                var i = _w.retrieveTargetInfo(a, [eL], t);
                if (i) {
                    var n = t.getViewRoot();
                    n && (a.direction = _w.aboveViewRoot(n, i.node) ? "rollUp" : "drillDown"),
                    t.resetViewRoot(i.node)
                }
            })
        });
        var iL = "sunburstHighlight";
        Gm.registerAction({
            type: iL,
            update: "updateView"
        }, function(n, t) {
            t.eachComponent({
                mainType: "series",
                subType: "sunburst",
                query: n
            }, function(t, e) {
                var i = _w.retrieveTargetInfo(n, [iL], t);
                i && (n.highlight = i.node)
            })
        });
        Gm.registerAction({
            type: "sunburstUnhighlight",
            update: "updateView"
        }, function(i, t) {
            t.eachComponent({
                mainType: "series",
                subType: "sunburst",
                query: i
            }, function(t, e) {
                i.unhighlight = !0
            })
        });
        var nL = ol.parsePercent
          , aL = (Math.PI,
        Math.PI / 180);
        function rL(t, e) {
            if ("function" == typeof e)
                return t.sort(e);
            var n = "asc" === e;
            return t.sort(function(t, e) {
                var i = (t.getValue() - e.getValue()) * (n ? 1 : -1);
                return 0 == i ? (t.dataIndex - e.dataIndex) * (n ? -1 : 1) : i
            })
        }
        function oL(t, e, D, i) {
            e.eachSeriesByType(t, function(t) {
                var e = t.get("center")
                  , i = t.get("radius");
                it.isArray(i) || (i = [0, i]),
                it.isArray(e) || (e = [e, e]);
                var n = D.getWidth()
                  , a = D.getHeight()
                  , h = Math.min(n, a)
                  , c = nL(e[0], n)
                  , d = nL(e[1], a)
                  , p = nL(i[0], h / 2)
                  , r = nL(i[1], h / 2)
                  , o = -t.get("startAngle") * aL
                  , f = t.get("minAngle") * aL
                  , g = t.getData().tree.root
                  , s = t.getViewRoot()
                  , m = s.depth
                  , l = t.get("sort");
                null != l && !function e(t, i) {
                    var n = t.children || [];
                    t.children = rL(n, i);
                    n.length && it.each(t.children, function(t) {
                        e(t, i)
                    })
                }(s, l);
                var u = 0;
                it.each(s.children, function(t) {
                    isNaN(t.getValue()) || u++
                });
                var v = s.getValue()
                  , y = Math.PI / (v || u) * 2
                  , x = 0 < s.depth
                  , _ = s.height - (x ? -1 : 1)
                  , b = (r - p) / (_ || 1)
                  , w = t.get("clockwise")
                  , S = t.get("stillShowZeroSum")
                  , M = w ? 1 : -1
                  , I = function(t, e) {
                    if (t) {
                        var i = e;
                        if (t !== g) {
                            var n = t.getValue()
                              , a = 0 === v && S ? y : n * y;
                            a < f && (a = f),
                            i = e + M * a;
                            var r = t.depth - m - (x ? -1 : 1)
                              , o = p + b * r
                              , s = p + b * (1 + r)
                              , l = t.getModel();
                            null != l.get("r0") && (o = nL(l.get("r0"), h / 2)),
                            null != l.get("r") && (s = nL(l.get("r"), h / 2)),
                            t.setLayout({
                                angle: a,
                                startAngle: e,
                                endAngle: i,
                                clockwise: w,
                                cx: c,
                                cy: d,
                                r0: o,
                                r: s
                            })
                        }
                        if (t.children && t.children.length) {
                            var u = 0;
                            it.each(t.children, function(t) {
                                u += I(t, e + u)
                            })
                        }
                        return i - e
                    }
                };
                if (x) {
                    var A = p
                      , T = p + b
                      , C = 2 * Math.PI;
                    g.setLayout({
                        angle: C,
                        startAngle: o,
                        endAngle: o + C,
                        clockwise: w,
                        cx: c,
                        cy: d,
                        r0: A,
                        r: T
                    })
                }
                I(s, o)
            })
        }
        function sL(r, o) {
            return o = o || [0, 0],
            it.map(["x", "y"], function(t, e) {
                var i = this.getAxis(t)
                  , n = o[e]
                  , a = r[e] / 2;
                return "category" === i.type ? i.getBandWidth() : Math.abs(i.dataToCoord(n - a) - i.dataToCoord(n + a))
            }, this)
        }
        function lL(r, o) {
            return o = o || [0, 0],
            it.map([0, 1], function(t) {
                var e = o[t]
                  , i = r[t] / 2
                  , n = []
                  , a = [];
                return n[t] = e - i,
                a[t] = e + i,
                n[1 - t] = a[1 - t] = o[1 - t],
                Math.abs(this.dataToPoint(n)[t] - this.dataToPoint(a)[t])
            }, this)
        }
        function uL(t, e) {
            var i = this.getAxis()
              , n = e instanceof Array ? e[0] : e
              , a = (t instanceof Array ? t[0] : t) / 2;
            return "category" === i.type ? i.getBandWidth() : Math.abs(i.dataToCoord(n - a) - i.dataToCoord(n + a))
        }
        function hL(s, l) {
            return it.map(["Radius", "Angle"], function(t, e) {
                var i = this["get" + t + "Axis"]()
                  , n = l[e]
                  , a = s[e] / 2
                  , r = "dataTo" + t
                  , o = "category" === i.type ? i.getBandWidth() : Math.abs(i[r](n - a) - i[r](n + a));
                return "Angle" === t && (o = o * Math.PI / 180),
                o
            }, this)
        }
        Gm.registerVisual(it.curry(Fx, "sunburst")),
        Gm.registerLayout(it.curry(oL, "sunburst")),
        Gm.registerProcessor(it.curry(Kx, "sunburst"));
        var cL = Hm.getDefaultLabel
          , dL = rg.getLayoutOnAxis
          , pL = ["itemStyle"]
          , fL = ["emphasis", "itemStyle"]
          , gL = ["label"]
          , mL = ["emphasis", "label"]
          , vL = "e\0\0"
          , yL = {
            cartesian2d: function(e) {
                var t = e.grid.getRect();
                return {
                    coordSys: {
                        type: "cartesian2d",
                        x: t.x,
                        y: t.y,
                        width: t.width,
                        height: t.height
                    },
                    api: {
                        coord: function(t) {
                            return e.dataToPoint(t)
                        },
                        size: it.bind(sL, e)
                    }
                }
            },
            geo: function(e) {
                var t = e.getBoundingRect();
                return {
                    coordSys: {
                        type: "geo",
                        x: t.x,
                        y: t.y,
                        width: t.width,
                        height: t.height,
                        zoom: e.getZoom()
                    },
                    api: {
                        coord: function(t) {
                            return e.dataToPoint(t)
                        },
                        size: it.bind(lL, e)
                    }
                }
            },
            singleAxis: function(e) {
                var t = e.getRect();
                return {
                    coordSys: {
                        type: "singleAxis",
                        x: t.x,
                        y: t.y,
                        width: t.width,
                        height: t.height
                    },
                    api: {
                        coord: function(t) {
                            return e.dataToPoint(t)
                        },
                        size: it.bind(uL, e)
                    }
                }
            },
            polar: function(a) {
                var r = a.getRadiusAxis()
                  , o = a.getAngleAxis()
                  , t = r.getExtent();
                return t[0] > t[1] && t.reverse(),
                {
                    coordSys: {
                        type: "polar",
                        cx: a.cx,
                        cy: a.cy,
                        r: t[1],
                        r0: t[0]
                    },
                    api: {
                        coord: it.bind(function(t) {
                            var e = r.dataToRadius(t[0])
                              , i = o.dataToAngle(t[1])
                              , n = a.coordToPoint([e, i]);
                            return n.push(e, i * Math.PI / 180),
                            n
                        }),
                        size: it.bind(hL, a)
                    }
                }
            },
            calendar: function(i) {
                var t = i.getRect()
                  , e = i.getRangeInfo();
                return {
                    coordSys: {
                        type: "calendar",
                        x: t.x,
                        y: t.y,
                        width: t.width,
                        height: t.height,
                        cellWidth: i.getCellWidth(),
                        cellHeight: i.getCellHeight(),
                        rangeInfo: {
                            start: e.start,
                            end: e.end,
                            weeks: e.weeks,
                            dayCount: e.allDay
                        }
                    },
                    api: {
                        coord: function(t, e) {
                            return i.dataToPoint(t, e)
                        }
                    }
                }
            }
        };
        function xL(t, e, i, n, a) {
            null == i[t] || a || (e[t] = i[t],
            i[t] = n[t])
        }
        function _L(a, r, e, i) {
            var n = a.get("renderItem")
              , o = a.coordinateSystem
              , t = {};
            o && (t = o.prepareCustoms ? o.prepareCustoms() : yL[o.type](o));
            var s, l, u, h, c, d = it.defaults({
                getWidth: i.getWidth,
                getHeight: i.getHeight,
                getZr: i.getZr,
                getDevicePixelRatio: i.getDevicePixelRatio,
                value: function(t, e) {
                    return null == e && (e = s),
                    r.get(r.getDimension(t || 0), e)
                },
                style: function(t, e) {
                    null == e && (e = s),
                    g(e);
                    var i = l.getModel(pL).getItemStyle();
                    null != c && (i.fill = c);
                    var n = r.getItemVisual(e, "opacity");
                    return null != n && (i.opacity = n),
                    Fs.setTextStyle(i, u, null, {
                        autoColor: c,
                        isRectText: !0
                    }),
                    i.text = u.getShallow("show") ? it.retrieve2(a.getFormattedLabel(e, "normal"), cL(r, e)) : null,
                    t && it.extend(i, t),
                    i
                },
                styleEmphasis: function(t, e) {
                    null == e && (e = s),
                    g(e);
                    var i = l.getModel(fL).getItemStyle();
                    return Fs.setTextStyle(i, h, null, {
                        isRectText: !0
                    }, !0),
                    i.text = h.getShallow("show") ? it.retrieve3(a.getFormattedLabel(e, "emphasis"), a.getFormattedLabel(e, "normal"), cL(r, e)) : null,
                    t && it.extend(i, t),
                    i
                },
                visual: function(t, e) {
                    return null == e && (e = s),
                    r.getItemVisual(e, t)
                },
                barLayout: function(t) {
                    if (o.getBaseAxis) {
                        var e = o.getBaseAxis();
                        return dL(it.defaults({
                            axis: e
                        }, t), i)
                    }
                },
                currentSeriesIndices: function() {
                    return e.getCurrentSeriesIndices()
                },
                font: function(t) {
                    return Fs.getFont(t, e)
                }
            }, t.api || {}), p = {
                context: {},
                seriesId: a.id,
                seriesName: a.name,
                seriesIndex: a.seriesIndex,
                coordSys: t.coordSys,
                dataInsideLength: r.count(),
                encode: function(a) {
                    var r = {};
                    return it.each(a.dimensions, function(t, e) {
                        var i = a.getDimensionInfo(t);
                        if (!i.isExtraCoord) {
                            var n = i.coordDim;
                            (r[n] = r[n] || [])[i.coordDimIndex] = e
                        }
                    }),
                    r
                }(a.getData())
            }, f = !0;
            return function(t, e) {
                return s = t,
                f = !0,
                n && n(it.defaults({
                    dataIndexInside: t,
                    dataIndex: r.getRawIndex(t),
                    actionType: e ? e.type : null
                }, p), d)
            }
            ;
            function g(t) {
                null == t && (t = s),
                f && (l = r.getItemModel(t),
                u = l.getModel(gL),
                h = l.getModel(mL),
                c = r.getItemVisual(t, "color"),
                f = !1)
            }
        }
        function bL(t, e, i, n, a, r) {
            return (t = wL(t, e, i, n, a, r, !0)) && r.setItemGraphicEl(e, t),
            t
        }
        function wL(t, e, i, n, a, r, o) {
            var s = !i
              , l = (i = i || {}).type
              , u = i.shape
              , h = i.style;
            if (t && (s || null != l && l !== t.__customGraphicType || "path" === l && function(t) {
                return t && (t.hasOwnProperty("pathData") || t.hasOwnProperty("d"))
            }(u) && AL(u) !== t.__customPathData || "image" === l && TL(h, "image") && h.image !== t.__customImagePath || "text" === l && TL(u, "text") && h.text !== t.__customText) && (a.remove(t),
            t = null),
            !s) {
                var c = !t;
                return function(e, t, i, n, a, r, o) {
                    var s = {}
                      , l = i.style || {};
                    if (i.shape && (s.shape = it.clone(i.shape)),
                    i.position && (s.position = i.position.slice()),
                    i.scale && (s.scale = i.scale.slice()),
                    i.origin && (s.origin = i.origin.slice()),
                    i.rotation && (s.rotation = i.rotation),
                    "image" === e.type && i.style) {
                        var u = s.style = {};
                        it.each(["x", "y", "width", "height"], function(t) {
                            xL(t, u, l, e.style, r)
                        })
                    }
                    if ("text" === e.type && i.style) {
                        u = s.style = {};
                        it.each(["x", "y"], function(t) {
                            xL(t, u, l, e.style, r)
                        }),
                        !l.hasOwnProperty("textFill") && l.fill && (l.textFill = l.fill),
                        !l.hasOwnProperty("textStroke") && l.stroke && (l.textStroke = l.stroke)
                    }
                    if ("group" !== e.type && (e.useStyle(l),
                    r)) {
                        e.style.opacity = 0;
                        var h = l.opacity;
                        null == h && (h = 1),
                        Fs.initProps(e, {
                            style: {
                                opacity: h
                            }
                        }, n, t)
                    }
                    r ? e.attr(s) : Fs.updateProps(e, s, n, t),
                    i.hasOwnProperty("z2") && e.attr("z2", i.z2 || 0),
                    i.hasOwnProperty("silent") && e.attr("silent", i.silent),
                    i.hasOwnProperty("invisible") && e.attr("invisible", i.invisible),
                    i.hasOwnProperty("ignore") && e.attr("ignore", i.ignore),
                    i.hasOwnProperty("info") && e.attr("info", i.info);
                    var c = i.styleEmphasis
                      , d = !1 === c;
                    e.__cusHasEmphStl && null == c || !e.__cusHasEmphStl && d || (Fs.setElementHoverStyle(e, c),
                    e.__cusHasEmphStl = !d),
                    o && Fs.setAsHoverStyleTrigger(e, !d)
                }(t = t || function(t) {
                    var e, i = t.type;
                    if ("path" === i) {
                        var n = t.shape
                          , a = null != n.width && null != n.height ? {
                            x: n.x || 0,
                            y: n.y || 0,
                            width: n.width,
                            height: n.height
                        } : null
                          , r = AL(n);
                        (e = Fs.makePath(r, null, a, n.layout || "center")).__customPathData = r
                    } else if ("image" === i)
                        (e = new Fs.Image({})).__customImagePath = t.style.image;
                    else if ("text" === i)
                        (e = new Fs.Text({})).__customText = t.style.text;
                    else {
                        e = new (Fs[i.charAt(0).toUpperCase() + i.slice(1)])
                    }
                    return e.__customGraphicType = i,
                    e.name = t.name,
                    e
                }(i), e, i, n, 0, c, o),
                "group" === l && function(t, e, i, n, a) {
                    var r = i.children
                      , o = r ? r.length : 0
                      , s = i.$mergeChildren
                      , l = "byName" === s || i.diffChildrenByName
                      , u = !1 === s;
                    if (!o && !l && !u)
                        return;
                    if (l)
                        return function(t) {
                            new wp(t.oldChildren,t.newChildren,SL,SL,t).add(ML).update(ML).remove(IL).execute()
                        }({
                            oldChildren: t.children() || [],
                            newChildren: r || [],
                            dataIndex: e,
                            animatableModel: n,
                            group: t,
                            data: a
                        });
                    u && t.removeAll();
                    for (var h = 0; h < o; h++)
                        r[h] && wL(t.childAt(h), e, r[h], n, t, a)
                }(t, e, i, n, r),
                a.add(t),
                t
            }
        }
        function SL(t, e) {
            var i = t && t.name;
            return null != i ? i : vL + e
        }
        function ML(t, e) {
            var i = this.context
              , n = null != t ? i.newChildren[t] : null;
            wL(null != e ? i.oldChildren[e] : null, i.dataIndex, n, i.animatableModel, i.group, i.data)
        }
        function IL(t) {
            var e = this.context
              , i = e.oldChildren[t];
            i && e.group.remove(i)
        }
        function AL(t) {
            return t && (t.pathData || t.d)
        }
        function TL(t, e) {
            return t && t.hasOwnProperty(e)
        }
        kc.extend({
            type: "series.custom",
            dependencies: ["grid", "polar", "geo", "singleAxis", "calendar"],
            defaultOption: {
                coordinateSystem: "cartesian2d",
                zlevel: 0,
                z: 2,
                legendHoverLink: !0,
                useTransform: !0
            },
            getInitialData: function(t, e) {
                return Sf(this.getSource(), this)
            },
            getDataParams: function(t, e, i) {
                var n = kc.prototype.getDataParams.apply(this, arguments);
                return i && (n.info = i.info),
                n
            }
        }),
        Xc.extend({
            type: "custom",
            _data: null,
            render: function(i, t, e, n) {
                var a = this._data
                  , r = i.getData()
                  , o = this.group
                  , s = _L(i, r, t, e);
                r.diff(a).add(function(t) {
                    bL(null, t, s(t, n), i, o, r)
                }).update(function(t, e) {
                    bL(a.getItemGraphicEl(e), t, s(t, n), i, o, r)
                }).remove(function(t) {
                    var e = a.getItemGraphicEl(t);
                    e && o.remove(e)
                }).execute(),
                this._data = r
            },
            incrementalPrepareRender: function(t, e, i) {
                this.group.removeAll(),
                this._data = null
            },
            incrementalRender: function(t, e, i, n, a) {
                var r = e.getData()
                  , o = _L(e, r, i, n);
                function s(t) {
                    t.isGroup || (t.incremental = !0,
                    t.useHoverLayer = !0)
                }
                for (var l = t.start; l < t.end; l++) {
                    bL(null, l, o(l, a), e, this.group, r).traverse(s)
                }
            },
            dispose: it.noop,
            filterForExposedEvent: function(t, e, i, n) {
                var a = e.element;
                if (null == a || i.name === a)
                    return !0;
                for (; (i = i.parent) && i !== this.group; )
                    if (i.name === a)
                        return !0;
                return !1
            }
        }),
        Gm.registerPreprocessor(function(t) {
            var e = t.graphic;
            it.isArray(e) ? e[0] && e[0].elements ? t.graphic = [t.graphic[0]] : t.graphic = [{
                elements: e
            }] : e && !e.elements && (t.graphic = [{
                elements: [e]
            }])
        });
        var CL = Gm.extendComponentModel({
            type: "graphic",
            defaultOption: {
                elements: [],
                parentId: null
            },
            _elOptionsToUpdate: null,
            mergeOption: function(t) {
                var e = this.option.elements;
                this.option.elements = null,
                CL.superApply(this, "mergeOption", arguments),
                this.option.elements = e
            },
            optionUpdated: function(t, e) {
                var i = this.option
                  , n = (e ? i : t).elements
                  , a = i.elements = e ? [] : i.elements
                  , r = [];
                this._flatten(n, r);
                var o = aa.mappingToExists(a, r);
                aa.makeIdAndName(o);
                var s = this._elOptionsToUpdate = [];
                it.each(o, function(t, e) {
                    var i = t.option;
                    i && (s.push(i),
                    function(t, e) {
                        var i = t.exist;
                        if (e.id = t.keyInfo.id,
                        !e.type && i && (e.type = i.type),
                        null == e.parentId) {
                            var n = e.parentOption;
                            n ? e.parentId = n.id : i && (e.parentId = i.parentId)
                        }
                        e.parentOption = null
                    }(t, i),
                    function(t, e, i) {
                        var n = it.extend({}, i)
                          , a = t[e]
                          , r = i.$action || "merge";
                        "merge" === r ? a ? (it.merge(a, n, !0),
                        Il.mergeLayoutParam(a, n, {
                            ignoreSize: !0
                        }),
                        Il.copyLayoutParams(i, a)) : t[e] = n : "replace" === r ? t[e] = n : "remove" === r && a && (t[e] = null)
                    }(a, e, i),
                    function(t, e) {
                        if (!t)
                            return;
                        t.hv = e.hv = [PL(e, ["left", "right"]), PL(e, ["top", "bottom"])],
                        "group" === t.type && (null == t.width && (t.width = e.width = 0),
                        null == t.height && (t.height = e.height = 0))
                    }(a[e], i))
                }, this);
                for (var l = a.length - 1; 0 <= l; l--)
                    null == a[l] ? a.splice(l, 1) : delete a[l].$action
            },
            _flatten: function(t, i, n) {
                it.each(t, function(t) {
                    if (t) {
                        n && (t.parentOption = n),
                        i.push(t);
                        var e = t.children;
                        "group" === t.type && e && this._flatten(e, i, t),
                        delete t.children
                    }
                }, this)
            },
            useElOptionsToUpdate: function() {
                var t = this._elOptionsToUpdate;
                return this._elOptionsToUpdate = null,
                t
            }
        });
        function DL(t, e, i, n) {
            var a = i.type
              , r = new (Fs[a.charAt(0).toUpperCase() + a.slice(1)])(i);
            e.add(r),
            n.set(t, r),
            r.__ecGraphicId = t
        }
        function LL(t, e) {
            var i = t && t.parent;
            i && ("group" === t.type && t.traverse(function(t) {
                LL(t, e)
            }),
            e.removeKey(t.__ecGraphicId),
            i.remove(t))
        }
        function PL(e, t) {
            var i;
            return it.each(t, function(t) {
                null != e[t] && "auto" !== e[t] && (i = !0)
            }),
            i
        }
        Gm.extendComponentView({
            type: "graphic",
            init: function(t, e) {
                this._elMap = it.createHashMap(),
                this._lastGraphicModel
            },
            render: function(t, e, i) {
                t !== this._lastGraphicModel && this._clear(),
                this._lastGraphicModel = t,
                this._updateElements(t),
                this._relocate(t, i)
            },
            _updateElements: function(u) {
                var t = u.useElOptionsToUpdate();
                if (t) {
                    var h = this._elMap
                      , c = this.group;
                    it.each(t, function(t) {
                        var e = t.$action
                          , i = t.id
                          , n = h.get(i)
                          , a = t.parentId
                          , r = null != a ? h.get(a) : c
                          , o = t.style;
                        "text" === t.type && o && (t.hv && t.hv[1] && (o.textVerticalAlign = o.textBaseline = null),
                        !o.hasOwnProperty("textFill") && o.fill && (o.textFill = o.fill),
                        !o.hasOwnProperty("textStroke") && o.stroke && (o.textStroke = o.stroke));
                        var s = function(e) {
                            return e = it.extend({}, e),
                            it.each(["id", "parentId", "$action", "hv", "bounding"].concat(Il.LOCATION_PARAMS), function(t) {
                                delete e[t]
                            }),
                            e
                        }(t);
                        e && "merge" !== e ? "replace" === e ? (LL(n, h),
                        DL(i, r, s, h)) : "remove" === e && LL(n, h) : n ? n.attr(s) : DL(i, r, s, h);
                        var l = h.get(i);
                        l && (l.__ecGraphicWidth = t.width,
                        l.__ecGraphicHeight = t.height,
                        function(t, e) {
                            var i = t.eventData;
                            t.silent || t.ignore || i || (i = t.eventData = {
                                componentType: "graphic",
                                componentIndex: e.componentIndex,
                                name: t.name
                            });
                            i && (i.info = t.info)
                        }(l, u))
                    })
                }
            },
            _relocate: function(t, e) {
                for (var i = t.option.elements, n = this.group, a = this._elMap, r = i.length - 1; 0 <= r; r--) {
                    var o = i[r]
                      , s = a.get(o.id);
                    if (s) {
                        var l = s.parent
                          , u = l === n ? {
                            width: e.getWidth(),
                            height: e.getHeight()
                        } : {
                            width: l.__ecGraphicWidth || 0,
                            height: l.__ecGraphicHeight || 0
                        };
                        Il.positionElement(s, o, u, null, {
                            hv: o.hv,
                            boundingMode: o.bounding
                        })
                    }
                }
            },
            _clear: function() {
                var e = this._elMap;
                e.each(function(t) {
                    LL(t, e)
                }),
                this._elMap = it.createHashMap()
            },
            dispose: function() {
                this._clear()
            }
        });
        var kL = aa.isNameSpecified
          , OL = Gm.extendComponentModel({
            type: "legend.plain",
            dependencies: ["series"],
            layoutMode: {
                type: "box",
                ignoreSize: !0
            },
            init: function(t, e, i) {
                this.mergeDefaultAndTheme(t, i),
                t.selected = t.selected || {}
            },
            mergeOption: function(t) {
                OL.superCall(this, "mergeOption", t)
            },
            optionUpdated: function() {
                this._updateData(this.ecModel);
                var t = this._data;
                if (t[0] && "single" === this.get("selectedMode")) {
                    for (var e = !1, i = 0; i < t.length; i++) {
                        var n = t[i].get("name");
                        if (this.isSelected(n)) {
                            this.select(n),
                            e = !0;
                            break
                        }
                    }
                    e || this.select(t[0].get("name"))
                }
            },
            _updateData: function(r) {
                var o = []
                  , s = [];
                r.eachRawSeries(function(t) {
                    var e, i = t.name;
                    if (s.push(i),
                    t.legendDataProvider) {
                        var n = t.legendDataProvider()
                          , a = n.mapArray(n.getName);
                        r.isSeriesFiltered(t) || (s = s.concat(a)),
                        a.length ? o = o.concat(a) : e = !0
                    } else
                        e = !0;
                    e && kL(t) && o.push(t.name)
                }),
                this._availableNames = s;
                var t = this.get("data") || o
                  , e = it.map(t, function(t) {
                    return "string" != typeof t && "number" != typeof t || (t = {
                        name: t
                    }),
                    new tl(t,this,this.ecModel)
                }, this);
                this._data = e
            },
            getData: function() {
                return this._data
            },
            select: function(t) {
                var e = this.option.selected;
                if ("single" === this.get("selectedMode")) {
                    var i = this._data;
                    it.each(i, function(t) {
                        e[t.get("name")] = !1
                    })
                }
                e[t] = !0
            },
            unSelect: function(t) {
                "single" !== this.get("selectedMode") && (this.option.selected[t] = !1)
            },
            toggleSelected: function(t) {
                var e = this.option.selected;
                e.hasOwnProperty(t) || (e[t] = !0),
                this[e[t] ? "unSelect" : "select"](t)
            },
            isSelected: function(t) {
                var e = this.option.selected;
                return !(e.hasOwnProperty(t) && !e[t]) && 0 <= it.indexOf(this._availableNames, t)
            },
            defaultOption: {
                zlevel: 0,
                z: 4,
                show: !0,
                orient: "horizontal",
                left: "center",
                top: 0,
                align: "auto",
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "#ccc",
                borderRadius: 0,
                borderWidth: 0,
                padding: 5,
                itemGap: 10,
                itemWidth: 25,
                itemHeight: 14,
                inactiveColor: "#ccc",
                textStyle: {
                    color: "#333"
                },
                selectedMode: !0,
                tooltip: {
                    show: !1
                }
            }
        })
          , RL = OL;
        function NL(e, i, t) {
            var a, r = {}, o = "toggleSelected" === e;
            return t.eachComponent("legend", function(n) {
                o && null != a ? n[a ? "select" : "unSelect"](i.name) : (n[e](i.name),
                a = n.isSelected(i.name));
                var t = n.getData();
                it.each(t, function(t) {
                    var e = t.get("name");
                    if ("\n" !== e && "" !== e) {
                        var i = n.isSelected(e);
                        r.hasOwnProperty(e) ? r[e] = r[e] && i : r[e] = i
                    }
                })
            }),
            {
                name: i.name,
                selected: r
            }
        }
        Gm.registerAction("legendToggleSelect", "legendselectchanged", it.curry(NL, "toggleSelected")),
        Gm.registerAction("legendSelect", "legendselected", it.curry(NL, "select")),
        Gm.registerAction("legendUnSelect", "legendunselected", it.curry(NL, "unSelect"));
        var EL = Il.getLayoutRect
          , zL = Il.box
          , VL = Il.positionElement;
        var BL = {
            layout: function(t, e, i) {
                var n = e.getBoxLayoutParams()
                  , a = e.get("padding")
                  , r = {
                    width: i.getWidth(),
                    height: i.getHeight()
                }
                  , o = EL(n, r, a);
                zL(e.get("orient"), t, e.get("itemGap"), o.width, o.height),
                VL(t, n, r, a)
            },
            makeBackground: function(t, e) {
                var i = fl.normalizeCssArray(e.get("padding"))
                  , n = e.getItemStyle(["color", "opacity"]);
                return n.fill = e.get("backgroundColor"),
                t = new Fs.Rect({
                    shape: {
                        x: t.x - i[3],
                        y: t.y - i[0],
                        width: t.width + i[1] + i[3],
                        height: t.height + i[0] + i[2],
                        r: e.get("borderRadius")
                    },
                    style: n,
                    silent: !0,
                    z2: -1
                })
            }
        }
          , GL = Fg.createSymbol
          , FL = BL.makeBackground
          , HL = it.curry
          , WL = it.each
          , ZL = Fs.Group;
        function UL(t, e) {
            e.dispatchAction({
                type: "legendToggleSelect",
                name: t
            })
        }
        function YL(t, e, i, n) {
            var a = i.getZr().storage.getDisplayList()[0];
            a && a.useHoverLayer || i.dispatchAction({
                type: "highlight",
                seriesName: t,
                name: e,
                excludeSeriesId: n
            })
        }
        function jL(t, e, i, n) {
            var a = i.getZr().storage.getDisplayList()[0];
            a && a.useHoverLayer || i.dispatchAction({
                type: "downplay",
                seriesName: t,
                name: e,
                excludeSeriesId: n
            })
        }
        var XL = Gm.extendComponentView({
            type: "legend.plain",
            newlineDisabled: !1,
            init: function() {
                this.group.add(this._contentGroup = new ZL),
                this._backgroundEl,
                this._isFirstRender = !0
            },
            getContentGroup: function() {
                return this._contentGroup
            },
            render: function(t, e, i) {
                var n = this._isFirstRender;
                if (this._isFirstRender = !1,
                this.resetInner(),
                t.get("show", !0)) {
                    var a = t.get("align");
                    a && "auto" !== a || (a = "right" === t.get("left") && "vertical" === t.get("orient") ? "right" : "left"),
                    this.renderInner(a, t, e, i);
                    var r = t.getBoxLayoutParams()
                      , o = {
                        width: i.getWidth(),
                        height: i.getHeight()
                    }
                      , s = t.get("padding")
                      , l = Il.getLayoutRect(r, o, s)
                      , u = this.layoutInner(t, a, l, n)
                      , h = Il.getLayoutRect(it.defaults({
                        width: u.width,
                        height: u.height
                    }, r), o, s);
                    this.group.attr("position", [h.x - u.x, h.y - u.y]),
                    this.group.add(this._backgroundEl = FL(u, t))
                }
            },
            resetInner: function() {
                this.getContentGroup().removeAll(),
                this._backgroundEl && this.group.remove(this._backgroundEl)
            },
            renderInner: function(l, u, h, c) {
                var d = this.getContentGroup()
                  , p = it.createHashMap()
                  , f = u.get("selectedMode")
                  , g = [];
                h.eachRawSeries(function(t) {
                    t.get("legendHoverLink") || g.push(t.id)
                }),
                WL(u.getData(), function(a, r) {
                    var o = a.get("name");
                    if (this.newlineDisabled || "" !== o && "\n" !== o) {
                        var t = h.getSeriesByName(o)[0];
                        if (!p.get(o))
                            if (t) {
                                var e = t.getData()
                                  , i = e.getVisual("color");
                                "function" == typeof i && (i = i(t.getDataParams(0)));
                                var n = e.getVisual("legendSymbol") || "roundRect"
                                  , s = e.getVisual("symbol");
                                this._createItem(o, r, a, u, n, s, l, i, f).on("click", HL(UL, o, c)).on("mouseover", HL(YL, t.name, null, c, g)).on("mouseout", HL(jL, t.name, null, c, g)),
                                p.set(o, !0)
                            } else
                                h.eachRawSeries(function(t) {
                                    if (!p.get(o) && t.legendDataProvider) {
                                        var e = t.legendDataProvider()
                                          , i = e.indexOfName(o);
                                        if (i < 0)
                                            return;
                                        var n = e.getItemVisual(i, "color");
                                        this._createItem(o, r, a, u, "roundRect", null, l, n, f).on("click", HL(UL, o, c)).on("mouseover", HL(YL, null, o, c, g)).on("mouseout", HL(jL, null, o, c, g)),
                                        p.set(o, !0)
                                    }
                                }, this)
                    } else
                        d.add(new ZL({
                            newline: !0
                        }))
                }, this)
            },
            _createItem: function(t, e, i, n, a, r, o, s, l) {
                var u = n.get("itemWidth")
                  , h = n.get("itemHeight")
                  , c = n.get("inactiveColor")
                  , d = n.get("symbolKeepAspect")
                  , p = n.isSelected(t)
                  , f = new ZL
                  , g = i.getModel("textStyle")
                  , m = i.get("icon")
                  , v = i.getModel("tooltip")
                  , y = v.parentModel;
                if (a = m || a,
                f.add(GL(a, 0, 0, u, h, p ? s : c, null == d || d)),
                !m && r && (r !== a || "none" === r)) {
                    var x = .8 * h;
                    "none" === r && (r = "circle"),
                    f.add(GL(r, (u - x) / 2, (h - x) / 2, x, x, p ? s : c, null == d || d))
                }
                var _ = "left" === o ? u + 5 : -5
                  , b = o
                  , w = n.get("formatter")
                  , S = t;
                "string" == typeof w && w ? S = w.replace("{name}", null != t ? t : "") : "function" == typeof w && (S = w(t)),
                f.add(new Fs.Text({
                    style: Fs.setTextStyle({}, g, {
                        text: S,
                        x: _,
                        y: h / 2,
                        textFill: p ? g.getTextColor() : c,
                        textAlign: b,
                        textVerticalAlign: "middle"
                    })
                }));
                var M = new Fs.Rect({
                    shape: f.getBoundingRect(),
                    invisible: !0,
                    tooltip: v.get("show") ? it.extend({
                        content: t,
                        formatter: y.get("formatter", !0) || function() {
                            return t
                        }
                        ,
                        formatterParams: {
                            componentType: "legend",
                            legendIndex: n.componentIndex,
                            name: t,
                            $vars: ["name"]
                        }
                    }, v.option) : null
                });
                return f.add(M),
                f.eachChild(function(t) {
                    t.silent = !0
                }),
                M.silent = !l,
                this.getContentGroup().add(f),
                Fs.setHoverStyle(f),
                f.__legendDataIndex = e,
                f
            },
            layoutInner: function(t, e, i) {
                var n = this.getContentGroup();
                Il.box(t.get("orient"), n, t.get("itemGap"), i.width, i.height);
                var a = n.getBoundingRect();
                return n.attr("position", [-a.x, -a.y]),
                this.group.getBoundingRect()
            },
            remove: function() {
                this.getContentGroup().removeAll(),
                this._isFirstRender = !0
            }
        });
        function qL(t) {
            var i = t.findComponents({
                mainType: "legend"
            });
            i && i.length && t.filterSeries(function(t) {
                for (var e = 0; e < i.length; e++)
                    if (!i[e].isSelected(t.name))
                        return !1;
                return !0
            })
        }
        Gm.registerProcessor(qL),
        Pl.registerSubTypeDefaulter("legend", function() {
            return "plain"
        });
        var KL = Il.mergeLayoutParam
          , $L = Il.getLayoutParams
          , JL = RL.extend({
            type: "legend.scroll",
            setScrollDataIndex: function(t) {
                this.option.scrollDataIndex = t
            },
            defaultOption: {
                scrollDataIndex: 0,
                pageButtonItemGap: 5,
                pageButtonGap: null,
                pageButtonPosition: "end",
                pageFormatter: "{current}/{total}",
                pageIcons: {
                    horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
                    vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
                },
                pageIconColor: "#2f4554",
                pageIconInactiveColor: "#aaa",
                pageIconSize: 15,
                pageTextStyle: {
                    color: "#333"
                },
                animationDurationUpdate: 800
            },
            init: function(t, e, i, n) {
                var a = $L(t);
                JL.superCall(this, "init", t, e, i, n),
                QL(this, t, a)
            },
            mergeOption: function(t, e) {
                JL.superCall(this, "mergeOption", t, e),
                QL(this, this.option, t)
            },
            getOrient: function() {
                return "vertical" === this.get("orient") ? {
                    index: 1,
                    name: "vertical"
                } : {
                    index: 0,
                    name: "horizontal"
                }
            }
        });
        function QL(t, e, i) {
            var n = [1, 1];
            n[t.getOrient().index] = 0,
            KL(e, i, {
                type: "box",
                ignoreSize: n
            })
        }
        var tP = Fs.Group
          , eP = ["width", "height"]
          , iP = ["x", "y"]
          , nP = XL.extend({
            type: "legend.scroll",
            newlineDisabled: !0,
            init: function() {
                nP.superCall(this, "init"),
                this._currentIndex = 0,
                this.group.add(this._containerGroup = new tP),
                this._containerGroup.add(this.getContentGroup()),
                this.group.add(this._controllerGroup = new tP),
                this._showController
            },
            resetInner: function() {
                nP.superCall(this, "resetInner"),
                this._controllerGroup.removeAll(),
                this._containerGroup.removeClipPath(),
                this._containerGroup.__rectSize = null
            },
            renderInner: function(t, a, e, r) {
                var o = this;
                nP.superCall(this, "renderInner", t, a, e, r);
                var s = this._controllerGroup
                  , l = a.get("pageIconSize", !0);
                it.isArray(l) || (l = [l, l]),
                n("pagePrev", 0);
                var i = a.getModel("pageTextStyle");
                function n(t, e) {
                    var i = t + "DataIndex"
                      , n = Fs.createIcon(a.get("pageIcons", !0)[a.getOrient().name][e], {
                        onclick: it.bind(o._pageGo, o, i, a, r)
                    }, {
                        x: -l[0] / 2,
                        y: -l[1] / 2,
                        width: l[0],
                        height: l[1]
                    });
                    n.name = t,
                    s.add(n)
                }
                s.add(new Fs.Text({
                    name: "pageText",
                    style: {
                        textFill: i.getTextColor(),
                        font: i.getFont(),
                        textVerticalAlign: "middle",
                        textAlign: "center"
                    },
                    silent: !0
                })),
                n("pageNext", 1)
            },
            layoutInner: function(t, e, i, n) {
                var a = this.getContentGroup()
                  , r = this._containerGroup
                  , o = this._controllerGroup
                  , s = t.getOrient().index
                  , l = eP[s]
                  , u = eP[1 - s]
                  , h = iP[1 - s];
                Il.box(t.get("orient"), a, t.get("itemGap"), s ? i.width : null, s ? null : i.height),
                Il.box("horizontal", o, t.get("pageButtonItemGap", !0));
                var c = a.getBoundingRect()
                  , d = o.getBoundingRect()
                  , p = this._showController = c[l] > i[l]
                  , f = [-c.x, -c.y];
                n || (f[s] = a.position[s]);
                var g = [0, 0]
                  , m = [-d.x, -d.y]
                  , v = it.retrieve2(t.get("pageButtonGap", !0), t.get("itemGap", !0));
                p && ("end" === t.get("pageButtonPosition", !0) ? m[s] += i[l] - d[l] : g[s] += d[l] + v);
                m[1 - s] += c[u] / 2 - d[u] / 2,
                a.attr("position", f),
                r.attr("position", g),
                o.attr("position", m);
                var y = this.group.getBoundingRect();
                if ((y = {
                    x: 0,
                    y: 0
                })[l] = p ? i[l] : c[l],
                y[u] = Math.max(c[u], d[u]),
                y[h] = Math.min(0, d[h] + m[1 - s]),
                r.__rectSize = i[l],
                p) {
                    var x = {
                        x: 0,
                        y: 0
                    };
                    x[l] = Math.max(i[l] - d[l] - v, 0),
                    x[u] = y[u],
                    r.setClipPath(new Fs.Rect({
                        shape: x
                    })),
                    r.__rectSize = x[l]
                } else
                    o.eachChild(function(t) {
                        t.attr({
                            invisible: !0,
                            silent: !0
                        })
                    });
                var _ = this._getPageInfo(t);
                return null != _.pageIndex && Fs.updateProps(a, {
                    position: _.contentPosition
                }, p && t),
                this._updatePageInfoView(t, _),
                y
            },
            _pageGo: function(t, e, i) {
                var n = this._getPageInfo(e)[t];
                null != n && i.dispatchAction({
                    type: "legendScroll",
                    scrollDataIndex: n,
                    legendId: e.id
                })
            },
            _updatePageInfoView: function(n, a) {
                var r = this._controllerGroup;
                it.each(["pagePrev", "pageNext"], function(t) {
                    var e = null != a[t + "DataIndex"]
                      , i = r.childOfName(t);
                    i && (i.setStyle("fill", e ? n.get("pageIconColor", !0) : n.get("pageIconInactiveColor", !0)),
                    i.cursor = e ? "pointer" : "default")
                });
                var t = r.childOfName("pageText")
                  , e = n.get("pageFormatter")
                  , i = a.pageIndex
                  , o = null != i ? i + 1 : 0
                  , s = a.pageCount;
                t && e && t.setStyle("text", it.isString(e) ? e.replace("{current}", o).replace("{total}", s) : e({
                    current: o,
                    total: s
                }))
            },
            _getPageInfo: function(t) {
                var e = t.get("scrollDataIndex", !0)
                  , i = this.getContentGroup()
                  , n = this._containerGroup.__rectSize
                  , a = t.getOrient().index
                  , r = eP[a]
                  , o = iP[a]
                  , s = this._findTargetItemIndex(e)
                  , l = i.children()
                  , u = l[s]
                  , h = l.length
                  , c = h ? 1 : 0
                  , d = {
                    contentPosition: i.position.slice(),
                    pageCount: c,
                    pageIndex: c - 1,
                    pagePrevDataIndex: null,
                    pageNextDataIndex: null
                };
                if (!u)
                    return d;
                var p = y(u);
                d.contentPosition[a] = -p.s;
                for (var f = s + 1, g = p, m = p, v = null; f <= h; ++f)
                    (!(v = y(l[f])) && m.e > g.s + n || v && !x(v, g.s)) && (g = m.i > g.i ? m : v) && (null == d.pageNextDataIndex && (d.pageNextDataIndex = g.i),
                    ++d.pageCount),
                    m = v;
                for (f = s - 1,
                g = p,
                m = p,
                v = null; -1 <= f; --f)
                    (v = y(l[f])) && x(m, v.s) || !(g.i < m.i) || (m = g,
                    null == d.pagePrevDataIndex && (d.pagePrevDataIndex = g.i),
                    ++d.pageCount,
                    ++d.pageIndex),
                    g = v;
                return d;
                function y(t) {
                    if (t) {
                        var e = t.getBoundingRect()
                          , i = e[o] + t.position[a];
                        return {
                            s: i,
                            e: i + e[r],
                            i: t.__legendDataIndex
                        }
                    }
                }
                function x(t, e) {
                    return t.e >= e && t.s <= e + n
                }
            },
            _findTargetItemIndex: function(i) {
                var n, t = this.getContentGroup();
                return this._showController ? t.eachChild(function(t, e) {
                    t.__legendDataIndex === i && (n = e)
                }) : n = 0,
                n
            }
        });
        Gm.registerAction("legendScroll", "legendscroll", function(t, e) {
            var i = t.scrollDataIndex;
            null != i && e.eachComponent({
                mainType: "legend",
                subType: "scroll",
                query: t
            }, function(t) {
                t.setScrollDataIndex(i)
            })
        });
        Gm.extendComponentModel({
            type: "tooltip",
            dependencies: ["axisPointer"],
            defaultOption: {
                zlevel: 0,
                z: 60,
                show: !0,
                showContent: !0,
                trigger: "item",
                triggerOn: "mousemove|click",
                alwaysShowContent: !1,
                displayMode: "single",
                renderMode: "auto",
                confine: !1,
                showDelay: 0,
                hideDelay: 100,
                transitionDuration: .4,
                enterable: !1,
                backgroundColor: "rgba(50,50,50,0.7)",
                borderColor: "#333",
                borderRadius: 4,
                borderWidth: 0,
                padding: 5,
                extraCssText: "",
                axisPointer: {
                    type: "line",
                    axis: "auto",
                    animation: "auto",
                    animationDurationUpdate: 200,
                    animationEasingUpdate: "exponentialOut",
                    crossStyle: {
                        color: "#999",
                        width: 1,
                        type: "dashed",
                        textStyle: {}
                    }
                },
                textStyle: {
                    color: "#fff",
                    fontSize: 14
                }
            }
        });
        var aP = it.each
          , rP = fl.toCamelCase
          , oP = ["", "-webkit-", "-moz-", "-o-"];
        function sP(a) {
            var r = []
              , t = a.get("transitionDuration")
              , e = a.get("backgroundColor")
              , i = a.getModel("textStyle")
              , n = a.get("padding");
            return t && r.push(function(t) {
                var e = "cubic-bezier(0.23, 1, 0.32, 1)"
                  , i = "left " + t + "s " + e + ",top " + t + "s " + e;
                return it.map(oP, function(t) {
                    return t + "transition:" + i
                }).join(";")
            }(t)),
            e && (et.canvasSupported ? r.push("background-Color:" + e) : (r.push("background-Color:#" + jt.toHex(e)),
            r.push("filter:alpha(opacity=70)"))),
            aP(["width", "color", "radius"], function(t) {
                var e = "border-" + t
                  , i = rP(e)
                  , n = a.get(i);
                null != n && r.push(e + ":" + n + ("color" === t ? "" : "px"))
            }),
            r.push(function(i) {
                var n = []
                  , t = i.get("fontSize")
                  , e = i.getTextColor();
                return e && n.push("color:" + e),
                n.push("font:" + i.getFont()),
                t && n.push("line-height:" + Math.round(3 * t / 2) + "px"),
                aP(["decoration", "align"], function(t) {
                    var e = i.get(t);
                    e && n.push("text-" + t + ":" + e)
                }),
                n.join(";")
            }(i)),
            null != n && r.push("padding:" + fl.normalizeCssArray(n).join("px ") + "px"),
            r.join(";") + ";"
        }
        function lP(i, t) {
            if (et.wxa)
                return null;
            var e = document.createElement("div")
              , n = this._zr = t.getZr();
            this.el = e,
            this._x = t.getWidth() / 2,
            this._y = t.getHeight() / 2,
            i.appendChild(e),
            this._container = i,
            this._show = !1,
            this._hideTimeout;
            var a = this;
            e.onmouseenter = function() {
                a._enterable && (clearTimeout(a._hideTimeout),
                a._show = !0),
                a._inContent = !0
            }
            ,
            e.onmousemove = function(t) {
                if (t = t || window.event,
                !a._enterable) {
                    var e = n.handler;
                    j.normalizeEvent(i, t, !0),
                    e.dispatch("mousemove", t)
                }
            }
            ,
            e.onmouseleave = function() {
                a._enterable && a._show && a.hideLater(a._hideDelay),
                a._inContent = !1
            }
        }
        lP.prototype = {
            constructor: lP,
            _enterable: !0,
            update: function() {
                var t = this._container
                  , e = t.currentStyle || document.defaultView.getComputedStyle(t)
                  , i = t.style;
                "absolute" !== i.position && "absolute" !== e.position && (i.position = "relative")
            },
            show: function(t) {
                clearTimeout(this._hideTimeout);
                var e = this.el;
                e.style.cssText = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + sP(t) + ";left:" + this._x + "px;top:" + this._y + "px;" + (t.get("extraCssText") || ""),
                e.style.display = e.innerHTML ? "block" : "none",
                e.style.pointerEvents = this._enterable ? "auto" : "none",
                this._show = !0
            },
            setContent: function(t) {
                this.el.innerHTML = null == t ? "" : t
            },
            setEnterable: function(t) {
                this._enterable = t
            },
            getSize: function() {
                var t = this.el;
                return [t.clientWidth, t.clientHeight]
            },
            moveTo: function(t, e) {
                var i, n = this._zr;
                n && n.painter && (i = n.painter.getViewportRootOffset()) && (t += i.offsetLeft,
                e += i.offsetTop);
                var a = this.el.style;
                a.left = t + "px",
                a.top = e + "px",
                this._x = t,
                this._y = e
            },
            hide: function() {
                this.el.style.display = "none",
                this._show = !1
            },
            hideLater: function(t) {
                !this._show || this._inContent && this._enterable || (t ? (this._hideDelay = t,
                this._show = !1,
                this._hideTimeout = setTimeout(it.bind(this.hide, this), t)) : this.hide())
            },
            isShow: function() {
                return this._show
            },
            getOuterSize: function() {
                var t = this.el.clientWidth
                  , e = this.el.clientHeight;
                if (document.defaultView && document.defaultView.getComputedStyle) {
                    var i = document.defaultView.getComputedStyle(this.el);
                    i && (t += parseInt(i.paddingLeft, 10) + parseInt(i.paddingRight, 10) + parseInt(i.borderLeftWidth, 10) + parseInt(i.borderRightWidth, 10),
                    e += parseInt(i.paddingTop, 10) + parseInt(i.paddingBottom, 10) + parseInt(i.borderTopWidth, 10) + parseInt(i.borderBottomWidth, 10))
                }
                return {
                    width: t,
                    height: e
                }
            }
        };
        var uP = lP;
        function hP(t) {
            this._zr = t.getZr(),
            this._show = !1,
            this._hideTimeout
        }
        hP.prototype = {
            constructor: hP,
            _enterable: !0,
            update: function() {},
            show: function(t) {
                this._hideTimeout && clearTimeout(this._hideTimeout),
                this.el.attr("show", !0),
                this._show = !0
            },
            setContent: function(t, e, i) {
                this.el && this._zr.remove(this.el);
                for (var n = {}, a = t, r = "{marker", o = a.indexOf(r); 0 <= o; ) {
                    var s = a.indexOf("|}")
                      , l = a.substr(o + r.length, s - o - r.length);
                    -1 < l.indexOf("sub") ? n["marker" + l] = {
                        textWidth: 4,
                        textHeight: 4,
                        textBorderRadius: 2,
                        textBackgroundColor: e[l],
                        textOffset: [3, 0]
                    } : n["marker" + l] = {
                        textWidth: 10,
                        textHeight: 10,
                        textBorderRadius: 5,
                        textBackgroundColor: e[l]
                    },
                    o = (a = a.substr(s + 1)).indexOf("{marker")
                }
                this.el = new qr({
                    style: {
                        rich: n,
                        text: t,
                        textLineHeight: 20,
                        textBackgroundColor: i.get("backgroundColor"),
                        textBorderRadius: i.get("borderRadius"),
                        textFill: i.get("textStyle.color"),
                        textPadding: i.get("padding")
                    },
                    z: i.get("z")
                }),
                this._zr.add(this.el);
                var u = this;
                this.el.on("mouseover", function() {
                    u._enterable && (clearTimeout(u._hideTimeout),
                    u._show = !0),
                    u._inContent = !0
                }),
                this.el.on("mouseout", function() {
                    u._enterable && u._show && u.hideLater(u._hideDelay),
                    u._inContent = !1
                })
            },
            setEnterable: function(t) {
                this._enterable = t
            },
            getSize: function() {
                var t = this.el.getBoundingRect();
                return [t.width, t.height]
            },
            moveTo: function(t, e) {
                this.el && this.el.attr("position", [t, e])
            },
            hide: function() {
                this.el.hide(),
                this._show = !1
            },
            hideLater: function(t) {
                !this._show || this._inContent && this._enterable || (t ? (this._hideDelay = t,
                this._show = !1,
                this._hideTimeout = setTimeout(it.bind(this.hide, this), t)) : this.hide())
            },
            isShow: function() {
                return this._show
            },
            getOuterSize: function() {
                return this.getSize()
            }
        };
        var cP = hP
          , dP = aa.getTooltipRenderMode
          , pP = it.bind
          , fP = it.each
          , gP = ol.parsePercent
          , mP = new Fs.Rect({
            shape: {
                x: -1,
                y: -1,
                width: 2,
                height: 2
            }
        });
        Gm.extendComponentView({
            type: "tooltip",
            init: function(t, e) {
                if (!et.node) {
                    var i, n = t.getComponent("tooltip").get("renderMode");
                    this._renderMode = dP(n),
                    "html" === this._renderMode ? (i = new uP(e.getDom(),e),
                    this._newLine = "<br/>") : (i = new cP(e),
                    this._newLine = "\n"),
                    this._tooltipContent = i
                }
            },
            render: function(t, e, i) {
                if (!et.node) {
                    this.group.removeAll(),
                    this._tooltipModel = t,
                    this._ecModel = e,
                    this._api = i,
                    this._lastDataByCoordSys = null,
                    this._alwaysShowContent = t.get("alwaysShowContent");
                    var n = this._tooltipContent;
                    n.update(),
                    n.setEnterable(t.get("enterable")),
                    this._initGlobalListener(),
                    this._keepShow()
                }
            },
            _initGlobalListener: function() {
                var n = this._tooltipModel.get("triggerOn");
                dD.register("itemTooltip", this._api, pP(function(t, e, i) {
                    "none" !== n && (0 <= n.indexOf(t) ? this._tryShow(e, i) : "leave" === t && this._hide(i))
                }, this))
            },
            _keepShow: function() {
                var t = this._tooltipModel
                  , e = this._ecModel
                  , i = this._api;
                if (null != this._lastX && null != this._lastY && "none" !== t.get("triggerOn")) {
                    var n = this;
                    clearTimeout(this._refreshUpdateTimeout),
                    this._refreshUpdateTimeout = setTimeout(function() {
                        n.manuallyShowTip(t, e, i, {
                            x: n._lastX,
                            y: n._lastY
                        })
                    })
                }
            },
            manuallyShowTip: function(t, e, i, n) {
                if (n.from !== this.uid && !et.node) {
                    var a = yP(n, i);
                    this._ticket = "";
                    var r = n.dataByCoordSys;
                    if (n.tooltip && null != n.x && null != n.y) {
                        var o = mP;
                        o.position = [n.x, n.y],
                        o.update(),
                        o.tooltip = n.tooltip,
                        this._tryShow({
                            offsetX: n.x,
                            offsetY: n.y,
                            target: o
                        }, a)
                    } else if (r)
                        this._tryShow({
                            offsetX: n.x,
                            offsetY: n.y,
                            position: n.position,
                            event: {},
                            dataByCoordSys: n.dataByCoordSys,
                            tooltipOption: n.tooltipOption
                        }, a);
                    else if (null != n.seriesIndex) {
                        if (this._manuallyAxisShowTip(t, e, i, n))
                            return;
                        var s = $C(n, e)
                          , l = s.point[0]
                          , u = s.point[1];
                        null != l && null != u && this._tryShow({
                            offsetX: l,
                            offsetY: u,
                            position: n.position,
                            target: s.el,
                            event: {}
                        }, a)
                    } else
                        null != n.x && null != n.y && (i.dispatchAction({
                            type: "updateAxisPointer",
                            x: n.x,
                            y: n.y
                        }),
                        this._tryShow({
                            offsetX: n.x,
                            offsetY: n.y,
                            position: n.position,
                            target: i.getZr().findHover(n.x, n.y).target,
                            event: {}
                        }, a))
                }
            },
            manuallyHideTip: function(t, e, i, n) {
                var a = this._tooltipContent;
                !this._alwaysShowContent && this._tooltipModel && a.hideLater(this._tooltipModel.get("hideDelay")),
                this._lastX = this._lastY = null,
                n.from !== this.uid && this._hide(yP(n, i))
            },
            _manuallyAxisShowTip: function(t, e, i, n) {
                var a = n.seriesIndex
                  , r = n.dataIndex
                  , o = e.getComponent("axisPointer").coordSysAxesInfo;
                if (null != a && null != r && null != o) {
                    var s = e.getSeriesByIndex(a);
                    if (s)
                        if ("axis" === (t = vP([s.getData().getItemModel(r), s, (s.coordinateSystem || {}).model, t])).get("trigger"))
                            return i.dispatchAction({
                                type: "updateAxisPointer",
                                seriesIndex: a,
                                dataIndex: r,
                                position: n.position
                            }),
                            !0
                }
            },
            _tryShow: function(t, e) {
                var i = t.target;
                if (this._tooltipModel) {
                    this._lastX = t.offsetX,
                    this._lastY = t.offsetY;
                    var n = t.dataByCoordSys;
                    n && n.length ? this._showAxisTooltip(n, t) : i && null != i.dataIndex ? (this._lastDataByCoordSys = null,
                    this._showSeriesItemTooltip(t, i, e)) : i && i.tooltip ? (this._lastDataByCoordSys = null,
                    this._showComponentItemTooltip(t, i, e)) : (this._lastDataByCoordSys = null,
                    this._hide(e))
                }
            },
            _showOrMove: function(t, e) {
                var i = t.get("showDelay");
                e = it.bind(e, this),
                clearTimeout(this._showTimout),
                0 < i ? this._showTimout = setTimeout(e, i) : e()
            },
            _showAxisTooltip: function(t, e) {
                var d = this._ecModel
                  , i = this._tooltipModel
                  , n = [e.offsetX, e.offsetY]
                  , a = []
                  , p = []
                  , r = vP([e.tooltipOption, i])
                  , f = this._renderMode
                  , o = this._newLine
                  , g = {};
                fP(t, function(t) {
                    fP(t.dataByAxis, function(s) {
                        var l = d.getComponent(s.axisDim + "Axis", s.axisIndex)
                          , u = s.value
                          , h = [];
                        if (l && null != u) {
                            var c = AD.getValueLabel(u, l.axis, d, s.seriesDataIndices, s.valueLabelOpt);
                            it.each(s.seriesDataIndices, function(t) {
                                var e = d.getSeriesByIndex(t.seriesIndex)
                                  , i = t.dataIndexInside
                                  , n = e && e.getDataParams(i);
                                if (n.axisDim = s.axisDim,
                                n.axisIndex = s.axisIndex,
                                n.axisType = s.axisType,
                                n.axisId = s.axisId,
                                n.axisValue = Lg.getAxisRawValue(l.axis, u),
                                n.axisValueLabel = c,
                                n) {
                                    p.push(n);
                                    var a, r = e.formatTooltip(i, !0, null, f);
                                    if (it.isObject(r)) {
                                        a = r.html;
                                        var o = r.markers;
                                        it.merge(g, o)
                                    } else
                                        a = r;
                                    h.push(a)
                                }
                            });
                            var t = c;
                            "html" !== f ? a.push(h.join(o)) : a.push((t ? fl.encodeHTML(t) + o : "") + h.join(o))
                        }
                    })
                }, this),
                a.reverse(),
                a = a.join(this._newLine + this._newLine);
                var s = e.position;
                this._showOrMove(r, function() {
                    this._updateContentNotChangedOnAxis(t) ? this._updatePosition(r, s, n[0], n[1], this._tooltipContent, p) : this._showTooltipContent(r, a, p, Math.random(), n[0], n[1], s, void 0, g)
                })
            },
            _showSeriesItemTooltip: function(t, e, i) {
                var n = this._ecModel
                  , a = e.seriesIndex
                  , r = n.getSeriesByIndex(a)
                  , o = e.dataModel || r
                  , s = e.dataIndex
                  , l = e.dataType
                  , u = o.getData()
                  , h = vP([u.getItemModel(s), o, r && (r.coordinateSystem || {}).model, this._tooltipModel])
                  , c = h.get("trigger");
                if (null == c || "item" === c) {
                    var d, p, f = o.getDataParams(s, l), g = o.formatTooltip(s, !1, l, this._renderMode);
                    p = it.isObject(g) ? (d = g.html,
                    g.markers) : (d = g,
                    null);
                    var m = "item_" + o.name + "_" + s;
                    this._showOrMove(h, function() {
                        this._showTooltipContent(h, d, f, m, t.offsetX, t.offsetY, t.position, t.target, p)
                    }),
                    i({
                        type: "showTip",
                        dataIndexInside: s,
                        dataIndex: u.getRawIndex(s),
                        seriesIndex: a,
                        from: this.uid
                    })
                }
            },
            _showComponentItemTooltip: function(t, e, i) {
                var n = e.tooltip;
                if ("string" == typeof n) {
                    n = {
                        content: n,
                        formatter: n
                    }
                }
                var a = new tl(n,this._tooltipModel,this._ecModel)
                  , r = a.get("content")
                  , o = Math.random();
                this._showOrMove(a, function() {
                    this._showTooltipContent(a, r, a.get("formatterParams") || {}, o, t.offsetX, t.offsetY, t.position, e)
                }),
                i({
                    type: "showTip",
                    from: this.uid
                })
            },
            _showTooltipContent: function(i, t, n, e, a, r, o, s, l) {
                if (this._ticket = "",
                i.get("showContent") && i.get("show")) {
                    var u = this._tooltipContent
                      , h = i.get("formatter");
                    o = o || i.get("position");
                    var c = t;
                    if (h && "string" == typeof h)
                        c = fl.formatTpl(h, n, !0);
                    else if ("function" == typeof h) {
                        var d = pP(function(t, e) {
                            t === this._ticket && (u.setContent(e, l, i),
                            this._updatePosition(i, o, a, r, u, n, s))
                        }, this);
                        this._ticket = e,
                        c = h(n, e, d)
                    }
                    u.setContent(c, l, i),
                    u.show(i),
                    this._updatePosition(i, o, a, r, u, n, s)
                }
            },
            _updatePosition: function(t, e, i, n, a, r, o) {
                var s = this._api.getWidth()
                  , l = this._api.getHeight();
                e = e || t.get("position");
                var u = a.getSize()
                  , h = t.get("align")
                  , c = t.get("verticalAlign")
                  , d = o && o.getBoundingRect().clone();
                if (o && d.applyTransform(o.transform),
                "function" == typeof e && (e = e([i, n], r, a.el, d, {
                    viewSize: [s, l],
                    contentSize: u.slice()
                })),
                it.isArray(e))
                    i = gP(e[0], s),
                    n = gP(e[1], l);
                else if (it.isObject(e)) {
                    e.width = u[0],
                    e.height = u[1];
                    var p = Il.getLayoutRect(e, {
                        width: s,
                        height: l
                    });
                    i = p.x,
                    n = p.y,
                    c = h = null
                } else if ("string" == typeof e && o) {
                    i = (f = function(t, e, i) {
                        var n = i[0]
                          , a = i[1]
                          , r = 0
                          , o = 0
                          , s = e.width
                          , l = e.height;
                        switch (t) {
                        case "inside":
                            r = e.x + s / 2 - n / 2,
                            o = e.y + l / 2 - a / 2;
                            break;
                        case "top":
                            r = e.x + s / 2 - n / 2,
                            o = e.y - a - 5;
                            break;
                        case "bottom":
                            r = e.x + s / 2 - n / 2,
                            o = e.y + l + 5;
                            break;
                        case "left":
                            r = e.x - n - 5,
                            o = e.y + l / 2 - a / 2;
                            break;
                        case "right":
                            r = e.x + s + 5,
                            o = e.y + l / 2 - a / 2
                        }
                        return [r, o]
                    }(e, d, u))[0],
                    n = f[1]
                } else {
                    var f;
                    i = (f = function(t, e, i, n, a, r, o) {
                        var s = i.getOuterSize()
                          , l = s.width
                          , u = s.height;
                        null != r && (n < t + l + r ? t -= l + r : t += r);
                        null != o && (a < e + u + o ? e -= u + o : e += o);
                        return [t, e]
                    }(i, n, a, s, l, h ? null : 20, c ? null : 20))[0],
                    n = f[1]
                }
                h && (i -= xP(h) ? u[0] / 2 : "right" === h ? u[0] : 0),
                c && (n -= xP(c) ? u[1] / 2 : "bottom" === c ? u[1] : 0),
                t.get("confine") && (i = (f = function(t, e, i, n, a) {
                    var r = i.getOuterSize()
                      , o = r.width
                      , s = r.height;
                    return t = Math.min(t + o, n) - o,
                    e = Math.min(e + s, a) - s,
                    t = Math.max(t, 0),
                    e = Math.max(e, 0),
                    [t, e]
                }(i, n, a, s, l))[0],
                n = f[1]);
                a.moveTo(i, n)
            },
            _updateContentNotChangedOnAxis: function(n) {
                var t = this._lastDataByCoordSys
                  , o = !!t && t.length === n.length;
                return o && fP(t, function(t, e) {
                    var i = t.dataByAxis || {}
                      , r = (n[e] || {}).dataByAxis || [];
                    (o &= i.length === r.length) && fP(i, function(t, e) {
                        var i = r[e] || {}
                          , n = t.seriesDataIndices || []
                          , a = i.seriesDataIndices || [];
                        (o &= t.value === i.value && t.axisType === i.axisType && t.axisId === i.axisId && n.length === a.length) && fP(n, function(t, e) {
                            var i = a[e];
                            o &= t.seriesIndex === i.seriesIndex && t.dataIndex === i.dataIndex
                        })
                    })
                }),
                this._lastDataByCoordSys = n,
                !!o
            },
            _hide: function(t) {
                this._lastDataByCoordSys = null,
                t({
                    type: "hideTip",
                    from: this.uid
                })
            },
            dispose: function(t, e) {
                et.node || (this._tooltipContent.hide(),
                dD.unregister("itemTooltip", e))
            }
        });
        function vP(t) {
            for (var e = t.pop(); t.length; ) {
                var i = t.pop();
                i && (tl.isInstance(i) && (i = i.get("tooltip", !0)),
                "string" == typeof i && (i = {
                    formatter: i
                }),
                e = new tl(i,e,e.ecModel))
            }
            return e
        }
        function yP(t, e) {
            return t.dispatchAction || it.bind(e.dispatchAction, e)
        }
        function xP(t) {
            return "center" === t || "middle" === t
        }
        Gm.registerAction({
            type: "showTip",
            event: "showTip",
            update: "tooltip:manuallyShowTip"
        }, function() {}),
        Gm.registerAction({
            type: "hideTip",
            event: "hideTip",
            update: "tooltip:manuallyHideTip"
        }, function() {});
        var _P = ol.parsePercent
          , bP = vf.isDimensionStacked;
        function wP(t) {
            return t.get("stack") || "__ec_stack_" + t.seriesIndex
        }
        function SP(t) {
            return t.dim
        }
        function MP(t, e, i) {
            i.getWidth(),
            i.getHeight();
            var P = {}
              , k = function(t) {
                var p = {};
                it.each(t, function(t, e) {
                    var i = t.getData()
                      , n = t.coordinateSystem.getBaseAxis()
                      , a = n.getExtent()
                      , r = "category" === n.type ? n.getBandWidth() : Math.abs(a[1] - a[0]) / i.count()
                      , o = p[SP(n)] || {
                        bandWidth: r,
                        remainedWidth: r,
                        autoWidthCount: 0,
                        categoryGap: "20%",
                        gap: "30%",
                        stacks: {}
                    }
                      , s = o.stacks;
                    p[SP(n)] = o;
                    var l = wP(t);
                    s[l] || o.autoWidthCount++,
                    s[l] = s[l] || {
                        width: 0,
                        maxWidth: 0
                    };
                    var u = _P(t.get("barWidth"), r)
                      , h = _P(t.get("barMaxWidth"), r)
                      , c = t.get("barGap")
                      , d = t.get("barCategoryGap");
                    u && !s[l].width && (u = Math.min(o.remainedWidth, u),
                    s[l].width = u,
                    o.remainedWidth -= u),
                    h && (s[l].maxWidth = h),
                    null != c && (o.gap = c),
                    null != d && (o.categoryGap = d)
                });
                var d = {};
                return it.each(p, function(t, i) {
                    d[i] = {};
                    var e = t.stacks
                      , n = t.bandWidth
                      , a = _P(t.categoryGap, n)
                      , r = _P(t.gap, 1)
                      , o = t.remainedWidth
                      , s = t.autoWidthCount
                      , l = (o - a) / (s + (s - 1) * r);
                    l = Math.max(l, 0),
                    it.each(e, function(t, e) {
                        var i = t.maxWidth;
                        i && i < l && (i = Math.min(i, o),
                        t.width && (i = Math.min(i, t.width)),
                        o -= i,
                        t.width = i,
                        s--)
                    }),
                    l = (o - a) / (s + (s - 1) * r),
                    l = Math.max(l, 0);
                    var u, h = 0;
                    it.each(e, function(t, e) {
                        t.width || (t.width = l),
                        h += (u = t).width * (1 + r)
                    }),
                    u && (h -= u.width * r);
                    var c = -h / 2;
                    it.each(e, function(t, e) {
                        d[i][e] = d[i][e] || {
                            offset: c,
                            width: t.width
                        },
                        c += t.width * (1 + r)
                    })
                }),
                d
            }(it.filter(e.getSeriesByType(t), function(t) {
                return !e.isSeriesFiltered(t) && t.coordinateSystem && "polar" === t.coordinateSystem.type
            }));
            e.eachSeriesByType(t, function(t) {
                if ("polar" === t.coordinateSystem.type) {
                    var e = t.getData()
                      , i = t.coordinateSystem
                      , n = i.getBaseAxis()
                      , a = wP(t)
                      , r = k[SP(n)][a]
                      , o = r.offset
                      , s = r.width
                      , l = i.getOtherAxis(n)
                      , u = t.coordinateSystem.cx
                      , h = t.coordinateSystem.cy
                      , c = t.get("barMinHeight") || 0
                      , d = t.get("barMinAngle") || 0;
                    P[a] = P[a] || [];
                    for (var p = e.mapDimension(l.dim), f = e.mapDimension(n.dim), g = bP(e, p), m = l.getExtent()[0], v = 0, y = e.count(); v < y; v++) {
                        var x = e.get(p, v)
                          , _ = e.get(f, v);
                        if (!isNaN(x)) {
                            var b, w, S, M, I = 0 <= x ? "p" : "n", A = m;
                            if (g && (P[a][_] || (P[a][_] = {
                                p: m,
                                n: m
                            }),
                            A = P[a][_][I]),
                            "radius" === l.dim) {
                                var T = l.dataToRadius(x) - m
                                  , C = n.dataToAngle(_);
                                Math.abs(T) < c && (T = (T < 0 ? -1 : 1) * c),
                                w = (b = A) + T,
                                M = (S = C - o) - s,
                                g && (P[a][_][I] = w)
                            } else {
                                var D = l.dataToAngle(x, !0) - m
                                  , L = n.dataToRadius(_);
                                Math.abs(D) < d && (D = (D < 0 ? -1 : 1) * d),
                                w = (b = L + o) + s,
                                M = (S = A) + D,
                                g && (P[a][_][I] = M)
                            }
                            e.setItemLayout(v, {
                                cx: u,
                                cy: h,
                                r0: b,
                                r: w,
                                startAngle: -S * Math.PI / 180,
                                endAngle: -M * Math.PI / 180
                            })
                        }
                    }
                }
            }, this)
        }
        function IP(t, e) {
            wm.call(this, "radius", t, e),
            this.type = "category"
        }
        IP.prototype = {
            constructor: IP,
            pointToData: function(t, e) {
                return this.polar.pointToData(t, e)["radius" === this.dim ? 0 : 1]
            },
            dataToRadius: wm.prototype.dataToCoord,
            radiusToData: wm.prototype.coordToData
        },
        it.inherits(IP, wm);
        var AP = IP
          , TP = (0,
        aa.makeInner)();
        function CP(t, e) {
            e = e || [0, 360],
            wm.call(this, "angle", t, e),
            this.type = "category"
        }
        CP.prototype = {
            constructor: CP,
            pointToData: function(t, e) {
                return this.polar.pointToData(t, e)["radius" === this.dim ? 0 : 1]
            },
            dataToAngle: wm.prototype.dataToCoord,
            angleToData: wm.prototype.coordToData,
            calculateCategoryInterval: function() {
                var t = this.getLabelModel()
                  , e = this.scale
                  , i = e.getExtent()
                  , n = e.count();
                if (i[1] - i[0] < 1)
                    return 0;
                var a = i[0]
                  , r = this.dataToCoord(a + 1) - this.dataToCoord(a)
                  , o = Math.abs(r)
                  , s = Bi.getBoundingRect(a, t.getFont(), "center", "top")
                  , l = Math.max(s.height, 7) / o;
                isNaN(l) && (l = 1 / 0);
                var u = Math.max(0, Math.floor(l))
                  , h = TP(this.model)
                  , c = h.lastAutoInterval
                  , d = h.lastTickCount;
                return null != c && null != d && Math.abs(c - u) <= 1 && Math.abs(d - n) <= 1 && u < c ? u = c : (h.lastTickCount = n,
                h.lastAutoInterval = u),
                u
            }
        },
        it.inherits(CP, wm);
        function DP(t) {
            this.name = t || "",
            this.cx = 0,
            this.cy = 0,
            this._radiusAxis = new AP,
            this._angleAxis = new LP,
            this._radiusAxis.polar = this._angleAxis.polar = this
        }
        var LP = CP;
        DP.prototype = {
            type: "polar",
            axisPointerEnabled: !0,
            constructor: DP,
            dimensions: ["radius", "angle"],
            model: null,
            containPoint: function(t) {
                var e = this.pointToCoord(t);
                return this._radiusAxis.contain(e[0]) && this._angleAxis.contain(e[1])
            },
            containData: function(t) {
                return this._radiusAxis.containData(t[0]) && this._angleAxis.containData(t[1])
            },
            getAxis: function(t) {
                return this["_" + t + "Axis"]
            },
            getAxes: function() {
                return [this._radiusAxis, this._angleAxis]
            },
            getAxesByScale: function(t) {
                var e = []
                  , i = this._angleAxis
                  , n = this._radiusAxis;
                return i.scale.type === t && e.push(i),
                n.scale.type === t && e.push(n),
                e
            },
            getAngleAxis: function() {
                return this._angleAxis
            },
            getRadiusAxis: function() {
                return this._radiusAxis
            },
            getOtherAxis: function(t) {
                var e = this._angleAxis;
                return t === e ? this._radiusAxis : e
            },
            getBaseAxis: function() {
                return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis()
            },
            getTooltipAxes: function(t) {
                var e = null != t && "auto" !== t ? this.getAxis(t) : this.getBaseAxis();
                return {
                    baseAxes: [e],
                    otherAxes: [this.getOtherAxis(e)]
                }
            },
            dataToPoint: function(t, e) {
                return this.coordToPoint([this._radiusAxis.dataToRadius(t[0], e), this._angleAxis.dataToAngle(t[1], e)])
            },
            pointToData: function(t, e) {
                var i = this.pointToCoord(t);
                return [this._radiusAxis.radiusToData(i[0], e), this._angleAxis.angleToData(i[1], e)]
            },
            pointToCoord: function(t) {
                var e = t[0] - this.cx
                  , i = t[1] - this.cy
                  , n = this.getAngleAxis()
                  , a = n.getExtent()
                  , r = Math.min(a[0], a[1])
                  , o = Math.max(a[0], a[1]);
                n.inverse ? r = o - 360 : o = r + 360;
                var s = Math.sqrt(e * e + i * i);
                e /= s,
                i /= s;
                for (var l = Math.atan2(-i, e) / Math.PI * 180, u = l < r ? 1 : -1; l < r || o < l; )
                    l += 360 * u;
                return [s, l]
            },
            coordToPoint: function(t) {
                var e = t[0]
                  , i = t[1] / 180 * Math.PI;
                return [Math.cos(i) * e + this.cx, -Math.sin(i) * e + this.cy]
            }
        };
        var PP = DP
          , kP = Pl.extend({
            type: "polarAxis",
            axis: null,
            getCoordSysModel: function() {
                return this.ecModel.queryComponents({
                    mainType: "polar",
                    index: this.option.polarIndex,
                    id: this.option.polarId
                })[0]
            }
        });
        it.merge(kP.prototype, Pg);
        var OP = {
            splitNumber: 5
        };
        function RP(t, e) {
            return e.type || (e.data ? "category" : "value")
        }
        sy("angle", kP, RP, {
            startAngle: 90,
            clockwise: !0,
            splitNumber: 12,
            axisLabel: {
                rotate: !1
            }
        }),
        sy("radius", kP, RP, OP);
        Gm.extendComponentModel({
            type: "polar",
            dependencies: ["polarAxis", "angleAxis"],
            coordinateSystem: null,
            findAxisModel: function(t) {
                var e;
                return this.ecModel.eachComponent(t, function(t) {
                    t.getCoordSysModel() === this && (e = t)
                }, this),
                e
            },
            defaultOption: {
                zlevel: 0,
                z: 0,
                center: ["50%", "50%"],
                radius: "80%"
            }
        });
        var NP = ol.parsePercent
          , EP = Lg.createScaleByModel
          , zP = Lg.niceScaleExtent
          , VP = vf.getStackedDimension;
        function BP(t, e) {
            var i = this
              , n = i.getAngleAxis()
              , a = i.getRadiusAxis();
            if (n.scale.setExtent(1 / 0, -1 / 0),
            a.scale.setExtent(1 / 0, -1 / 0),
            t.eachSeries(function(t) {
                if (t.coordinateSystem === i) {
                    var e = t.getData();
                    it.each(e.mapDimension("radius", !0), function(t) {
                        a.scale.unionExtentFromData(e, VP(e, t))
                    }),
                    it.each(e.mapDimension("angle", !0), function(t) {
                        n.scale.unionExtentFromData(e, VP(e, t))
                    })
                }
            }),
            zP(n.scale, n.model),
            zP(a.scale, a.model),
            "category" === n.type && !n.onBand) {
                var r = n.getExtent()
                  , o = 360 / n.scale.count();
                n.inverse ? r[1] += o : r[1] -= o,
                n.setExtent(r[0], r[1])
            }
        }
        function GP(t, e) {
            if (t.type = e.get("type"),
            t.scale = EP(e),
            t.onBand = e.get("boundaryGap") && "category" === t.type,
            t.inverse = e.get("inverse"),
            "angleAxis" === e.mainType) {
                t.inverse ^= e.get("clockwise");
                var i = e.get("startAngle");
                t.setExtent(i, i + (t.inverse ? -360 : 360))
            }
            (e.axis = t).model = e
        }
        var FP = {
            dimensions: PP.prototype.dimensions,
            create: function(i, s) {
                var l = [];
                return i.eachComponent("polar", function(t, e) {
                    var i = new PP(e);
                    i.update = BP;
                    var n = i.getRadiusAxis()
                      , a = i.getAngleAxis()
                      , r = t.findAxisModel("radiusAxis")
                      , o = t.findAxisModel("angleAxis");
                    GP(n, r),
                    GP(a, o),
                    function(t, e, i) {
                        var n = e.get("center")
                          , a = i.getWidth()
                          , r = i.getHeight();
                        t.cx = NP(n[0], a),
                        t.cy = NP(n[1], r);
                        var o = t.getRadiusAxis()
                          , s = Math.min(a, r) / 2
                          , l = NP(e.get("radius"), s);
                        o.inverse ? o.setExtent(l, 0) : o.setExtent(0, l)
                    }(i, t, s),
                    l.push(i),
                    (t.coordinateSystem = i).model = t
                }),
                i.eachSeries(function(t) {
                    if ("polar" === t.get("coordinateSystem")) {
                        var e = i.queryComponents({
                            mainType: "polar",
                            index: t.get("polarIndex"),
                            id: t.get("polarId")
                        })[0];
                        t.coordinateSystem = e.coordinateSystem
                    }
                }),
                l
            }
        };
        ju.register("polar", FP);
        var HP = ["axisLine", "axisLabel", "axisTick", "splitLine", "splitArea"];
        function WP(t, e, i) {
            e[1] > e[0] && (e = e.slice().reverse());
            var n = t.coordToPoint([e[0], i])
              , a = t.coordToPoint([e[1], i]);
            return {
                x1: n[0],
                y1: n[1],
                x2: a[0],
                y2: a[1]
            }
        }
        function ZP(t) {
            return t.getRadiusAxis().inverse ? 0 : 1
        }
        function UP(t) {
            var e = t[0]
              , i = t[t.length - 1];
            e && i && Math.abs(Math.abs(e.coord - i.coord) - 360) < 1e-4 && t.pop()
        }
        rx.extend({
            type: "angleAxis",
            axisPointerClass: "PolarAxisPointer",
            render: function(e, t) {
                if (this.group.removeAll(),
                e.get("show")) {
                    var i = e.axis
                      , n = i.polar
                      , a = n.getRadiusAxis().getExtent()
                      , r = i.getTicksCoords()
                      , o = it.map(i.getViewLabels(), function(t) {
                        return (t = it.clone(t)).coord = i.dataToCoord(t.tickValue),
                        t
                    });
                    UP(o),
                    UP(r),
                    it.each(HP, function(t) {
                        !e.get(t + ".show") || i.scale.isBlank() && "axisLine" !== t || this["_" + t](e, n, r, a, o)
                    }, this)
                }
            },
            _axisLine: function(t, e, i, n) {
                var a = t.getModel("axisLine.lineStyle")
                  , r = new Fs.Circle({
                    shape: {
                        cx: e.cx,
                        cy: e.cy,
                        r: n[ZP(e)]
                    },
                    style: a.getLineStyle(),
                    z2: 1,
                    silent: !0
                });
                r.style.fill = null,
                this.group.add(r)
            },
            _axisTick: function(t, e, i, n) {
                var a = t.getModel("axisTick")
                  , r = (a.get("inside") ? -1 : 1) * a.get("length")
                  , o = n[ZP(e)]
                  , s = it.map(i, function(t) {
                    return new Fs.Line({
                        shape: WP(e, [o, o + r], t.coord)
                    })
                });
                this.group.add(Fs.mergePath(s, {
                    style: it.defaults(a.getModel("lineStyle").getLineStyle(), {
                        stroke: t.get("axisLine.lineStyle.color")
                    })
                }))
            },
            _axisLabel: function(c, d, t, p, e) {
                var f = c.getCategories(!0)
                  , g = c.getModel("axisLabel")
                  , m = g.get("margin");
                it.each(e, function(t, e) {
                    var i = g
                      , n = t.tickValue
                      , a = p[ZP(d)]
                      , r = d.coordToPoint([a + m, t.coord])
                      , o = d.cx
                      , s = d.cy
                      , l = Math.abs(r[0] - o) / a < .3 ? "center" : r[0] > o ? "left" : "right"
                      , u = Math.abs(r[1] - s) / a < .3 ? "middle" : r[1] > s ? "top" : "bottom";
                    f && f[n] && f[n].textStyle && (i = new tl(f[n].textStyle,g,g.ecModel));
                    var h = new Fs.Text({
                        silent: !0
                    });
                    this.group.add(h),
                    Fs.setTextStyle(h.style, i, {
                        x: r[0],
                        y: r[1],
                        textFill: i.getTextColor() || c.get("axisLine.lineStyle.color"),
                        text: t.formattedLabel,
                        textAlign: l,
                        textVerticalAlign: u
                    })
                }, this)
            },
            _splitLine: function(t, e, i, n) {
                var a = t.getModel("splitLine").getModel("lineStyle")
                  , r = a.get("color")
                  , o = 0;
                r = r instanceof Array ? r : [r];
                for (var s = [], l = 0; l < i.length; l++) {
                    var u = o++ % r.length;
                    s[u] = s[u] || [],
                    s[u].push(new Fs.Line({
                        shape: WP(e, n, i[l].coord)
                    }))
                }
                for (l = 0; l < s.length; l++)
                    this.group.add(Fs.mergePath(s[l], {
                        style: it.defaults({
                            stroke: r[l % r.length]
                        }, a.getLineStyle()),
                        silent: !0,
                        z: t.get("z")
                    }))
            },
            _splitArea: function(t, e, i, n) {
                if (i.length) {
                    var a = t.getModel("splitArea").getModel("areaStyle")
                      , r = a.get("color")
                      , o = 0;
                    r = r instanceof Array ? r : [r];
                    for (var s = [], l = Math.PI / 180, u = -i[0].coord * l, h = Math.min(n[0], n[1]), c = Math.max(n[0], n[1]), d = t.get("clockwise"), p = 1; p < i.length; p++) {
                        var f = o++ % r.length;
                        s[f] = s[f] || [],
                        s[f].push(new Fs.Sector({
                            shape: {
                                cx: e.cx,
                                cy: e.cy,
                                r0: h,
                                r: c,
                                startAngle: u,
                                endAngle: -i[p].coord * l,
                                clockwise: d
                            },
                            silent: !0
                        })),
                        u = -i[p].coord * l
                    }
                    for (p = 0; p < s.length; p++)
                        this.group.add(Fs.mergePath(s[p], {
                            style: it.defaults({
                                fill: r[p % r.length]
                            }, a.getAreaStyle()),
                            silent: !0
                        }))
                }
            }
        });
        var YP = ["axisLine", "axisTickLabel", "axisName"]
          , jP = ["splitLine", "splitArea"];
        rx.extend({
            type: "radiusAxis",
            axisPointerClass: "PolarAxisPointer",
            render: function(e, t) {
                if (this.group.removeAll(),
                e.get("show")) {
                    var i = e.axis
                      , n = i.polar
                      , a = n.getAngleAxis()
                      , r = i.getTicksCoords()
                      , o = a.getExtent()[0]
                      , s = i.getExtent()
                      , l = function(t, e, i) {
                        return {
                            position: [t.cx, t.cy],
                            rotation: i / 180 * Math.PI,
                            labelDirection: -1,
                            tickDirection: -1,
                            nameDirection: 1,
                            labelRotate: e.getModel("axisLabel").get("rotate"),
                            z2: 1
                        }
                    }(n, e, o)
                      , u = new jy(e,l);
                    it.each(YP, u.add, u),
                    this.group.add(u.getGroup()),
                    it.each(jP, function(t) {
                        e.get(t + ".show") && !i.scale.isBlank() && this["_" + t](e, n, o, s, r)
                    }, this)
                }
            },
            _splitLine: function(t, e, i, n, a) {
                var r = t.getModel("splitLine").getModel("lineStyle")
                  , o = r.get("color")
                  , s = 0;
                o = o instanceof Array ? o : [o];
                for (var l = [], u = 0; u < a.length; u++) {
                    var h = s++ % o.length;
                    l[h] = l[h] || [],
                    l[h].push(new Fs.Circle({
                        shape: {
                            cx: e.cx,
                            cy: e.cy,
                            r: a[u].coord
                        },
                        silent: !0
                    }))
                }
                for (u = 0; u < l.length; u++)
                    this.group.add(Fs.mergePath(l[u], {
                        style: it.defaults({
                            stroke: o[u % o.length],
                            fill: null
                        }, r.getLineStyle()),
                        silent: !0
                    }))
            },
            _splitArea: function(t, e, i, n, a) {
                if (a.length) {
                    var r = t.getModel("splitArea").getModel("areaStyle")
                      , o = r.get("color")
                      , s = 0;
                    o = o instanceof Array ? o : [o];
                    for (var l = [], u = a[0].coord, h = 1; h < a.length; h++) {
                        var c = s++ % o.length;
                        l[c] = l[c] || [],
                        l[c].push(new Fs.Sector({
                            shape: {
                                cx: e.cx,
                                cy: e.cy,
                                r0: u,
                                r: a[h].coord,
                                startAngle: 0,
                                endAngle: 2 * Math.PI
                            },
                            silent: !0
                        })),
                        u = a[h].coord
                    }
                    for (h = 0; h < l.length; h++)
                        this.group.add(Fs.mergePath(l[h], {
                            style: it.defaults({
                                fill: o[h % o.length]
                            }, r.getAreaStyle()),
                            silent: !0
                        }))
                }
            }
        });
        var XP = wD.extend({
            makeElOption: function(t, e, i, n, a) {
                var r = i.axis;
                "angle" === r.dim && (this.animationThreshold = Math.PI / 18);
                var o, s = r.polar, l = s.getOtherAxis(r).getExtent();
                o = r["dataTo" + fl.capitalFirst(r.dim)](e);
                var u = n.get("type");
                if (u && "none" !== u) {
                    var h = AD.buildElStyle(n)
                      , c = qP[u](r, s, o, l, h);
                    c.style = h,
                    t.graphicKey = c.type,
                    t.pointer = c
                }
                var d = function(t, e, i, n, a) {
                    var r = e.axis
                      , o = r.dataToCoord(t)
                      , s = n.getAngleAxis().getExtent()[0];
                    s = s / 180 * Math.PI;
                    var l, u, h, c = n.getRadiusAxis().getExtent();
                    if ("radius" === r.dim) {
                        var d = ct.create();
                        ct.rotate(d, d, s),
                        ct.translate(d, d, [n.cx, n.cy]),
                        l = Fs.applyTransform([o, -a], d);
                        var p = e.getModel("axisLabel").get("rotate") || 0
                          , f = jy.innerTextLayout(s, p * Math.PI / 180, -1);
                        u = f.textAlign,
                        h = f.textVerticalAlign
                    } else {
                        var g = c[1];
                        l = n.coordToPoint([g + a, o]);
                        var m = n.cx
                          , v = n.cy;
                        u = Math.abs(l[0] - m) / g < .3 ? "center" : l[0] > m ? "left" : "right",
                        h = Math.abs(l[1] - v) / g < .3 ? "middle" : l[1] > v ? "top" : "bottom"
                    }
                    return {
                        position: l,
                        align: u,
                        verticalAlign: h
                    }
                }(e, i, 0, s, n.get("label.margin"));
                AD.buildLabelElOption(t, i, n, a, d)
            }
        });
        var qP = {
            line: function(t, e, i, n, a) {
                return "angle" === t.dim ? {
                    type: "Line",
                    shape: AD.makeLineShape(e.coordToPoint([n[0], i]), e.coordToPoint([n[1], i]))
                } : {
                    type: "Circle",
                    shape: {
                        cx: e.cx,
                        cy: e.cy,
                        r: i
                    }
                }
            },
            shadow: function(t, e, i, n, a) {
                var r = Math.max(1, t.getBandWidth())
                  , o = Math.PI / 180;
                return "angle" === t.dim ? {
                    type: "Sector",
                    shape: AD.makeSectorShape(e.cx, e.cy, n[0], n[1], (-i - r / 2) * o, (r / 2 - i) * o)
                } : {
                    type: "Sector",
                    shape: AD.makeSectorShape(e.cx, e.cy, i - r / 2, i + r / 2, 0, 2 * Math.PI)
                }
            }
        };
        rx.registerAxisPointerClass("PolarAxisPointer", XP),
        Gm.registerLayout(it.curry(MP, "bar")),
        Gm.extendComponentView({
            type: "polar"
        });
        var KP = Pl.extend({
            type: "geo",
            coordinateSystem: null,
            layoutMode: "box",
            init: function(t) {
                Pl.prototype.init.apply(this, arguments),
                aa.defaultEmphasis(t, "label", ["show"])
            },
            optionUpdated: function() {
                var t = this.option
                  , i = this;
                t.regions = Lb.getFilledRegions(t.regions, t.map, t.nameMap),
                this._optionModelMap = it.reduce(t.regions || [], function(t, e) {
                    return e.name && t.set(e.name, new tl(e,i)),
                    t
                }, it.createHashMap()),
                this.updateSelectedMap(t.regions)
            },
            defaultOption: {
                zlevel: 0,
                z: 0,
                show: !0,
                left: "center",
                top: "center",
                aspectScale: null,
                silent: !1,
                map: "",
                boundingCoords: null,
                center: null,
                zoom: 1,
                scaleLimit: null,
                label: {
                    show: !1,
                    color: "#000"
                },
                itemStyle: {
                    borderWidth: .5,
                    borderColor: "#444",
                    color: "#eee"
                },
                emphasis: {
                    label: {
                        show: !0,
                        color: "rgb(100,0,0)"
                    },
                    itemStyle: {
                        color: "rgba(255,215,0,0.8)"
                    }
                },
                regions: []
            },
            getRegionModel: function(t) {
                return this._optionModelMap.get(t) || new tl(null,this,this.ecModel)
            },
            getFormattedLabel: function(t, e) {
                var i = this.getRegionModel(t).get("label." + e + ".formatter")
                  , n = {
                    name: t
                };
                return "function" == typeof i ? (n.status = e,
                i(n)) : "string" == typeof i ? i.replace("{a}", null != t ? t : "") : void 0
            },
            setZoom: function(t) {
                this.option.zoom = t
            },
            setCenter: function(t) {
                this.option.center = t
            }
        });
        it.mixin(KP, Px);
        Gm.extendComponentView({
            type: "geo",
            init: function(t, e) {
                var i = new db(e,!0);
                this._mapDraw = i,
                this.group.add(i.group)
            },
            render: function(t, e, i, n) {
                if (!n || "geoToggleSelect" !== n.type || n.from !== this.uid) {
                    var a = this._mapDraw;
                    t.get("show") ? a.draw(t, e, i, this, n) : this._mapDraw.group.removeAll(),
                    this.group.silent = t.get("silent")
                }
            },
            dispose: function() {
                this._mapDraw && this._mapDraw.remove()
            }
        });
        function $P(a, t) {
            t.update = "updateView",
            Gm.registerAction(t, function(i, t) {
                var n = {};
                return t.eachComponent({
                    mainType: "geo",
                    query: i
                }, function(e) {
                    e[a](i.name);
                    var t = e.coordinateSystem;
                    it.each(t.regions, function(t) {
                        n[t.name] = e.isSelected(t.name) || !1
                    })
                }),
                {
                    selected: n,
                    name: i.name
                }
            })
        }
        $P("toggleSelected", {
            type: "geoToggleSelect",
            event: "geoselectchanged"
        }),
        $P("select", {
            type: "geoSelect",
            event: "geoselected"
        }),
        $P("unSelect", {
            type: "geoUnSelect",
            event: "geounselected"
        });
        var JP = ["rect", "polygon", "keep", "clear"];
        function QP(t, e) {
            var i = t && t.brush;
            if (it.isArray(i) || (i = i ? [i] : []),
            i.length) {
                var n = [];
                it.each(i, function(t) {
                    var e = t.hasOwnProperty("toolbox") ? t.toolbox : [];
                    e instanceof Array && (n = n.concat(e))
                });
                var a = t && t.toolbox;
                it.isArray(a) && (a = a[0]),
                a || (a = {
                    feature: {}
                },
                t.toolbox = [a]);
                var r = a.feature || (a.feature = {})
                  , o = r.brush || (r.brush = {})
                  , s = o.type || (o.type = []);
                s.push.apply(s, n),
                function(i) {
                    var e = {};
                    it.each(i, function(t) {
                        e[t] = 1
                    }),
                    i.length = 0,
                    it.each(e, function(t, e) {
                        i.push(e)
                    })
                }(s),
                e && !s.length && s.push.apply(s, JP)
            }
        }
        var tk = it.each;
        function ek(t) {
            if (t)
                for (var e in t)
                    if (t.hasOwnProperty(e))
                        return !0
        }
        var ik = {
            createVisualMappings: function(t, e, r) {
                var i = {};
                return tk(e, function(n) {
                    var a = i[n] = function() {
                        function t() {}
                        return t.prototype.__hidden = t.prototype,
                        new t
                    }();
                    tk(t[n], function(t, e) {
                        if (lS.isValidType(e)) {
                            var i = {
                                type: e,
                                visual: t
                            };
                            r && r(i, n),
                            a[e] = new lS(i),
                            "opacity" === e && ((i = it.clone(i)).type = "colorAlpha",
                            a.__hidden.__alphaForOpacity = new lS(i))
                        }
                    })
                }),
                i
            },
            replaceVisualOption: function(e, i, t) {
                var n;
                it.each(t, function(t) {
                    i.hasOwnProperty(t) && ek(i[t]) && (n = !0)
                }),
                n && it.each(t, function(t) {
                    i.hasOwnProperty(t) && ek(i[t]) ? e[t] = it.clone(i[t]) : delete e[t]
                })
            },
            applyVisual: function(t, u, h, c, d, p) {
                var f, g = {};
                function m(t) {
                    return h.getItemVisual(f, t)
                }
                function v(t, e) {
                    h.setItemVisual(f, t, e)
                }
                function e(t, e) {
                    f = null == p ? t : e;
                    var i = h.getRawDataItem(f);
                    if (!i || !1 !== i.visualMap)
                        for (var n = c.call(d, t), a = u[n], r = g[n], o = 0, s = r.length; o < s; o++) {
                            var l = r[o];
                            a[l] && a[l].applyVisual(t, m, v)
                        }
                }
                it.each(t, function(t) {
                    var e = lS.prepareVisualTypes(u[t]);
                    g[t] = e
                }),
                null == p ? h.each(e) : h.each([p], e)
            },
            incrementalApplyVisual: function(t, p, f, g) {
                var m = {};
                return it.each(t, function(t) {
                    var e = lS.prepareVisualTypes(p[t]);
                    m[t] = e
                }),
                {
                    progress: function(t, i) {
                        function e(t) {
                            return i.getItemVisual(a, t)
                        }
                        function n(t, e) {
                            i.setItemVisual(a, t, e)
                        }
                        var a;
                        for (null != g && (g = i.getDimension(g)); null != (a = t.next()); ) {
                            var r = i.getRawDataItem(a);
                            if (!r || !1 !== r.visualMap)
                                for (var o = null != g ? i.get(g, a, !0) : a, s = f(o), l = p[s], u = m[s], h = 0, c = u.length; h < c; h++) {
                                    var d = u[h];
                                    l[d] && l[d].applyVisual(o, e, n)
                                }
                        }
                    }
                }
            }
        };
        function nk(r) {
            var o = ["x", "y"]
              , s = ["width", "height"];
            return {
                point: function(t, e, i) {
                    if (t) {
                        var n = i.range;
                        return ak(t[r], n)
                    }
                },
                rect: function(t, e, i) {
                    if (t) {
                        var n = i.range
                          , a = [t[o[r]], t[o[r]] + t[s[r]]];
                        return a[1] < a[0] && a.reverse(),
                        ak(a[0], n) || ak(a[1], n) || ak(n[0], a) || ak(n[1], a)
                    }
                }
            }
        }
        function ak(t, e) {
            return e[0] <= t && t <= e[1]
        }
        function rk(t, e, i, n, a) {
            for (var r = 0, o = a[a.length - 1]; r < a.length; r++) {
                var s = a[r];
                if (ok(t, e, i, n, s[0], s[1], o[0], o[1]))
                    return !0;
                o = s
            }
        }
        function ok(t, e, i, n, a, r, o, s) {
            var l = sk(i - t, a - o, n - e, r - s);
            if (function(t) {
                return t <= 1e-6 && -1e-6 <= t
            }(l))
                return !1;
            var u = sk(a - t, a - o, r - e, r - s) / l;
            if (u < 0 || 1 < u)
                return !1;
            var h = sk(i - t, a - t, n - e, r - e) / l;
            return !(h < 0 || 1 < h)
        }
        function sk(t, e, i, n) {
            return t * n - e * i
        }
        var lk = {
            lineX: nk(0),
            lineY: nk(1),
            rect: {
                point: function(t, e, i) {
                    return t && i.boundingRect.contain(t[0], t[1])
                },
                rect: function(t, e, i) {
                    return t && i.boundingRect.intersect(t)
                }
            },
            polygon: {
                point: function(t, e, i) {
                    return t && i.boundingRect.contain(t[0], t[1]) && qg.contain(i.range, t[0], t[1])
                },
                rect: function(t, e, i) {
                    var n = i.range;
                    if (!t || n.length <= 1)
                        return !1;
                    var a = t.x
                      , r = t.y
                      , o = t.width
                      , s = t.height
                      , l = n[0];
                    return !!(qg.contain(n, a, r) || qg.contain(n, a + o, r) || qg.contain(n, a, r + s) || qg.contain(n, a + o, r + s) || Oe.create(t).contain(l[0], l[1]) || rk(a, r, a + o, r, n) || rk(a, r, a, r + s, n) || rk(a + o, r, a + o, r + s, n) || rk(a, r + s, a + o, r + s, n)) || void 0
                }
            }
        }
          , uk = it.each
          , hk = it.indexOf
          , ck = it.curry
          , dk = ["dataToPoint", "pointToData"]
          , pk = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"];
        function fk(t, e, i) {
            var n = this._targetInfoList = []
              , a = {}
              , r = vk(e, t);
            uk(yk, function(t, e) {
                i && i.include && !(0 <= hk(i.include, e)) || t(r, n, a)
            })
        }
        var gk = fk.prototype;
        function mk(t) {
            return t[0] > t[1] && t.reverse(),
            t
        }
        function vk(t, e) {
            return aa.parseFinder(t, e, {
                includeMainTypes: pk
            })
        }
        gk.setOutputRanges = function(t, e) {
            this.matchOutputRanges(t, e, function(t, e, i) {
                if ((t.coordRanges || (t.coordRanges = [])).push(e),
                !t.coordRange) {
                    t.coordRange = e;
                    var n = bk[t.brushType](0, i, e);
                    t.__rangeOffset = {
                        offset: Sk[t.brushType](n.values, t.range, [1, 1]),
                        xyMinMax: n.xyMinMax
                    }
                }
            })
        }
        ,
        gk.matchOutputRanges = function(t, n, a) {
            uk(t, function(i) {
                var t = this.findTargetInfo(i, n);
                t && !0 !== t && it.each(t.coordSyses, function(t) {
                    var e = bk[i.brushType](1, t, i.range);
                    a(i, e.values, t, n)
                })
            }, this)
        }
        ,
        gk.setInputRanges = function(t, a) {
            uk(t, function(t) {
                var e = this.findTargetInfo(t, a);
                if (t.range = t.range || [],
                e && !0 !== e) {
                    t.panelId = e.panelId;
                    var i = bk[t.brushType](0, e.coordSys, t.coordRange)
                      , n = t.__rangeOffset;
                    t.range = n ? Sk[t.brushType](i.values, n.offset, function(t, e) {
                        var i = Ik(t)
                          , n = Ik(e)
                          , a = [i[0] / n[0], i[1] / n[1]];
                        return isNaN(a[0]) && (a[0] = 1),
                        isNaN(a[1]) && (a[1] = 1),
                        a
                    }(i.xyMinMax, n.xyMinMax)) : i.values
                }
            }, this)
        }
        ,
        gk.makePanelOpts = function(i, n) {
            return it.map(this._targetInfoList, function(t) {
                var e = t.getPanelRect();
                return {
                    panelId: t.panelId,
                    defaultBrushType: n && n(t),
                    clipPath: vA.makeRectPanelClipPath(e),
                    isTargetByCursor: vA.makeRectIsTargetByCursor(e, i, t.coordSysModel),
                    getLinearBrushOtherExtent: vA.makeLinearBrushOtherExtent(e)
                }
            })
        }
        ,
        gk.controlSeries = function(t, e, i) {
            var n = this.findTargetInfo(t, i);
            return !0 === n || n && 0 <= hk(n.coordSyses, e.coordinateSystem)
        }
        ,
        gk.findTargetInfo = function(t, e) {
            for (var i = this._targetInfoList, n = vk(e, t), a = 0; a < i.length; a++) {
                var r = i[a]
                  , o = t.panelId;
                if (o) {
                    if (r.panelId === o)
                        return r
                } else
                    for (a = 0; a < xk.length; a++)
                        if (xk[a](n, r))
                            return r
            }
            return !0
        }
        ;
        var yk = {
            grid: function(t, n) {
                var a = t.xAxisModels
                  , r = t.yAxisModels
                  , e = t.gridModels
                  , i = it.createHashMap()
                  , o = {}
                  , s = {};
                (a || r || e) && (uk(a, function(t) {
                    var e = t.axis.grid.model;
                    i.set(e.id, e),
                    o[e.id] = !0
                }),
                uk(r, function(t) {
                    var e = t.axis.grid.model;
                    i.set(e.id, e),
                    s[e.id] = !0
                }),
                uk(e, function(t) {
                    i.set(t.id, t),
                    o[t.id] = !0,
                    s[t.id] = !0
                }),
                i.each(function(t) {
                    var e = t.coordinateSystem
                      , i = [];
                    uk(e.getCartesians(), function(t, e) {
                        (0 <= hk(a, t.getAxis("x").model) || 0 <= hk(r, t.getAxis("y").model)) && i.push(t)
                    }),
                    n.push({
                        panelId: "grid--" + t.id,
                        gridModel: t,
                        coordSysModel: t,
                        coordSys: i[0],
                        coordSyses: i,
                        getPanelRect: _k.grid,
                        xAxisDeclared: o[t.id],
                        yAxisDeclared: s[t.id]
                    })
                }))
            },
            geo: function(t, i) {
                uk(t.geoModels, function(t) {
                    var e = t.coordinateSystem;
                    i.push({
                        panelId: "geo--" + t.id,
                        geoModel: t,
                        coordSysModel: t,
                        coordSys: e,
                        coordSyses: [e],
                        getPanelRect: _k.geo
                    })
                })
            }
        }
          , xk = [function(t, e) {
            var i = t.xAxisModel
              , n = t.yAxisModel
              , a = t.gridModel;
            return !a && i && (a = i.axis.grid.model),
            !a && n && (a = n.axis.grid.model),
            a && a === e.gridModel
        }
        , function(t, e) {
            var i = t.geoModel;
            return i && i === e.geoModel
        }
        ]
          , _k = {
            grid: function() {
                return this.coordSys.grid.getRect().clone()
            },
            geo: function() {
                var t = this.coordSys
                  , e = t.getBoundingRect().clone();
                return e.applyTransform(Fs.getTransform(t)),
                e
            }
        }
          , bk = {
            lineX: ck(wk, 0),
            lineY: ck(wk, 1),
            rect: function(t, e, i) {
                var n = e[dk[t]]([i[0][0], i[1][0]])
                  , a = e[dk[t]]([i[0][1], i[1][1]])
                  , r = [mk([n[0], a[0]]), mk([n[1], a[1]])];
                return {
                    values: r,
                    xyMinMax: r
                }
            },
            polygon: function(i, n, t) {
                var a = [[1 / 0, -1 / 0], [1 / 0, -1 / 0]];
                return {
                    values: it.map(t, function(t) {
                        var e = n[dk[i]](t);
                        return a[0][0] = Math.min(a[0][0], e[0]),
                        a[1][0] = Math.min(a[1][0], e[1]),
                        a[0][1] = Math.max(a[0][1], e[0]),
                        a[1][1] = Math.max(a[1][1], e[1]),
                        e
                    }),
                    xyMinMax: a
                }
            }
        };
        function wk(t, e, i, n) {
            var a = i.getAxis(["x", "y"][t])
              , r = mk(it.map([0, 1], function(t) {
                return e ? a.coordToData(a.toLocalCoord(n[t])) : a.toGlobalCoord(a.dataToCoord(n[t]))
            }))
              , o = [];
            return o[t] = r,
            o[1 - t] = [NaN, NaN],
            {
                values: r,
                xyMinMax: o
            }
        }
        var Sk = {
            lineX: ck(Mk, 0),
            lineY: ck(Mk, 1),
            rect: function(t, e, i) {
                return [[t[0][0] - i[0] * e[0][0], t[0][1] - i[0] * e[0][1]], [t[1][0] - i[1] * e[1][0], t[1][1] - i[1] * e[1][1]]]
            },
            polygon: function(t, i, n) {
                return it.map(t, function(t, e) {
                    return [t[0] - n[0] * i[e][0], t[1] - n[1] * i[e][1]]
                })
            }
        };
        function Mk(t, e, i, n) {
            return [e[0] - n[t] * i[0], e[1] - n[t] * i[1]]
        }
        function Ik(t) {
            return t ? [t[0][1] - t[0][0], t[1][1] - t[1][0]] : [NaN, NaN]
        }
        var Ak = fk
          , Tk = ["inBrush", "outOfBrush"]
          , Ck = "__ecBrushSelect"
          , Dk = "__ecInBrushSelectEvent"
          , Lk = Gm.PRIORITY.VISUAL.BRUSH;
        function Pk(t, e) {
            if (!t.isDisposed()) {
                var i = t.getZr();
                i[Dk] = !0,
                t.dispatchAction({
                    type: "brushSelect",
                    batch: e
                }),
                i[Dk] = !1
            }
        }
        function kk(t, e, i, n) {
            for (var a = 0, r = e.length; a < r; a++) {
                var o = e[a];
                if (t[o.brushType](n, i, o.selectors, o))
                    return !0
            }
        }
        function Ok(t) {
            var o = t.brushSelector;
            if (it.isString(o)) {
                var e = [];
                return it.each(lk, function(r, t) {
                    e[t] = function(t, e, i, n) {
                        var a = e.getItemLayout(t);
                        return r[o](a, i, n)
                    }
                }),
                e
            }
            if (it.isFunction(o)) {
                var i = {};
                return it.each(lk, function(t, e) {
                    i[e] = o
                }),
                i
            }
            return o
        }
        Gm.registerLayout(Lk, function(e, t, i) {
            e.eachComponent({
                mainType: "brush"
            }, function(t) {
                i && "takeGlobalCursor" === i.type && t.setBrushOption("brush" === i.key ? i.brushOption : {
                    brushType: !1
                }),
                (t.brushTargetManager = new Ak(t.option,e)).setInputRanges(t.areas, e)
            })
        }),
        Gm.registerVisual(Lk, function(f, t, e) {
            var a, g, m = [];
            f.eachComponent({
                mainType: "brush"
            }, function(r, t) {
                var s = {
                    brushId: r.id,
                    brushIndex: t,
                    brushName: r.name,
                    areas: it.clone(r.areas),
                    selected: []
                };
                m.push(s);
                var e = r.option
                  , i = e.brushLink
                  , n = []
                  , l = []
                  , u = []
                  , h = 0;
                t || (a = e.throttleType,
                g = e.throttleDelay);
                var o = it.map(r.areas, function(t) {
                    return function(i) {
                        var n = i.selectors = {};
                        return it.each(lk[i.brushType], function(e, t) {
                            n[t] = function(t) {
                                return e(t, n, i)
                            }
                        }),
                        i
                    }(it.defaults({
                        boundingRect: Rk[t.brushType](t)
                    }, t))
                })
                  , c = ik.createVisualMappings(r.option, Tk, function(t) {
                    t.mappingMethod = "fixed"
                });
                function d(t) {
                    return "all" === i || n[t]
                }
                function p(t) {
                    return !!t.length
                }
                it.isArray(i) && it.each(i, function(t) {
                    n[t] = 1
                }),
                f.eachSeries(function(t, e) {
                    var i = u[e] = [];
                    "parallel" === t.subType ? function(t, e) {
                        var i = t.coordinateSystem;
                        h |= i.hasAxisBrushed(),
                        d(e) && i.eachActiveState(t.getData(), function(t, e) {
                            "active" === t && (l[e] = 1)
                        })
                    }(t, e) : function(e, t, i) {
                        var n = Ok(e);
                        if (!n || function(t, e) {
                            var i = t.option.seriesIndex;
                            return null != i && "all" !== i && (it.isArray(i) ? it.indexOf(i, e) < 0 : e !== i)
                        }(r, t))
                            return;
                        if (it.each(o, function(t) {
                            n[t.brushType] && r.brushTargetManager.controlSeries(t, e, f) && i.push(t),
                            h |= p(i)
                        }),
                        d(t) && p(i)) {
                            var a = e.getData();
                            a.each(function(t) {
                                kk(n, i, a, t) && (l[t] = 1)
                            })
                        }
                    }(t, e, i)
                }),
                f.eachSeries(function(t, e) {
                    var i = {
                        seriesId: t.id,
                        seriesIndex: e,
                        seriesName: t.name,
                        dataIndex: []
                    };
                    s.selected.push(i);
                    var n = Ok(t)
                      , a = u[e]
                      , r = t.getData()
                      , o = d(e) ? function(t) {
                        return l[t] ? (i.dataIndex.push(r.getRawIndex(t)),
                        "inBrush") : "outOfBrush"
                    }
                    : function(t) {
                        return kk(n, a, r, t) ? (i.dataIndex.push(r.getRawIndex(t)),
                        "inBrush") : "outOfBrush"
                    }
                    ;
                    (d(e) ? h : p(a)) && ik.applyVisual(Tk, c, r, o)
                })
            }),
            function(t, e, i, n, a) {
                if (!a)
                    return;
                var r = t.getZr();
                if (r[Dk])
                    return;
                r[Ck] || (r[Ck] = Pk);
                Qc.createOrUpdate(r, Ck, i, e)(t, n)
            }(t, a, g, m, e)
        });
        var Rk = {
            lineX: it.noop,
            lineY: it.noop,
            rect: function(t) {
                return Nk(t.range)
            },
            polygon: function(t) {
                for (var e, i = t.range, n = 0, a = i.length; n < a; n++) {
                    e = e || [[1 / 0, -1 / 0], [1 / 0, -1 / 0]];
                    var r = i[n];
                    r[0] < e[0][0] && (e[0][0] = r[0]),
                    r[0] > e[0][1] && (e[0][1] = r[0]),
                    r[1] < e[1][0] && (e[1][0] = r[1]),
                    r[1] > e[1][1] && (e[1][1] = r[1])
                }
                return e && Nk(e)
            }
        };
        function Nk(t) {
            return new Oe(t[0][0],t[1][0],t[0][1] - t[0][0],t[1][1] - t[1][0])
        }
        var Ek = ["#ddd"];
        Gm.extendComponentModel({
            type: "brush",
            dependencies: ["geo", "grid", "xAxis", "yAxis", "parallel", "series"],
            defaultOption: {
                toolbox: null,
                brushLink: null,
                seriesIndex: "all",
                geoIndex: null,
                xAxisIndex: null,
                yAxisIndex: null,
                brushType: "rect",
                brushMode: "single",
                transformable: !0,
                brushStyle: {
                    borderWidth: 1,
                    color: "rgba(120,140,180,0.3)",
                    borderColor: "rgba(120,140,180,0.8)"
                },
                throttleType: "fixRate",
                throttleDelay: 0,
                removeOnClick: !0,
                z: 1e4
            },
            areas: [],
            brushType: null,
            brushOption: {},
            coordInfoList: [],
            optionUpdated: function(t, e) {
                var i = this.option;
                e || ik.replaceVisualOption(i, t, ["inBrush", "outOfBrush"]);
                var n = i.inBrush = i.inBrush || {};
                i.outOfBrush = i.outOfBrush || {
                    color: Ek
                },
                n.hasOwnProperty("liftZ") || (n.liftZ = 5)
            },
            setAreas: function(t) {
                t && (this.areas = it.map(t, function(t) {
                    return zk(this.option, t)
                }, this))
            },
            setBrushOption: function(t) {
                this.brushOption = zk(this.option, t),
                this.brushType = this.brushOption.brushType
            }
        });
        function zk(t, e) {
            return it.merge({
                brushType: t.brushType,
                brushMode: t.brushMode,
                transformable: t.transformable,
                brushStyle: new tl(t.brushStyle).getItemStyle(),
                removeOnClick: t.removeOnClick,
                z: t.z
            }, e, !0)
        }
        Gm.extendComponentView({
            type: "brush",
            init: function(t, e) {
                this.ecModel = t,
                this.api = e,
                this.model,
                (this._brushController = new fA(e.getZr())).on("brush", it.bind(this._onBrush, this)).mount()
            },
            render: function(t) {
                return this.model = t,
                Vk.apply(this, arguments)
            },
            updateTransform: Vk,
            updateView: Vk,
            dispose: function() {
                this._brushController.dispose()
            },
            _onBrush: function(t, e) {
                var i = this.model.id;
                this.model.brushTargetManager.setOutputRanges(t, this.ecModel),
                e.isEnd && !e.removeOnClick || this.api.dispatchAction({
                    type: "brush",
                    brushId: i,
                    areas: it.clone(t),
                    $from: i
                })
            }
        });
        function Vk(t, e, i, n) {
            n && n.$from === t.id || this._brushController.setPanels(t.brushTargetManager.makePanelOpts(i)).enableBrush(t.brushOption).updateCovers(t.areas.slice())
        }
        Gm.registerAction({
            type: "brush",
            event: "brush"
        }, function(e, t) {
            t.eachComponent({
                mainType: "brush",
                query: e
            }, function(t) {
                t.setAreas(e.areas)
            })
        }),
        Gm.registerAction({
            type: "brushSelect",
            event: "brushSelected",
            update: "none"
        }, function() {});
        var Bk = {};
        var Gk = {
            register: function(t, e) {
                Bk[t] = e
            },
            get: function(t) {
                return Bk[t]
            }
        }
          , Fk = ed.toolbox.brush;
        function Hk(t, e, i) {
            this.model = t,
            this.ecModel = e,
            this.api = i,
            this._brushType,
            this._brushMode
        }
        Hk.defaultOption = {
            show: !0,
            type: ["rect", "polygon", "lineX", "lineY", "keep", "clear"],
            icon: {
                rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
                polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
                lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
                lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
                keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
                clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
            },
            title: it.clone(Fk.title)
        };
        var Wk = Hk.prototype;
        Wk.render = Wk.updateView = function(e, t, i) {
            var n, a, r;
            t.eachComponent({
                mainType: "brush"
            }, function(t) {
                n = t.brushType,
                a = t.brushOption.brushMode || "single",
                r |= t.areas.length
            }),
            this._brushType = n,
            this._brushMode = a,
            it.each(e.get("type", !0), function(t) {
                e.setIconStatus(t, ("keep" === t ? "multiple" === a : "clear" === t ? r : t === n) ? "emphasis" : "normal")
            })
        }
        ,
        Wk.getIcons = function() {
            var t = this.model
              , e = t.get("icon", !0)
              , i = {};
            return it.each(t.get("type", !0), function(t) {
                e[t] && (i[t] = e[t])
            }),
            i
        }
        ,
        Wk.onclick = function(t, e, i) {
            var n = this._brushType
              , a = this._brushMode;
            "clear" === i ? (e.dispatchAction({
                type: "axisAreaSelect",
                intervals: []
            }),
            e.dispatchAction({
                type: "brush",
                command: "clear",
                areas: []
            })) : e.dispatchAction({
                type: "takeGlobalCursor",
                key: "brush",
                brushOption: {
                    brushType: "keep" === i ? n : n !== i && i,
                    brushMode: "keep" === i ? "multiple" === a ? "single" : "multiple" : a
                }
            })
        }
        ,
        Gk.register("brush", Hk),
        Gm.registerPreprocessor(QP);
        function Zk(t, e, i) {
            this._model = t
        }
        function Uk(t, e, i, n) {
            var a = i.calendarModel
              , r = i.seriesModel
              , o = a ? a.coordinateSystem : r ? r.coordinateSystem : null;
            return o === this ? o[t](n) : null
        }
        Zk.prototype = {
            constructor: Zk,
            type: "calendar",
            dimensions: ["time", "value"],
            getDimensionsInfo: function() {
                return [{
                    name: "time",
                    type: "time"
                }, "value"]
            },
            getRangeInfo: function() {
                return this._rangeInfo
            },
            getModel: function() {
                return this._model
            },
            getRect: function() {
                return this._rect
            },
            getCellWidth: function() {
                return this._sw
            },
            getCellHeight: function() {
                return this._sh
            },
            getOrient: function() {
                return this._orient
            },
            getFirstDayOfWeek: function() {
                return this._firstDayOfWeek
            },
            getDateInfo: function(t) {
                var e = (t = ol.parseDate(t)).getFullYear()
                  , i = t.getMonth() + 1;
                i = i < 10 ? "0" + i : i;
                var n = t.getDate();
                n = n < 10 ? "0" + n : n;
                var a = t.getDay();
                return {
                    y: e,
                    m: i,
                    d: n,
                    day: a = Math.abs((a + 7 - this.getFirstDayOfWeek()) % 7),
                    time: t.getTime(),
                    formatedDate: e + "-" + i + "-" + n,
                    date: t
                }
            },
            getNextNDay: function(t, e) {
                return 0 === (e = e || 0) || (t = new Date(this.getDateInfo(t).time)).setDate(t.getDate() + e),
                this.getDateInfo(t)
            },
            update: function(t, e) {
                this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"),
                this._orient = this._model.get("orient"),
                this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0,
                this._rangeInfo = this._getRangeInfo(this._initRangeOption());
                var i = this._rangeInfo.weeks || 1
                  , n = ["width", "height"]
                  , a = this._model.get("cellSize").slice()
                  , r = this._model.getBoxLayoutParams()
                  , o = "horizontal" === this._orient ? [i, 7] : [7, i];
                it.each([0, 1], function(t) {
                    u(a, t) && (r[n[t]] = a[t] * o[t])
                });
                var s = {
                    width: e.getWidth(),
                    height: e.getHeight()
                }
                  , l = this._rect = Il.getLayoutRect(r, s);
                function u(t, e) {
                    return null != t[e] && "auto" !== t[e]
                }
                it.each([0, 1], function(t) {
                    u(a, t) || (a[t] = l[n[t]] / o[t])
                }),
                this._sw = a[0],
                this._sh = a[1]
            },
            dataToPoint: function(t, e) {
                it.isArray(t) && (t = t[0]),
                null == e && (e = !0);
                var i = this.getDateInfo(t)
                  , n = this._rangeInfo
                  , a = i.formatedDate;
                if (e && !(i.time >= n.start.time && i.time < n.end.time + 864e5))
                    return [NaN, NaN];
                var r = i.day
                  , o = this._getRangeInfo([n.start.time, a]).nthWeek;
                return "vertical" === this._orient ? [this._rect.x + r * this._sw + this._sw / 2, this._rect.y + o * this._sh + this._sh / 2] : [this._rect.x + o * this._sw + this._sw / 2, this._rect.y + r * this._sh + this._sh / 2]
            },
            pointToData: function(t) {
                var e = this.pointToDate(t);
                return e && e.time
            },
            dataToRect: function(t, e) {
                var i = this.dataToPoint(t, e);
                return {
                    contentShape: {
                        x: i[0] - (this._sw - this._lineWidth) / 2,
                        y: i[1] - (this._sh - this._lineWidth) / 2,
                        width: this._sw - this._lineWidth,
                        height: this._sh - this._lineWidth
                    },
                    center: i,
                    tl: [i[0] - this._sw / 2, i[1] - this._sh / 2],
                    tr: [i[0] + this._sw / 2, i[1] - this._sh / 2],
                    br: [i[0] + this._sw / 2, i[1] + this._sh / 2],
                    bl: [i[0] - this._sw / 2, i[1] + this._sh / 2]
                }
            },
            pointToDate: function(t) {
                var e = Math.floor((t[0] - this._rect.x) / this._sw) + 1
                  , i = Math.floor((t[1] - this._rect.y) / this._sh) + 1
                  , n = this._rangeInfo.range;
                return "vertical" === this._orient ? this._getDateByWeeksAndDay(i, e - 1, n) : this._getDateByWeeksAndDay(e, i - 1, n)
            },
            convertToPixel: it.curry(Uk, "dataToPoint"),
            convertFromPixel: it.curry(Uk, "pointToData"),
            _initRangeOption: function() {
                var t = this._model.get("range")
                  , e = t;
                if (it.isArray(e) && 1 === e.length && (e = e[0]),
                /^\d{4}$/.test(e) && (t = [e + "-01-01", e + "-12-31"]),
                /^\d{4}[\/|-]\d{1,2}$/.test(e)) {
                    var i = this.getDateInfo(e)
                      , n = i.date;
                    n.setMonth(n.getMonth() + 1);
                    var a = this.getNextNDay(n, -1);
                    t = [i.formatedDate, a.formatedDate]
                }
                /^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(e) && (t = [e, e]);
                var r = this._getRangeInfo(t);
                return r.start.time > r.end.time && t.reverse(),
                t
            },
            _getRangeInfo: function(t) {
                var e;
                (t = [this.getDateInfo(t[0]), this.getDateInfo(t[1])])[0].time > t[1].time && (e = !0,
                t.reverse());
                var i = Math.floor(t[1].time / 864e5) - Math.floor(t[0].time / 864e5) + 1
                  , n = new Date(t[0].time)
                  , a = n.getDate()
                  , r = t[1].date.getDate();
                if (n.setDate(a + i - 1),
                n.getDate() !== r)
                    for (var o = 0 < n.getTime() - t[1].time ? 1 : -1; n.getDate() !== r && 0 < (n.getTime() - t[1].time) * o; )
                        i -= o,
                        n.setDate(a + i - 1);
                var s = Math.floor((i + t[0].day + 6) / 7)
                  , l = e ? 1 - s : s - 1;
                return e && t.reverse(),
                {
                    range: [t[0].formatedDate, t[1].formatedDate],
                    start: t[0],
                    end: t[1],
                    allDay: i,
                    weeks: s,
                    nthWeek: l,
                    fweek: t[0].day,
                    lweek: t[1].day
                }
            },
            _getDateByWeeksAndDay: function(t, e, i) {
                var n = this._getRangeInfo(i);
                if (t > n.weeks || 0 === t && e < n.fweek || t === n.weeks && e > n.lweek)
                    return !1;
                var a = 7 * (t - 1) - n.fweek + e
                  , r = new Date(n.start.time);
                return r.setDate(n.start.d + a),
                this.getDateInfo(r)
            }
        },
        Zk.dimensions = Zk.prototype.dimensions,
        Zk.getDimensionsInfo = Zk.prototype.getDimensionsInfo,
        Zk.create = function(i, n) {
            var a = [];
            return i.eachComponent("calendar", function(t) {
                var e = new Zk(t,i,n);
                a.push(e),
                t.coordinateSystem = e
            }),
            i.eachSeries(function(t) {
                "calendar" === t.get("coordinateSystem") && (t.coordinateSystem = a[t.get("calendarIndex") || 0])
            }),
            a
        }
        ,
        ju.register("calendar", Zk);
        var Yk = Il.getLayoutParams
          , jk = Il.sizeCalculable
          , Xk = Il.mergeLayoutParam
          , qk = Pl.extend({
            type: "calendar",
            coordinateSystem: null,
            defaultOption: {
                zlevel: 0,
                z: 2,
                left: 80,
                top: 60,
                cellSize: 20,
                orient: "horizontal",
                splitLine: {
                    show: !0,
                    lineStyle: {
                        color: "#000",
                        width: 1,
                        type: "solid"
                    }
                },
                itemStyle: {
                    color: "#fff",
                    borderWidth: 1,
                    borderColor: "#ccc"
                },
                dayLabel: {
                    show: !0,
                    firstDay: 0,
                    position: "start",
                    margin: "50%",
                    nameMap: "en",
                    color: "#000"
                },
                monthLabel: {
                    show: !0,
                    position: "start",
                    margin: 5,
                    align: "center",
                    nameMap: "en",
                    formatter: null,
                    color: "#000"
                },
                yearLabel: {
                    show: !0,
                    position: null,
                    margin: 30,
                    formatter: null,
                    color: "#ccc",
                    fontFamily: "sans-serif",
                    fontWeight: "bolder",
                    fontSize: 20
                }
            },
            init: function(t, e, i, n) {
                var a = Yk(t);
                qk.superApply(this, "init", arguments),
                Kk(t, a)
            },
            mergeOption: function(t, e) {
                qk.superApply(this, "mergeOption", arguments),
                Kk(this.option, t)
            }
        });
        function Kk(t, e) {
            var i = t.cellSize;
            it.isArray(i) ? 1 === i.length && (i[1] = i[0]) : i = t.cellSize = [i, i];
            var n = it.map([0, 1], function(t) {
                return jk(e, t) && (i[t] = "auto"),
                null != i[t] && "auto" !== i[t]
            });
            Xk(t, e, {
                type: "box",
                ignoreSize: n
            })
        }
        var $k = {
            EN: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
            CN: ["", "", "", "", "", "", "", "", "", "", "", ""]
        }
          , Jk = {
            EN: ["S", "M", "T", "W", "T", "F", "S"],
            CN: ["", "", "", "", "", "", ""]
        }
          , Qk = (Gm.extendComponentView({
            type: "calendar",
            _tlpoints: null,
            _blpoints: null,
            _firstDayOfMonth: null,
            _firstDayPoints: null,
            render: function(t, e, i) {
                var n = this.group;
                n.removeAll();
                var a = t.coordinateSystem
                  , r = a.getRangeInfo()
                  , o = a.getOrient();
                this._renderDayRect(t, r, n),
                this._renderLines(t, r, o, n),
                this._renderYearText(t, r, o, n),
                this._renderMonthText(t, o, n),
                this._renderWeekText(t, r, o, n)
            },
            _renderDayRect: function(t, e, i) {
                for (var n = t.coordinateSystem, a = t.getModel("itemStyle").getItemStyle(), r = n.getCellWidth(), o = n.getCellHeight(), s = e.start.time; s <= e.end.time; s = n.getNextNDay(s, 1).time) {
                    var l = n.dataToRect([s], !1).tl
                      , u = new Fs.Rect({
                        shape: {
                            x: l[0],
                            y: l[1],
                            width: r,
                            height: o
                        },
                        cursor: "default",
                        style: a
                    });
                    i.add(u)
                }
            },
            _renderLines: function(i, t, n, a) {
                var r = this
                  , o = i.coordinateSystem
                  , s = i.getModel("splitLine.lineStyle").getLineStyle()
                  , l = i.get("splitLine.show")
                  , e = s.lineWidth;
                this._tlpoints = [],
                this._blpoints = [],
                this._firstDayOfMonth = [],
                this._firstDayPoints = [];
                for (var u = t.start, h = 0; u.time <= t.end.time; h++) {
                    d(u.formatedDate),
                    0 === h && (u = o.getDateInfo(t.start.y + "-" + t.start.m));
                    var c = u.date;
                    c.setMonth(c.getMonth() + 1),
                    u = o.getDateInfo(c)
                }
                function d(t) {
                    r._firstDayOfMonth.push(o.getDateInfo(t)),
                    r._firstDayPoints.push(o.dataToRect([t], !1).tl);
                    var e = r._getLinePointsOfOneWeek(i, t, n);
                    r._tlpoints.push(e[0]),
                    r._blpoints.push(e[e.length - 1]),
                    l && r._drawSplitline(e, s, a)
                }
                d(o.getNextNDay(t.end.time, 1).formatedDate),
                l && this._drawSplitline(r._getEdgesPoints(r._tlpoints, e, n), s, a),
                l && this._drawSplitline(r._getEdgesPoints(r._blpoints, e, n), s, a)
            },
            _getEdgesPoints: function(t, e, i) {
                var n = [t[0].slice(), t[t.length - 1].slice()]
                  , a = "horizontal" === i ? 0 : 1;
                return n[0][a] = n[0][a] - e / 2,
                n[1][a] = n[1][a] + e / 2,
                n
            },
            _drawSplitline: function(t, e, i) {
                var n = new Fs.Polyline({
                    z2: 20,
                    shape: {
                        points: t
                    },
                    style: e
                });
                i.add(n)
            },
            _getLinePointsOfOneWeek: function(t, e, i) {
                var n = t.coordinateSystem;
                e = n.getDateInfo(e);
                for (var a = [], r = 0; r < 7; r++) {
                    var o = n.getNextNDay(e.time, r)
                      , s = n.dataToRect([o.time], !1);
                    a[2 * o.day] = s.tl,
                    a[2 * o.day + 1] = s["horizontal" === i ? "bl" : "tr"]
                }
                return a
            },
            _formatterLabel: function(t, e) {
                return "string" == typeof t && t ? fl.formatTplSimple(t, e) : "function" == typeof t ? t(e) : e.nameMap
            },
            _yearTextPositionControl: function(t, e, i, n, a) {
                e = e.slice();
                var r = ["center", "bottom"];
                "bottom" === n ? (e[1] += a,
                r = ["center", "top"]) : "left" === n ? e[0] -= a : "right" === n ? (e[0] += a,
                r = ["center", "top"]) : e[1] -= a;
                var o = 0;
                return "left" !== n && "right" !== n || (o = Math.PI / 2),
                {
                    rotation: o,
                    position: e,
                    style: {
                        textAlign: r[0],
                        textVerticalAlign: r[1]
                    }
                }
            },
            _renderYearText: function(t, e, i, n) {
                var a = t.getModel("yearLabel");
                if (a.get("show")) {
                    var r = a.get("margin")
                      , o = a.get("position");
                    o = o || ("horizontal" !== i ? "top" : "left");
                    var s = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]]
                      , l = (s[0][0] + s[1][0]) / 2
                      , u = (s[0][1] + s[1][1]) / 2
                      , h = "horizontal" === i ? 0 : 1
                      , c = {
                        top: [l, s[h][1]],
                        bottom: [l, s[1 - h][1]],
                        left: [s[1 - h][0], u],
                        right: [s[h][0], u]
                    }
                      , d = e.start.y;
                    +e.end.y > +e.start.y && (d = d + "-" + e.end.y);
                    var p = a.get("formatter")
                      , f = {
                        start: e.start.y,
                        end: e.end.y,
                        nameMap: d
                    }
                      , g = this._formatterLabel(p, f)
                      , m = new Fs.Text({
                        z2: 30
                    });
                    Fs.setTextStyle(m.style, a, {
                        text: g
                    }),
                    m.attr(this._yearTextPositionControl(m, c[o], i, o, r)),
                    n.add(m)
                }
            },
            _monthTextPositionControl: function(t, e, i, n, a) {
                var r = "left"
                  , o = "top"
                  , s = t[0]
                  , l = t[1];
                return "horizontal" === i ? (l += a,
                e && (r = "center"),
                "start" === n && (o = "bottom")) : (s += a,
                e && (o = "middle"),
                "start" === n && (r = "right")),
                {
                    x: s,
                    y: l,
                    textAlign: r,
                    textVerticalAlign: o
                }
            },
            _renderMonthText: function(t, e, i) {
                var n = t.getModel("monthLabel");
                if (n.get("show")) {
                    var a = n.get("nameMap")
                      , r = n.get("margin")
                      , o = n.get("position")
                      , s = n.get("align")
                      , l = [this._tlpoints, this._blpoints];
                    it.isString(a) && (a = $k[a.toUpperCase()] || []);
                    var u = "start" === o ? 0 : 1
                      , h = "horizontal" === e ? 0 : 1;
                    r = "start" === o ? -r : r;
                    for (var c = "center" === s, d = 0; d < l[u].length - 1; d++) {
                        var p = l[u][d].slice()
                          , f = this._firstDayOfMonth[d];
                        if (c) {
                            var g = this._firstDayPoints[d];
                            p[h] = (g[h] + l[0][d + 1][h]) / 2
                        }
                        var m = n.get("formatter")
                          , v = a[+f.m - 1]
                          , y = {
                            yyyy: f.y,
                            yy: (f.y + "").slice(2),
                            MM: f.m,
                            M: +f.m,
                            nameMap: v
                        }
                          , x = this._formatterLabel(m, y)
                          , _ = new Fs.Text({
                            z2: 30
                        });
                        it.extend(Fs.setTextStyle(_.style, n, {
                            text: x
                        }), this._monthTextPositionControl(p, c, e, o, r)),
                        i.add(_)
                    }
                }
            },
            _weekTextPositionControl: function(t, e, i, n, a) {
                var r = "center"
                  , o = "middle"
                  , s = t[0]
                  , l = t[1]
                  , u = "start" === i;
                return "horizontal" === e ? (s = s + n + (u ? 1 : -1) * a[0] / 2,
                r = u ? "right" : "left") : (l = l + n + (u ? 1 : -1) * a[1] / 2,
                o = u ? "bottom" : "top"),
                {
                    x: s,
                    y: l,
                    textAlign: r,
                    textVerticalAlign: o
                }
            },
            _renderWeekText: function(t, e, i, n) {
                var a = t.getModel("dayLabel");
                if (a.get("show")) {
                    var r = t.coordinateSystem
                      , o = a.get("position")
                      , s = a.get("nameMap")
                      , l = a.get("margin")
                      , u = r.getFirstDayOfWeek();
                    it.isString(s) && (s = Jk[s.toUpperCase()] || []);
                    var h = r.getNextNDay(e.end.time, 7 - e.lweek).time
                      , c = [r.getCellWidth(), r.getCellHeight()];
                    l = ol.parsePercent(l, c["horizontal" === i ? 0 : 1]),
                    "start" === o && (h = r.getNextNDay(e.start.time, -(7 + e.fweek)).time,
                    l = -l);
                    for (var d = 0; d < 7; d++) {
                        var p, f = r.getNextNDay(h, d), g = r.dataToRect([f.time], !1).center;
                        p = Math.abs((d + u) % 7);
                        var m = new Fs.Text({
                            z2: 30
                        });
                        it.extend(Fs.setTextStyle(m.style, a, {
                            text: s[p]
                        }), this._weekTextPositionControl(g, i, o, l, c)),
                        n.add(m)
                    }
                }
            }
        }),
        Il.getLayoutRect);
        Gm.extendComponentModel({
            type: "title",
            layoutMode: {
                type: "box",
                ignoreSize: !0
            },
            defaultOption: {
                zlevel: 0,
                z: 6,
                show: !0,
                text: "",
                target: "blank",
                subtext: "",
                subtarget: "blank",
                left: 0,
                top: 0,
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "#ccc",
                borderWidth: 0,
                padding: 5,
                itemGap: 10,
                textStyle: {
                    fontSize: 18,
                    fontWeight: "bolder",
                    color: "#333"
                },
                subtextStyle: {
                    color: "#aaa"
                }
            }
        }),
        Gm.extendComponentView({
            type: "title",
            render: function(t, e, i) {
                if (this.group.removeAll(),
                t.get("show")) {
                    var n = this.group
                      , a = t.getModel("textStyle")
                      , r = t.getModel("subtextStyle")
                      , o = t.get("textAlign")
                      , s = t.get("textBaseline")
                      , l = new Fs.Text({
                        style: Fs.setTextStyle({}, a, {
                            text: t.get("text"),
                            textFill: a.getTextColor()
                        }, {
                            disableBox: !0
                        }),
                        z2: 10
                    })
                      , u = l.getBoundingRect()
                      , h = t.get("subtext")
                      , c = new Fs.Text({
                        style: Fs.setTextStyle({}, r, {
                            text: h,
                            textFill: r.getTextColor(),
                            y: u.height + t.get("itemGap"),
                            textVerticalAlign: "top"
                        }, {
                            disableBox: !0
                        }),
                        z2: 10
                    })
                      , d = t.get("link")
                      , p = t.get("sublink")
                      , f = t.get("triggerEvent", !0);
                    l.silent = !d && !f,
                    c.silent = !p && !f,
                    d && l.on("click", function() {
                        window.open(d, "_" + t.get("target"))
                    }),
                    p && c.on("click", function() {
                        window.open(p, "_" + t.get("subtarget"))
                    }),
                    l.eventData = c.eventData = f ? {
                        componentType: "title",
                        componentIndex: t.componentIndex
                    } : null,
                    n.add(l),
                    h && n.add(c);
                    var g = n.getBoundingRect()
                      , m = t.getBoxLayoutParams();
                    m.width = g.width,
                    m.height = g.height;
                    var v = Qk(m, {
                        width: i.getWidth(),
                        height: i.getHeight()
                    }, t.get("padding"));
                    o || ("middle" === (o = t.get("left") || t.get("right")) && (o = "center"),
                    "right" === o ? v.x += v.width : "center" === o && (v.x += v.width / 2)),
                    s || ("center" === (s = t.get("top") || t.get("bottom")) && (s = "middle"),
                    "bottom" === s ? v.y += v.height : "middle" === s && (v.y += v.height / 2),
                    s = s || "top"),
                    n.attr("position", [v.x, v.y]);
                    var y = {
                        textAlign: o,
                        textVerticalAlign: s
                    };
                    l.setStyle(y),
                    c.setStyle(y),
                    g = n.getBoundingRect();
                    var x = v.margin
                      , _ = t.getItemStyle(["color", "opacity"]);
                    _.fill = t.get("backgroundColor");
                    var b = new Fs.Rect({
                        shape: {
                            x: g.x - x[3],
                            y: g.y - x[0],
                            width: g.width + x[1] + x[3],
                            height: g.height + x[0] + x[2],
                            r: t.get("borderRadius")
                        },
                        style: _,
                        silent: !0
                    });
                    Fs.subPixelOptimizeRect(b),
                    n.add(b)
                }
            }
        }),
        Pl.registerSubTypeDefaulter("dataZoom", function() {
            return "slider"
        });
        var tO = ["cartesian2d", "polar", "singleAxis"];
        function eO(t, o) {
            t = t.slice();
            var s = it.map(t, fl.capitalFirst);
            o = (o || []).slice();
            var l = it.map(o, fl.capitalFirst);
            return function(a, r) {
                it.each(t, function(t, e) {
                    for (var i = {
                        name: t,
                        capital: s[e]
                    }, n = 0; n < o.length; n++)
                        i[o[n]] = t + l[n];
                    a.call(r, i)
                })
            }
        }
        var iO = eO(["x", "y", "z", "radius", "angle", "single"], ["axisIndex", "axis", "index", "id"]);
        function nO(t, e, i, n) {
            this._dimName = t,
            this._axisIndex = e,
            this._valueWindow,
            this._percentWindow,
            this._dataExtent,
            this._minMaxSpan,
            this.ecModel = n,
            this._dataZoomModel = i
        }
        var aO = {
            isCoordSupported: function(t) {
                return 0 <= it.indexOf(tO, t)
            },
            createNameEach: eO,
            eachAxisDim: iO,
            createLinkedNodesFinder: function(a, r, o) {
                return function(t) {
                    var e, i = {
                        nodes: [],
                        records: {}
                    };
                    if (r(function(t) {
                        i.records[t.name] = {}
                    }),
                    !t)
                        return i;
                    for (s(t, i); e = !1,
                    a(n),
                    e; )
                        ;
                    function n(t) {
                        !function(t, e) {
                            return 0 <= it.indexOf(e.nodes, t)
                        }(t, i) && function(t, i) {
                            var n = !1;
                            return r(function(e) {
                                it.each(o(t, e) || [], function(t) {
                                    i.records[e.name][t] && (n = !0)
                                })
                            }),
                            n
                        }(t, i) && (s(t, i),
                        e = !0)
                    }
                    return i
                }
                ;
                function s(t, i) {
                    i.nodes.push(t),
                    r(function(e) {
                        it.each(o(t, e) || [], function(t) {
                            i.records[e.name][t] = !0
                        })
                    })
                }
            }
        }
          , rO = it.each
          , oO = ol.asc;
        function sO(t, e) {
            var i = t.getAxisModel()
              , n = t._percentWindow
              , a = t._valueWindow;
            if (n) {
                var r = ol.getPixelPrecision(a, [0, 500]);
                r = Math.min(r, 20);
                var o = e || 0 === n[0] && 100 === n[1];
                i.setRange(o ? null : +a[0].toFixed(r), o ? null : +a[1].toFixed(r))
            }
        }
        nO.prototype = {
            constructor: nO,
            hostedBy: function(t) {
                return this._dataZoomModel === t
            },
            getDataValueWindow: function() {
                return this._valueWindow.slice()
            },
            getDataPercentWindow: function() {
                return this._percentWindow.slice()
            },
            getTargetSeriesModels: function() {
                var n = []
                  , a = this.ecModel;
                return a.eachSeries(function(t) {
                    if (aO.isCoordSupported(t.get("coordinateSystem"))) {
                        var e = this._dimName
                          , i = a.queryComponents({
                            mainType: e + "Axis",
                            index: t.get(e + "AxisIndex"),
                            id: t.get(e + "AxisId")
                        })[0];
                        this._axisIndex === (i && i.componentIndex) && n.push(t)
                    }
                }, this),
                n
            },
            getAxisModel: function() {
                return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex)
            },
            getOtherAxisModel: function() {
                var t, e, i, n = this._dimName, a = this.ecModel, r = this.getAxisModel();
                return t = "x" === n || "y" === n ? (e = "gridIndex",
                "x" === n ? "y" : "x") : (e = "polarIndex",
                "angle" === n ? "radius" : "angle"),
                a.eachComponent(t + "Axis", function(t) {
                    (t.get(e) || 0) === (r.get(e) || 0) && (i = t)
                }),
                i
            },
            getMinMaxSpan: function() {
                return it.clone(this._minMaxSpan)
            },
            calculateDataWindow: function(e) {
                var n = this._dataExtent
                  , a = this.getAxisModel().axis.scale
                  , r = this._dataZoomModel.getRangePropMode()
                  , o = [0, 100]
                  , s = [e.start, e.end]
                  , l = [];
                return rO(["startValue", "endValue"], function(t) {
                    l.push(null != e[t] ? a.parse(e[t]) : null)
                }),
                rO([0, 1], function(t) {
                    var e = l[t]
                      , i = s[t];
                    "percent" === r[t] ? (null == i && (i = o[t]),
                    e = a.parse(ol.linearMap(i, o, n, !0))) : i = ol.linearMap(e, n, o, !0),
                    l[t] = e,
                    s[t] = i
                }),
                {
                    valueWindow: oO(l),
                    percentWindow: oO(s)
                }
            },
            reset: function(t) {
                if (t === this._dataZoomModel) {
                    var e = this.getTargetSeriesModels();
                    this._dataExtent = function(t, e, i) {
                        var n = [1 / 0, -1 / 0];
                        rO(i, function(t) {
                            var i = t.getData();
                            i && rO(i.mapDimension(e, !0), function(t) {
                                var e = i.getApproximateExtent(t);
                                e[0] < n[0] && (n[0] = e[0]),
                                e[1] > n[1] && (n[1] = e[1])
                            })
                        }),
                        n[1] < n[0] && (n = [NaN, NaN]);
                        return function(t, e) {
                            var i = t.getAxisModel()
                              , n = i.getMin(!0)
                              , a = "category" === i.get("type")
                              , r = a && i.getCategories().length;
                            null != n && "dataMin" !== n && "function" != typeof n ? e[0] = n : a && (e[0] = 0 < r ? 0 : NaN);
                            var o = i.getMax(!0);
                            null != o && "dataMax" !== o && "function" != typeof o ? e[1] = o : a && (e[1] = 0 < r ? r - 1 : NaN);
                            i.get("scale", !0) || (0 < e[0] && (e[0] = 0),
                            e[1] < 0 && (e[1] = 0))
                        }(t, n),
                        n
                    }(this, this._dimName, e);
                    var i = this.calculateDataWindow(t.option);
                    this._valueWindow = i.valueWindow,
                    this._percentWindow = i.percentWindow,
                    function(n) {
                        var a = n._minMaxSpan = {}
                          , r = n._dataZoomModel;
                        rO(["min", "max"], function(t) {
                            a[t + "Span"] = r.get(t + "Span");
                            var e = r.get(t + "ValueSpan");
                            if (null != e && (a[t + "ValueSpan"] = e,
                            null != (e = n.getAxisModel().axis.scale.parse(e)))) {
                                var i = n._dataExtent;
                                a[t + "Span"] = ol.linearMap(i[0] + e, i, [0, 100], !0)
                            }
                        })
                    }(this),
                    sO(this)
                }
            },
            restore: function(t) {
                t === this._dataZoomModel && (this._valueWindow = this._percentWindow = null,
                sO(this, !0))
            },
            filterData: function(t, e) {
                if (t === this._dataZoomModel) {
                    var n = this._dimName
                      , i = this.getTargetSeriesModels()
                      , a = t.get("filterMode")
                      , c = this._valueWindow;
                    "none" !== a && rO(i, function(i) {
                        var u = i.getData()
                          , h = u.mapDimension(n, !0);
                        h.length && ("weakFilter" === a ? u.filterSelf(function(t) {
                            for (var e, i, n, a = 0; a < h.length; a++) {
                                var r = u.get(h[a], t)
                                  , o = !isNaN(r)
                                  , s = r < c[0]
                                  , l = r > c[1];
                                if (o && !s && !l)
                                    return !0;
                                o && (n = !0),
                                s && (e = !0),
                                l && (i = !0)
                            }
                            return n && e && i
                        }) : rO(h, function(t) {
                            if ("empty" === a)
                                i.setData(u.map(t, function(t) {
                                    return function(t) {
                                        return t >= c[0] && t <= c[1]
                                    }(t) ? t : NaN
                                }));
                            else {
                                var e = {};
                                e[t] = c,
                                u.selectRange(e)
                            }
                        }),
                        rO(h, function(t) {
                            u.setApproximateExtent(c, t)
                        }))
                    })
                }
            }
        };
        var lO = nO
          , uO = it.each
          , hO = aO.eachAxisDim;
        function cO(e) {
            var i = {};
            return uO(["start", "end", "startValue", "endValue", "throttle"], function(t) {
                e.hasOwnProperty(t) && (i[t] = e[t])
            }),
            i
        }
        function dO(t, a) {
            var r = t._rangePropMode
              , o = t.get("rangeMode");
            uO([["start", "startValue"], ["end", "endValue"]], function(t, e) {
                var i = null != a[t[0]]
                  , n = null != a[t[1]];
                i && !n ? r[e] = "percent" : !i && n ? r[e] = "value" : o ? r[e] = o[e] : i && (r[e] = "percent")
            })
        }
        var pO = Gm.extendComponentModel({
            type: "dataZoom",
            dependencies: ["xAxis", "yAxis", "zAxis", "radiusAxis", "angleAxis", "singleAxis", "series"],
            defaultOption: {
                zlevel: 0,
                z: 4,
                orient: null,
                xAxisIndex: null,
                yAxisIndex: null,
                filterMode: "filter",
                throttle: null,
                start: 0,
                end: 100,
                startValue: null,
                endValue: null,
                minSpan: null,
                maxSpan: null,
                minValueSpan: null,
                maxValueSpan: null,
                rangeMode: null
            },
            init: function(t, e, i) {
                this._dataIntervalByAxis = {},
                this._dataInfo = {},
                this._axisProxies = {},
                this.textStyleModel,
                this._autoThrottle = !0,
                this._rangePropMode = ["percent", "percent"];
                var n = cO(t);
                this.mergeDefaultAndTheme(t, i),
                this.doInit(n)
            },
            mergeOption: function(t) {
                var e = cO(t);
                it.merge(this.option, t, !0),
                this.doInit(e)
            },
            doInit: function(t) {
                var i = this.option;
                et.canvasSupported || (i.realtime = !1),
                this._setDefaultThrottle(t),
                dO(this, t),
                uO([["start", "startValue"], ["end", "endValue"]], function(t, e) {
                    "value" === this._rangePropMode[e] && (i[t[0]] = null)
                }, this),
                this.textStyleModel = this.getModel("textStyle"),
                this._resetTarget(),
                this._giveAxisProxies()
            },
            _giveAxisProxies: function() {
                var o = this._axisProxies;
                this.eachTargetAxis(function(t, e, i, n) {
                    var a = this.dependentModels[t.axis][e]
                      , r = a.__dzAxisProxy || (a.__dzAxisProxy = new lO(t.name,e,this,n));
                    o[t.name + "_" + e] = r
                }, this)
            },
            _resetTarget: function() {
                var i = this.option
                  , t = this._judgeAutoMode();
                hO(function(t) {
                    var e = t.axisIndex;
                    i[e] = aa.normalizeToArray(i[e])
                }, this),
                "axisIndex" === t ? this._autoSetAxisIndex() : "orient" === t && this._autoSetOrient()
            },
            _judgeAutoMode: function() {
                var e = this.option
                  , i = !1;
                hO(function(t) {
                    null != e[t.axisIndex] && (i = !0)
                }, this);
                var t = e.orient;
                return null == t && i ? "orient" : i ? void 0 : (null == t && (e.orient = "horizontal"),
                "axisIndex")
            },
            _autoSetAxisIndex: function() {
                var r = !0
                  , e = this.get("orient", !0)
                  , o = this.option
                  , t = this.dependentModels;
                if (r) {
                    var i = "vertical" === e ? "y" : "x";
                    t[i + "Axis"].length ? (o[i + "AxisIndex"] = [0],
                    r = !1) : uO(t.singleAxis, function(t) {
                        r && t.get("orient", !0) === e && (o.singleAxisIndex = [t.componentIndex],
                        r = !1)
                    })
                }
                r && hO(function(t) {
                    if (r) {
                        var e = []
                          , i = this.dependentModels[t.axis];
                        if (i.length && !e.length)
                            for (var n = 0, a = i.length; n < a; n++)
                                "category" === i[n].get("type") && e.push(n);
                        (o[t.axisIndex] = e).length && (r = !1)
                    }
                }, this),
                r && this.ecModel.eachSeries(function(a) {
                    this._isSeriesHasAllAxesTypeOf(a, "value") && hO(function(t) {
                        var e = o[t.axisIndex]
                          , i = a.get(t.axisIndex)
                          , n = a.get(t.axisId);
                        i = a.ecModel.queryComponents({
                            mainType: t.axis,
                            index: i,
                            id: n
                        })[0].componentIndex,
                        it.indexOf(e, i) < 0 && e.push(i)
                    })
                }, this)
            },
            _autoSetOrient: function() {
                var e;
                this.eachTargetAxis(function(t) {
                    e = e || t.name
                }, this),
                this.option.orient = "y" === e ? "vertical" : "horizontal"
            },
            _isSeriesHasAllAxesTypeOf: function(n, a) {
                var r = !0;
                return hO(function(t) {
                    var e = n.get(t.axisIndex)
                      , i = this.dependentModels[t.axis][e];
                    i && i.get("type") === a || (r = !1)
                }, this),
                r
            },
            _setDefaultThrottle: function(t) {
                if (t.hasOwnProperty("throttle") && (this._autoThrottle = !1),
                this._autoThrottle) {
                    var e = this.ecModel.option;
                    this.option.throttle = e.animation && 0 < e.animationDurationUpdate ? 100 : 20
                }
            },
            getFirstTargetAxisModel: function() {
                var i;
                return hO(function(t) {
                    if (null == i) {
                        var e = this.get(t.axisIndex);
                        e.length && (i = this.dependentModels[t.axis][e[0]])
                    }
                }, this),
                i
            },
            eachTargetAxis: function(i, n) {
                var a = this.ecModel;
                hO(function(e) {
                    uO(this.get(e.axisIndex), function(t) {
                        i.call(n, e, t, this, a)
                    }, this)
                }, this)
            },
            getAxisProxy: function(t, e) {
                return this._axisProxies[t + "_" + e]
            },
            getAxisModel: function(t, e) {
                var i = this.getAxisProxy(t, e);
                return i && i.getAxisModel()
            },
            setRawRange: function(e, t) {
                var i = this.option;
                uO([["start", "startValue"], ["end", "endValue"]], function(t) {
                    null == e[t[0]] && null == e[t[1]] || (i[t[0]] = e[t[0]],
                    i[t[1]] = e[t[1]])
                }, this),
                t || dO(this, e)
            },
            getPercentRange: function() {
                var t = this.findRepresentativeAxisProxy();
                if (t)
                    return t.getDataPercentWindow()
            },
            getValueRange: function(t, e) {
                if (null != t || null != e)
                    return this.getAxisProxy(t, e).getDataValueWindow();
                var i = this.findRepresentativeAxisProxy();
                return i ? i.getDataValueWindow() : void 0
            },
            findRepresentativeAxisProxy: function(t) {
                if (t)
                    return t.__dzAxisProxy;
                var e = this._axisProxies;
                for (var i in e)
                    if (e.hasOwnProperty(i) && e[i].hostedBy(this))
                        return e[i];
                for (var i in e)
                    if (e.hasOwnProperty(i) && !e[i].hostedBy(this))
                        return e[i]
            },
            getRangePropMode: function() {
                return this._rangePropMode.slice()
            }
        })
          , fO = Rc.extend({
            type: "dataZoom",
            render: function(t, e, i, n) {
                this.dataZoomModel = t,
                this.ecModel = e,
                this.api = i
            },
            getTargetCoordInfo: function() {
                var t = this.dataZoomModel
                  , a = this.ecModel
                  , r = {};
                return t.eachTargetAxis(function(t, e) {
                    var i = a.getComponent(t.axis, e);
                    if (i) {
                        var n = i.getCoordSysModel();
                        n && function(t, e, i, n) {
                            for (var a, r = 0; r < i.length; r++)
                                if (i[r].model === t) {
                                    a = i[r];
                                    break
                                }
                            a || i.push(a = {
                                model: t,
                                axisModels: [],
                                coordIndex: n
                            });
                            a.axisModels.push(e)
                        }(n, i, r[n.mainType] || (r[n.mainType] = []), n.componentIndex)
                    }
                }, this),
                r
            }
        })
          , gO = (pO.extend({
            type: "dataZoom.slider",
            layoutMode: "box",
            defaultOption: {
                show: !0,
                right: "ph",
                top: "ph",
                width: "ph",
                height: "ph",
                left: null,
                bottom: null,
                backgroundColor: "rgba(47,69,84,0)",
                dataBackground: {
                    lineStyle: {
                        color: "#2f4554",
                        width: .5,
                        opacity: .3
                    },
                    areaStyle: {
                        color: "rgba(47,69,84,0.3)",
                        opacity: .3
                    }
                },
                borderColor: "#ddd",
                fillerColor: "rgba(167,183,204,0.4)",
                handleIcon: "M8.2,13.6V3.9H6.3v9.7H3.1v14.9h3.3v9.7h1.8v-9.7h3.3V13.6H8.2z M9.7,24.4H4.8v-1.4h4.9V24.4z M9.7,19.1H4.8v-1.4h4.9V19.1z",
                handleSize: "100%",
                handleStyle: {
                    color: "#a7b7cc"
                },
                labelPrecision: null,
                labelFormatter: null,
                showDetail: !0,
                showDataShadow: "auto",
                realtime: !0,
                zoomLock: !1,
                textStyle: {
                    color: "#333"
                }
            }
        }),
        Fs.Rect)
          , mO = ol.linearMap
          , vO = ol.asc
          , yO = it.bind
          , xO = it.each
          , _O = "horizontal"
          , bO = "vertical"
          , wO = ["line", "bar", "candlestick", "scatter"]
          , SO = fO.extend({
            type: "dataZoom.slider",
            init: function(t, e) {
                this._displayables = {},
                this._orient,
                this._range,
                this._handleEnds,
                this._size,
                this._handleWidth,
                this._handleHeight,
                this._location,
                this._dragging,
                this._dataShadowInfo,
                this.api = e
            },
            render: function(t, e, i, n) {
                SO.superApply(this, "render", arguments),
                Qc.createOrUpdate(this, "_dispatchZoomAction", this.dataZoomModel.get("throttle"), "fixRate"),
                this._orient = t.get("orient"),
                !1 !== this.dataZoomModel.get("show") ? (n && "dataZoom" === n.type && n.from === this.uid || this._buildView(),
                this._updateView()) : this.group.removeAll()
            },
            remove: function() {
                SO.superApply(this, "remove", arguments),
                Qc.clear(this, "_dispatchZoomAction")
            },
            dispose: function() {
                SO.superApply(this, "dispose", arguments),
                Qc.clear(this, "_dispatchZoomAction")
            },
            _buildView: function() {
                var t = this.group;
                t.removeAll(),
                this._resetLocation(),
                this._resetInterval();
                var e = this._displayables.barGroup = new Fs.Group;
                this._renderBackground(),
                this._renderHandle(),
                this._renderDataShadow(),
                t.add(e),
                this._positionGroup()
            },
            _resetLocation: function() {
                var t = this.dataZoomModel
                  , e = this.api
                  , i = this._findCoordRect()
                  , n = {
                    width: e.getWidth(),
                    height: e.getHeight()
                }
                  , a = this._orient === _O ? {
                    right: n.width - i.x - i.width,
                    top: n.height - 30 - 7,
                    width: i.width,
                    height: 30
                } : {
                    right: 7,
                    top: i.y,
                    width: 30,
                    height: i.height
                }
                  , r = Il.getLayoutParams(t.option);
                it.each(["right", "top", "width", "height"], function(t) {
                    "ph" === r[t] && (r[t] = a[t])
                });
                var o = Il.getLayoutRect(r, n, t.padding);
                this._location = {
                    x: o.x,
                    y: o.y
                },
                this._size = [o.width, o.height],
                this._orient === bO && this._size.reverse()
            },
            _positionGroup: function() {
                var t = this.group
                  , e = this._location
                  , i = this._orient
                  , n = this.dataZoomModel.getFirstTargetAxisModel()
                  , a = n && n.get("inverse")
                  , r = this._displayables.barGroup
                  , o = (this._dataShadowInfo || {}).otherAxisInverse;
                r.attr(i !== _O || a ? i === _O && a ? {
                    scale: o ? [-1, 1] : [-1, -1]
                } : i !== bO || a ? {
                    scale: o ? [-1, -1] : [-1, 1],
                    rotation: Math.PI / 2
                } : {
                    scale: o ? [1, -1] : [1, 1],
                    rotation: Math.PI / 2
                } : {
                    scale: o ? [1, 1] : [1, -1]
                });
                var s = t.getBoundingRect([r]);
                t.attr("position", [e.x - s.x, e.y - s.y])
            },
            _getViewExtent: function() {
                return [0, this._size[0]]
            },
            _renderBackground: function() {
                var t = this.dataZoomModel
                  , e = this._size
                  , i = this._displayables.barGroup;
                i.add(new gO({
                    silent: !0,
                    shape: {
                        x: 0,
                        y: 0,
                        width: e[0],
                        height: e[1]
                    },
                    style: {
                        fill: t.get("backgroundColor")
                    },
                    z2: -40
                })),
                i.add(new gO({
                    shape: {
                        x: 0,
                        y: 0,
                        width: e[0],
                        height: e[1]
                    },
                    style: {
                        fill: "transparent"
                    },
                    z2: 0,
                    onclick: it.bind(this._onClickPanelClick, this)
                }))
            },
            _renderDataShadow: function() {
                var t = this._dataShadowInfo = this._prepareDataShadowInfo();
                if (t) {
                    var e = this._size
                      , i = t.series
                      , n = i.getRawData()
                      , a = i.getShadowDim ? i.getShadowDim() : t.otherDim;
                    if (null != a) {
                        var r = n.getDataExtent(a)
                          , o = .3 * (r[1] - r[0]);
                        r = [r[0] - o, r[1] + o];
                        var s, l = [0, e[1]], u = [0, e[0]], h = [[e[0], 0], [0, 0]], c = [], d = u[1] / (n.count() - 1), p = 0, f = Math.round(n.count() / e[0]);
                        n.each([a], function(t, e) {
                            if (0 < f && e % f)
                                p += d;
                            else {
                                var i = null == t || isNaN(t) || "" === t
                                  , n = i ? 0 : mO(t, r, l, !0);
                                i && !s && e ? (h.push([h[h.length - 1][0], 0]),
                                c.push([c[c.length - 1][0], 0])) : !i && s && (h.push([p, 0]),
                                c.push([p, 0])),
                                h.push([p, n]),
                                c.push([p, n]),
                                p += d,
                                s = i
                            }
                        });
                        var g = this.dataZoomModel;
                        this._displayables.barGroup.add(new Fs.Polygon({
                            shape: {
                                points: h
                            },
                            style: it.defaults({
                                fill: g.get("dataBackgroundColor")
                            }, g.getModel("dataBackground.areaStyle").getAreaStyle()),
                            silent: !0,
                            z2: -20
                        })),
                        this._displayables.barGroup.add(new Fs.Polyline({
                            shape: {
                                points: c
                            },
                            style: g.getModel("dataBackground.lineStyle").getLineStyle(),
                            silent: !0,
                            z2: -19
                        }))
                    }
                }
            },
            _prepareDataShadowInfo: function() {
                var e = this.dataZoomModel
                  , s = e.get("showDataShadow");
                if (!1 !== s) {
                    var l, u = this.ecModel;
                    return e.eachTargetAxis(function(r, o) {
                        var t = e.getAxisProxy(r.name, o).getTargetSeriesModels();
                        it.each(t, function(t) {
                            if (!(l || !0 !== s && it.indexOf(wO, t.get("type")) < 0)) {
                                var e, i = u.getComponent(r.axis, o).axis, n = function(t) {
                                    return {
                                        x: "y",
                                        y: "x",
                                        radius: "angle",
                                        angle: "radius"
                                    }[t]
                                }(r.name), a = t.coordinateSystem;
                                null != n && a.getOtherAxis && (e = a.getOtherAxis(i).inverse),
                                n = t.getData().mapDimension(n),
                                l = {
                                    thisAxis: i,
                                    series: t,
                                    thisDim: r.name,
                                    otherDim: n,
                                    otherAxisInverse: e
                                }
                            }
                        }, this)
                    }, this),
                    l
                }
            },
            _renderHandle: function() {
                var t = this._displayables
                  , r = t.handles = []
                  , o = t.handleLabels = []
                  , s = this._displayables.barGroup
                  , e = this._size
                  , l = this.dataZoomModel;
                s.add(t.filler = new gO({
                    draggable: !0,
                    cursor: MO(this._orient),
                    drift: yO(this._onDragMove, this, "all"),
                    onmousemove: function(t) {
                        j.stop(t.event)
                    },
                    ondragstart: yO(this._showDataInfo, this, !0),
                    ondragend: yO(this._onDragEnd, this),
                    onmouseover: yO(this._showDataInfo, this, !0),
                    onmouseout: yO(this._showDataInfo, this, !1),
                    style: {
                        fill: l.get("fillerColor"),
                        textPosition: "inside"
                    }
                })),
                s.add(new gO(Fs.subPixelOptimizeRect({
                    silent: !0,
                    shape: {
                        x: 0,
                        y: 0,
                        width: e[0],
                        height: e[1]
                    },
                    style: {
                        stroke: l.get("dataBackgroundColor") || l.get("borderColor"),
                        lineWidth: 1,
                        fill: "rgba(0,0,0,0)"
                    }
                }))),
                xO([0, 1], function(t) {
                    var e = Fs.createIcon(l.get("handleIcon"), {
                        cursor: MO(this._orient),
                        draggable: !0,
                        drift: yO(this._onDragMove, this, t),
                        onmousemove: function(t) {
                            j.stop(t.event)
                        },
                        ondragend: yO(this._onDragEnd, this),
                        onmouseover: yO(this._showDataInfo, this, !0),
                        onmouseout: yO(this._showDataInfo, this, !1)
                    }, {
                        x: -1,
                        y: 0,
                        width: 2,
                        height: 2
                    })
                      , i = e.getBoundingRect();
                    this._handleHeight = ol.parsePercent(l.get("handleSize"), this._size[1]),
                    this._handleWidth = i.width / i.height * this._handleHeight,
                    e.setStyle(l.getModel("handleStyle").getItemStyle());
                    var n = l.get("handleColor");
                    null != n && (e.style.fill = n),
                    s.add(r[t] = e);
                    var a = l.textStyleModel;
                    this.group.add(o[t] = new Fs.Text({
                        silent: !0,
                        invisible: !0,
                        style: {
                            x: 0,
                            y: 0,
                            text: "",
                            textVerticalAlign: "middle",
                            textAlign: "center",
                            textFill: a.getTextColor(),
                            textFont: a.getFont()
                        },
                        z2: 10
                    }))
                }, this)
            },
            _resetInterval: function() {
                var t = this._range = this.dataZoomModel.getPercentRange()
                  , e = this._getViewExtent();
                this._handleEnds = [mO(t[0], [0, 100], e, !0), mO(t[1], [0, 100], e, !0)]
            },
            _updateInterval: function(t, e) {
                var i = this.dataZoomModel
                  , n = this._handleEnds
                  , a = this._getViewExtent()
                  , r = i.findRepresentativeAxisProxy().getMinMaxSpan()
                  , o = [0, 100];
                dI(e, n, a, i.get("zoomLock") ? "all" : t, null != r.minSpan ? mO(r.minSpan, o, a, !0) : null, null != r.maxSpan ? mO(r.maxSpan, o, a, !0) : null);
                var s = this._range
                  , l = this._range = vO([mO(n[0], a, o, !0), mO(n[1], a, o, !0)]);
                return !s || s[0] !== l[0] || s[1] !== l[1]
            },
            _updateView: function(t) {
                var n = this._displayables
                  , a = this._handleEnds
                  , e = vO(a.slice())
                  , r = this._size;
                xO([0, 1], function(t) {
                    var e = n.handles[t]
                      , i = this._handleHeight;
                    e.attr({
                        scale: [i / 2, i / 2],
                        position: [a[t], r[1] / 2 - i / 2]
                    })
                }, this),
                n.filler.setShape({
                    x: e[0],
                    y: 0,
                    width: e[1] - e[0],
                    height: r[1]
                }),
                this._updateDataInfo(t)
            },
            _updateDataInfo: function(t) {
                var e = this.dataZoomModel
                  , r = this._displayables
                  , o = r.handleLabels
                  , s = this._orient
                  , l = ["", ""];
                if (e.get("showDetail")) {
                    var i = e.findRepresentativeAxisProxy();
                    if (i) {
                        var n = i.getAxisModel().axis
                          , a = this._range
                          , u = t ? i.calculateDataWindow({
                            start: a[0],
                            end: a[1]
                        }).valueWindow : i.getDataValueWindow();
                        l = [this._formatLabel(u[0], n), this._formatLabel(u[1], n)]
                    }
                }
                var h = vO(this._handleEnds.slice());
                function c(t) {
                    var e = Fs.getTransform(r.handles[t].parent, this.group)
                      , i = Fs.transformDirection(0 === t ? "right" : "left", e)
                      , n = this._handleWidth / 2 + 5
                      , a = Fs.applyTransform([h[t] + (0 === t ? -n : n), this._size[1] / 2], e);
                    o[t].setStyle({
                        x: a[0],
                        y: a[1],
                        textVerticalAlign: s === _O ? "middle" : i,
                        textAlign: s === _O ? i : "center",
                        text: l[t]
                    })
                }
                c.call(this, 0),
                c.call(this, 1)
            },
            _formatLabel: function(t, e) {
                var i = this.dataZoomModel
                  , n = i.get("labelFormatter")
                  , a = i.get("labelPrecision");
                null != a && "auto" !== a || (a = e.getPixelPrecision());
                var r = null == t || isNaN(t) ? "" : "category" === e.type || "time" === e.type ? e.scale.getLabel(Math.round(t)) : t.toFixed(Math.min(a, 20));
                return it.isFunction(n) ? n(t, r) : it.isString(n) ? n.replace("{value}", r) : r
            },
            _showDataInfo: function(t) {
                t = this._dragging || t;
                var e = this._displayables.handleLabels;
                e[0].attr("invisible", !t),
                e[1].attr("invisible", !t)
            },
            _onDragMove: function(t, e, i) {
                this._dragging = !0;
                var n = this._displayables.barGroup.getLocalTransform()
                  , a = Fs.applyTransform([e, i], n, !0)
                  , r = this._updateInterval(t, a[0])
                  , o = this.dataZoomModel.get("realtime");
                this._updateView(!o),
                r && o && this._dispatchZoomAction()
            },
            _onDragEnd: function() {
                this._dragging = !1,
                this._showDataInfo(!1),
                this.dataZoomModel.get("realtime") || this._dispatchZoomAction()
            },
            _onClickPanelClick: function(t) {
                var e = this._size
                  , i = this._displayables.barGroup.transformCoordToLocal(t.offsetX, t.offsetY);
                if (!(i[0] < 0 || i[0] > e[0] || i[1] < 0 || i[1] > e[1])) {
                    var n = this._handleEnds
                      , a = (n[0] + n[1]) / 2
                      , r = this._updateInterval("all", i[0] - a);
                    this._updateView(),
                    r && this._dispatchZoomAction()
                }
            },
            _dispatchZoomAction: function() {
                var t = this._range;
                this.api.dispatchAction({
                    type: "dataZoom",
                    from: this.uid,
                    dataZoomId: this.dataZoomModel.id,
                    start: t[0],
                    end: t[1]
                })
            },
            _findCoordRect: function() {
                var i;
                if (xO(this.getTargetCoordInfo(), function(t) {
                    if (!i && t.length) {
                        var e = t[0].model.coordinateSystem;
                        i = e.getRect && e.getRect()
                    }
                }),
                !i) {
                    var t = this.api.getWidth()
                      , e = this.api.getHeight();
                    i = {
                        x: .2 * t,
                        y: .2 * e,
                        width: .6 * t,
                        height: .6 * e
                    }
                }
                return i
            }
        });
        function MO(t) {
            return "vertical" === t ? "ns-resize" : "ew-resize"
        }
        pO.extend({
            type: "dataZoom.inside",
            defaultOption: {
                disabled: !1,
                zoomLock: !1,
                zoomOnMouseWheel: !0,
                moveOnMouseMove: !0,
                moveOnMouseWheel: !1,
                preventDefaultMouseMove: !0
            }
        });
        var IO = "\0_ec_dataZoom_roams";
        function AO(t) {
            var e = t.getZr();
            return e[IO] || (e[IO] = {})
        }
        function TO(i) {
            it.each(i, function(t, e) {
                t.count || (t.controller.dispose(),
                delete i[e])
            })
        }
        function CO(t, e) {
            t.dispatchAction({
                type: "dataZoom",
                batch: e
            })
        }
        var DO = {
            register: function(t, n) {
                var e = AO(t)
                  , a = n.dataZoomId
                  , r = n.coordId;
                it.each(e, function(t, e) {
                    var i = t.dataZoomInfos;
                    i[a] && it.indexOf(n.allCoordIds, r) < 0 && (delete i[a],
                    t.count--)
                }),
                TO(e);
                var i = e[r];
                i || ((i = e[r] = {
                    coordId: r,
                    dataZoomInfos: {},
                    count: 0
                }).controller = function(t, o) {
                    var e = new nb(t.getZr());
                    return it.each(["pan", "zoom", "scrollMove"], function(r) {
                        e.on(r, function(n) {
                            var a = [];
                            it.each(o.dataZoomInfos, function(t) {
                                if (n.isAvailableBehavior(t.dataZoomModel.option)) {
                                    var e = (t.getRange || {})[r]
                                      , i = e && e(o.controller, n);
                                    !t.dataZoomModel.get("disabled", !0) && i && a.push({
                                        dataZoomId: t.dataZoomId,
                                        start: i[0],
                                        end: i[1]
                                    })
                                }
                            }),
                            a.length && o.dispatchAction(a)
                        })
                    }),
                    e
                }(t, i),
                i.dispatchAction = it.curry(CO, t)),
                i.dataZoomInfos[a] || i.count++,
                i.dataZoomInfos[a] = n;
                var o = function(t) {
                    var n, a = {
                        type_true: 2,
                        type_move: 1,
                        type_false: 0,
                        type_undefined: -1
                    }, r = !0;
                    return it.each(t, function(t) {
                        var e = t.dataZoomModel
                          , i = !e.get("disabled", !0) && (!e.get("zoomLock", !0) || "move");
                        a["type_" + n] < a["type_" + i] && (n = i),
                        r &= e.get("preventDefaultMouseMove", !0)
                    }),
                    {
                        controlType: n,
                        opt: {
                            zoomOnMouseWheel: !0,
                            moveOnMouseMove: !0,
                            moveOnMouseWheel: !0,
                            preventDefaultMouseMove: !!r
                        }
                    }
                }(i.dataZoomInfos);
                i.controller.enable(o.controlType, o.opt),
                i.controller.setPointerChecker(n.containsPoint),
                Qc.createOrUpdate(i, "dispatchAction", n.dataZoomModel.get("throttle", !0), "fixRate")
            },
            unregister: function(t, i) {
                var e = AO(t);
                it.each(e, function(t) {
                    t.controller.dispose();
                    var e = t.dataZoomInfos;
                    e[i] && (delete e[i],
                    t.count--)
                }),
                TO(e)
            },
            generateCoordId: function(t) {
                return t.type + "\0_" + t.id
            }
        }
          , LO = it.bind
          , PO = fO.extend({
            type: "dataZoom.inside",
            init: function(t, e) {
                this._range
            },
            render: function(o, t, s, e) {
                PO.superApply(this, "render", arguments),
                this._range = o.getPercentRange(),
                it.each(this.getTargetCoordInfo(), function(t, a) {
                    var r = it.map(t, function(t) {
                        return DO.generateCoordId(t.model)
                    });
                    it.each(t, function(e) {
                        var n = e.model
                          , i = {};
                        it.each(["pan", "zoom", "scrollMove"], function(t) {
                            i[t] = LO(kO[t], this, e, a)
                        }, this),
                        DO.register(s, {
                            coordId: DO.generateCoordId(n),
                            allCoordIds: r,
                            containsPoint: function(t, e, i) {
                                return n.coordinateSystem.containPoint([e, i])
                            },
                            dataZoomId: o.id,
                            dataZoomModel: o,
                            getRange: i
                        })
                    }, this)
                }, this)
            },
            dispose: function() {
                DO.unregister(this.api, this.dataZoomModel.id),
                PO.superApply(this, "dispose", arguments),
                this._range = null
            }
        })
          , kO = {
            zoom: function(t, e, i, n) {
                var a = this._range
                  , r = a.slice()
                  , o = t.axisModels[0];
                if (o) {
                    var s = RO[e](null, [n.originX, n.originY], o, i, t)
                      , l = (0 < s.signal ? s.pixelStart + s.pixelLength - s.pixel : s.pixel - s.pixelStart) / s.pixelLength * (r[1] - r[0]) + r[0]
                      , u = Math.max(1 / n.scale, 0);
                    r[0] = (r[0] - l) * u + l,
                    r[1] = (r[1] - l) * u + l;
                    var h = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
                    return dI(0, r, [0, 100], 0, h.minSpan, h.maxSpan),
                    this._range = r,
                    a[0] !== r[0] || a[1] !== r[1] ? r : void 0
                }
            },
            pan: OO(function(t, e, i, n, a, r) {
                var o = RO[n]([r.oldX, r.oldY], [r.newX, r.newY], e, a, i);
                return o.signal * (t[1] - t[0]) * o.pixel / o.pixelLength
            }),
            scrollMove: OO(function(t, e, i, n, a, r) {
                return RO[n]([0, 0], [r.scrollDelta, r.scrollDelta], e, a, i).signal * (t[1] - t[0]) * r.scrollDelta
            })
        };
        function OO(l) {
            return function(t, e, i, n) {
                var a = this._range
                  , r = a.slice()
                  , o = t.axisModels[0];
                if (o) {
                    var s = l(r, o, t, e, i, n);
                    return dI(s, r, [0, 100], "all"),
                    this._range = r,
                    a[0] !== r[0] || a[1] !== r[1] ? r : void 0
                }
            }
        }
        var RO = {
            grid: function(t, e, i, n, a) {
                var r = i.axis
                  , o = {}
                  , s = a.model.coordinateSystem.getRect();
                return t = t || [0, 0],
                "x" === r.dim ? (o.pixel = e[0] - t[0],
                o.pixelLength = s.width,
                o.pixelStart = s.x,
                o.signal = r.inverse ? 1 : -1) : (o.pixel = e[1] - t[1],
                o.pixelLength = s.height,
                o.pixelStart = s.y,
                o.signal = r.inverse ? -1 : 1),
                o
            },
            polar: function(t, e, i, n, a) {
                var r = i.axis
                  , o = {}
                  , s = a.model.coordinateSystem
                  , l = s.getRadiusAxis().getExtent()
                  , u = s.getAngleAxis().getExtent();
                return t = t ? s.pointToCoord(t) : [0, 0],
                e = s.pointToCoord(e),
                "radiusAxis" === i.mainType ? (o.pixel = e[0] - t[0],
                o.pixelLength = l[1] - l[0],
                o.pixelStart = l[0],
                o.signal = r.inverse ? 1 : -1) : (o.pixel = e[1] - t[1],
                o.pixelLength = u[1] - u[0],
                o.pixelStart = u[0],
                o.signal = r.inverse ? -1 : 1),
                o
            },
            singleAxis: function(t, e, i, n, a) {
                var r = i.axis
                  , o = a.model.coordinateSystem.getRect()
                  , s = {};
                return t = t || [0, 0],
                "horizontal" === r.orient ? (s.pixel = e[0] - t[0],
                s.pixelLength = o.width,
                s.pixelStart = o.x,
                s.signal = r.inverse ? 1 : -1) : (s.pixel = e[1] - t[1],
                s.pixelLength = o.height,
                s.pixelStart = o.y,
                s.signal = r.inverse ? -1 : 1),
                s
            }
        }
          , NO = it.createHashMap
          , EO = it.each;
        Gm.registerProcessor({
            getTargetSeries: function(t) {
                var a = NO();
                return t.eachComponent("dataZoom", function(t) {
                    t.eachTargetAxis(function(t, e, i) {
                        var n = i.getAxisProxy(t.name, e);
                        EO(n.getTargetSeriesModels(), function(t) {
                            a.set(t.uid, t)
                        })
                    })
                }),
                a
            },
            modifyOutputEnd: !0,
            overallReset: function(t, n) {
                t.eachComponent("dataZoom", function(t) {
                    t.eachTargetAxis(function(t, e, i) {
                        i.getAxisProxy(t.name, e).reset(i, n)
                    }),
                    t.eachTargetAxis(function(t, e, i) {
                        i.getAxisProxy(t.name, e).filterData(i, n)
                    })
                }),
                t.eachComponent("dataZoom", function(t) {
                    var e = t.findRepresentativeAxisProxy()
                      , i = e.getDataPercentWindow()
                      , n = e.getDataValueWindow();
                    t.setRawRange({
                        start: i[0],
                        end: i[1],
                        startValue: n[0],
                        endValue: n[1]
                    }, !0)
                })
            }
        }),
        Gm.registerAction("dataZoom", function(i, t) {
            var n = aO.createLinkedNodesFinder(it.bind(t.eachComponent, t, "dataZoom"), aO.eachAxisDim, function(t, e) {
                return t.get(e.axisIndex)
            })
              , a = [];
            t.eachComponent({
                mainType: "dataZoom",
                query: i
            }, function(t, e) {
                a.push.apply(a, n(t).nodes)
            }),
            it.each(a, function(t, e) {
                t.setRawRange({
                    start: i.start,
                    end: i.end,
                    startValue: i.startValue,
                    endValue: i.endValue
                })
            })
        });
        var zO = it.each;
        function VO(t, e) {
            return t && t.hasOwnProperty && t.hasOwnProperty(e)
        }
        function BO(t) {
            var e = t && t.visualMap;
            it.isArray(e) || (e = e ? [e] : []),
            zO(e, function(t) {
                if (t) {
                    VO(t, "splitList") && !VO(t, "pieces") && (t.pieces = t.splitList,
                    delete t.splitList);
                    var e = t.pieces;
                    e && it.isArray(e) && zO(e, function(t) {
                        it.isObject(t) && (VO(t, "start") && !VO(t, "min") && (t.min = t.start),
                        VO(t, "end") && !VO(t, "max") && (t.max = t.end))
                    })
                }
            })
        }
        Pl.registerSubTypeDefaulter("visualMap", function(t) {
            return t.categories || (t.pieces ? 0 < t.pieces.length : 0 < t.splitNumber) && !t.calculable ? "piecewise" : "continuous"
        });
        var GO = Gm.PRIORITY.VISUAL.COMPONENT;
        function FO(t, e, i, n) {
            for (var a = e.targetVisuals[n], r = lS.prepareVisualTypes(a), o = {
                color: t.getData().getVisual("color")
            }, s = 0, l = r.length; s < l; s++) {
                var u = r[s]
                  , h = a["opacity" === u ? "__alphaForOpacity" : u];
                h && h.applyVisual(i, c, d)
            }
            return o.color;
            function c(t) {
                return o[t]
            }
            function d(t, e) {
                o[t] = e
            }
        }
        Gm.registerVisual(GO, {
            createOnAllSeries: !0,
            reset: function(i, t) {
                var n = [];
                return t.eachComponent("visualMap", function(t) {
                    var e = i.pipelineContext;
                    !t.isTargetSeries(i) || e && e.large || n.push(ik.incrementalApplyVisual(t.stateList, t.targetVisuals, it.bind(t.getValueState, t), t.getDataDimension(i.getData())))
                }),
                n
            }
        }),
        Gm.registerVisual(GO, {
            createOnAllSeries: !0,
            reset: function(a, t) {
                var r = a.getData()
                  , o = [];
                t.eachComponent("visualMap", function(t) {
                    if (t.isTargetSeries(a)) {
                        var e = t.getVisualMeta(it.bind(FO, null, a, t)) || {
                            stops: [],
                            outerColors: []
                        }
                          , i = t.getDataDimension(r)
                          , n = r.getDimensionInfo(i);
                        null != n && (e.dimension = n.index,
                        o.push(e))
                    }
                }),
                a.getData().setVisual("visualMeta", o)
            }
        });
        var HO = {
            get: function(t, e, i) {
                var n = it.clone((WO[t] || {})[e]);
                return i && it.isArray(n) ? n[n.length - 1] : n
            }
        }
          , WO = {
            color: {
                active: ["#006edd", "#e0ffff"],
                inactive: ["rgba(0,0,0,0)"]
            },
            colorHue: {
                active: [0, 360],
                inactive: [0, 0]
            },
            colorSaturation: {
                active: [.3, 1],
                inactive: [0, 0]
            },
            colorLightness: {
                active: [.9, .5],
                inactive: [0, 0]
            },
            colorAlpha: {
                active: [.3, 1],
                inactive: [0, 0]
            },
            opacity: {
                active: [.3, 1],
                inactive: [0, 0]
            },
            symbol: {
                active: ["circle", "roundRect", "diamond"],
                inactive: ["none"]
            },
            symbolSize: {
                active: [10, 50],
                inactive: [0, 0]
            }
        }
          , ZO = HO
          , UO = lS.mapVisual
          , YO = lS.eachVisual
          , jO = it.isArray
          , XO = it.each
          , qO = ol.asc
          , KO = ol.linearMap
          , $O = it.noop
          , JO = Gm.extendComponentModel({
            type: "visualMap",
            dependencies: ["series"],
            stateList: ["inRange", "outOfRange"],
            replacableOptionKeys: ["inRange", "outOfRange", "target", "controller", "color"],
            dataBound: [-1 / 0, 1 / 0],
            layoutMode: {
                type: "box",
                ignoreSize: !0
            },
            defaultOption: {
                show: !0,
                zlevel: 0,
                z: 4,
                seriesIndex: "all",
                min: 0,
                max: 200,
                dimension: null,
                inRange: null,
                outOfRange: null,
                left: 0,
                right: null,
                top: null,
                bottom: 0,
                itemWidth: null,
                itemHeight: null,
                inverse: !1,
                orient: "vertical",
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "#ccc",
                contentColor: "#5793f3",
                inactiveColor: "#aaa",
                borderWidth: 0,
                padding: 5,
                textGap: 10,
                precision: 0,
                color: null,
                formatter: null,
                text: null,
                textStyle: {
                    color: "#333"
                }
            },
            init: function(t, e, i) {
                this._dataExtent,
                this.targetVisuals = {},
                this.controllerVisuals = {},
                this.textStyleModel,
                this.itemSize,
                this.mergeDefaultAndTheme(t, i)
            },
            optionUpdated: function(t, e) {
                var i = this.option;
                et.canvasSupported || (i.realtime = !1),
                e || ik.replaceVisualOption(i, t, this.replacableOptionKeys),
                this.textStyleModel = this.getModel("textStyle"),
                this.resetItemSize(),
                this.completeVisualOption()
            },
            resetVisual: function(t) {
                var e = this.stateList;
                t = it.bind(t, this),
                this.controllerVisuals = ik.createVisualMappings(this.option.controller, e, t),
                this.targetVisuals = ik.createVisualMappings(this.option.target, e, t)
            },
            getTargetSeriesIndices: function() {
                var t = this.option.seriesIndex
                  , i = [];
                return null == t || "all" === t ? this.ecModel.eachSeries(function(t, e) {
                    i.push(e)
                }) : i = aa.normalizeToArray(t),
                i
            },
            eachTargetSeries: function(e, i) {
                it.each(this.getTargetSeriesIndices(), function(t) {
                    e.call(i, this.ecModel.getSeriesByIndex(t))
                }, this)
            },
            isTargetSeries: function(e) {
                var i = !1;
                return this.eachTargetSeries(function(t) {
                    t === e && (i = !0)
                }),
                i
            },
            formatValueText: function(t, e, i) {
                var n, a, r = this.option, o = r.precision, s = this.dataBound, l = r.formatter;
                return i = i || ["<", ">"],
                it.isArray(t) && (t = t.slice(),
                n = !0),
                a = e ? t : n ? [u(t[0]), u(t[1])] : u(t),
                it.isString(l) ? l.replace("{value}", n ? a[0] : a).replace("{value2}", n ? a[1] : a) : it.isFunction(l) ? n ? l(t[0], t[1]) : l(t) : n ? t[0] === s[0] ? i[0] + " " + a[1] : t[1] === s[1] ? i[1] + " " + a[0] : a[0] + " - " + a[1] : a;
                function u(t) {
                    return t === s[0] ? "min" : t === s[1] ? "max" : (+t).toFixed(Math.min(o, 20))
                }
            },
            resetExtent: function() {
                var t = this.option
                  , e = qO([t.min, t.max]);
                this._dataExtent = e
            },
            getDataDimension: function(t) {
                var e = this.option.dimension
                  , i = t.dimensions;
                if (null != e || i.length) {
                    if (null != e)
                        return t.getDimension(e);
                    for (var n = t.dimensions, a = n.length - 1; 0 <= a; a--) {
                        var r = n[a];
                        if (!t.getDimensionInfo(r).isCalculationCoord)
                            return r
                    }
                }
            },
            getExtent: function() {
                return this._dataExtent.slice()
            },
            completeVisualOption: function() {
                var t = this.ecModel
                  , e = this.option
                  , i = {
                    inRange: e.inRange,
                    outOfRange: e.outOfRange
                }
                  , n = e.target || (e.target = {})
                  , a = e.controller || (e.controller = {});
                it.merge(n, i),
                it.merge(a, i);
                var u = this.isCategory();
                function r(n) {
                    jO(e.color) && !n.inRange && (n.inRange = {
                        color: e.color.slice().reverse()
                    }),
                    n.inRange = n.inRange || {
                        color: t.get("gradientColor")
                    },
                    XO(this.stateList, function(t) {
                        var e = n[t];
                        if (it.isString(e)) {
                            var i = ZO.get(e, "active", u);
                            i ? (n[t] = {},
                            n[t][e] = i) : delete n[t]
                        }
                    }, this)
                }
                r.call(this, n),
                r.call(this, a),
                function(t, e, i) {
                    var n = t[e]
                      , a = t[i];
                    n && !a && (a = t[i] = {},
                    XO(n, function(t, e) {
                        if (lS.isValidType(e)) {
                            var i = ZO.get(e, "inactive", u);
                            null != i && (a[e] = i,
                            "color" !== e || a.hasOwnProperty("opacity") || a.hasOwnProperty("colorAlpha") || (a.opacity = [0, 0]))
                        }
                    }))
                }
                .call(this, n, "inRange", "outOfRange"),
                function(r) {
                    var o = (r.inRange || {}).symbol || (r.outOfRange || {}).symbol
                      , s = (r.inRange || {}).symbolSize || (r.outOfRange || {}).symbolSize
                      , l = this.get("inactiveColor");
                    XO(this.stateList, function(t) {
                        var e = this.itemSize
                          , i = r[t];
                        null == (i = i || (r[t] = {
                            color: u ? l : [l]
                        })).symbol && (i.symbol = o && it.clone(o) || (u ? "roundRect" : ["roundRect"])),
                        null == i.symbolSize && (i.symbolSize = s && it.clone(s) || (u ? e[0] : [e[0], e[0]])),
                        i.symbol = UO(i.symbol, function(t) {
                            return "none" === t || "square" === t ? "roundRect" : t
                        });
                        var n = i.symbolSize;
                        if (null != n) {
                            var a = -1 / 0;
                            YO(n, function(t) {
                                a < t && (a = t)
                            }),
                            i.symbolSize = UO(n, function(t) {
                                return KO(t, [0, a], [0, e[0]], !0)
                            })
                        }
                    }, this)
                }
                .call(this, a)
            },
            resetItemSize: function() {
                this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))]
            },
            isCategory: function() {
                return !!this.option.categories
            },
            setSelected: $O,
            getValueState: $O,
            getVisualMeta: $O
        })
          , QO = [20, 140]
          , tR = JO.extend({
            type: "visualMap.continuous",
            defaultOption: {
                align: "auto",
                calculable: !1,
                range: null,
                realtime: !0,
                itemHeight: null,
                itemWidth: null,
                hoverLink: !0,
                hoverLinkDataSize: null,
                hoverLinkOnHandle: null
            },
            optionUpdated: function(t, e) {
                tR.superApply(this, "optionUpdated", arguments),
                this.resetExtent(),
                this.resetVisual(function(t) {
                    t.mappingMethod = "linear",
                    t.dataExtent = this.getExtent()
                }),
                this._resetRange()
            },
            resetItemSize: function() {
                tR.superApply(this, "resetItemSize", arguments);
                var t = this.itemSize;
                "horizontal" === this._orient && t.reverse(),
                null != t[0] && !isNaN(t[0]) || (t[0] = QO[0]),
                null != t[1] && !isNaN(t[1]) || (t[1] = QO[1])
            },
            _resetRange: function() {
                var t = this.getExtent()
                  , e = this.option.range;
                !e || e.auto ? (t.auto = 1,
                this.option.range = t) : it.isArray(e) && (e[0] > e[1] && e.reverse(),
                e[0] = Math.max(e[0], t[0]),
                e[1] = Math.min(e[1], t[1]))
            },
            completeVisualOption: function() {
                JO.prototype.completeVisualOption.apply(this, arguments),
                it.each(this.stateList, function(t) {
                    var e = this.option.controller[t].symbolSize;
                    e && e[0] !== e[1] && (e[0] = 0)
                }, this)
            },
            setSelected: function(t) {
                this.option.range = t.slice(),
                this._resetRange()
            },
            getSelected: function() {
                var t = this.getExtent()
                  , e = ol.asc((this.get("range") || []).slice());
                return e[0] > t[1] && (e[0] = t[1]),
                e[1] > t[1] && (e[1] = t[1]),
                e[0] < t[0] && (e[0] = t[0]),
                e[1] < t[0] && (e[1] = t[0]),
                e
            },
            getValueState: function(t) {
                var e = this.option.range
                  , i = this.getExtent();
                return (e[0] <= i[0] || e[0] <= t) && (e[1] >= i[1] || t <= e[1]) ? "inRange" : "outOfRange"
            },
            findTargetDataIndices: function(n) {
                var a = [];
                return this.eachTargetSeries(function(t) {
                    var i = []
                      , e = t.getData();
                    e.each(this.getDataDimension(e), function(t, e) {
                        n[0] <= t && t <= n[1] && i.push(e)
                    }, this),
                    a.push({
                        seriesId: t.id,
                        dataIndex: i
                    })
                }, this),
                a
            },
            getVisualMeta: function(i) {
                var t = eR(this, "outOfRange", this.getExtent())
                  , e = eR(this, "inRange", this.option.range.slice())
                  , n = [];
                function a(t, e) {
                    n.push({
                        value: t,
                        color: i(t, e)
                    })
                }
                for (var r = 0, o = 0, s = e.length, l = t.length; o < l && (!e.length || t[o] <= e[0]); o++)
                    t[o] < e[r] && a(t[o], "outOfRange");
                for (var u = 1; r < s; r++,
                u = 0)
                    u && n.length && a(e[r], "outOfRange"),
                    a(e[r], "inRange");
                for (u = 1; o < l; o++)
                    (!e.length || e[e.length - 1] < t[o]) && (u && (n.length && a(n[n.length - 1].value, "outOfRange"),
                    u = 0),
                    a(t[o], "outOfRange"));
                var h = n.length;
                return {
                    stops: n,
                    outerColors: [h ? n[0].color : "transparent", h ? n[h - 1].color : "transparent"]
                }
            }
        });
        function eR(t, e, i) {
            if (i[0] === i[1])
                return i.slice();
            for (var n = (i[1] - i[0]) / 200, a = i[0], r = [], o = 0; o <= 200 && a < i[1]; o++)
                r.push(a),
                a += n;
            return r.push(i[1]),
            r
        }
        var iR = Gm.extendComponentView({
            type: "visualMap",
            autoPositionValues: {
                left: 1,
                right: 1,
                top: 1,
                bottom: 1
            },
            init: function(t, e) {
                this.ecModel = t,
                this.api = e,
                this.visualMapModel
            },
            render: function(t, e, i, n) {
                !1 !== (this.visualMapModel = t).get("show") ? this.doRender.apply(this, arguments) : this.group.removeAll()
            },
            renderBackground: function(t) {
                var e = this.visualMapModel
                  , i = fl.normalizeCssArray(e.get("padding") || 0)
                  , n = t.getBoundingRect();
                t.add(new Fs.Rect({
                    z2: -1,
                    silent: !0,
                    shape: {
                        x: n.x - i[3],
                        y: n.y - i[0],
                        width: n.width + i[3] + i[1],
                        height: n.height + i[0] + i[2]
                    },
                    style: {
                        fill: e.get("backgroundColor"),
                        stroke: e.get("borderColor"),
                        lineWidth: e.get("borderWidth")
                    }
                }))
            },
            getControllerVisual: function(i, n, a) {
                var t = (a = a || {}).forceState
                  , e = this.visualMapModel
                  , r = {};
                if ("symbol" === n && (r.symbol = e.get("itemSymbol")),
                "color" === n) {
                    var o = e.get("contentColor");
                    r.color = o
                }
                function s(t) {
                    return r[t]
                }
                function l(t, e) {
                    r[t] = e
                }
                var u = e.controllerVisuals[t || e.getValueState(i)]
                  , h = lS.prepareVisualTypes(u);
                return it.each(h, function(t) {
                    var e = u[t];
                    a.convertOpacityToAlpha && "opacity" === t && (t = "colorAlpha",
                    e = u.__alphaForOpacity),
                    lS.dependsOn(t, n) && e && e.applyVisual(i, s, l)
                }),
                r[n]
            },
            positionGroup: function(t) {
                var e = this.visualMapModel
                  , i = this.api;
                Il.positionElement(t, e.getBoxLayoutParams(), {
                    width: i.getWidth(),
                    height: i.getHeight()
                })
            },
            doRender: it.noop
        })
          , nR = Il.getLayoutRect;
        var aR = {
            getItemAlign: function(t, e, i) {
                var n = t.option
                  , a = n.align;
                if (null != a && "auto" !== a)
                    return a;
                for (var r = {
                    width: e.getWidth(),
                    height: e.getHeight()
                }, o = "horizontal" === n.orient ? 1 : 0, s = [["left", "right", "width"], ["top", "bottom", "height"]], l = s[o], u = [0, null, 10], h = {}, c = 0; c < 3; c++)
                    h[s[1 - o][c]] = u[c],
                    h[l[c]] = 2 === c ? i[0] : n[l[c]];
                var d = [["x", "width", 3], ["y", "height", 0]][o]
                  , p = nR(h, r, n.padding);
                return l[(p.margin[d[2]] || 0) + p[d[0]] + .5 * p[d[1]] < .5 * r[d[1]] ? 0 : 1]
            },
            convertDataIndex: function(e) {
                return it.each(e || [], function(t) {
                    null != e.dataIndex && (e.dataIndexInside = e.dataIndex,
                    e.dataIndex = null)
                }),
                e
            }
        }
          , rR = ol.linearMap
          , oR = it.each
          , sR = Math.min
          , lR = Math.max
          , uR = iR.extend({
            type: "visualMap.continuous",
            init: function() {
                uR.superApply(this, "init", arguments),
                this._shapes = {},
                this._dataInterval = [],
                this._handleEnds = [],
                this._orient,
                this._useHandle,
                this._hoverLinkDataIndices = [],
                this._dragging,
                this._hovering
            },
            doRender: function(t, e, i, n) {
                n && "selectDataRange" === n.type && n.from === this.uid || this._buildView()
            },
            _buildView: function() {
                this.group.removeAll();
                var t = this.visualMapModel
                  , e = this.group;
                this._orient = t.get("orient"),
                this._useHandle = t.get("calculable"),
                this._resetInterval(),
                this._renderBar(e);
                var i = t.get("text");
                this._renderEndsText(e, i, 0),
                this._renderEndsText(e, i, 1),
                this._updateView(!0),
                this.renderBackground(e),
                this._updateView(),
                this._enableHoverLinkToSeries(),
                this._enableHoverLinkFromSeries(),
                this.positionGroup(e)
            },
            _renderEndsText: function(t, e, i) {
                if (e) {
                    var n = e[1 - i];
                    n = null != n ? n + "" : "";
                    var a = this.visualMapModel
                      , r = a.get("textGap")
                      , o = a.itemSize
                      , s = this._shapes.barGroup
                      , l = this._applyTransform([o[0] / 2, 0 === i ? -r : o[1] + r], s)
                      , u = this._applyTransform(0 === i ? "bottom" : "top", s)
                      , h = this._orient
                      , c = this.visualMapModel.textStyleModel;
                    this.group.add(new Fs.Text({
                        style: {
                            x: l[0],
                            y: l[1],
                            textVerticalAlign: "horizontal" === h ? "middle" : u,
                            textAlign: "horizontal" === h ? u : "center",
                            text: n,
                            textFont: c.getFont(),
                            textFill: c.getTextColor()
                        }
                    }))
                }
            },
            _renderBar: function(t) {
                var e = this.visualMapModel
                  , i = this._shapes
                  , n = e.itemSize
                  , a = this._orient
                  , r = this._useHandle
                  , o = aR.getItemAlign(e, this.api, n)
                  , s = i.barGroup = this._createBarGroup(o);
                s.add(i.outOfRange = hR()),
                s.add(i.inRange = hR(null, r ? dR(this._orient) : null, it.bind(this._dragHandle, this, "all", !1), it.bind(this._dragHandle, this, "all", !0)));
                var l = e.textStyleModel.getTextRect("")
                  , u = lR(l.width, l.height);
                r && (i.handleThumbs = [],
                i.handleLabels = [],
                i.handleLabelPoints = [],
                this._createHandle(s, 0, n, u, a, o),
                this._createHandle(s, 1, n, u, a, o)),
                this._createIndicator(s, n, u, a),
                t.add(s)
            },
            _createHandle: function(t, e, i, n, a) {
                var r = it.bind(this._dragHandle, this, e, !1)
                  , o = it.bind(this._dragHandle, this, e, !0)
                  , s = hR(function(t, e) {
                    return 0 === t ? [[0, 0], [e, 0], [e, -e]] : [[0, 0], [e, 0], [e, e]]
                }(e, n), dR(this._orient), r, o);
                s.position[0] = i[0],
                t.add(s);
                var l = this.visualMapModel.textStyleModel
                  , u = new Fs.Text({
                    draggable: !0,
                    drift: r,
                    onmousemove: function(t) {
                        j.stop(t.event)
                    },
                    ondragend: o,
                    style: {
                        x: 0,
                        y: 0,
                        text: "",
                        textFont: l.getFont(),
                        textFill: l.getTextColor()
                    }
                });
                this.group.add(u);
                var h = ["horizontal" === a ? n / 2 : 1.5 * n, "horizontal" === a ? 0 === e ? -1.5 * n : 1.5 * n : 0 === e ? -n / 2 : n / 2]
                  , c = this._shapes;
                c.handleThumbs[e] = s,
                c.handleLabelPoints[e] = h,
                c.handleLabels[e] = u
            },
            _createIndicator: function(t, e, i, n) {
                var a = hR([[0, 0]], "move");
                a.position[0] = e[0],
                a.attr({
                    invisible: !0,
                    silent: !0
                }),
                t.add(a);
                var r = this.visualMapModel.textStyleModel
                  , o = new Fs.Text({
                    silent: !0,
                    invisible: !0,
                    style: {
                        x: 0,
                        y: 0,
                        text: "",
                        textFont: r.getFont(),
                        textFill: r.getTextColor()
                    }
                });
                this.group.add(o);
                var s = ["horizontal" === n ? i / 2 : 9, 0]
                  , l = this._shapes;
                l.indicator = a,
                l.indicatorLabel = o,
                l.indicatorLabelPoint = s
            },
            _dragHandle: function(t, e, i, n) {
                if (this._useHandle) {
                    if (this._dragging = !e,
                    !e) {
                        var a = this._applyTransform([i, n], this._shapes.barGroup, !0);
                        this._updateInterval(t, a[1]),
                        this._updateView()
                    }
                    e === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
                        type: "selectDataRange",
                        from: this.uid,
                        visualMapId: this.visualMapModel.id,
                        selected: this._dataInterval.slice()
                    }),
                    e ? this._hovering || this._clearHoverLinkToSeries() : cR(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[t], !1)
                }
            },
            _resetInterval: function() {
                var t = this.visualMapModel
                  , e = this._dataInterval = t.getSelected()
                  , i = t.getExtent()
                  , n = [0, t.itemSize[1]];
                this._handleEnds = [rR(e[0], i, n, !0), rR(e[1], i, n, !0)]
            },
            _updateInterval: function(t, e) {
                e = e || 0;
                var i = this.visualMapModel
                  , n = this._handleEnds
                  , a = [0, i.itemSize[1]];
                dI(e, n, a, t, 0);
                var r = i.getExtent();
                this._dataInterval = [rR(n[0], a, r, !0), rR(n[1], a, r, !0)]
            },
            _updateView: function(t) {
                var e = this.visualMapModel
                  , i = e.getExtent()
                  , n = this._shapes
                  , a = [0, e.itemSize[1]]
                  , r = t ? a : this._handleEnds
                  , o = this._createBarVisual(this._dataInterval, i, r, "inRange")
                  , s = this._createBarVisual(i, i, a, "outOfRange");
                n.inRange.setStyle({
                    fill: o.barColor,
                    opacity: o.opacity
                }).setShape("points", o.barPoints),
                n.outOfRange.setStyle({
                    fill: s.barColor,
                    opacity: s.opacity
                }).setShape("points", s.barPoints),
                this._updateHandle(r, o)
            },
            _createBarVisual: function(t, e, i, n) {
                var a = {
                    forceState: n,
                    convertOpacityToAlpha: !0
                }
                  , r = this._makeColorGradient(t, a)
                  , o = [this.getControllerVisual(t[0], "symbolSize", a), this.getControllerVisual(t[1], "symbolSize", a)]
                  , s = this._createBarPoints(i, o);
                return {
                    barColor: new Go(0,0,0,1,r),
                    barPoints: s,
                    handlesColor: [r[0].color, r[r.length - 1].color]
                }
            },
            _makeColorGradient: function(t, e) {
                var i = []
                  , n = (t[1] - t[0]) / 100;
                i.push({
                    color: this.getControllerVisual(t[0], "color", e),
                    offset: 0
                });
                for (var a = 1; a < 100; a++) {
                    var r = t[0] + n * a;
                    if (r > t[1])
                        break;
                    i.push({
                        color: this.getControllerVisual(r, "color", e),
                        offset: a / 100
                    })
                }
                return i.push({
                    color: this.getControllerVisual(t[1], "color", e),
                    offset: 1
                }),
                i
            },
            _createBarPoints: function(t, e) {
                var i = this.visualMapModel.itemSize;
                return [[i[0] - e[0], t[0]], [i[0], t[0]], [i[0], t[1]], [i[0] - e[1], t[1]]]
            },
            _createBarGroup: function(t) {
                var e = this._orient
                  , i = this.visualMapModel.get("inverse");
                return new Fs.Group("horizontal" !== e || i ? "horizontal" === e && i ? {
                    scale: "bottom" === t ? [-1, 1] : [1, 1],
                    rotation: -Math.PI / 2
                } : "vertical" !== e || i ? {
                    scale: "left" === t ? [1, 1] : [-1, 1]
                } : {
                    scale: "left" === t ? [1, -1] : [-1, -1]
                } : {
                    scale: "bottom" === t ? [1, 1] : [-1, 1],
                    rotation: Math.PI / 2
                })
            },
            _updateHandle: function(n, a) {
                if (this._useHandle) {
                    var r = this._shapes
                      , o = this.visualMapModel
                      , s = r.handleThumbs
                      , l = r.handleLabels;
                    oR([0, 1], function(t) {
                        var e = s[t];
                        e.setStyle("fill", a.handlesColor[t]),
                        e.position[1] = n[t];
                        var i = Fs.applyTransform(r.handleLabelPoints[t], Fs.getTransform(e, this.group));
                        l[t].setStyle({
                            x: i[0],
                            y: i[1],
                            text: o.formatValueText(this._dataInterval[t]),
                            textVerticalAlign: "middle",
                            textAlign: this._applyTransform("horizontal" === this._orient ? 0 === t ? "bottom" : "top" : "left", r.barGroup)
                        })
                    }, this)
                }
            },
            _showIndicator: function(t, e, i, n) {
                var a = this.visualMapModel
                  , r = a.getExtent()
                  , o = a.itemSize
                  , s = [0, o[1]]
                  , l = rR(t, r, s, !0)
                  , u = this._shapes
                  , h = u.indicator;
                if (h) {
                    h.position[1] = l,
                    h.attr("invisible", !1),
                    h.setShape("points", function(t, e, i, n) {
                        return t ? [[0, -sR(e, lR(i, 0))], [6, 0], [0, sR(e, lR(n - i, 0))]] : [[0, 0], [5, -5], [5, 5]]
                    }(!!i, n, l, o[1]));
                    var c = this.getControllerVisual(t, "color", {
                        convertOpacityToAlpha: !0
                    });
                    h.setStyle("fill", c);
                    var d = Fs.applyTransform(u.indicatorLabelPoint, Fs.getTransform(h, this.group))
                      , p = u.indicatorLabel;
                    p.attr("invisible", !1);
                    var f = this._applyTransform("left", u.barGroup)
                      , g = this._orient;
                    p.setStyle({
                        text: (i || "") + a.formatValueText(e),
                        textVerticalAlign: "horizontal" === g ? f : "middle",
                        textAlign: "horizontal" === g ? "center" : f,
                        x: d[0],
                        y: d[1]
                    })
                }
            },
            _enableHoverLinkToSeries: function() {
                var n = this;
                this._shapes.barGroup.on("mousemove", function(t) {
                    if (n._hovering = !0,
                    !n._dragging) {
                        var e = n.visualMapModel.itemSize
                          , i = n._applyTransform([t.offsetX, t.offsetY], n._shapes.barGroup, !0, !0);
                        i[1] = sR(lR(0, i[1]), e[1]),
                        n._doHoverLinkToSeries(i[1], 0 <= i[0] && i[0] <= e[0])
                    }
                }).on("mouseout", function() {
                    n._hovering = !1,
                    n._dragging || n._clearHoverLinkToSeries()
                })
            },
            _enableHoverLinkFromSeries: function() {
                var t = this.api.getZr();
                this.visualMapModel.option.hoverLink ? (t.on("mouseover", this._hoverLinkFromSeriesMouseOver, this),
                t.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries()
            },
            _doHoverLinkToSeries: function(t, e) {
                var i = this.visualMapModel
                  , n = i.itemSize;
                if (i.option.hoverLink) {
                    var a = [0, n[1]]
                      , r = i.getExtent();
                    t = sR(lR(a[0], t), a[1]);
                    var o = function(t, e, i) {
                        var n = 6
                          , a = t.get("hoverLinkDataSize");
                        a && (n = rR(a, e, i, !0) / 2);
                        return n
                    }(i, r, a)
                      , s = [t - o, t + o]
                      , l = rR(t, a, r, !0)
                      , u = [rR(s[0], a, r, !0), rR(s[1], a, r, !0)];
                    s[0] < a[0] && (u[0] = -1 / 0),
                    a[1] < s[1] && (u[1] = 1 / 0),
                    e && (u[0] === -1 / 0 ? this._showIndicator(l, u[1], "< ", o) : u[1] === 1 / 0 ? this._showIndicator(l, u[0], "> ", o) : this._showIndicator(l, l, " ", o));
                    var h = this._hoverLinkDataIndices
                      , c = [];
                    (e || cR(i)) && (c = this._hoverLinkDataIndices = i.findTargetDataIndices(u));
                    var d = aa.compressBatches(h, c);
                    this._dispatchHighDown("downplay", aR.convertDataIndex(d[0])),
                    this._dispatchHighDown("highlight", aR.convertDataIndex(d[1]))
                }
            },
            _hoverLinkFromSeriesMouseOver: function(t) {
                var e = t.target
                  , i = this.visualMapModel;
                if (e && null != e.dataIndex) {
                    var n = this.ecModel.getSeriesByIndex(e.seriesIndex);
                    if (i.isTargetSeries(n)) {
                        var a = n.getData(e.dataType)
                          , r = a.get(i.getDataDimension(a), e.dataIndex, !0);
                        isNaN(r) || this._showIndicator(r, r)
                    }
                }
            },
            _hideIndicator: function() {
                var t = this._shapes;
                t.indicator && t.indicator.attr("invisible", !0),
                t.indicatorLabel && t.indicatorLabel.attr("invisible", !0)
            },
            _clearHoverLinkToSeries: function() {
                this._hideIndicator();
                var t = this._hoverLinkDataIndices;
                this._dispatchHighDown("downplay", aR.convertDataIndex(t)),
                t.length = 0
            },
            _clearHoverLinkFromSeries: function() {
                this._hideIndicator();
                var t = this.api.getZr();
                t.off("mouseover", this._hoverLinkFromSeriesMouseOver),
                t.off("mouseout", this._hideIndicator)
            },
            _applyTransform: function(t, e, i, n) {
                var a = Fs.getTransform(e, n ? null : this.group);
                return Fs[it.isArray(t) ? "applyTransform" : "transformDirection"](t, a, i)
            },
            _dispatchHighDown: function(t, e) {
                e && e.length && this.api.dispatchAction({
                    type: t,
                    batch: e
                })
            },
            dispose: function() {
                this._clearHoverLinkFromSeries(),
                this._clearHoverLinkToSeries()
            },
            remove: function() {
                this._clearHoverLinkFromSeries(),
                this._clearHoverLinkToSeries()
            }
        });
        function hR(t, e, i, n) {
            return new Fs.Polygon({
                shape: {
                    points: t
                },
                draggable: !!i,
                cursor: e,
                drift: i,
                onmousemove: function(t) {
                    j.stop(t.event)
                },
                ondragend: n
            })
        }
        function cR(t) {
            var e = t.get("hoverLinkOnHandle");
            return !!(null == e ? t.get("realtime") : e)
        }
        function dR(t) {
            return "vertical" === t ? "ns-resize" : "ew-resize"
        }
        Gm.registerAction({
            type: "selectDataRange",
            event: "dataRangeSelected",
            update: "update"
        }, function(e, t) {
            t.eachComponent({
                mainType: "visualMap",
                query: e
            }, function(t) {
                t.setSelected(e.selected)
            })
        }),
        Gm.registerPreprocessor(BO);
        var pR = ol.reformIntervals
          , fR = JO.extend({
            type: "visualMap.piecewise",
            defaultOption: {
                selected: null,
                minOpen: !1,
                maxOpen: !1,
                align: "auto",
                itemWidth: 20,
                itemHeight: 14,
                itemSymbol: "roundRect",
                pieceList: null,
                categories: null,
                splitNumber: 5,
                selectedMode: "multiple",
                itemGap: 10,
                hoverLink: !0,
                showLabel: null
            },
            optionUpdated: function(t, e) {
                fR.superApply(this, "optionUpdated", arguments),
                this._pieceList = [],
                this.resetExtent();
                var i = this._mode = this._determineMode();
                gR[this._mode].call(this),
                this._resetSelected(t, e);
                var n = this.option.categories;
                this.resetVisual(function(t, e) {
                    "categories" === i ? (t.mappingMethod = "category",
                    t.categories = it.clone(n)) : (t.dataExtent = this.getExtent(),
                    t.mappingMethod = "piecewise",
                    t.pieceList = it.map(this._pieceList, function(t) {
                        t = it.clone(t);
                        return "inRange" !== e && (t.visual = null),
                        t
                    }))
                })
            },
            completeVisualOption: function() {
                var n = this.option
                  , i = {}
                  , t = lS.listVisualTypes()
                  , a = this.isCategory();
                function r(t, e, i) {
                    return t && t[e] && (it.isObject(t[e]) ? t[e].hasOwnProperty(i) : t[e] === i)
                }
                it.each(n.pieces, function(e) {
                    it.each(t, function(t) {
                        e.hasOwnProperty(t) && (i[t] = 1)
                    })
                }),
                it.each(i, function(t, e) {
                    var i = 0;
                    it.each(this.stateList, function(t) {
                        i |= r(n, t, e) || r(n.target, t, e)
                    }, this),
                    i || it.each(this.stateList, function(t) {
                        (n[t] || (n[t] = {}))[e] = ZO.get(e, "inRange" === t ? "active" : "inactive", a)
                    })
                }, this),
                JO.prototype.completeVisualOption.apply(this, arguments)
            },
            _resetSelected: function(t, e) {
                var i = this.option
                  , n = this._pieceList
                  , a = (e ? i : t).selected || {};
                if (i.selected = a,
                it.each(n, function(t, e) {
                    var i = this.getSelectedMapKey(t);
                    a.hasOwnProperty(i) || (a[i] = !0)
                }, this),
                "single" === i.selectedMode) {
                    var r = !1;
                    it.each(n, function(t, e) {
                        var i = this.getSelectedMapKey(t);
                        a[i] && (r ? a[i] = !1 : r = !0)
                    }, this)
                }
            },
            getSelectedMapKey: function(t) {
                return "categories" === this._mode ? t.value + "" : t.index + ""
            },
            getPieceList: function() {
                return this._pieceList
            },
            _determineMode: function() {
                var t = this.option;
                return t.pieces && 0 < t.pieces.length ? "pieces" : this.option.categories ? "categories" : "splitNumber"
            },
            setSelected: function(t) {
                this.option.selected = it.clone(t)
            },
            getValueState: function(t) {
                var e = lS.findPieceIndex(t, this._pieceList);
                return null != e && this.option.selected[this.getSelectedMapKey(this._pieceList[e])] ? "inRange" : "outOfRange"
            },
            findTargetDataIndices: function(n) {
                var a = [];
                return this.eachTargetSeries(function(t) {
                    var i = []
                      , e = t.getData();
                    e.each(this.getDataDimension(e), function(t, e) {
                        lS.findPieceIndex(t, this._pieceList) === n && i.push(e)
                    }, this),
                    a.push({
                        seriesId: t.id,
                        dataIndex: i
                    })
                }, this),
                a
            },
            getRepresentValue: function(t) {
                var e;
                if (this.isCategory())
                    e = t.value;
                else if (null != t.value)
                    e = t.value;
                else {
                    var i = t.interval || [];
                    e = i[0] === -1 / 0 && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2
                }
                return e
            },
            getVisualMeta: function(a) {
                if (!this.isCategory()) {
                    var r = []
                      , o = []
                      , s = this
                      , t = this._pieceList.slice();
                    if (t.length) {
                        var e = t[0].interval[0];
                        e !== -1 / 0 && t.unshift({
                            interval: [-1 / 0, e]
                        }),
                        (e = t[t.length - 1].interval[1]) !== 1 / 0 && t.push({
                            interval: [e, 1 / 0]
                        })
                    } else
                        t.push({
                            interval: [-1 / 0, 1 / 0]
                        });
                    var i = -1 / 0;
                    return it.each(t, function(t) {
                        var e = t.interval;
                        e && (e[0] > i && n([i, e[0]], "outOfRange"),
                        n(e.slice()),
                        i = e[1])
                    }, this),
                    {
                        stops: r,
                        outerColors: o
                    }
                }
                function n(t, e) {
                    var i = s.getRepresentValue({
                        interval: t
                    });
                    e = e || s.getValueState(i);
                    var n = a(i, e);
                    t[0] === -1 / 0 ? o[0] = n : t[1] === 1 / 0 ? o[1] = n : r.push({
                        value: t[0],
                        color: n
                    }, {
                        value: t[1],
                        color: n
                    })
                }
            }
        })
          , gR = {
            splitNumber: function() {
                var t = this.option
                  , e = this._pieceList
                  , i = Math.min(t.precision, 20)
                  , n = this.getExtent()
                  , a = t.splitNumber;
                a = Math.max(parseInt(a, 10), 1),
                t.splitNumber = a;
                for (var r = (n[1] - n[0]) / a; +r.toFixed(i) !== r && i < 5; )
                    i++;
                t.precision = i,
                r = +r.toFixed(i);
                var o = 0;
                t.minOpen && e.push({
                    index: o++,
                    interval: [-1 / 0, n[0]],
                    close: [0, 0]
                });
                for (var s = n[0], l = o + a; o < l; s += r) {
                    var u = o === a - 1 ? n[1] : s + r;
                    e.push({
                        index: o++,
                        interval: [s, u],
                        close: [1, 1]
                    })
                }
                t.maxOpen && e.push({
                    index: o++,
                    interval: [n[1], 1 / 0],
                    close: [0, 0]
                }),
                pR(e),
                it.each(e, function(t) {
                    t.text = this.formatValueText(t.interval)
                }, this)
            },
            categories: function() {
                var t = this.option;
                it.each(t.categories, function(t) {
                    this._pieceList.push({
                        text: this.formatValueText(t, !0),
                        value: t
                    })
                }, this),
                mR(t, this._pieceList)
            },
            pieces: function() {
                var t = this.option
                  , d = this._pieceList;
                it.each(t.pieces, function(t, e) {
                    it.isObject(t) || (t = {
                        value: t
                    });
                    var i = {
                        text: "",
                        index: e
                    };
                    if (null != t.label && (i.text = t.label),
                    t.hasOwnProperty("value")) {
                        var n = i.value = t.value;
                        i.interval = [n, n],
                        i.close = [1, 1]
                    } else {
                        for (var a = i.interval = [], r = i.close = [0, 0], o = [1, 0, 1], s = [-1 / 0, 1 / 0], l = [], u = 0; u < 2; u++) {
                            for (var h = [["gte", "gt", "min"], ["lte", "lt", "max"]][u], c = 0; c < 3 && null == a[u]; c++)
                                a[u] = t[h[c]],
                                r[u] = o[c],
                                l[u] = 2 === c;
                            null == a[u] && (a[u] = s[u])
                        }
                        l[0] && a[1] === 1 / 0 && (r[0] = 0),
                        l[1] && a[0] === -1 / 0 && (r[1] = 0),
                        a[0] === a[1] && r[0] && r[1] && (i.value = a[0])
                    }
                    i.visual = lS.retrieveVisuals(t),
                    d.push(i)
                }, this),
                mR(t, d),
                pR(d),
                it.each(d, function(t) {
                    var e = t.close
                      , i = [["<", ""][e[1]], [">", ""][e[0]]];
                    t.text = t.text || this.formatValueText(null != t.value ? t.value : t.interval, !1, i)
                }, this)
            }
        };
        function mR(t, e) {
            var i = t.inverse;
            ("vertical" === t.orient ? !i : i) && e.reverse()
        }
        var vR = Fg.createSymbol;
        iR.extend({
            type: "visualMap.piecewise",
            doRender: function() {
                var r = this.group;
                r.removeAll();
                var o = this.visualMapModel
                  , s = o.get("textGap")
                  , t = o.textStyleModel
                  , l = t.getFont()
                  , u = t.getTextColor()
                  , h = this._getItemAlign()
                  , c = o.itemSize
                  , e = this._getViewData()
                  , i = e.endsText
                  , d = it.retrieve(o.get("showLabel", !0), !i);
                i && this._renderEndsText(r, i[0], c, d, h),
                it.each(e.viewPieceList, function(t) {
                    var e = t.piece
                      , i = new Fs.Group;
                    i.onclick = it.bind(this._onItemClick, this, e),
                    this._enableHoverLink(i, t.indexInModelPieceList);
                    var n = o.getRepresentValue(e);
                    if (this._createItemSymbol(i, n, [0, 0, c[0], c[1]]),
                    d) {
                        var a = this.visualMapModel.getValueState(n);
                        i.add(new Fs.Text({
                            style: {
                                x: "right" === h ? -s : c[0] + s,
                                y: c[1] / 2,
                                text: e.text,
                                textVerticalAlign: "middle",
                                textAlign: h,
                                textFont: l,
                                textFill: u,
                                opacity: "outOfRange" === a ? .5 : 1
                            }
                        }))
                    }
                    r.add(i)
                }, this),
                i && this._renderEndsText(r, i[1], c, d, h),
                Il.box(o.get("orient"), r, o.get("itemGap")),
                this.renderBackground(r),
                this.positionGroup(r)
            },
            _enableHoverLink: function(t, i) {
                function e(t) {
                    var e = this.visualMapModel;
                    e.option.hoverLink && this.api.dispatchAction({
                        type: t,
                        batch: aR.convertDataIndex(e.findTargetDataIndices(i))
                    })
                }
                t.on("mouseover", it.bind(e, this, "highlight")).on("mouseout", it.bind(e, this, "downplay"))
            },
            _getItemAlign: function() {
                var t = this.visualMapModel
                  , e = t.option;
                if ("vertical" === e.orient)
                    return aR.getItemAlign(t, this.api, t.itemSize);
                var i = e.align;
                return i && "auto" !== i || (i = "left"),
                i
            },
            _renderEndsText: function(t, e, i, n, a) {
                if (e) {
                    var r = new Fs.Group
                      , o = this.visualMapModel.textStyleModel;
                    r.add(new Fs.Text({
                        style: {
                            x: n ? "right" === a ? i[0] : 0 : i[0] / 2,
                            y: i[1] / 2,
                            textVerticalAlign: "middle",
                            textAlign: n ? a : "center",
                            text: e,
                            textFont: o.getFont(),
                            textFill: o.getTextColor()
                        }
                    })),
                    t.add(r)
                }
            },
            _getViewData: function() {
                var t = this.visualMapModel
                  , e = it.map(t.getPieceList(), function(t, e) {
                    return {
                        piece: t,
                        indexInModelPieceList: e
                    }
                })
                  , i = t.get("text")
                  , n = t.get("orient")
                  , a = t.get("inverse");
                return ("horizontal" === n ? a : !a) ? e.reverse() : i = i && i.slice().reverse(),
                {
                    viewPieceList: e,
                    endsText: i
                }
            },
            _createItemSymbol: function(t, e, i) {
                t.add(vR(this.getControllerVisual(e, "symbol"), i[0], i[1], i[2], i[3], this.getControllerVisual(e, "color")))
            },
            _onItemClick: function(t) {
                var e = this.visualMapModel
                  , i = e.option
                  , n = it.clone(i.selected)
                  , a = e.getSelectedMapKey(t);
                "single" === i.selectedMode ? (n[a] = !0,
                it.each(n, function(t, e) {
                    n[e] = e === a
                })) : n[a] = !n[a],
                this.api.dispatchAction({
                    type: "selectDataRange",
                    from: this.uid,
                    visualMapId: this.visualMapModel.id,
                    selected: n
                })
            }
        });
        Gm.registerPreprocessor(BO);
        var yR = fl.addCommas
          , xR = fl.encodeHTML;
        function _R(t) {
            aa.defaultEmphasis(t, "label", ["show"])
        }
        var bR = Gm.extendComponentModel({
            type: "marker",
            dependencies: ["series", "grid", "polar", "geo"],
            init: function(t, e, i, n) {
                this.mergeDefaultAndTheme(t, i),
                this.mergeOption(t, i, n.createdBySelf, !0)
            },
            isAnimationEnabled: function() {
                if (et.node)
                    return !1;
                var t = this.__hostSeries;
                return this.getShallow("animation") && t && t.isAnimationEnabled()
            },
            mergeOption: function(t, n, e, a) {
                var r = this.constructor
                  , o = this.mainType + "Model";
                e || n.eachSeries(function(t) {
                    var e = t.get(this.mainType, !0)
                      , i = t[o];
                    e && e.data ? (i ? i.mergeOption(e, n, !0) : (a && _R(e),
                    it.each(e.data, function(t) {
                        t instanceof Array ? (_R(t[0]),
                        _R(t[1])) : _R(t)
                    }),
                    i = new r(e,this,n),
                    it.extend(i, {
                        mainType: this.mainType,
                        seriesIndex: t.seriesIndex,
                        name: t.name,
                        createdBySelf: !0
                    }),
                    i.__hostSeries = t),
                    t[o] = i) : t[o] = null
                }, this)
            },
            formatTooltip: function(t) {
                var e = this.getData()
                  , i = this.getRawValue(t)
                  , n = it.isArray(i) ? it.map(i, yR).join(", ") : yR(i)
                  , a = e.getName(t)
                  , r = xR(this.name);
                return null == i && !a || (r += "<br />"),
                a && (r += xR(a),
                null != i && (r += " : ")),
                null != i && (r += xR(n)),
                r
            },
            getData: function() {
                return this._data
            },
            setData: function(t) {
                this._data = t
            }
        });
        it.mixin(bR, $h);
        var wR = bR
          , SR = (wR.extend({
            type: "markPoint",
            defaultOption: {
                zlevel: 0,
                z: 5,
                symbol: "pin",
                symbolSize: 50,
                tooltip: {
                    trigger: "item"
                },
                label: {
                    show: !0,
                    position: "inside"
                },
                itemStyle: {
                    borderWidth: 2
                },
                emphasis: {
                    label: {
                        show: !0
                    }
                }
            }
        }),
        vf.isDimensionStacked)
          , MR = it.indexOf;
        function IR(t, e, i, n, a, r) {
            var o = []
              , s = SR(e, n) ? e.getCalculationInfo("stackResultDimension") : n
              , l = DR(e, s, t)
              , u = e.indicesOfNearest(s, l)[0];
            o[a] = e.get(i, u),
            o[r] = e.get(n, u);
            var h = ol.getPrecision(e.get(n, u));
            return 0 <= (h = Math.min(h, 20)) && (o[r] = +o[r].toFixed(h)),
            o
        }
        var AR = it.curry
          , TR = {
            min: AR(IR, "min"),
            max: AR(IR, "max"),
            average: AR(IR, "average")
        };
        function CR(t, e, i, n) {
            var a = {};
            return null != t.valueIndex || null != t.valueDim ? (a.valueDataDim = null != t.valueIndex ? e.getDimension(t.valueIndex) : t.valueDim,
            a.valueAxis = i.getAxis(function(t, e) {
                var i = t.getData()
                  , n = i.dimensions;
                e = i.getDimension(e);
                for (var a = 0; a < n.length; a++) {
                    var r = i.getDimensionInfo(n[a]);
                    if (r.name === e)
                        return r.coordDim
                }
            }(n, a.valueDataDim)),
            a.baseAxis = i.getOtherAxis(a.valueAxis),
            a.baseDataDim = e.mapDimension(a.baseAxis.dim)) : (a.baseAxis = n.getBaseAxis(),
            a.valueAxis = i.getOtherAxis(a.baseAxis),
            a.baseDataDim = e.mapDimension(a.baseAxis.dim),
            a.valueDataDim = e.mapDimension(a.valueAxis.dim)),
            a
        }
        function DR(t, e, i) {
            if ("average" !== i)
                return "median" === i ? t.getMedian(e) : t.getDataExtent(e, !0)["max" === i ? 1 : 0];
            var n = 0
              , a = 0;
            return t.each(e, function(t, e) {
                isNaN(t) || (n += t,
                a++)
            }),
            n / a
        }
        var LR = {
            dataTransform: function(t, e) {
                var i = t.getData()
                  , n = t.coordinateSystem;
                if (e && !function(t) {
                    return !isNaN(parseFloat(t.x)) && !isNaN(parseFloat(t.y))
                }(e) && !it.isArray(e.coord) && n) {
                    var a = n.dimensions
                      , r = CR(e, i, n, t);
                    if ((e = it.clone(e)).type && TR[e.type] && r.baseAxis && r.valueAxis) {
                        var o = MR(a, r.baseAxis.dim)
                          , s = MR(a, r.valueAxis.dim);
                        e.coord = TR[e.type](i, r.baseDataDim, r.valueDataDim, o, s),
                        e.value = e.coord[s]
                    } else {
                        for (var l = [null != e.xAxis ? e.xAxis : e.radiusAxis, null != e.yAxis ? e.yAxis : e.angleAxis], u = 0; u < 2; u++)
                            TR[l[u]] && (l[u] = DR(i, i.mapDimension(a[u]), l[u]));
                        e.coord = l
                    }
                }
                return e
            },
            getAxisInfo: CR,
            dataFilter: function(t, e) {
                return !(t && t.containData && e.coord && !function(t) {
                    return !(isNaN(parseFloat(t.x)) && isNaN(parseFloat(t.y)))
                }(e)) || t.containData(e.coord)
            },
            dimValueGetter: function(t, e, i, n) {
                return n < 2 ? t.coord && t.coord[n] : t.value
            },
            numCalculate: DR
        }
          , PR = Gm.extendComponentView({
            type: "marker",
            init: function() {
                this.markerGroupMap = it.createHashMap()
            },
            render: function(t, i, n) {
                var e = this.markerGroupMap;
                e.each(function(t) {
                    t.__keep = !1
                });
                var a = this.type + "Model";
                i.eachSeries(function(t) {
                    var e = t[a];
                    e && this.renderSeries(t, e, i, n)
                }, this),
                e.each(function(t) {
                    t.__keep || this.group.remove(t.group)
                }, this)
            },
            renderSeries: function() {}
        });
        function kR(s, l, u) {
            var h = l.coordinateSystem;
            s.each(function(t) {
                var e, i = s.getItemModel(t), n = ol.parsePercent(i.get("x"), u.getWidth()), a = ol.parsePercent(i.get("y"), u.getHeight());
                if (isNaN(n) || isNaN(a)) {
                    if (l.getMarkerPosition)
                        e = l.getMarkerPosition(s.getValues(s.dimensions, t));
                    else if (h) {
                        var r = s.get(h.dimensions[0], t)
                          , o = s.get(h.dimensions[1], t);
                        e = h.dataToPoint([r, o])
                    }
                } else
                    e = [n, a];
                isNaN(n) || (e[0] = n),
                isNaN(a) || (e[1] = a),
                s.setItemLayout(t, e)
            })
        }
        PR.extend({
            type: "markPoint",
            updateTransform: function(t, e, i) {
                e.eachSeries(function(t) {
                    var e = t.markPointModel;
                    e && (kR(e.getData(), t, i),
                    this.markerGroupMap.get(t.id).updateLayout(e))
                }, this)
            },
            renderSeries: function(t, n, e, i) {
                var a = t.coordinateSystem
                  , r = t.id
                  , o = t.getData()
                  , s = this.markerGroupMap
                  , l = s.get(r) || s.set(r, new dv)
                  , u = function(t, i, e) {
                    var n;
                    n = t ? it.map(t && t.dimensions, function(t) {
                        var e = i.getData().getDimensionInfo(i.getData().mapDimension(t)) || {};
                        return it.defaults({
                            name: t
                        }, e)
                    }) : [{
                        name: "value",
                        type: "float"
                    }];
                    var a = new Qp(n,e)
                      , r = it.map(e.get("data"), it.curry(LR.dataTransform, i));
                    t && (r = it.filter(r, it.curry(LR.dataFilter, t)));
                    return a.initData(r, null, t ? LR.dimValueGetter : function(t) {
                        return t.value
                    }
                    ),
                    a
                }(a, t, n);
                n.setData(u),
                kR(n.getData(), t, i),
                u.each(function(t) {
                    var e = u.getItemModel(t)
                      , i = e.getShallow("symbolSize");
                    "function" == typeof i && (i = i(n.getRawValue(t), n.getDataParams(t))),
                    u.setItemVisual(t, {
                        symbolSize: i,
                        color: e.get("itemStyle.color") || o.getVisual("color"),
                        symbol: e.getShallow("symbol")
                    })
                }),
                l.updateData(u),
                this.group.add(l.group),
                u.eachItemGraphicEl(function(t) {
                    t.traverse(function(t) {
                        t.dataModel = n
                    })
                }),
                l.__keep = !0,
                l.group.silent = n.get("silent") || t.get("silent")
            }
        });
        Gm.registerPreprocessor(function(t) {
            t.markPoint = t.markPoint || {}
        });
        function OR(t, e, i, n) {
            var a = t.getData()
              , r = n.type;
            if (!it.isArray(n) && ("min" === r || "max" === r || "average" === r || "median" === r || null != n.xAxis || null != n.yAxis)) {
                var o, s;
                if (null != n.yAxis || null != n.xAxis)
                    o = null != n.yAxis ? "y" : "x",
                    e.getAxis(o),
                    s = it.retrieve(n.yAxis, n.xAxis);
                else {
                    var l = LR.getAxisInfo(n, a, e, t);
                    o = l.valueDataDim,
                    l.valueAxis,
                    s = LR.numCalculate(a, o, r)
                }
                var u = "x" === o ? 0 : 1
                  , h = 1 - u
                  , c = it.clone(n)
                  , d = {};
                c.type = null,
                c.coord = [],
                d.coord = [],
                c.coord[h] = -1 / 0,
                d.coord[h] = 1 / 0;
                var p = i.get("precision");
                0 <= p && "number" == typeof s && (s = +s.toFixed(Math.min(p, 20))),
                c.coord[u] = d.coord[u] = s,
                n = [c, d, {
                    type: r,
                    valueIndex: n.valueIndex,
                    value: s
                }]
            }
            return (n = [LR.dataTransform(t, n[0]), LR.dataTransform(t, n[1]), it.extend({}, n[2])])[2].type = n[2].type || "",
            it.merge(n[2], n[0]),
            it.merge(n[2], n[1]),
            n
        }
        wR.extend({
            type: "markLine",
            defaultOption: {
                zlevel: 0,
                z: 5,
                symbol: ["circle", "arrow"],
                symbolSize: [8, 16],
                precision: 2,
                tooltip: {
                    trigger: "item"
                },
                label: {
                    show: !0,
                    position: "end"
                },
                lineStyle: {
                    type: "dashed"
                },
                emphasis: {
                    label: {
                        show: !0
                    },
                    lineStyle: {
                        width: 3
                    }
                },
                animationEasing: "linear"
            }
        });
        function RR(t) {
            return !isNaN(t) && !isFinite(t)
        }
        function NR(t, e, i, n) {
            var a = 1 - t
              , r = n.dimensions[t];
            return RR(e[a]) && RR(i[a]) && e[t] === i[t] && n.getAxis(r).containData(e[t])
        }
        function ER(t, e) {
            if ("cartesian2d" === t.type) {
                var i = e[0].coord
                  , n = e[1].coord;
                if (i && n && (NR(1, i, n, t) || NR(0, i, n, t)))
                    return !0
            }
            return LR.dataFilter(t, e[0]) && LR.dataFilter(t, e[1])
        }
        function zR(t, e, i, n, a) {
            var r, o = n.coordinateSystem, s = t.getItemModel(e), l = ol.parsePercent(s.get("x"), a.getWidth()), u = ol.parsePercent(s.get("y"), a.getHeight());
            if (isNaN(l) || isNaN(u)) {
                if (n.getMarkerPosition)
                    r = n.getMarkerPosition(t.getValues(t.dimensions, e));
                else {
                    var h = o.dimensions
                      , c = t.get(h[0], e)
                      , d = t.get(h[1], e);
                    r = o.dataToPoint([c, d])
                }
                if ("cartesian2d" === o.type) {
                    var p = o.getAxis("x")
                      , f = o.getAxis("y");
                    h = o.dimensions;
                    RR(t.get(h[0], e)) ? r[0] = p.toGlobalCoord(p.getExtent()[i ? 0 : 1]) : RR(t.get(h[1], e)) && (r[1] = f.toGlobalCoord(f.getExtent()[i ? 0 : 1]))
                }
                isNaN(l) || (r[0] = l),
                isNaN(u) || (r[1] = u)
            } else
                r = [l, u];
            t.setItemLayout(e, r)
        }
        PR.extend({
            type: "markLine",
            updateTransform: function(t, e, r) {
                e.eachSeries(function(e) {
                    var t = e.markLineModel;
                    if (t) {
                        var i = t.getData()
                          , n = t.__from
                          , a = t.__to;
                        n.each(function(t) {
                            zR(n, t, !0, e, r),
                            zR(a, t, !1, e, r)
                        }),
                        i.each(function(t) {
                            i.setItemLayout(t, [n.getItemLayout(t), a.getItemLayout(t)])
                        }),
                        this.markerGroupMap.get(e.id).updateLayout()
                    }
                }, this)
            },
            renderSeries: function(a, i, t, r) {
                var e = a.coordinateSystem
                  , n = a.id
                  , o = a.getData()
                  , s = this.markerGroupMap
                  , l = s.get(n) || s.set(n, new lM);
                this.group.add(l.group);
                var u = function(t, i, e) {
                    var n;
                    n = t ? it.map(t && t.dimensions, function(t) {
                        var e = i.getData().getDimensionInfo(i.getData().mapDimension(t)) || {};
                        return it.defaults({
                            name: t
                        }, e)
                    }) : [{
                        name: "value",
                        type: "float"
                    }];
                    var a = new Qp(n,e)
                      , r = new Qp(n,e)
                      , o = new Qp([],e)
                      , s = it.map(e.get("data"), it.curry(OR, i, t, e));
                    t && (s = it.filter(s, it.curry(ER, t)));
                    var l = t ? LR.dimValueGetter : function(t) {
                        return t.value
                    }
                    ;
                    return a.initData(it.map(s, function(t) {
                        return t[0]
                    }), null, l),
                    r.initData(it.map(s, function(t) {
                        return t[1]
                    }), null, l),
                    o.initData(it.map(s, function(t) {
                        return t[2]
                    })),
                    o.hasItemOption = !0,
                    {
                        from: a,
                        to: r,
                        line: o
                    }
                }(e, a, i)
                  , h = u.from
                  , c = u.to
                  , d = u.line;
                i.__from = h,
                i.__to = c,
                i.setData(d);
                var p = i.get("symbol")
                  , f = i.get("symbolSize");
                function g(t, e, i) {
                    var n = t.getItemModel(e);
                    zR(t, e, i, a, r),
                    t.setItemVisual(e, {
                        symbolSize: n.get("symbolSize") || f[i ? 0 : 1],
                        symbol: n.get("symbol", !0) || p[i ? 0 : 1],
                        color: n.get("itemStyle.color") || o.getVisual("color")
                    })
                }
                it.isArray(p) || (p = [p, p]),
                "number" == typeof f && (f = [f, f]),
                u.from.each(function(t) {
                    g(h, t, !0),
                    g(c, t, !1)
                }),
                d.each(function(t) {
                    var e = d.getItemModel(t).get("lineStyle.color");
                    d.setItemVisual(t, {
                        color: e || h.getItemVisual(t, "color")
                    }),
                    d.setItemLayout(t, [h.getItemLayout(t), c.getItemLayout(t)]),
                    d.setItemVisual(t, {
                        fromSymbolSize: h.getItemVisual(t, "symbolSize"),
                        fromSymbol: h.getItemVisual(t, "symbol"),
                        toSymbolSize: c.getItemVisual(t, "symbolSize"),
                        toSymbol: c.getItemVisual(t, "symbol")
                    })
                }),
                l.updateData(d),
                u.line.eachItemGraphicEl(function(t, e) {
                    t.traverse(function(t) {
                        t.dataModel = i
                    })
                }),
                l.__keep = !0,
                l.group.silent = i.get("silent") || a.get("silent")
            }
        });
        Gm.registerPreprocessor(function(t) {
            t.markLine = t.markLine || {}
        });
        function VR(t, e, i, n) {
            var a = LR.dataTransform(t, n[0])
              , r = LR.dataTransform(t, n[1])
              , o = it.retrieve
              , s = a.coord
              , l = r.coord;
            s[0] = o(s[0], -1 / 0),
            s[1] = o(s[1], -1 / 0),
            l[0] = o(l[0], 1 / 0),
            l[1] = o(l[1], 1 / 0);
            var u = it.mergeAll([{}, a, r]);
            return u.coord = [a.coord, r.coord],
            u.x0 = a.x,
            u.y0 = a.y,
            u.x1 = r.x,
            u.y1 = r.y,
            u
        }
        wR.extend({
            type: "markArea",
            defaultOption: {
                zlevel: 0,
                z: 1,
                tooltip: {
                    trigger: "item"
                },
                animation: !1,
                label: {
                    show: !0,
                    position: "top"
                },
                itemStyle: {
                    borderWidth: 0
                },
                emphasis: {
                    label: {
                        show: !0,
                        position: "top"
                    }
                }
            }
        });
        function BR(t) {
            return !isNaN(t) && !isFinite(t)
        }
        function GR(t, e, i) {
            var n = 1 - t;
            return BR(e[n]) && BR(i[n])
        }
        function FR(t, e) {
            var i = e.coord[0]
              , n = e.coord[1];
            return !("cartesian2d" !== t.type || !i || !n || !GR(1, i, n) && !GR(0, i, n)) || (LR.dataFilter(t, {
                coord: i,
                x: e.x0,
                y: e.y0
            }) || LR.dataFilter(t, {
                coord: n,
                x: e.x1,
                y: e.y1
            }))
        }
        function HR(t, e, i, n, a) {
            var r, o = n.coordinateSystem, s = t.getItemModel(e), l = ol.parsePercent(s.get(i[0]), a.getWidth()), u = ol.parsePercent(s.get(i[1]), a.getHeight());
            if (isNaN(l) || isNaN(u)) {
                if (n.getMarkerPosition)
                    r = n.getMarkerPosition(t.getValues(i, e));
                else {
                    var h = [p = t.get(i[0], e), f = t.get(i[1], e)];
                    o.clampData && o.clampData(h, h),
                    r = o.dataToPoint(h, !0)
                }
                if ("cartesian2d" === o.type) {
                    var c = o.getAxis("x")
                      , d = o.getAxis("y")
                      , p = t.get(i[0], e)
                      , f = t.get(i[1], e);
                    BR(p) ? r[0] = c.toGlobalCoord(c.getExtent()["x0" === i[0] ? 0 : 1]) : BR(f) && (r[1] = d.toGlobalCoord(d.getExtent()["y0" === i[1] ? 0 : 1]))
                }
                isNaN(l) || (r[0] = l),
                isNaN(u) || (r[1] = u)
            } else
                r = [l, u];
            return r
        }
        var WR = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]];
        function ZR(t) {
            var e = t.itemStyle || (t.itemStyle = {})
              , i = e.emphasis || (e.emphasis = {})
              , n = t.label || t.label || {}
              , a = n.normal || (n.normal = {})
              , r = {
                normal: 1,
                emphasis: 1
            };
            it.each(n, function(t, e) {
                r[e] || UR(a, e) || (a[e] = t)
            }),
            i.label && !UR(n, "emphasis") && (n.emphasis = i.label,
            delete i.label)
        }
        function UR(t, e) {
            return t.hasOwnProperty(e)
        }
        PR.extend({
            type: "markArea",
            updateTransform: function(t, e, a) {
                e.eachSeries(function(i) {
                    var t = i.markAreaModel;
                    if (t) {
                        var n = t.getData();
                        n.each(function(e) {
                            var t = it.map(WR, function(t) {
                                return HR(n, e, t, i, a)
                            });
                            n.setItemLayout(e, t),
                            n.getItemGraphicEl(e).setShape("points", t)
                        })
                    }
                }, this)
            },
            renderSeries: function(i, o, t, n) {
                var e = i.coordinateSystem
                  , a = i.id
                  , r = i.getData()
                  , s = this.markerGroupMap
                  , l = s.get(a) || s.set(a, {
                    group: new Fs.Group
                });
                this.group.add(l.group),
                l.__keep = !0;
                var u = function(t, n, e) {
                    var i, a;
                    a = t ? (i = it.map(t && t.dimensions, function(t) {
                        var e = n.getData()
                          , i = e.getDimensionInfo(e.mapDimension(t)) || {};
                        return it.defaults({
                            name: t
                        }, i)
                    }),
                    new Qp(it.map(["x0", "y0", "x1", "y1"], function(t, e) {
                        return {
                            name: t,
                            type: i[e % 2].type
                        }
                    }),e)) : new Qp(i = [{
                        name: "value",
                        type: "float"
                    }],e);
                    var r = it.map(e.get("data"), it.curry(VR, n, t, e));
                    t && (r = it.filter(r, it.curry(FR, t)));
                    var o = t ? function(t, e, i, n) {
                        return t.coord[Math.floor(n / 2)][n % 2]
                    }
                    : function(t) {
                        return t.value
                    }
                    ;
                    return a.initData(r, null, o),
                    a.hasItemOption = !0,
                    a
                }(e, i, o);
                o.setData(u),
                u.each(function(e) {
                    u.setItemLayout(e, it.map(WR, function(t) {
                        return HR(u, e, t, i, n)
                    })),
                    u.setItemVisual(e, {
                        color: r.getVisual("color")
                    })
                }),
                u.diff(l.__data).add(function(t) {
                    var e = new Fs.Polygon({
                        shape: {
                            points: u.getItemLayout(t)
                        }
                    });
                    u.setItemGraphicEl(t, e),
                    l.group.add(e)
                }).update(function(t, e) {
                    var i = l.__data.getItemGraphicEl(e);
                    Fs.updateProps(i, {
                        shape: {
                            points: u.getItemLayout(t)
                        }
                    }, o, t),
                    l.group.add(i),
                    u.setItemGraphicEl(t, i)
                }).remove(function(t) {
                    var e = l.__data.getItemGraphicEl(t);
                    l.group.remove(e)
                }).execute(),
                u.eachItemGraphicEl(function(t, e) {
                    var i = u.getItemModel(e)
                      , n = i.getModel("label")
                      , a = i.getModel("emphasis.label")
                      , r = u.getItemVisual(e, "color");
                    t.useStyle(it.defaults(i.getModel("itemStyle").getItemStyle(), {
                        fill: jt.modifyAlpha(r, .4),
                        stroke: r
                    })),
                    t.hoverStyle = i.getModel("emphasis.itemStyle").getItemStyle(),
                    Fs.setLabelStyle(t.style, t.hoverStyle, n, a, {
                        labelFetcher: o,
                        labelDataIndex: e,
                        defaultText: u.getName(e) || "",
                        isRectText: !0,
                        autoColor: r
                    }),
                    Fs.setHoverStyle(t, {}),
                    t.dataModel = o
                }),
                l.__data = u,
                l.group.silent = o.get("silent") || i.get("silent")
            }
        }),
        Gm.registerPreprocessor(function(t) {
            t.markArea = t.markArea || {}
        });
        function YR(t) {
            var e = t && t.timeline;
            it.isArray(e) || (e = e ? [e] : []),
            it.each(e, function(t) {
                t && function(t) {
                    var e = t.type
                      , i = {
                        number: "value",
                        time: "time"
                    };
                    i[e] && (t.axisType = i[e],
                    delete t.type);
                    if (ZR(t),
                    UR(t, "controlPosition")) {
                        var n = t.controlStyle || (t.controlStyle = {});
                        UR(n, "position") || (n.position = t.controlPosition),
                        "none" !== n.position || UR(n, "show") || (n.show = !1,
                        delete n.position),
                        delete t.controlPosition
                    }
                    it.each(t.data || [], function(t) {
                        it.isObject(t) && !it.isArray(t) && (!UR(t, "value") && UR(t, "name") && (t.value = t.name),
                        ZR(t))
                    })
                }(t)
            })
        }
        Pl.registerSubTypeDefaulter("timeline", function() {
            return "slider"
        }),
        Gm.registerAction({
            type: "timelineChange",
            event: "timelineChanged",
            update: "prepareAndUpdate"
        }, function(t, e) {
            var i = e.getComponent("timeline");
            return i && null != t.currentIndex && (i.setCurrentIndex(t.currentIndex),
            !i.get("loop", !0) && i.isIndexMax() && i.setPlayState(!1)),
            e.resetOption("timeline"),
            it.defaults({
                currentIndex: i.option.currentIndex
            }, t)
        }),
        Gm.registerAction({
            type: "timelinePlayChange",
            event: "timelinePlayChanged",
            update: "update"
        }, function(t, e) {
            var i = e.getComponent("timeline");
            i && null != t.playState && i.setPlayState(t.playState)
        });
        var jR = Pl.extend({
            type: "timeline",
            layoutMode: "box",
            defaultOption: {
                zlevel: 0,
                z: 4,
                show: !0,
                axisType: "time",
                realtime: !0,
                left: "20%",
                top: null,
                right: "20%",
                bottom: 0,
                width: null,
                height: 40,
                padding: 5,
                controlPosition: "left",
                autoPlay: !1,
                rewind: !1,
                loop: !0,
                playInterval: 2e3,
                currentIndex: 0,
                itemStyle: {},
                label: {
                    color: "#000"
                },
                data: []
            },
            init: function(t, e, i) {
                this._data,
                this._names,
                this.mergeDefaultAndTheme(t, i),
                this._initData()
            },
            mergeOption: function(t) {
                jR.superApply(this, "mergeOption", arguments),
                this._initData()
            },
            setCurrentIndex: function(t) {
                null == t && (t = this.option.currentIndex);
                var e = this._data.count();
                this.option.loop ? t = (t % e + e) % e : (e <= t && (t = e - 1),
                t < 0 && (t = 0)),
                this.option.currentIndex = t
            },
            getCurrentIndex: function() {
                return this.option.currentIndex
            },
            isIndexMax: function() {
                return this.getCurrentIndex() >= this._data.count() - 1
            },
            setPlayState: function(t) {
                this.option.autoPlay = !!t
            },
            getPlayState: function() {
                return !!this.option.autoPlay
            },
            _initData: function() {
                var t = this.option
                  , e = t.data || []
                  , i = t.axisType
                  , a = this._names = [];
                if ("category" === i) {
                    var r = [];
                    it.each(e, function(t, e) {
                        var i, n = aa.getDataItemValue(t);
                        it.isObject(t) ? (i = it.clone(t)).value = e : i = e,
                        r.push(i),
                        it.isString(n) || null != n && !isNaN(n) || (n = ""),
                        a.push(n + "")
                    }),
                    e = r
                }
                var n = {
                    category: "ordinal",
                    time: "time"
                }[i] || "number";
                (this._data = new Qp([{
                    name: "value",
                    type: n
                }],this)).initData(e, a)
            },
            getData: function() {
                return this._data
            },
            getCategories: function() {
                if ("category" === this.get("axisType"))
                    return this._names.slice()
            }
        })
          , XR = jR.extend({
            type: "timeline.slider",
            defaultOption: {
                backgroundColor: "rgba(0,0,0,0)",
                borderColor: "#ccc",
                borderWidth: 0,
                orient: "horizontal",
                inverse: !1,
                tooltip: {
                    trigger: "item"
                },
                symbol: "emptyCircle",
                symbolSize: 10,
                lineStyle: {
                    show: !0,
                    width: 2,
                    color: "#304654"
                },
                label: {
                    position: "auto",
                    show: !0,
                    interval: "auto",
                    rotate: 0,
                    color: "#304654"
                },
                itemStyle: {
                    color: "#304654",
                    borderWidth: 1
                },
                checkpointStyle: {
                    symbol: "circle",
                    symbolSize: 13,
                    color: "#c23531",
                    borderWidth: 5,
                    borderColor: "rgba(194,53,49, 0.5)",
                    animation: !0,
                    animationDuration: 300,
                    animationEasing: "quinticInOut"
                },
                controlStyle: {
                    show: !0,
                    showPlayBtn: !0,
                    showPrevBtn: !0,
                    showNextBtn: !0,
                    itemSize: 22,
                    itemGap: 12,
                    position: "left",
                    playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
                    stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
                    nextIcon: "path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z",
                    prevIcon: "path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z",
                    color: "#304654",
                    borderColor: "#304654",
                    borderWidth: 1
                },
                emphasis: {
                    label: {
                        show: !0,
                        color: "#c23531"
                    },
                    itemStyle: {
                        color: "#c23531"
                    },
                    controlStyle: {
                        color: "#c23531",
                        borderColor: "#c23531",
                        borderWidth: 2
                    }
                },
                data: []
            }
        });
        it.mixin(XR, $h);
        function qR(t, e, i, n) {
            wm.call(this, t, e, i),
            this.type = n || "value",
            this.model = null
        }
        var KR = Rc.extend({
            type: "timeline"
        });
        qR.prototype = {
            constructor: qR,
            getLabelModel: function() {
                return this.model.getModel("label")
            },
            isHorizontal: function() {
                return "horizontal" === this.model.get("orient")
            }
        },
        it.inherits(qR, wm);
        var $R = qR
          , JR = Fg.createSymbol
          , QR = fl.encodeHTML
          , tN = it.bind
          , eN = it.each
          , iN = Math.PI;
        KR.extend({
            type: "timeline.slider",
            init: function(t, e) {
                this.api = e,
                this._axis,
                this._viewRect,
                this._timer,
                this._currentPointer,
                this._mainGroup,
                this._labelGroup
            },
            render: function(e, t, i, n) {
                if (this.model = e,
                this.api = i,
                this.ecModel = t,
                this.group.removeAll(),
                e.get("show", !0)) {
                    var a = this._layout(e, i)
                      , r = this._createGroup("mainGroup")
                      , o = this._createGroup("labelGroup")
                      , s = this._axis = this._createAxis(a, e);
                    e.formatTooltip = function(t) {
                        return QR(s.scale.getLabel(t))
                    }
                    ,
                    eN(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(t) {
                        this["_render" + t](a, r, s, e)
                    }, this),
                    this._renderAxisLabel(a, o, s, e),
                    this._position(a, e)
                }
                this._doPlayStop()
            },
            remove: function() {
                this._clearTimer(),
                this.group.removeAll()
            },
            dispose: function() {
                this._clearTimer()
            },
            _layout: function(t, e) {
                var i = t.get("label.position")
                  , n = t.get("orient")
                  , a = function(t, e) {
                    return Il.getLayoutRect(t.getBoxLayoutParams(), {
                        width: e.getWidth(),
                        height: e.getHeight()
                    }, t.get("padding"))
                }(t, e);
                null == i || "auto" === i ? i = "horizontal" === n ? a.y + a.height / 2 < e.getHeight() / 2 ? "-" : "+" : a.x + a.width / 2 < e.getWidth() / 2 ? "+" : "-" : isNaN(i) && (i = {
                    horizontal: {
                        top: "-",
                        bottom: "+"
                    },
                    vertical: {
                        left: "-",
                        right: "+"
                    }
                }[n][i]);
                var r, o, s, l, u = {
                    horizontal: "center",
                    vertical: 0 <= i || "+" === i ? "left" : "right"
                }, h = {
                    horizontal: 0 <= i || "+" === i ? "top" : "bottom",
                    vertical: "middle"
                }, c = {
                    horizontal: 0,
                    vertical: iN / 2
                }, d = "vertical" === n ? a.height : a.width, p = t.getModel("controlStyle"), f = p.get("show", !0), g = f ? p.get("itemSize") : 0, m = f ? p.get("itemGap") : 0, v = g + m, y = t.get("label.rotate") || 0;
                y = y * iN / 180;
                var x = p.get("position", !0)
                  , _ = f && p.get("showPlayBtn", !0)
                  , b = f && p.get("showPrevBtn", !0)
                  , w = f && p.get("showNextBtn", !0)
                  , S = 0
                  , M = d;
                return "left" === x || "bottom" === x ? (_ && (r = [0, 0],
                S += v),
                b && (o = [S, 0],
                S += v)) : (_ && (r = [M - g, 0],
                M -= v),
                b && (o = [0, 0],
                S += v)),
                w && (s = [M - g, 0],
                M -= v),
                l = [S, M],
                t.get("inverse") && l.reverse(),
                {
                    viewRect: a,
                    mainLength: d,
                    orient: n,
                    rotation: c[n],
                    labelRotation: y,
                    labelPosOpt: i,
                    labelAlign: t.get("label.align") || u[n],
                    labelBaseline: t.get("label.verticalAlign") || t.get("label.baseline") || h[n],
                    playPosition: r,
                    prevBtnPosition: o,
                    nextBtnPosition: s,
                    axisExtent: l,
                    controlSize: g,
                    controlGap: m
                }
            },
            _position: function(t, e) {
                var i = this._mainGroup
                  , n = this._labelGroup
                  , a = t.viewRect;
                if ("vertical" === t.orient) {
                    var r = ct.create()
                      , o = a.x
                      , s = a.y + a.height;
                    ct.translate(r, r, [-o, -s]),
                    ct.rotate(r, r, -iN / 2),
                    ct.translate(r, r, [o, s]),
                    (a = a.clone()).applyTransform(r)
                }
                var l = m(a)
                  , u = m(i.getBoundingRect())
                  , h = m(n.getBoundingRect())
                  , c = i.position
                  , d = n.position;
                d[0] = c[0] = l[0][0];
                var p, f = t.labelPosOpt;
                isNaN(f) ? (v(c, u, l, 1, p = "+" === f ? 0 : 1),
                v(d, h, l, 1, 1 - p)) : (v(c, u, l, 1, p = 0 <= f ? 0 : 1),
                d[1] = c[1] + f);
                function g(t) {
                    var e = t.position;
                    t.origin = [l[0][0] - e[0], l[1][0] - e[1]]
                }
                function m(t) {
                    return [[t.x, t.x + t.width], [t.y, t.y + t.height]]
                }
                function v(t, e, i, n, a) {
                    t[n] += i[n][a] - e[n][a]
                }
                i.attr("position", c),
                n.attr("position", d),
                i.rotation = n.rotation = t.rotation,
                g(i),
                g(n)
            },
            _createAxis: function(t, e) {
                var i = e.getData()
                  , n = e.get("axisType")
                  , a = Lg.createScaleByModel(e, n);
                a.getTicks = function() {
                    return i.mapArray(["value"], function(t) {
                        return t
                    })
                }
                ;
                var r = i.getDataExtent("value");
                a.setExtent(r[0], r[1]),
                a.niceTicks();
                var o = new $R("value",a,t.axisExtent,n);
                return o.model = e,
                o
            },
            _createGroup: function(t) {
                var e = this["_" + t] = new Fs.Group;
                return this.group.add(e),
                e
            },
            _renderAxisLine: function(t, e, i, n) {
                var a = i.getExtent();
                n.get("lineStyle.show") && e.add(new Fs.Line({
                    shape: {
                        x1: a[0],
                        y1: 0,
                        x2: a[1],
                        y2: 0
                    },
                    style: it.extend({
                        lineCap: "round"
                    }, n.getModel("lineStyle").getLineStyle()),
                    silent: !0,
                    z2: 1
                }))
            },
            _renderAxisTick: function(t, s, l, u) {
                var h = u.getData()
                  , e = l.scale.getTicks();
                eN(e, function(t) {
                    var e = l.dataToCoord(t)
                      , i = h.getItemModel(t)
                      , n = i.getModel("itemStyle")
                      , a = i.getModel("emphasis.itemStyle")
                      , r = {
                        position: [e, 0],
                        onclick: tN(this._changeTimeline, this, t)
                    }
                      , o = nN(i, n, s, r);
                    Fs.setHoverStyle(o, a.getItemStyle()),
                    i.get("tooltip") ? (o.dataIndex = t,
                    o.dataModel = u) : o.dataIndex = o.dataModel = null
                }, this)
            },
            _renderAxisLabel: function(s, l, u, t) {
                if (u.getLabelModel().get("show")) {
                    var h = t.getData()
                      , e = u.getViewLabels();
                    eN(e, function(t) {
                        var e = t.tickValue
                          , i = h.getItemModel(e)
                          , n = i.getModel("label")
                          , a = i.getModel("emphasis.label")
                          , r = u.dataToCoord(t.tickValue)
                          , o = new Fs.Text({
                            position: [r, 0],
                            rotation: s.labelRotation - s.rotation,
                            onclick: tN(this._changeTimeline, this, e),
                            silent: !1
                        });
                        Fs.setTextStyle(o.style, n, {
                            text: t.formattedLabel,
                            textAlign: s.labelAlign,
                            textVerticalAlign: s.labelBaseline
                        }),
                        l.add(o),
                        Fs.setHoverStyle(o, Fs.setTextStyle({}, a))
                    }, this)
                }
            },
            _renderControl: function(t, r, e, o) {
                var s = t.controlSize
                  , l = t.rotation
                  , u = o.getModel("controlStyle").getItemStyle()
                  , h = o.getModel("emphasis.controlStyle").getItemStyle()
                  , c = [0, -s / 2, s, s]
                  , i = o.getPlayState()
                  , n = o.get("inverse", !0);
                function a(t, e, i, n) {
                    if (t) {
                        var a = function(t, e, i, n) {
                            return Fs.makePath(t.get(e).replace(/^path:\/\//, ""), it.clone(n || {}), new Oe(i[0],i[1],i[2],i[3]), "center")
                        }(o, e, c, {
                            position: t,
                            origin: [s / 2, 0],
                            rotation: n ? -l : 0,
                            rectHover: !0,
                            style: u,
                            onclick: i
                        });
                        r.add(a),
                        Fs.setHoverStyle(a, h)
                    }
                }
                a(t.nextBtnPosition, "controlStyle.nextIcon", tN(this._changeTimeline, this, n ? "-" : "+")),
                a(t.prevBtnPosition, "controlStyle.prevIcon", tN(this._changeTimeline, this, n ? "+" : "-")),
                a(t.playPosition, "controlStyle." + (i ? "stopIcon" : "playIcon"), tN(this._handlePlayClick, this, !i), !0)
            },
            _renderCurrentPointer: function(t, e, i, n) {
                var a = n.getData()
                  , r = n.getCurrentIndex()
                  , o = a.getItemModel(r).getModel("checkpointStyle")
                  , s = this
                  , l = {
                    onCreate: function(t) {
                        t.draggable = !0,
                        t.drift = tN(s._handlePointerDrag, s),
                        t.ondragend = tN(s._handlePointerDragend, s),
                        aN(t, r, i, n, !0)
                    },
                    onUpdate: function(t) {
                        aN(t, r, i, n)
                    }
                };
                this._currentPointer = nN(o, o, this._mainGroup, {}, this._currentPointer, l)
            },
            _handlePlayClick: function(t) {
                this._clearTimer(),
                this.api.dispatchAction({
                    type: "timelinePlayChange",
                    playState: t,
                    from: this.uid
                })
            },
            _handlePointerDrag: function(t, e, i) {
                this._clearTimer(),
                this._pointerChangeTimeline([i.offsetX, i.offsetY])
            },
            _handlePointerDragend: function(t) {
                this._pointerChangeTimeline([t.offsetX, t.offsetY], !0)
            },
            _pointerChangeTimeline: function(t, e) {
                var i = this._toAxisCoord(t)[0]
                  , n = this._axis
                  , a = ol.asc(n.getExtent().slice());
                i > a[1] && (i = a[1]),
                i < a[0] && (i = a[0]),
                this._currentPointer.position[0] = i,
                this._currentPointer.dirty();
                var r = this._findNearestTick(i)
                  , o = this.model;
                (e || r !== o.getCurrentIndex() && o.get("realtime")) && this._changeTimeline(r)
            },
            _doPlayStop: function() {
                this._clearTimer(),
                this.model.getPlayState() && (this._timer = setTimeout(tN(function() {
                    var t = this.model;
                    this._changeTimeline(t.getCurrentIndex() + (t.get("rewind", !0) ? -1 : 1))
                }, this), this.model.get("playInterval")))
            },
            _toAxisCoord: function(t) {
                var e = this._mainGroup.getLocalTransform();
                return Fs.applyTransform(t, e, !0)
            },
            _findNearestTick: function(a) {
                var r, t = this.model.getData(), o = 1 / 0, s = this._axis;
                return t.each(["value"], function(t, e) {
                    var i = s.dataToCoord(t)
                      , n = Math.abs(i - a);
                    n < o && (o = n,
                    r = e)
                }),
                r
            },
            _clearTimer: function() {
                this._timer && (clearTimeout(this._timer),
                this._timer = null)
            },
            _changeTimeline: function(t) {
                var e = this.model.getCurrentIndex();
                "+" === t ? t = e + 1 : "-" === t && (t = e - 1),
                this.api.dispatchAction({
                    type: "timelineChange",
                    currentIndex: t,
                    from: this.uid
                })
            }
        });
        function nN(t, e, i, n, a, r) {
            var o = e.get("color");
            if (a)
                a.setColor(o),
                i.add(a),
                r && r.onUpdate(a);
            else {
                var s = t.get("symbol");
                (a = JR(s, -1, -1, 2, 2, o)).setStyle("strokeNoScale", !0),
                i.add(a),
                r && r.onCreate(a)
            }
            var l = e.getItemStyle(["color", "symbol", "symbolSize"]);
            a.setStyle(l),
            n = it.merge({
                rectHover: !0,
                z2: 100
            }, n, !0);
            var u = t.get("symbolSize");
            (u = u instanceof Array ? u.slice() : [+u, +u])[0] /= 2,
            u[1] /= 2,
            n.scale = u;
            var h = t.get("symbolOffset");
            if (h) {
                var c = n.position = n.position || [0, 0];
                c[0] += ol.parsePercent(h[0], u[0]),
                c[1] += ol.parsePercent(h[1], u[1])
            }
            var d = t.get("symbolRotate");
            return n.rotation = (d || 0) * Math.PI / 180 || 0,
            a.attr(n),
            a.updateTransform(),
            a
        }
        function aN(t, e, i, n, a) {
            if (!t.dragging) {
                var r = n.getModel("checkpointStyle")
                  , o = i.dataToCoord(n.getData().get(["value"], e));
                a || !r.get("animation", !0) ? t.attr({
                    position: [o, 0]
                }) : (t.stopAnimation(!0),
                t.animateTo({
                    position: [o, 0]
                }, r.get("animationDuration", !0), r.get("animationEasing", !0)))
            }
        }
        Gm.registerPreprocessor(YR);
        var rN = Gm.extendComponentModel({
            type: "toolbox",
            layoutMode: {
                type: "box",
                ignoreSize: !0
            },
            optionUpdated: function() {
                rN.superApply(this, "optionUpdated", arguments),
                it.each(this.option.feature, function(t, e) {
                    var i = Gk.get(e);
                    i && it.merge(t, i.defaultOption)
                })
            },
            defaultOption: {
                show: !0,
                z: 6,
                zlevel: 0,
                orient: "horizontal",
                left: "right",
                top: "top",
                backgroundColor: "transparent",
                borderColor: "#ccc",
                borderRadius: 0,
                borderWidth: 0,
                padding: 5,
                itemSize: 15,
                itemGap: 8,
                showTitle: !0,
                iconStyle: {
                    borderColor: "#666",
                    color: "none"
                },
                emphasis: {
                    iconStyle: {
                        borderColor: "#3E98C5"
                    }
                }
            }
        });
        Gm.extendComponentView({
            type: "toolbox",
            render: function(h, c, d, l) {
                var p = this.group;
                if (p.removeAll(),
                h.get("show")) {
                    var f = +h.get("itemSize")
                      , u = h.get("feature") || {}
                      , g = this._features || (this._features = {})
                      , m = [];
                    it.each(u, function(t, e) {
                        m.push(e)
                    }),
                    new wp(this._featureNames || [],m).add(t).update(t).remove(it.curry(t, null)).execute(),
                    this._featureNames = m,
                    BL.layout(p, h, d),
                    p.add(BL.makeBackground(p.getBoundingRect(), h)),
                    p.eachChild(function(t) {
                        var e = t.__title
                          , i = t.hoverStyle;
                        if (i && e) {
                            var n = Bi.getBoundingRect(e, Bi.makeFont(i))
                              , a = t.position[0] + p.position[0]
                              , r = !1;
                            t.position[1] + p.position[1] + f + n.height > d.getHeight() && (i.textPosition = "top",
                            r = !0);
                            var o = r ? -5 - n.height : f + 8;
                            a + n.width / 2 > d.getWidth() ? (i.textPosition = ["100%", o],
                            i.textAlign = "right") : a - n.width / 2 < 0 && (i.textPosition = [0, o],
                            i.textAlign = "left")
                        }
                    })
                }
                function t(t, e) {
                    var i, n = m[t], a = m[e], r = u[n], o = new tl(r,h,h.ecModel);
                    if (n && !a) {
                        if (function(t) {
                            return 0 === t.indexOf("my")
                        }(n))
                            i = {
                                model: o,
                                onclick: o.option.onclick,
                                featureName: n
                            };
                        else {
                            var s = Gk.get(n);
                            if (!s)
                                return;
                            i = new s(o,c,d)
                        }
                        g[n] = i
                    } else {
                        if (!(i = g[a]))
                            return;
                        i.model = o,
                        i.ecModel = c,
                        i.api = d
                    }
                    n || !a ? o.get("show") && !i.unusable ? (function(n, a, t) {
                        var r = n.getModel("iconStyle")
                          , o = n.getModel("emphasis.iconStyle")
                          , e = a.getIcons ? a.getIcons() : n.get("icon")
                          , s = n.get("title") || {};
                        if ("string" == typeof e) {
                            var i = e
                              , l = s;
                            s = {},
                            (e = {})[t] = i,
                            s[t] = l
                        }
                        var u = n.iconPaths = {};
                        it.each(e, function(t, e) {
                            var i = Fs.createIcon(t, {}, {
                                x: -f / 2,
                                y: -f / 2,
                                width: f,
                                height: f
                            });
                            i.setStyle(r.getItemStyle()),
                            i.hoverStyle = o.getItemStyle(),
                            Fs.setHoverStyle(i),
                            h.get("showTitle") && (i.__title = s[e],
                            i.on("mouseover", function() {
                                var t = o.getItemStyle();
                                i.setStyle({
                                    text: s[e],
                                    textPosition: t.textPosition || "bottom",
                                    textFill: t.fill || t.stroke || "#000",
                                    textAlign: t.textAlign || "center"
                                })
                            }).on("mouseout", function() {
                                i.setStyle({
                                    textFill: null
                                })
                            })),
                            i.trigger(n.get("iconStatus." + e) || "normal"),
                            p.add(i),
                            i.on("click", it.bind(a.onclick, a, c, d, e)),
                            u[e] = i
                        })
                    }(o, i, n),
                    o.setIconStatus = function(t, e) {
                        var i = this.option
                          , n = this.iconPaths;
                        i.iconStatus = i.iconStatus || {},
                        i.iconStatus[t] = e,
                        n[t] && n[t].trigger(e)
                    }
                    ,
                    i.render && i.render(o, c, d, l)) : i.remove && i.remove(c, d) : i.dispose && i.dispose(c, d)
                }
            },
            updateView: function(t, e, i, n) {
                it.each(this._features, function(t) {
                    t.updateView && t.updateView(t.model, e, i, n)
                })
            },
            remove: function(e, i) {
                it.each(this._features, function(t) {
                    t.remove && t.remove(e, i)
                }),
                this.group.removeAll()
            },
            dispose: function(e, i) {
                it.each(this._features, function(t) {
                    t.dispose && t.dispose(e, i)
                })
            }
        });
        var oN = ed.toolbox.saveAsImage;
        function sN(t) {
            this.model = t
        }
        sN.defaultOption = {
            show: !0,
            icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
            title: oN.title,
            type: "png",
            name: "",
            excludeComponents: ["toolbox"],
            pixelRatio: 1,
            lang: oN.lang.slice()
        },
        sN.prototype.unusable = !et.canvasSupported,
        sN.prototype.onclick = function(t, e) {
            var i = this.model
              , n = i.get("name") || t.get("title.0.text") || "echarts"
              , a = document.createElement("a")
              , r = i.get("type", !0) || "png";
            a.download = n + "." + r,
            a.target = "_blank";
            var o = e.getConnectedDataURL({
                type: r,
                backgroundColor: i.get("backgroundColor", !0) || t.get("backgroundColor") || "#fff",
                excludeComponents: i.get("excludeComponents"),
                pixelRatio: i.get("pixelRatio")
            });
            if (a.href = o,
            "function" != typeof MouseEvent || et.browser.ie || et.browser.edge)
                if (window.navigator.msSaveOrOpenBlob) {
                    for (var s = atob(o.split(",")[1]), l = s.length, u = new Uint8Array(l); l--; )
                        u[l] = s.charCodeAt(l);
                    var h = new Blob([u]);
                    window.navigator.msSaveOrOpenBlob(h, n + "." + r)
                } else {
                    var c = i.get("lang")
                      , d = '<body style="margin:0;"><img src="' + o + '" style="max-width:100%;" title="' + (c && c[0] || "") + '" /></body>';
                    window.open().document.write(d)
                }
            else {
                var p = new MouseEvent("click",{
                    view: window,
                    bubbles: !0,
                    cancelable: !1
                });
                a.dispatchEvent(p)
            }
        }
        ,
        Gk.register("saveAsImage", sN);
        var lN = ed.toolbox.magicType;
        function uN(t) {
            this.model = t
        }
        uN.defaultOption = {
            show: !0,
            type: [],
            icon: {
                line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
                bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
                stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z",
                tiled: "M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z"
            },
            title: it.clone(lN.title),
            option: {},
            seriesIndex: {}
        };
        var hN = uN.prototype;
        hN.getIcons = function() {
            var t = this.model
              , e = t.get("icon")
              , i = {};
            return it.each(t.get("type"), function(t) {
                e[t] && (i[t] = e[t])
            }),
            i
        }
        ;
        var cN = {
            line: function(t, e, i, n) {
                if ("bar" === t)
                    return it.merge({
                        id: e,
                        type: "line",
                        data: i.get("data"),
                        stack: i.get("stack"),
                        markPoint: i.get("markPoint"),
                        markLine: i.get("markLine")
                    }, n.get("option.line") || {}, !0)
            },
            bar: function(t, e, i, n) {
                if ("line" === t)
                    return it.merge({
                        id: e,
                        type: "bar",
                        data: i.get("data"),
                        stack: i.get("stack"),
                        markPoint: i.get("markPoint"),
                        markLine: i.get("markLine")
                    }, n.get("option.bar") || {}, !0)
            },
            stack: function(t, e, i, n) {
                if ("line" === t || "bar" === t)
                    return it.merge({
                        id: e,
                        stack: "__ec_magicType_stack__"
                    }, n.get("option.stack") || {}, !0)
            },
            tiled: function(t, e, i, n) {
                if ("line" === t || "bar" === t)
                    return it.merge({
                        id: e,
                        stack: ""
                    }, n.get("option.tiled") || {}, !0)
            }
        }
          , dN = [["line", "bar"], ["stack", "tiled"]];
        hN.onclick = function(u, t, h) {
            var c = this.model
              , e = c.get("seriesIndex." + h);
            if (cN[h]) {
                var d = {
                    series: []
                };
                it.each(dN, function(t) {
                    0 <= it.indexOf(t, h) && it.each(t, function(t) {
                        c.setIconStatus(t, "normal")
                    })
                }),
                c.setIconStatus(h, "emphasis"),
                u.eachComponent({
                    mainType: "series",
                    query: null == e ? null : {
                        seriesIndex: e
                    }
                }, function(t) {
                    var e = t.subType
                      , i = t.id
                      , n = cN[h](e, i, t, c);
                    n && (it.defaults(n, t.option),
                    d.series.push(n));
                    var a = t.coordinateSystem;
                    if (a && "cartesian2d" === a.type && ("line" === h || "bar" === h)) {
                        var r = a.getAxesByScale("ordinal")[0];
                        if (r) {
                            var o = r.dim + "Axis"
                              , s = u.queryComponents({
                                mainType: o,
                                index: t.get(name + "Index"),
                                id: t.get(name + "Id")
                            })[0].componentIndex;
                            d[o] = d[o] || [];
                            for (var l = 0; l <= s; l++)
                                d[o][s] = d[o][s] || {};
                            d[o][s].boundaryGap = "bar" === h
                        }
                    }
                }),
                t.dispatchAction({
                    type: "changeMagicType",
                    currentType: h,
                    newOption: d
                })
            }
        }
        ,
        Gm.registerAction({
            type: "changeMagicType",
            event: "magicTypeChanged",
            update: "prepareAndUpdate"
        }, function(t, e) {
            e.mergeOption(t.newOption)
        }),
        Gk.register("magicType", uN);
        var pN = ed.toolbox.dataView
          , fN = new Array(60).join("-")
          , gN = "\t";
        function mN(t) {
            var e = function(t) {
                var a = {}
                  , r = []
                  , o = [];
                return t.eachRawSeries(function(t) {
                    var e = t.coordinateSystem;
                    if (!e || "cartesian2d" !== e.type && "polar" !== e.type)
                        r.push(t);
                    else {
                        var i = e.getBaseAxis();
                        if ("category" === i.type) {
                            var n = i.dim + "_" + i.index;
                            a[n] || (a[n] = {
                                categoryAxis: i,
                                valueAxis: e.getOtherAxis(i),
                                series: []
                            },
                            o.push({
                                axisDim: i.dim,
                                axisIndex: i.index
                            })),
                            a[n].series.push(t)
                        } else
                            r.push(t)
                    }
                }),
                {
                    seriesGroupByCategoryAxis: a,
                    other: r,
                    meta: o
                }
            }(t);
            return {
                value: it.filter([function(t) {
                    var h = [];
                    return it.each(t, function(t, e) {
                        var i = t.categoryAxis
                          , n = t.valueAxis.dim
                          , a = [" "].concat(it.map(t.series, function(t) {
                            return t.name
                        }))
                          , r = [i.model.getCategories()];
                        it.each(t.series, function(t) {
                            r.push(t.getRawData().mapArray(n, function(t) {
                                return t
                            }))
                        });
                        for (var o = [a.join(gN)], s = 0; s < r[0].length; s++) {
                            for (var l = [], u = 0; u < r.length; u++)
                                l.push(r[u][s]);
                            o.push(l.join(gN))
                        }
                        h.push(o.join("\n"))
                    }),
                    h.join("\n\n" + fN + "\n\n")
                }(e.seriesGroupByCategoryAxis), function(t) {
                    return it.map(t, function(t) {
                        var a = t.getRawData()
                          , r = [t.name]
                          , o = [];
                        return a.each(a.dimensions, function() {
                            for (var t = arguments.length, e = arguments[t - 1], i = a.getName(e), n = 0; n < t - 1; n++)
                                o[n] = arguments[n];
                            r.push((i ? i + gN : "") + o.join(gN))
                        }),
                        r.join("\n")
                    }).join("\n\n" + fN + "\n\n")
                }(e.other)], function(t) {
                    return t.replace(/[\n\t\s]/g, "")
                }).join("\n\n" + fN + "\n\n"),
                meta: e.meta
            }
        }
        function vN(t) {
            return t.replace(/^\s\s*/, "").replace(/\s\s*$/, "")
        }
        var yN = new RegExp("[" + gN + "]+","g");
        function xN(t, r) {
            var e = t.split(new RegExp("\n*" + fN + "\n*","g"))
              , o = {
                series: []
            };
            return it.each(e, function(t, e) {
                if (function(t) {
                    if (0 <= t.slice(0, t.indexOf("\n")).indexOf(gN))
                        return !0
                }(t)) {
                    var i = function(t) {
                        for (var e = t.split(/\n+/g), i = vN(e.shift()).split(yN), n = [], a = it.map(i, function(t) {
                            return {
                                name: t,
                                data: []
                            }
                        }), r = 0; r < e.length; r++) {
                            var o = vN(e[r]).split(yN);
                            n.push(o.shift());
                            for (var s = 0; s < o.length; s++)
                                a[s] && (a[s].data[r] = o[s])
                        }
                        return {
                            series: a,
                            categories: n
                        }
                    }(t)
                      , n = r[e]
                      , a = n.axisDim + "Axis";
                    n && (o[a] = o[a] || [],
                    o[a][n.axisIndex] = {
                        data: i.categories
                    },
                    o.series = o.series.concat(i.series))
                } else {
                    i = function(t) {
                        for (var e = t.split(/\n+/g), i = vN(e.shift()), n = [], a = 0; a < e.length; a++) {
                            var r, o = vN(e[a]).split(yN), s = "", l = !1;
                            r = isNaN(o[0]) ? (l = !0,
                            s = o[0],
                            o = o.slice(1),
                            n[a] = {
                                name: s,
                                value: []
                            },
                            n[a].value) : n[a] = [];
                            for (var u = 0; u < o.length; u++)
                                r.push(+o[u]);
                            1 === r.length && (l ? n[a].value = r[0] : n[a] = r[0])
                        }
                        return {
                            name: i,
                            data: n
                        }
                    }(t);
                    o.series.push(i)
                }
            }),
            o
        }
        function _N(t) {
            this._dom = null,
            this.model = t
        }
        _N.defaultOption = {
            show: !0,
            readOnly: !1,
            optionToContent: null,
            contentToOption: null,
            icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
            title: it.clone(pN.title),
            lang: it.clone(pN.lang),
            backgroundColor: "#fff",
            textColor: "#000",
            textareaColor: "#fff",
            textareaBorderColor: "#333",
            buttonColor: "#c23531",
            buttonTextColor: "#fff"
        },
        _N.prototype.onclick = function(t, e) {
            var i = e.getDom()
              , n = this.model;
            this._dom && i.removeChild(this._dom);
            var a = document.createElement("div");
            a.style.cssText = "position:absolute;left:5px;top:5px;bottom:5px;right:5px;",
            a.style.backgroundColor = n.get("backgroundColor") || "#fff";
            var r = document.createElement("h4")
              , o = n.get("lang") || [];
            r.innerHTML = o[0] || n.get("title"),
            r.style.cssText = "margin: 10px 20px;",
            r.style.color = n.get("textColor");
            var s = document.createElement("div")
              , l = document.createElement("textarea");
            s.style.cssText = "display:block;width:100%;overflow:auto;";
            var u = n.get("optionToContent")
              , h = n.get("contentToOption")
              , c = mN(t);
            if ("function" == typeof u) {
                var d = u(e.getOption());
                "string" == typeof d ? s.innerHTML = d : it.isDom(d) && s.appendChild(d)
            } else
                s.appendChild(l),
                l.readOnly = n.get("readOnly"),
                l.style.cssText = "width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;",
                l.style.color = n.get("textColor"),
                l.style.borderColor = n.get("textareaBorderColor"),
                l.style.backgroundColor = n.get("textareaColor"),
                l.value = c.value;
            var p = c.meta
              , f = document.createElement("div");
            f.style.cssText = "position:absolute;bottom:0;left:0;right:0;";
            var g = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px"
              , m = document.createElement("div")
              , v = document.createElement("div");
            g += ";background-color:" + n.get("buttonColor"),
            g += ";color:" + n.get("buttonTextColor");
            var y = this;
            function x() {
                i.removeChild(a),
                y._dom = null
            }
            j.addEventListener(m, "click", x),
            j.addEventListener(v, "click", function() {
                var t;
                try {
                    t = "function" == typeof h ? h(s, e.getOption()) : xN(l.value, p)
                } catch (t) {
                    throw x(),
                    new Error("Data view format error " + t)
                }
                t && e.dispatchAction({
                    type: "changeDataView",
                    newOption: t
                }),
                x()
            }),
            m.innerHTML = o[1],
            v.innerHTML = o[2],
            v.style.cssText = g,
            m.style.cssText = g,
            n.get("readOnly") || f.appendChild(v),
            f.appendChild(m),
            j.addEventListener(l, "keydown", function(t) {
                if (9 === (t.keyCode || t.which)) {
                    var e = this.value
                      , i = this.selectionStart
                      , n = this.selectionEnd;
                    this.value = e.substring(0, i) + gN + e.substring(n),
                    this.selectionStart = this.selectionEnd = i + 1,
                    j.stop(t)
                }
            }),
            a.appendChild(r),
            a.appendChild(s),
            a.appendChild(f),
            s.style.height = i.clientHeight - 80 + "px",
            i.appendChild(a),
            this._dom = a
        }
        ,
        _N.prototype.remove = function(t, e) {
            this._dom && e.getDom().removeChild(this._dom)
        }
        ,
        _N.prototype.dispose = function(t, e) {
            this.remove(t, e)
        }
        ,
        Gk.register("dataView", _N),
        Gm.registerAction({
            type: "changeDataView",
            event: "dataViewChanged",
            update: "prepareAndUpdate"
        }, function(t, n) {
            var a = [];
            it.each(t.newOption.series, function(t) {
                var e = n.getSeriesByName(t.name)[0];
                if (e) {
                    var i = e.get("data");
                    a.push({
                        name: t.name,
                        data: function(t, n) {
                            return it.map(t, function(t, e) {
                                var i = n && n[e];
                                return it.isObject(i) && !it.isArray(i) ? (it.isObject(t) && !it.isArray(t) && (t = t.value),
                                it.defaults({
                                    value: t
                                }, i)) : t
                            })
                        }(t.data, i)
                    })
                } else
                    a.push(it.extend({
                        type: "scatter"
                    }, t))
            }),
            n.mergeOption(it.defaults({
                series: a
            }, t.newOption))
        });
        var bN = it.each
          , wN = "\0_ec_hist_store";
        function SN(t) {
            var e = t[wN];
            return e = e || (t[wN] = [{}])
        }
        var MN = {
            push: function(r, t) {
                var o = SN(r);
                bN(t, function(t, e) {
                    for (var i = o.length - 1; 0 <= i; i--) {
                        if (o[i][e])
                            break
                    }
                    if (i < 0) {
                        var n = r.queryComponents({
                            mainType: "dataZoom",
                            subType: "select",
                            id: e
                        })[0];
                        if (n) {
                            var a = n.getPercentRange();
                            o[0][e] = {
                                dataZoomId: e,
                                start: a[0],
                                end: a[1]
                            }
                        }
                    }
                }),
                o.push(t)
            },
            pop: function(t) {
                var n = SN(t)
                  , e = n[n.length - 1];
                1 < n.length && n.pop();
                var a = {};
                return bN(e, function(t, e) {
                    for (var i = n.length - 1; 0 <= i; i--) {
                        if (t = n[i][e]) {
                            a[e] = t;
                            break
                        }
                    }
                }),
                a
            },
            clear: function(t) {
                t[wN] = null
            },
            count: function(t) {
                return SN(t).length
            }
        }
          , IN = (pO.extend({
            type: "dataZoom.select"
        }),
        fO.extend({
            type: "dataZoom.select"
        }),
        ed.toolbox.dataZoom)
          , AN = it.each;
        function TN(t, e, i) {
            (this._brushController = new fA(i.getZr())).on("brush", it.bind(this._onBrush, this)).mount(),
            this._isZoomActive
        }
        TN.defaultOption = {
            show: !0,
            icon: {
                zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
                back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
            },
            title: it.clone(IN.title)
        };
        var CN = TN.prototype;
        CN.render = function(t, e, i, n) {
            this.model = t,
            this.ecModel = e,
            this.api = i,
            function(t, e, i, n, a) {
                var r = i._isZoomActive;
                n && "takeGlobalCursor" === n.type && (r = "dataZoomSelect" === n.key && n.dataZoomSelectActive);
                i._isZoomActive = r,
                t.setIconStatus("zoom", r ? "emphasis" : "normal");
                var o = new Ak(LN(t.option),e,{
                    include: ["grid"]
                });
                i._brushController.setPanels(o.makePanelOpts(a, function(t) {
                    return t.xAxisDeclared && !t.yAxisDeclared ? "lineX" : !t.xAxisDeclared && t.yAxisDeclared ? "lineY" : "rect"
                })).enableBrush(!!r && {
                    brushType: "auto",
                    brushStyle: {
                        lineWidth: 0,
                        fill: "rgba(0,0,0,0.2)"
                    }
                })
            }(t, e, this, n, i),
            function(t, e) {
                t.setIconStatus("back", 1 < MN.count(e) ? "emphasis" : "normal")
            }(t, e)
        }
        ,
        CN.onclick = function(t, e, i) {
            DN[i].call(this)
        }
        ,
        CN.remove = function(t, e) {
            this._brushController.unmount()
        }
        ,
        CN.dispose = function(t, e) {
            this._brushController.dispose()
        }
        ;
        var DN = {
            zoom: function() {
                var t = !this._isZoomActive;
                this.api.dispatchAction({
                    type: "takeGlobalCursor",
                    key: "dataZoomSelect",
                    dataZoomSelectActive: t
                })
            },
            back: function() {
                this._dispatchZoomAction(MN.pop(this.ecModel))
            }
        };
        function LN(e) {
            var i = {};
            return it.each(["xAxisIndex", "yAxisIndex"], function(t) {
                i[t] = e[t],
                null == i[t] && (i[t] = "all"),
                !1 !== i[t] && "none" !== i[t] || (i[t] = [])
            }),
            i
        }
        CN._onBrush = function(t, e) {
            if (e.isEnd && t.length) {
                var s = {}
                  , l = this.ecModel;
                this._brushController.updateCovers([]),
                new Ak(LN(this.model.option),l,{
                    include: ["grid"]
                }).matchOutputRanges(t, l, function(t, e, i) {
                    if ("cartesian2d" === i.type) {
                        var n = t.brushType;
                        "rect" === n ? (a("x", i, e[0]),
                        a("y", i, e[1])) : a({
                            lineX: "x",
                            lineY: "y"
                        }[n], i, e)
                    }
                }),
                MN.push(l, s),
                this._dispatchZoomAction(s)
            }
            function a(t, e, i) {
                var n = e.getAxis(t)
                  , a = n.model
                  , r = function(e, i, t) {
                    var n;
                    return t.eachComponent({
                        mainType: "dataZoom",
                        subType: "select"
                    }, function(t) {
                        t.getAxisModel(e, i.componentIndex) && (n = t)
                    }),
                    n
                }(t, a, l)
                  , o = r.findRepresentativeAxisProxy(a).getMinMaxSpan();
                null == o.minValueSpan && null == o.maxValueSpan || (i = dI(0, i.slice(), n.scale.getExtent(), 0, o.minValueSpan, o.maxValueSpan)),
                r && (s[r.id] = {
                    dataZoomId: r.id,
                    startValue: i[0],
                    endValue: i[1]
                })
            }
        }
        ,
        CN._dispatchZoomAction = function(t) {
            var i = [];
            AN(t, function(t, e) {
                i.push(it.clone(t))
            }),
            i.length && this.api.dispatchAction({
                type: "dataZoom",
                from: this.uid,
                batch: i
            })
        }
        ,
        Gk.register("dataZoom", TN),
        Gm.registerPreprocessor(function(o) {
            if (o) {
                var s = o.dataZoom || (o.dataZoom = []);
                it.isArray(s) || (o.dataZoom = s = [s]);
                var t = o.toolbox;
                if (t && (it.isArray(t) && (t = t[0]),
                t && t.feature)) {
                    var e = t.feature.dataZoom;
                    i("xAxis", e),
                    i("yAxis", e)
                }
            }
            function i(n, t) {
                if (t) {
                    var a = n + "Index"
                      , r = t[a];
                    null == r || "all" === r || it.isArray(r) || (r = !1 === r || "none" === r ? [] : [r]),
                    function(t, e) {
                        var i = o[t];
                        it.isArray(i) || (i = i ? [i] : []);
                        AN(i, e)
                    }(n, function(t, e) {
                        if (null == r || "all" === r || -1 !== it.indexOf(r, e)) {
                            var i = {
                                type: "select",
                                $fromToolbox: !0,
                                id: "\0_ec_\0toolbox-dataZoom_" + n + e
                            };
                            i[a] = e,
                            s.push(i)
                        }
                    })
                }
            }
        });
        var PN = ed.toolbox.restore;
        function kN(t) {
            this.model = t
        }
        kN.defaultOption = {
            show: !0,
            icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
            title: PN.title
        },
        kN.prototype.onclick = function(t, e, i) {
            MN.clear(t),
            e.dispatchAction({
                type: "restore",
                from: this.uid
            })
        }
        ,
        Gk.register("restore", kN),
        Gm.registerAction({
            type: "restore",
            event: "restore",
            update: "prepareAndUpdate"
        }, function(t, e) {
            e.resetOption("recreate")
        });
        var ON, RN = "urn:schemas-microsoft-com:vml", NN = "undefined" == typeof window ? null : window, EN = !1, zN = NN && NN.document;
        if (zN && !et.canvasSupported)
            try {
                zN.namespaces.zrvml || zN.namespaces.add("zrvml", RN),
                ON = function(t) {
                    return zN.createElement("<zrvml:" + t + ' class="zrvml">')
                }
            } catch (t) {
                ON = function(t) {
                    return zN.createElement("<" + t + ' xmlns="' + RN + '" class="zrvml">')
                }
            }
        var VN = {
            doc: zN,
            createNode: function(t) {
                return ON(t)
            },
            initVML: function() {
                if (!EN && zN) {
                    EN = !0;
                    var t = zN.styleSheets;
                    t.length < 31 ? zN.createStyleSheet().addRule(".zrvml", "behavior:url(#default#VML)") : t[0].addRule(".zrvml", "behavior:url(#default#VML)")
                }
            }
        }
          , BN = R.applyTransform
          , GN = ir.CMD
          , FN = Math.round
          , HN = Math.sqrt
          , WN = Math.abs
          , ZN = Math.cos
          , UN = Math.sin
          , YN = Math.max;
        if (!et.canvasSupported) {
            var jN = ","
              , XN = "progid:DXImageTransform.Microsoft"
              , qN = 21600
              , KN = qN / 2
              , $N = function(t) {
                t.style.cssText = "position:absolute;left:0;top:0;width:1px;height:1px;",
                t.coordsize = qN + "," + qN,
                t.coordorigin = "0,0"
            }
              , JN = function(t, e, i) {
                return "rgb(" + [t, e, i].join(",") + ")"
            }
              , QN = function(t, e) {
                e && t && e.parentNode !== t && t.appendChild(e)
            }
              , tE = function(t, e) {
                e && t && e.parentNode === t && t.removeChild(e)
            }
              , eE = function(t, e, i) {
                return 1e5 * (parseFloat(t) || 0) + 1e3 * (parseFloat(e) || 0) + i
            }
              , iE = function(t, e) {
                return "string" == typeof t ? 0 <= t.lastIndexOf("%") ? parseFloat(t) / 100 * e : parseFloat(t) : t
            }
              , nE = function(t, e, i) {
                var n = jt.parse(e);
                i = +i,
                isNaN(i) && (i = 1),
                n && (t.color = JN(n[0], n[1], n[2]),
                t.opacity = i * n[3])
            }
              , aE = function(t, e, i, n) {
                var a = "fill" === e
                  , r = t.getElementsByTagName(e)[0];
                null != i[e] && "none" !== i[e] && (a || !a && i.lineWidth) ? (t[a ? "filled" : "stroked"] = "true",
                i[e]instanceof Vo && tE(t, r),
                r = r || VN.createNode(e),
                a ? function(t, e, i) {
                    var n, a, r = e.fill;
                    if (null != r)
                        if (r instanceof Vo) {
                            var o, s = 0, l = [0, 0], u = 0, h = 1, c = i.getBoundingRect(), d = c.width, p = c.height;
                            if ("linear" === r.type) {
                                o = "gradient";
                                var f = i.transform
                                  , g = [r.x * d, r.y * p]
                                  , m = [r.x2 * d, r.y2 * p];
                                f && (BN(g, g, f),
                                BN(m, m, f));
                                var v = m[0] - g[0]
                                  , y = m[1] - g[1];
                                (s = 180 * Math.atan2(v, y) / Math.PI) < 0 && (s += 360),
                                s < 1e-6 && (s = 0)
                            } else {
                                o = "gradientradial";
                                g = [r.x * d, r.y * p],
                                f = i.transform;
                                var x = i.scale
                                  , _ = d
                                  , b = p;
                                l = [(g[0] - c.x) / _, (g[1] - c.y) / b],
                                f && BN(g, g, f),
                                _ /= x[0] * qN,
                                b /= x[1] * qN;
                                var w = YN(_, b);
                                u = 0 / w,
                                h = 2 * r.r / w - u
                            }
                            var S = r.colorStops.slice();
                            S.sort(function(t, e) {
                                return t.offset - e.offset
                            });
                            for (var M = S.length, I = [], A = [], T = 0; T < M; T++) {
                                var C = S[T]
                                  , D = (n = C.color,
                                void 0,
                                a = jt.parse(n),
                                [JN(a[0], a[1], a[2]), a[3]]);
                                A.push(C.offset * h + u + " " + D[0]),
                                0 !== T && T !== M - 1 || I.push(D)
                            }
                            if (2 <= M) {
                                var L = I[0][0]
                                  , P = I[1][0]
                                  , k = I[0][1] * e.opacity
                                  , O = I[1][1] * e.opacity;
                                t.type = o,
                                t.method = "none",
                                t.focus = "100%",
                                t.angle = s,
                                t.color = L,
                                t.color2 = P,
                                t.colors = A.join(","),
                                t.opacity = O,
                                t.opacity2 = k
                            }
                            "radial" === o && (t.focusposition = l.join(","))
                        } else
                            nE(t, r, e.opacity)
                }(r, i, n) : function(t, e) {
                    null != e.lineDash && (t.dashstyle = e.lineDash.join(" ")),
                    null == e.stroke || e.stroke instanceof Vo || nE(t, e.stroke, e.opacity)
                }(r, i),
                QN(t, r)) : (t[a ? "filled" : "stroked"] = "false",
                tE(t, r))
            }
              , rE = [[], [], []];
            Cr.prototype.brushVML = function(t) {
                var e = this.style
                  , i = this._vmlEl;
                i || (i = VN.createNode("shape"),
                $N(i),
                this._vmlEl = i),
                aE(i, "fill", e, this),
                aE(i, "stroke", e, this);
                var n = this.transform
                  , a = null != n
                  , r = i.getElementsByTagName("stroke")[0];
                if (r) {
                    var o = e.lineWidth;
                    if (a && !e.strokeNoScale) {
                        var s = n[0] * n[3] - n[1] * n[2];
                        o *= HN(WN(s))
                    }
                    r.weight = o + "px"
                }
                var l = this.path || (this.path = new ir);
                this.__dirtyPath && (l.beginPath(),
                l.subPixelOptimize = !1,
                this.buildPath(l, this.shape),
                l.toStatic(),
                this.__dirtyPath = !1),
                i.path = function(t, e) {
                    var i, n, a, r, o, s, l = GN.M, u = GN.C, h = GN.L, c = GN.A, d = GN.Q, p = [], f = t.data, g = t.len();
                    for (r = 0; r < g; ) {
                        switch (n = "",
                        i = 0,
                        a = f[r++]) {
                        case l:
                            n = " m ",
                            i = 1,
                            o = f[r++],
                            s = f[r++],
                            rE[0][0] = o,
                            rE[0][1] = s;
                            break;
                        case h:
                            n = " l ",
                            i = 1,
                            o = f[r++],
                            s = f[r++],
                            rE[0][0] = o,
                            rE[0][1] = s;
                            break;
                        case d:
                        case u:
                            n = " c ",
                            i = 3;
                            var m, v, y = f[r++], x = f[r++], _ = f[r++], b = f[r++];
                            a === d ? (_ = ((m = _) + 2 * y) / 3,
                            b = ((v = b) + 2 * x) / 3,
                            y = (o + 2 * y) / 3,
                            x = (s + 2 * x) / 3) : (m = f[r++],
                            v = f[r++]),
                            rE[0][0] = y,
                            rE[0][1] = x,
                            rE[1][0] = _,
                            rE[1][1] = b,
                            o = rE[2][0] = m,
                            s = rE[2][1] = v;
                            break;
                        case c:
                            var w = 0
                              , S = 0
                              , M = 1
                              , I = 1
                              , A = 0;
                            e && (w = e[4],
                            S = e[5],
                            M = HN(e[0] * e[0] + e[1] * e[1]),
                            I = HN(e[2] * e[2] + e[3] * e[3]),
                            A = Math.atan2(-e[1] / I, e[0] / M));
                            var T = f[r++]
                              , C = f[r++]
                              , D = f[r++]
                              , L = f[r++]
                              , P = f[r++] + A
                              , k = f[r++] + P + A;
                            r++;
                            var O = f[r++]
                              , R = T + ZN(P) * D
                              , N = C + UN(P) * L
                              , E = (y = T + ZN(k) * D,
                            x = C + UN(k) * L,
                            O ? " wa " : " at ");
                            Math.abs(R - y) < 1e-4 && (.01 < Math.abs(k - P) ? O && (R += .0125) : Math.abs(N - C) < 1e-4 ? O && R < T || !O && T < R ? x -= .0125 : x += .0125 : O && N < C || !O && C < N ? y += .0125 : y -= .0125),
                            p.push(E, FN(((T - D) * M + w) * qN - KN), jN, FN(((C - L) * I + S) * qN - KN), jN, FN(((T + D) * M + w) * qN - KN), jN, FN(((C + L) * I + S) * qN - KN), jN, FN((R * M + w) * qN - KN), jN, FN((N * I + S) * qN - KN), jN, FN((y * M + w) * qN - KN), jN, FN((x * I + S) * qN - KN)),
                            o = y,
                            s = x;
                            break;
                        case GN.R:
                            var z = rE[0]
                              , V = rE[1];
                            z[0] = f[r++],
                            z[1] = f[r++],
                            V[0] = z[0] + f[r++],
                            V[1] = z[1] + f[r++],
                            e && (BN(z, z, e),
                            BN(V, V, e)),
                            z[0] = FN(z[0] * qN - KN),
                            V[0] = FN(V[0] * qN - KN),
                            z[1] = FN(z[1] * qN - KN),
                            V[1] = FN(V[1] * qN - KN),
                            p.push(" m ", z[0], jN, z[1], " l ", V[0], jN, z[1], " l ", V[0], jN, V[1], " l ", z[0], jN, V[1]);
                            break;
                        case GN.Z:
                            p.push(" x ")
                        }
                        if (0 < i) {
                            p.push(n);
                            for (var B = 0; B < i; B++) {
                                var G = rE[B];
                                e && BN(G, G, e),
                                p.push(FN(G[0] * qN - KN), jN, FN(G[1] * qN - KN), B < i - 1 ? jN : "")
                            }
                        }
                    }
                    return p.join("")
                }(l, this.transform),
                i.style.zIndex = eE(this.zlevel, this.z, this.z2),
                QN(t, i),
                null != e.text ? this.drawRectText(t, this.getBoundingRect()) : this.removeRectText(t)
            }
            ,
            Cr.prototype.onRemove = function(t) {
                tE(t, this._vmlEl),
                this.removeRectText(t)
            }
            ,
            Cr.prototype.onAdd = function(t) {
                QN(t, this._vmlEl),
                this.appendRectText(t)
            }
            ;
            _n.prototype.brushVML = function(t) {
                var e, i, n = this.style, a = n.image;
                if (function(t) {
                    return "object" == typeof t && t.tagName && "IMG" === t.tagName.toUpperCase()
                }(a)) {
                    var r = a.src;
                    if (r === this._imageSrc)
                        e = this._imageWidth,
                        i = this._imageHeight;
                    else {
                        var o = a.runtimeStyle
                          , s = o.width
                          , l = o.height;
                        o.width = "auto",
                        o.height = "auto",
                        e = a.width,
                        i = a.height,
                        o.width = s,
                        o.height = l,
                        this._imageSrc = r,
                        this._imageWidth = e,
                        this._imageHeight = i
                    }
                    a = r
                } else
                    a === this._imageSrc && (e = this._imageWidth,
                    i = this._imageHeight);
                if (a) {
                    var u = n.x || 0
                      , h = n.y || 0
                      , c = n.width
                      , d = n.height
                      , p = n.sWidth
                      , f = n.sHeight
                      , g = n.sx || 0
                      , m = n.sy || 0
                      , v = p && f
                      , y = this._vmlEl;
                    y || (y = VN.doc.createElement("div"),
                    $N(y),
                    this._vmlEl = y);
                    var x, _ = y.style, b = !1, w = 1, S = 1;
                    if (this.transform && (x = this.transform,
                    w = HN(x[0] * x[0] + x[1] * x[1]),
                    S = HN(x[2] * x[2] + x[3] * x[3]),
                    b = x[1] || x[2]),
                    b) {
                        var M = [u, h]
                          , I = [u + c, h]
                          , A = [u, h + d]
                          , T = [u + c, h + d];
                        BN(M, M, x),
                        BN(I, I, x),
                        BN(A, A, x),
                        BN(T, T, x);
                        var C = YN(M[0], I[0], A[0], T[0])
                          , D = YN(M[1], I[1], A[1], T[1])
                          , L = [];
                        L.push("M11=", x[0] / w, jN, "M12=", x[2] / S, jN, "M21=", x[1] / w, jN, "M22=", x[3] / S, jN, "Dx=", FN(u * w + x[4]), jN, "Dy=", FN(h * S + x[5])),
                        _.padding = "0 " + FN(C) + "px " + FN(D) + "px 0",
                        _.filter = XN + ".Matrix(" + L.join("") + ", SizingMethod=clip)"
                    } else
                        x && (u = u * w + x[4],
                        h = h * S + x[5]),
                        _.filter = "",
                        _.left = FN(u) + "px",
                        _.top = FN(h) + "px";
                    var P = this._imageEl
                      , k = this._cropEl;
                    P || (P = VN.doc.createElement("div"),
                    this._imageEl = P);
                    var O = P.style;
                    if (v) {
                        if (e && i)
                            O.width = FN(w * e * c / p) + "px",
                            O.height = FN(S * i * d / f) + "px";
                        else {
                            var R = new Image
                              , N = this;
                            R.onload = function() {
                                R.onload = null,
                                e = R.width,
                                i = R.height,
                                O.width = FN(w * e * c / p) + "px",
                                O.height = FN(S * i * d / f) + "px",
                                N._imageWidth = e,
                                N._imageHeight = i,
                                N._imageSrc = a
                            }
                            ,
                            R.src = a
                        }
                        k || ((k = VN.doc.createElement("div")).style.overflow = "hidden",
                        this._cropEl = k);
                        var E = k.style;
                        E.width = FN((c + g * c / p) * w),
                        E.height = FN((d + m * d / f) * S),
                        E.filter = XN + ".Matrix(Dx=" + -g * c / p * w + ",Dy=" + -m * d / f * S + ")",
                        k.parentNode || y.appendChild(k),
                        P.parentNode !== k && k.appendChild(P)
                    } else
                        O.width = FN(w * c) + "px",
                        O.height = FN(S * d) + "px",
                        y.appendChild(P),
                        k && k.parentNode && (y.removeChild(k),
                        this._cropEl = null);
                    var z = ""
                      , V = n.opacity;
                    V < 1 && (z += ".Alpha(opacity=" + FN(100 * V) + ") "),
                    z += XN + ".AlphaImageLoader(src=" + a + ", SizingMethod=scale)",
                    O.filter = z,
                    y.style.zIndex = eE(this.zlevel, this.z, this.z2),
                    QN(t, y),
                    null != n.text && this.drawRectText(t, this.getBoundingRect())
                }
            }
            ,
            _n.prototype.onRemove = function(t) {
                tE(t, this._vmlEl),
                this._vmlEl = null,
                this._cropEl = null,
                this._imageEl = null,
                this.removeRectText(t)
            }
            ,
            _n.prototype.onAdd = function(t) {
                QN(t, this._vmlEl),
                this.appendRectText(t)
            }
            ;
            var oE, sE = "normal", lE = {}, uE = 0, hE = document.createElement("div");
            Bi.$override("measureText", function(t, e) {
                var i = VN.doc;
                oE || ((oE = i.createElement("div")).style.cssText = "position:absolute;top:-20000px;left:0;padding:0;margin:0;border:none;white-space:pre;",
                VN.doc.body.appendChild(oE));
                try {
                    oE.style.font = e
                } catch (t) {}
                return oE.innerHTML = "",
                oE.appendChild(i.createTextNode(t)),
                {
                    width: oE.offsetWidth
                }
            });
            for (var cE = new Oe, dE = function(t, e, i, n) {
                var a = this.style;
                this.__dirty && pn.normalizeTextStyle(a, !0);
                var r = a.text;
                if (null != r && (r += ""),
                r) {
                    if (a.rich) {
                        var o = Bi.parseRichText(r, a);
                        r = [];
                        for (var s = 0; s < o.lines.length; s++) {
                            for (var l = o.lines[s].tokens, u = [], h = 0; h < l.length; h++)
                                u.push(l[h].text);
                            r.push(u.join(""))
                        }
                        r = r.join("\n")
                    }
                    var c, d, p = a.textAlign, f = a.textVerticalAlign, g = function(t) {
                        var e = lE[t];
                        if (!e) {
                            100 < uE && (uE = 0,
                            lE = {});
                            var i, n = hE.style;
                            try {
                                n.font = t,
                                i = n.fontFamily.split(",")[0]
                            } catch (t) {}
                            e = {
                                style: n.fontStyle || sE,
                                variant: n.fontVariant || sE,
                                weight: n.fontWeight || sE,
                                size: 0 | parseFloat(n.fontSize || 12),
                                family: i || "Microsoft YaHei"
                            },
                            lE[t] = e,
                            uE++
                        }
                        return e
                    }(a.font), m = g.style + " " + g.variant + " " + g.weight + " " + g.size + 'px "' + g.family + '"';
                    i = i || Bi.getBoundingRect(r, m, p, f, a.textPadding, a.textLineHeight);
                    var v = this.transform;
                    if (v && !n && (cE.copy(e),
                    cE.applyTransform(v),
                    e = cE),
                    n)
                        c = e.x,
                        d = e.y;
                    else {
                        var y = a.textPosition
                          , x = a.textDistance;
                        if (y instanceof Array)
                            c = e.x + iE(y[0], e.width),
                            d = e.y + iE(y[1], e.height),
                            p = p || "left";
                        else {
                            var _ = Bi.adjustTextPositionOnRect(y, e, x);
                            c = _.x,
                            d = _.y,
                            p = p || _.textAlign,
                            f = f || _.textVerticalAlign
                        }
                    }
                    c = Bi.adjustTextX(c, i.width, p),
                    d = Bi.adjustTextY(d, i.height, f),
                    d += i.height / 2;
                    var b, w, S, M = VN.createNode, I = this._textVmlEl;
                    I ? w = (b = (S = I.firstChild).nextSibling).nextSibling : (I = M("line"),
                    b = M("path"),
                    w = M("textpath"),
                    S = M("skew"),
                    w.style["v-text-align"] = "left",
                    $N(I),
                    b.textpathok = !0,
                    w.on = !0,
                    I.from = "0 0",
                    I.to = "1000 0.05",
                    QN(I, S),
                    QN(I, b),
                    QN(I, w),
                    this._textVmlEl = I);
                    var A = [c, d]
                      , T = I.style;
                    v && n ? (BN(A, A, v),
                    S.on = !0,
                    S.matrix = v[0].toFixed(3) + jN + v[2].toFixed(3) + jN + v[1].toFixed(3) + jN + v[3].toFixed(3) + ",0,0",
                    S.offset = (FN(A[0]) || 0) + "," + (FN(A[1]) || 0),
                    S.origin = "0 0",
                    T.left = "0px",
                    T.top = "0px") : (S.on = !1,
                    T.left = FN(c) + "px",
                    T.top = FN(d) + "px"),
                    w.string = function(t) {
                        return String(t).replace(/&/g, "&amp;").replace(/"/g, "&quot;")
                    }(r);
                    try {
                        w.style.font = m
                    } catch (t) {}
                    aE(I, "fill", {
                        fill: a.textFill,
                        opacity: a.opacity
                    }, this),
                    aE(I, "stroke", {
                        stroke: a.textStroke,
                        opacity: a.opacity,
                        lineDash: a.lineDash
                    }, this),
                    I.style.zIndex = eE(this.zlevel, this.z, this.z2),
                    QN(t, I)
                }
            }, pE = function(t) {
                tE(t, this._textVmlEl),
                this._textVmlEl = null
            }, fE = function(t) {
                QN(t, this._textVmlEl)
            }, gE = [mn, yn, _n, Cr, qr], mE = 0; mE < gE.length; mE++) {
                var vE = gE[mE].prototype;
                vE.drawRectText = dE,
                vE.removeRectText = pE,
                vE.appendRectText = fE
            }
            qr.prototype.brushVML = function(t) {
                var e = this.style;
                null != e.text ? this.drawRectText(t, {
                    x: e.x || 0,
                    y: e.y || 0,
                    width: 0,
                    height: 0
                }, this.getBoundingRect(), !0) : this.removeRectText(t)
            }
            ,
            qr.prototype.onRemove = function(t) {
                this.removeRectText(t)
            }
            ,
            qr.prototype.onAdd = function(t) {
                this.appendRectText(t)
            }
        }
        var yE = it.each;
        function xE(t) {
            return parseInt(t, 10)
        }
        function _E(t, e) {
            VN.initVML(),
            this.root = t,
            this.storage = e;
            var i = document.createElement("div")
              , n = document.createElement("div");
            i.style.cssText = "display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;",
            n.style.cssText = "position:absolute;left:0;top:0;",
            t.appendChild(i),
            this._vmlRoot = n,
            this._vmlViewport = i,
            this.resize();
            var a = e.delFromStorage
              , r = e.addToStorage;
            e.delFromStorage = function(t) {
                a.call(e, t),
                t && t.onRemove && t.onRemove(n)
            }
            ,
            e.addToStorage = function(t) {
                t.onAdd && t.onAdd(n),
                r.call(e, t)
            }
            ,
            this._firstPaint = !0
        }
        _E.prototype = {
            constructor: _E,
            getType: function() {
                return "vml"
            },
            getViewportRoot: function() {
                return this._vmlViewport
            },
            getViewportRootOffset: function() {
                var t = this.getViewportRoot();
                if (t)
                    return {
                        offsetLeft: t.offsetLeft || 0,
                        offsetTop: t.offsetTop || 0
                    }
            },
            refresh: function() {
                var t = this.storage.getDisplayList(!0, !0);
                this._paintList(t)
            },
            _paintList: function(t) {
                for (var e = this._vmlRoot, i = 0; i < t.length; i++) {
                    var n = t[i];
                    n.invisible || n.ignore ? (n.__alreadyNotVisible || n.onRemove(e),
                    n.__alreadyNotVisible = !0) : (n.__alreadyNotVisible && n.onAdd(e),
                    n.__alreadyNotVisible = !1,
                    n.__dirty && (n.beforeBrush && n.beforeBrush(),
                    (n.brushVML || n.brush).call(n, e),
                    n.afterBrush && n.afterBrush())),
                    n.__dirty = !1
                }
                this._firstPaint && (this._vmlViewport.appendChild(e),
                this._firstPaint = !1)
            },
            resize: function(t, e) {
                t = null == t ? this._getWidth() : t,
                e = null == e ? this._getHeight() : e;
                if (this._width !== t || this._height !== e) {
                    this._width = t,
                    this._height = e;
                    var i = this._vmlViewport.style;
                    i.width = t + "px",
                    i.height = e + "px"
                }
            },
            dispose: function() {
                this.root.innerHTML = "",
                this._vmlRoot = this._vmlViewport = this.storage = null
            },
            getWidth: function() {
                return this._width
            },
            getHeight: function() {
                return this._height
            },
            clear: function() {
                this._vmlViewport && this.root.removeChild(this._vmlViewport)
            },
            _getWidth: function() {
                var t = this.root
                  , e = t.currentStyle;
                return (t.clientWidth || xE(e.width)) - xE(e.paddingLeft) - xE(e.paddingRight) | 0
            },
            _getHeight: function() {
                var t = this.root
                  , e = t.currentStyle;
                return (t.clientHeight || xE(e.height)) - xE(e.paddingTop) - xE(e.paddingBottom) | 0
            }
        },
        yE(["getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], function(t) {
            _E.prototype[t] = function(t) {
                return function() {
                    pe('In IE8.0 VML mode painter not support method "' + t + '"')
                }
            }(t)
        });
        var bE = _E;
        (0,
        qn.registerPainter)("vml", bE);
        var wE = {
            createElement: function(t) {
                return document.createElementNS("http://www.w3.org/2000/svg", t)
            }
        }
          , SE = wE.createElement
          , ME = ir.CMD
          , IE = Array.prototype.join
          , AE = "none"
          , TE = Math.round
          , CE = Math.sin
          , DE = Math.cos
          , LE = Math.PI
          , PE = 2 * Math.PI
          , kE = 180 / LE
          , OE = 1e-4;
        function RE(t) {
            return TE(1e4 * t) / 1e4
        }
        function NE(t) {
            return t < OE && -OE < t
        }
        function EE(t, e) {
            e && zE(t, "transform", "matrix(" + IE.call(e, ",") + ")")
        }
        function zE(t, e, i) {
            i && ("linear" === i.type || "radial" === i.type) || t.setAttribute(e, i)
        }
        function VE(t, e, i, n) {
            if (function(t, e) {
                var i = e ? t.textFill : t.fill;
                return null != i && i !== AE
            }(e, i)) {
                var a = i ? e.textFill : e.fill;
                a = "transparent" === a ? AE : a,
                "none" !== t.getAttribute("clip-path") && a === AE && (a = "rgba(0, 0, 0, 0.002)"),
                zE(t, "fill", a),
                zE(t, "fill-opacity", null != e.fillOpacity ? e.fillOpacity * e.opacity : e.opacity)
            } else
                zE(t, "fill", AE);
            if (function(t, e) {
                var i = e ? t.textStroke : t.stroke;
                return null != i && i !== AE
            }(e, i)) {
                var r = i ? e.textStroke : e.stroke;
                zE(t, "stroke", r = "transparent" === r ? AE : r),
                zE(t, "stroke-width", (i ? e.textStrokeWidth : e.lineWidth) / (!i && e.strokeNoScale ? n.getLineScale() : 1)),
                zE(t, "paint-order", i ? "stroke" : "fill"),
                zE(t, "stroke-opacity", null != e.strokeOpacity ? e.strokeOpacity : e.opacity),
                e.lineDash ? (zE(t, "stroke-dasharray", e.lineDash.join(",")),
                zE(t, "stroke-dashoffset", TE(e.lineDashOffset || 0))) : zE(t, "stroke-dasharray", ""),
                e.lineCap && zE(t, "stroke-linecap", e.lineCap),
                e.lineJoin && zE(t, "stroke-linejoin", e.lineJoin),
                e.miterLimit && zE(t, "stroke-miterlimit", e.miterLimit)
            } else
                zE(t, "stroke", AE)
        }
        var BE = {};
        BE.brush = function(t) {
            var e = t.style
              , i = t.__svgEl;
            i || (i = SE("path"),
            t.__svgEl = i),
            t.path || t.createPathProxy();
            var n = t.path;
            if (t.__dirtyPath) {
                n.beginPath(),
                n.subPixelOptimize = !1,
                t.buildPath(n, t.shape),
                t.__dirtyPath = !1;
                var a = function(t) {
                    for (var e = [], i = t.data, n = t.len(), a = 0; a < n; ) {
                        var r = ""
                          , o = 0;
                        switch (i[a++]) {
                        case ME.M:
                            r = "M",
                            o = 2;
                            break;
                        case ME.L:
                            r = "L",
                            o = 2;
                            break;
                        case ME.Q:
                            r = "Q",
                            o = 4;
                            break;
                        case ME.C:
                            r = "C",
                            o = 6;
                            break;
                        case ME.A:
                            var s = i[a++]
                              , l = i[a++]
                              , u = i[a++]
                              , h = i[a++]
                              , c = i[a++]
                              , d = i[a++]
                              , p = i[a++]
                              , f = i[a++]
                              , g = Math.abs(d)
                              , m = NE(g - PE) && !NE(g)
                              , v = !1;
                            v = PE <= g || !NE(g) && (-LE < d && d < 0 || LE < d) == !!f;
                            var y = RE(s + u * DE(c))
                              , x = RE(l + h * CE(c));
                            m && (d = f ? PE - 1e-4 : 1e-4 - PE,
                            v = !0,
                            9 === a && e.push("M", y, x));
                            var _ = RE(s + u * DE(c + d))
                              , b = RE(l + h * CE(c + d));
                            e.push("A", RE(u), RE(h), TE(p * kE), +v, +f, _, b);
                            break;
                        case ME.Z:
                            r = "Z";
                            break;
                        case ME.R:
                            _ = RE(i[a++]),
                            b = RE(i[a++]);
                            var w = RE(i[a++])
                              , S = RE(i[a++]);
                            e.push("M", _, b, "L", _ + w, b, "L", _ + w, b + S, "L", _, b + S, "L", _, b)
                        }
                        r && e.push(r);
                        for (var M = 0; M < o; M++)
                            e.push(RE(i[a++]))
                    }
                    return e.join(" ")
                }(n);
                a.indexOf("NaN") < 0 && zE(i, "d", a)
            }
            VE(i, e, !1, t),
            EE(i, t.transform),
            null != e.text && WE(t, t.getBoundingRect())
        }
        ;
        var GE = {
            brush: function(t) {
                var e = t.style
                  , i = e.image;
                i instanceof HTMLImageElement && (i = i.src);
                if (i) {
                    var n = e.x || 0
                      , a = e.y || 0
                      , r = e.width
                      , o = e.height
                      , s = t.__svgEl;
                    s || (s = SE("image"),
                    t.__svgEl = s),
                    i !== t.__imageSrc && (function(t, e, i) {
                        t.setAttributeNS("http://www.w3.org/1999/xlink", e, i)
                    }(s, "href", i),
                    t.__imageSrc = i),
                    zE(s, "width", r),
                    zE(s, "height", o),
                    zE(s, "x", n),
                    zE(s, "y", a),
                    EE(s, t.transform),
                    null != e.text && WE(t, t.getBoundingRect())
                }
            }
        }
          , FE = {}
          , HE = new Oe
          , WE = function(t, e, i) {
            var n = t.style;
            t.__dirty && pn.normalizeTextStyle(n, !0);
            var a = n.text;
            if (null != a) {
                a += "";
                var r, o, s = t.__textSvgEl;
                s || (s = SE("text"),
                t.__textSvgEl = s);
                var l = n.textPosition
                  , u = n.textDistance
                  , h = n.textAlign || "left";
                "number" == typeof n.fontSize && (n.fontSize += "px");
                var c = n.font || [n.fontStyle || "", n.fontWeight || "", n.fontSize || "", n.fontFamily || ""].join(" ") || Bi.DEFAULT_FONT
                  , d = ZE(n.textVerticalAlign)
                  , p = (i = Bi.getBoundingRect(a, c, h, d, n.textPadding, n.textLineHeight)).lineHeight;
                if (l instanceof Array)
                    r = e.x + l[0],
                    o = e.y + l[1];
                else {
                    var f = Bi.adjustTextPositionOnRect(l, e, u);
                    r = f.x,
                    o = f.y,
                    d = ZE(f.textVerticalAlign),
                    h = f.textAlign
                }
                zE(s, "alignment-baseline", d),
                c && (s.style.font = c);
                var g = n.textPadding;
                if (zE(s, "x", r),
                zE(s, "y", o),
                VE(s, n, !0, t),
                t instanceof qr || t.style.transformText)
                    EE(s, t.transform);
                else {
                    if (t.transform)
                        HE.copy(e),
                        HE.applyTransform(t.transform),
                        e = HE;
                    else {
                        var m = t.transformCoordToGlobal(e.x, e.y);
                        e.x = m[0],
                        e.y = m[1],
                        t.transform = ct.identity(ct.create())
                    }
                    var v = n.textOrigin;
                    "center" === v ? (r = i.width / 2 + r,
                    o = i.height / 2 + o) : v && (r = v[0] + r,
                    o = v[1] + o);
                    var y = -n.textRotation || 0
                      , x = ct.create();
                    ct.rotate(x, x, y);
                    m = [t.transform[4], t.transform[5]];
                    ct.translate(x, x, m),
                    EE(s, x)
                }
                var _ = a.split("\n")
                  , b = _.length
                  , w = h;
                "left" === w ? (w = "start",
                g && (r += g[3])) : "right" === w ? (w = "end",
                g && (r -= g[1])) : "center" === w && (w = "middle",
                g && (r += (g[3] - g[1]) / 2));
                var S = 0;
                if ("after-edge" === d ? (S = -i.height + p,
                g && (S -= g[2])) : "middle" === d ? (S = (-i.height + p) / 2,
                g && (o += (g[0] - g[2]) / 2)) : g && (S += g[0]),
                t.__text !== a || t.__textFont !== c) {
                    var M = t.__tspanList || [];
                    t.__tspanList = M;
                    for (var I = 0; I < b; I++) {
                        (T = M[I]) ? T.innerHTML = "" : (T = M[I] = SE("tspan"),
                        s.appendChild(T),
                        zE(T, "alignment-baseline", d),
                        zE(T, "text-anchor", w)),
                        zE(T, "x", r),
                        zE(T, "y", o + I * p + S),
                        T.appendChild(document.createTextNode(_[I]))
                    }
                    for (; I < M.length; I++)
                        s.removeChild(M[I]);
                    M.length = b,
                    t.__text = a,
                    t.__textFont = c
                } else if (t.__tspanList.length) {
                    var A = t.__tspanList.length;
                    for (I = 0; I < A; ++I) {
                        var T;
                        (T = t.__tspanList[I]) && (zE(T, "x", r),
                        zE(T, "y", o + I * p + S))
                    }
                }
            }
        };
        function ZE(t) {
            return "middle" === t ? "middle" : "bottom" === t ? "after-edge" : "hanging"
        }
        FE.drawRectText = WE,
        FE.brush = function(t) {
            var e = t.style;
            null != e.text && (e.textPosition = [0, 0],
            WE(t, {
                x: e.x || 0,
                y: e.y || 0,
                width: 0,
                height: 0
            }, t.getBoundingRect()))
        }
        ;
        var UE = {
            path: BE,
            image: GE,
            text: FE
        };
        function YE() {}
        function jE(t, e) {
            for (var i = 0, n = e.length, a = 0, r = 0; i < n; i++) {
                var o = e[i];
                if (o.removed) {
                    for (s = [],
                    l = r; l < r + o.count; l++)
                        s.push(l);
                    o.indices = s,
                    r += o.count
                } else {
                    for (var s = [], l = a; l < a + o.count; l++)
                        s.push(l);
                    o.indices = s,
                    a += o.count,
                    o.added || (r += o.count)
                }
            }
            return e
        }
        YE.prototype = {
            diff: function(l, u, t) {
                t = t || function(t, e) {
                    return t === e
                }
                ,
                this.equals = t;
                var h = this;
                l = l.slice();
                var c = (u = u.slice()).length
                  , d = l.length
                  , p = 1
                  , e = c + d
                  , f = [{
                    newPos: -1,
                    components: []
                }]
                  , i = this.extractCommon(f[0], u, l, 0);
                if (f[0].newPos + 1 >= c && d <= i + 1) {
                    for (var n = [], a = 0; a < u.length; a++)
                        n.push(a);
                    return [{
                        indices: n,
                        count: u.length
                    }]
                }
                function r() {
                    for (var t = -1 * p; t <= p; t += 2) {
                        var e, i = f[t - 1], n = f[t + 1], a = (n ? n.newPos : 0) - t;
                        i && (f[t - 1] = void 0);
                        var r = i && i.newPos + 1 < c
                          , o = n && 0 <= a && a < d;
                        if (r || o) {
                            if (!r || o && i.newPos < n.newPos ? (e = {
                                newPos: (s = n).newPos,
                                components: s.components.slice(0)
                            },
                            h.pushComponent(e.components, void 0, !0)) : ((e = i).newPos++,
                            h.pushComponent(e.components, !0, void 0)),
                            a = h.extractCommon(e, u, l, t),
                            e.newPos + 1 >= c && d <= a + 1)
                                return jE(h, e.components);
                            f[t] = e
                        } else
                            f[t] = void 0
                    }
                    var s;
                    p++
                }
                for (; p <= e; ) {
                    var o = r();
                    if (o)
                        return o
                }
            },
            pushComponent: function(t, e, i) {
                var n = t[t.length - 1];
                n && n.added === e && n.removed === i ? t[t.length - 1] = {
                    count: n.count + 1,
                    added: e,
                    removed: i
                } : t.push({
                    count: 1,
                    added: e,
                    removed: i
                })
            },
            extractCommon: function(t, e, i, n) {
                for (var a = e.length, r = i.length, o = t.newPos, s = o - n, l = 0; o + 1 < a && s + 1 < r && this.equals(e[o + 1], i[s + 1]); )
                    o++,
                    s++,
                    l++;
                return l && t.components.push({
                    count: l
                }),
                t.newPos = o,
                s
            },
            tokenize: function(t) {
                return t.slice()
            },
            join: function(t) {
                return t.slice()
            }
        };
        var XE = new YE;
        var qE = function(t, e, i) {
            return XE.diff(t, e, i)
        }
          , KE = UE.path
          , $E = UE.image
          , JE = UE.text;
        function QE(t, e, i, n, a) {
            this._zrId = t,
            this._svgRoot = e,
            this._tagNames = "string" == typeof i ? [i] : i,
            this._markLabel = n,
            this._domName = a || "_dom",
            this.nextId = 0
        }
        QE.prototype.createElement = wE.createElement,
        QE.prototype.getDefs = function(t) {
            var e = this._svgRoot
              , n = this._svgRoot.getElementsByTagName("defs");
            return 0 === n.length ? t ? ((n = e.insertBefore(this.createElement("defs"), e.firstChild)).contains || (n.contains = function(t) {
                var e = n.children;
                if (!e)
                    return !1;
                for (var i = e.length - 1; 0 <= i; --i)
                    if (e[i] === t)
                        return !0;
                return !1
            }
            ),
            n) : null : n[0]
        }
        ,
        QE.prototype.update = function(t, e) {
            if (t) {
                var i = this.getDefs(!1);
                if (t[this._domName] && i.contains(t[this._domName]))
                    "function" == typeof e && e(t);
                else {
                    var n = this.add(t);
                    n && (t[this._domName] = n)
                }
            }
        }
        ,
        QE.prototype.addDom = function(t) {
            this.getDefs(!0).appendChild(t)
        }
        ,
        QE.prototype.removeDom = function(t) {
            var e = this.getDefs(!1);
            e && t[this._domName] && (e.removeChild(t[this._domName]),
            t[this._domName] = null)
        }
        ,
        QE.prototype.getDoms = function() {
            var i = this.getDefs(!1);
            if (!i)
                return [];
            var n = [];
            return it.each(this._tagNames, function(t) {
                var e = i.getElementsByTagName(t);
                n = n.concat([].slice.call(e))
            }),
            n
        }
        ,
        QE.prototype.markAllUnused = function() {
            var t = this.getDoms()
              , e = this;
            it.each(t, function(t) {
                t[e._markLabel] = "0"
            })
        }
        ,
        QE.prototype.markUsed = function(t) {
            t && (t[this._markLabel] = "1")
        }
        ,
        QE.prototype.removeUnused = function() {
            var e = this.getDefs(!1);
            if (e) {
                var t = this.getDoms()
                  , i = this;
                it.each(t, function(t) {
                    "1" !== t[i._markLabel] && e.removeChild(t)
                })
            }
        }
        ,
        QE.prototype.getSvgProxy = function(t) {
            return t instanceof Cr ? KE : t instanceof _n ? $E : t instanceof qr ? JE : KE
        }
        ,
        QE.prototype.getTextSvgElement = function(t) {
            return t.__textSvgEl
        }
        ,
        QE.prototype.getSvgElement = function(t) {
            return t.__svgEl
        }
        ;
        var tz = QE;
        function ez(t, e) {
            tz.call(this, t, e, ["linearGradient", "radialGradient"], "__gradient_in_use__")
        }
        it.inherits(ez, tz),
        ez.prototype.addWithoutUpdate = function(r, o) {
            if (o && o.style) {
                var s = this;
                it.each(["fill", "stroke"], function(t) {
                    if (o.style[t] && ("linear" === o.style[t].type || "radial" === o.style[t].type)) {
                        var e, i = o.style[t], n = s.getDefs(!0);
                        i._dom ? (e = i._dom,
                        n.contains(i._dom) || s.addDom(e)) : e = s.add(i),
                        s.markUsed(o);
                        var a = e.getAttribute("id");
                        r.setAttribute(t, "url(#" + a + ")")
                    }
                })
            }
        }
        ,
        ez.prototype.add = function(t) {
            var e;
            if ("linear" === t.type)
                e = this.createElement("linearGradient");
            else {
                if ("radial" !== t.type)
                    return pe("Illegal gradient type."),
                    null;
                e = this.createElement("radialGradient")
            }
            return t.id = t.id || this.nextId++,
            e.setAttribute("id", "zr" + this._zrId + "-gradient-" + t.id),
            this.updateDom(t, e),
            this.addDom(e),
            e
        }
        ,
        ez.prototype.update = function(i) {
            var n = this;
            tz.prototype.update.call(this, i, function() {
                var t = i.type
                  , e = i._dom.tagName;
                "linear" === t && "linearGradient" === e || "radial" === t && "radialGradient" === e ? n.updateDom(i, i._dom) : (n.removeDom(i),
                n.add(i))
            })
        }
        ,
        ez.prototype.updateDom = function(t, e) {
            if ("linear" === t.type)
                e.setAttribute("x1", t.x),
                e.setAttribute("y1", t.y),
                e.setAttribute("x2", t.x2),
                e.setAttribute("y2", t.y2);
            else {
                if ("radial" !== t.type)
                    return void pe("Illegal gradient type.");
                e.setAttribute("cx", t.x),
                e.setAttribute("cy", t.y),
                e.setAttribute("r", t.r)
            }
            t.global ? e.setAttribute("gradientUnits", "userSpaceOnUse") : e.setAttribute("gradientUnits", "objectBoundingBox"),
            e.innerHTML = "";
            for (var i = t.colorStops, n = 0, a = i.length; n < a; ++n) {
                var r = this.createElement("stop");
                r.setAttribute("offset", 100 * i[n].offset + "%");
                var o = i[n].color;
                if (o.indexOf(!1)) {
                    var s = jt.parse(o)[3]
                      , l = jt.toHex(o);
                    r.setAttribute("stop-color", "#" + l),
                    r.setAttribute("stop-opacity", s)
                } else
                    r.setAttribute("stop-color", i[n].color);
                e.appendChild(r)
            }
            t._dom = e
        }
        ,
        ez.prototype.markUsed = function(t) {
            if (t.style) {
                var e = t.style.fill;
                e && e._dom && tz.prototype.markUsed.call(this, e._dom),
                (e = t.style.stroke) && e._dom && tz.prototype.markUsed.call(this, e._dom)
            }
        }
        ;
        var iz = ez;
        function nz(t, e) {
            tz.call(this, t, e, "clipPath", "__clippath_in_use__")
        }
        it.inherits(nz, tz),
        nz.prototype.update = function(t) {
            var e = this.getSvgElement(t);
            e && this.updateDom(e, t.__clipPaths, !1);
            var i = this.getTextSvgElement(t);
            i && this.updateDom(i, t.__clipPaths, !0),
            this.markUsed(t)
        }
        ,
        nz.prototype.updateDom = function(t, e, i) {
            if (e && 0 < e.length) {
                var n, a, r = this.getDefs(!0), o = e[0], s = i ? "_textDom" : "_dom";
                o[s] ? (a = o[s].getAttribute("id"),
                n = o[s],
                r.contains(n) || r.appendChild(n)) : (a = "zr" + this._zrId + "-clip-" + this.nextId,
                ++this.nextId,
                (n = this.createElement("clipPath")).setAttribute("id", a),
                r.appendChild(n),
                o[s] = n);
                var l = this.getSvgProxy(o);
                if (o.transform && o.parent.invTransform && !i) {
                    var u = Array.prototype.slice.call(o.transform);
                    ct.mul(o.transform, o.parent.invTransform, o.transform),
                    l.brush(o),
                    o.transform = u
                } else
                    l.brush(o);
                var h = this.getSvgElement(o);
                n.innerHTML = "",
                n.appendChild(h.cloneNode()),
                t.setAttribute("clip-path", "url(#" + a + ")"),
                1 < e.length && this.updateDom(n, e.slice(1), i)
            } else
                t && t.setAttribute("clip-path", "none")
        }
        ,
        nz.prototype.markUsed = function(t) {
            var e = this;
            t.__clipPaths && 0 < t.__clipPaths.length && it.each(t.__clipPaths, function(t) {
                t._dom && tz.prototype.markUsed.call(e, t._dom),
                t._textDom && tz.prototype.markUsed.call(e, t._textDom)
            })
        }
        ;
        var az = nz;
        function rz(t, e) {
            tz.call(this, t, e, ["filter"], "__filter_in_use__", "_shadowDom")
        }
        function oz(t) {
            return t && (t.shadowBlur || t.shadowOffsetX || t.shadowOffsetY || t.textShadowBlur || t.textShadowOffsetX || t.textShadowOffsetY)
        }
        it.inherits(rz, tz),
        rz.prototype.addWithoutUpdate = function(t, e) {
            if (e && oz(e.style)) {
                var i, n = e.style;
                if (n._shadowDom)
                    i = n._shadowDom,
                    this.getDefs(!0).contains(n._shadowDom) || this.addDom(i);
                else
                    i = this.add(e);
                this.markUsed(e);
                var a = i.getAttribute("id");
                t.style.filter = "url(#" + a + ")"
            }
        }
        ,
        rz.prototype.add = function(t) {
            var e = this.createElement("filter")
              , i = t.style;
            return i._shadowDomId = i._shadowDomId || this.nextId++,
            e.setAttribute("id", "zr" + this._zrId + "-shadow-" + i._shadowDomId),
            this.updateDom(t, e),
            this.addDom(e),
            e
        }
        ,
        rz.prototype.update = function(t, e) {
            var i = e.style;
            if (oz(i)) {
                var n = this;
                tz.prototype.update.call(this, e, function(t) {
                    n.updateDom(e, t._shadowDom)
                })
            } else
                this.remove(t, i)
        }
        ,
        rz.prototype.remove = function(t, e) {
            null != e._shadowDomId && (this.removeDom(e),
            t.style.filter = "")
        }
        ,
        rz.prototype.updateDom = function(t, e) {
            var i = e.getElementsByTagName("feDropShadow");
            i = 0 === i.length ? this.createElement("feDropShadow") : i[0];
            var n, a, r, o, s = t.style, l = t.scale && t.scale[0] || 1, u = t.scale && t.scale[1] || 1;
            if (s.shadowBlur || s.shadowOffsetX || s.shadowOffsetY)
                n = s.shadowOffsetX || 0,
                a = s.shadowOffsetY || 0,
                r = s.shadowBlur,
                o = s.shadowColor;
            else {
                if (!s.textShadowBlur)
                    return void this.removeDom(e, s);
                n = s.textShadowOffsetX || 0,
                a = s.textShadowOffsetY || 0,
                r = s.textShadowBlur,
                o = s.textShadowColor
            }
            i.setAttribute("dx", n / l),
            i.setAttribute("dy", a / u),
            i.setAttribute("flood-color", o);
            var h = r / 2 / l + " " + r / 2 / u;
            i.setAttribute("stdDeviation", h),
            e.setAttribute("x", "-100%"),
            e.setAttribute("y", "-100%"),
            e.setAttribute("width", Math.ceil(r / 2 * 200) + "%"),
            e.setAttribute("height", Math.ceil(r / 2 * 200) + "%"),
            e.appendChild(i),
            s._shadowDom = e
        }
        ,
        rz.prototype.markUsed = function(t) {
            var e = t.style;
            e && e._shadowDom && tz.prototype.markUsed.call(this, e._shadowDom)
        }
        ;
        var sz = rz
          , lz = wE.createElement
          , uz = UE.path
          , hz = UE.image
          , cz = UE.text;
        function dz(t) {
            return parseInt(t, 10)
        }
        function pz(t, e) {
            return e && t && e.parentNode !== t
        }
        function fz(t, e, i) {
            if (pz(t, e) && i) {
                var n = i.nextSibling;
                n ? t.insertBefore(e, n) : t.appendChild(e)
            }
        }
        function gz(t, e) {
            if (pz(t, e)) {
                var i = t.firstChild;
                i ? t.insertBefore(e, i) : t.appendChild(e)
            }
        }
        function mz(t, e) {
            e && t && e.parentNode === t && t.removeChild(e)
        }
        function vz(t) {
            return t.__textSvgEl
        }
        function yz(t) {
            return t.__svgEl
        }
        function xz(t, e, i, n) {
            this.root = t,
            this.storage = e,
            this._opts = i = it.extend({}, i || {});
            var a = lz("svg");
            a.setAttribute("xmlns", "http://www.w3.org/2000/svg"),
            a.setAttribute("version", "1.1"),
            a.setAttribute("baseProfile", "full"),
            a.style.cssText = "user-select:none;position:absolute;left:0;top:0;",
            this.gradientManager = new iz(n,a),
            this.clipPathManager = new az(n,a),
            this.shadowManager = new sz(n,a);
            var r = document.createElement("div");
            r.style.cssText = "overflow:hidden;position:relative",
            this._svgRoot = a,
            this._viewport = r,
            t.appendChild(r),
            r.appendChild(a),
            this.resize(i.width, i.height),
            this._visibleList = []
        }
        xz.prototype = {
            constructor: xz,
            getType: function() {
                return "svg"
            },
            getViewportRoot: function() {
                return this._viewport
            },
            getViewportRootOffset: function() {
                var t = this.getViewportRoot();
                if (t)
                    return {
                        offsetLeft: t.offsetLeft || 0,
                        offsetTop: t.offsetTop || 0
                    }
            },
            refresh: function() {
                var t = this.storage.getDisplayList(!0);
                this._paintList(t)
            },
            setBackgroundColor: function(t) {
                this._viewport.style.background = t
            },
            _paintList: function(t) {
                this.gradientManager.markAllUnused(),
                this.clipPathManager.markAllUnused(),
                this.shadowManager.markAllUnused();
                var e, i, n = this._svgRoot, a = this._visibleList, r = t.length, o = [];
                for (e = 0; e < r; e++) {
                    var s = t[e]
                      , l = (i = s)instanceof Cr ? uz : i instanceof _n ? hz : i instanceof qr ? cz : uz
                      , u = yz(s) || vz(s);
                    s.invisible || (s.__dirty && (l && l.brush(s),
                    this.clipPathManager.update(s),
                    s.style && (this.gradientManager.update(s.style.fill),
                    this.gradientManager.update(s.style.stroke),
                    this.shadowManager.update(u, s)),
                    s.__dirty = !1),
                    o.push(s))
                }
                var h, c = qE(a, o);
                for (e = 0; e < c.length; e++) {
                    if ((f = c[e]).removed)
                        for (var d = 0; d < f.count; d++) {
                            u = yz(s = a[f.indices[d]]);
                            var p = vz(s);
                            mz(n, u),
                            mz(n, p)
                        }
                }
                for (e = 0; e < c.length; e++) {
                    var f;
                    if ((f = c[e]).added)
                        for (d = 0; d < f.count; d++) {
                            u = yz(s = o[f.indices[d]]),
                            p = vz(s);
                            h ? fz(n, u, h) : gz(n, u),
                            u ? fz(n, p, u) : h ? fz(n, p, h) : gz(n, p),
                            fz(n, p, u),
                            h = p || u || h,
                            this.gradientManager.addWithoutUpdate(u, s),
                            this.shadowManager.addWithoutUpdate(h, s),
                            this.clipPathManager.markUsed(s)
                        }
                    else if (!f.removed)
                        for (d = 0; d < f.count; d++) {
                            h = u = vz(s = o[f.indices[d]]) || yz(s) || h,
                            this.gradientManager.markUsed(s),
                            this.gradientManager.addWithoutUpdate(u, s),
                            this.shadowManager.markUsed(s),
                            this.shadowManager.addWithoutUpdate(u, s),
                            this.clipPathManager.markUsed(s)
                        }
                }
                this.gradientManager.removeUnused(),
                this.clipPathManager.removeUnused(),
                this.shadowManager.removeUnused(),
                this._visibleList = o
            },
            _getDefs: function(t) {
                var n, e = this._svgRoot;
                return 0 !== (n = this._svgRoot.getElementsByTagName("defs")).length ? n[0] : t ? ((n = e.insertBefore(lz("defs"), e.firstChild)).contains || (n.contains = function(t) {
                    var e = n.children;
                    if (!e)
                        return !1;
                    for (var i = e.length - 1; 0 <= i; --i)
                        if (e[i] === t)
                            return !0;
                    return !1
                }
                ),
                n) : null
            },
            resize: function(t, e) {
                var i = this._viewport;
                i.style.display = "none";
                var n = this._opts;
                if (null != t && (n.width = t),
                null != e && (n.height = e),
                t = this._getSize(0),
                e = this._getSize(1),
                i.style.display = "",
                this._width !== t || this._height !== e) {
                    this._width = t,
                    this._height = e;
                    var a = i.style;
                    a.width = t + "px",
                    a.height = e + "px";
                    var r = this._svgRoot;
                    r.setAttribute("width", t),
                    r.setAttribute("height", e)
                }
            },
            getWidth: function() {
                return this._width
            },
            getHeight: function() {
                return this._height
            },
            _getSize: function(t) {
                var e = this._opts
                  , i = ["width", "height"][t]
                  , n = ["clientWidth", "clientHeight"][t]
                  , a = ["paddingLeft", "paddingTop"][t]
                  , r = ["paddingRight", "paddingBottom"][t];
                if (null != e[i] && "auto" !== e[i])
                    return parseFloat(e[i]);
                var o = this.root
                  , s = document.defaultView.getComputedStyle(o);
                return (o[n] || dz(s[i]) || dz(o.style[i])) - (dz(s[a]) || 0) - (dz(s[r]) || 0) | 0
            },
            dispose: function() {
                this.root.innerHTML = "",
                this._svgRoot = this._viewport = this.storage = null
            },
            clear: function() {
                this._viewport && this.root.removeChild(this._viewport)
            },
            pathToDataUrl: function() {
                return this.refresh(),
                "data:image/svg+xml;charset=UTF-8," + this._svgRoot.outerHTML
            }
        },
        it.each(["getLayer", "insertLayer", "eachLayer", "eachBuiltinLayer", "eachOtherLayer", "getLayers", "modLayer", "delLayer", "clearLayer", "toDataURL", "pathToImage"], function(t) {
            xz.prototype[t] = function(t) {
                return function() {
                    pe('In SVG mode painter not support method "' + t + '"')
                }
            }(t)
        });
        var _z = xz;
        (0,
        qn.registerPainter)("svg", _z);
        var bz, wz = i(function(t, e) {
            !function() {
                for (var t in Gm) {
                    if (null == Gm || !Gm.hasOwnProperty(t) || "default" === t || "__esModule" === t)
                        return;
                    e[t] = Gm[t]
                }
            }(),
            function() {
                for (var t in Bm) {
                    if (null == Bm || !Bm.hasOwnProperty(t) || "default" === t || "__esModule" === t)
                        return;
                    e[t] = Bm[t]
                }
            }()
        });
        return (bz = wz) && bz.__esModule && Object.prototype.hasOwnProperty.call(bz, "default") ? bz.default : bz
    }
    ,
    "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = t || self).echarts = e(),
    window.echarts || this.echarts
});